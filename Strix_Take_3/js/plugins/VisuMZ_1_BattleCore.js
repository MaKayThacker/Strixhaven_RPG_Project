//=============================================================================
// VisuStella MZ - Battle Core
// VisuMZ_1_BattleCore.js
//=============================================================================

var Imported = Imported || {};
Imported.VisuMZ_1_BattleCore = true;

var VisuMZ = VisuMZ || {};
VisuMZ.BattleCore = VisuMZ.BattleCore || {};
VisuMZ.BattleCore.version = 1.83;

//=============================================================================
 /*:
 * @target MZ
 * @plugindesc [RPG Maker MZ] [Tier 1] [Version 1.83] [BattleCore]
 * @author VisuStella
 * @url http://www.yanfly.moe/wiki/Battle_Core_VisuStella_MZ
 * @orderAfter VisuMZ_0_CoreEngine
 *
 * @help
 * ============================================================================
 * Introduction
 * ============================================================================
 *
 * The Battle Core plugin revamps the battle engine provided by RPG Maker MZ to
 * become more flexible, streamlined, and support a variety of features. The
 * updated battle engine allows for custom Action Sequences, battle layout
 * styles, and a lot of control over the battle mechanics, too.
 *
 * Features include all (but not limited to) the following:
 * 
 * * Action Sequence Plugin Commands to give you full control over what happens
 *   during the course of a skill or item.
 * * Animated Sideview Battler support for enemies!
 * * Auto Battle options for party-wide and actor-only instances.
 * * Base Troop Events to quickly streamline events for all Troop events.
 * * Battle Command control to let you change which commands appear for actors.
 * * Battle Layout styles to change the way the battle scene looks.
 * * Casting animation support for skills.
 * * Critical Hit control over the success rate formula and damage multipliers.
 * * Custom target scopes added for skills and items.
 * * Damage formula control, including Damage Styles.
 * * Damage caps, both hard caps and soft caps.
 * * Damage traits such Armor Penetration/Reduction to bypass defenses.
 * * Elements & Status Menu Core support for traits.
 * * Multitude of JavaScript notetags and global Plugin Parameters to let you
 *   make a variety of effects across various instances during battle.
 * * Party Command window can be skipped/disabled entirely.
 * * Weather effects now show in battle.
 * * Streamlined Battle Log to remove redundant information and improve the
 *   flow of battle.
 * * Visual HP Gauges can be displayed above the heads of actors and/or enemies
 *   with a possible requirement for enemies to be defeated at least once first
 *   in order for them to show.
 *
 * ============================================================================
 * Requirements
 * ============================================================================
 *
 * This plugin is made for RPG Maker MZ. This will not work in other iterations
 * of RPG Maker.
 *
 * ------ Tier 1 ------
 *
 * This plugin is a Tier 1 plugin. Place it under other plugins of lower tier
 * value on your Plugin Manager list (ie: 0, 1, 2, 3, 4, 5). This is to ensure
 * that your plugins will have the best compatibility with the rest of the
 * VisuStella MZ library.
 *
 * ============================================================================
 * Major Changes
 * ============================================================================
 *
 * This plugin will overwrite some core parts of the RPG Maker MZ base code in
 * order to ensure the Battle Core plugin will work at full capacity. The
 * following are explanations of what has been changed.
 *
 * ---
 *
 * Action Sequences
 *
 * - Action sequences are now done either entirely by the Battle Log Window or
 * through common events if the <Custom Action Sequence> notetag is used.
 * In RPG Maker MZ by default, Action Sequences would be a mixture of using the
 * Battle Log Window, the Battle Manager, and the Battle Scene, making it hard
 * to fully grab control of the situation.
 *
 * ---
 *
 * Action Speed
 *
 * - Action speeds determine the turn order in the default battle system. The
 * AGI of a battle unit is also taken into consideration. However, the random
 * variance applied to the action speed system makes the turn order extremely
 * chaotic and hard for the player to determine. Thus, the random variance
 * aspect of it has been turned off. This can be reenabled by default through
 * Plugin Parameters => Mechanics Settings => Allow Random Speed?
 *
 * ---
 *
 * Animated Sideview Battler Support For Enemies
 *
 * - Enemies can now use Sideview Actor sprites for themselves! They will
 * behave like actors and can even carry their own set of weapons for physical
 * attacks. These must be set up using notetags. More information can be found
 * in the notetag section.
 *
 * - As the sprites are normally used for actors, some changes have been made
 * to Sprite_Actor to be able to support both actors and enemies. These changes
 * should have minimal impact on other plugins.
 *
 * ---
 *
 * Battle Sprite Updates
 *
 * - A lot of functions in Sprite_Battler, Sprite_Actor, and Sprite_Enemy have
 * been overwritten to make the new Action Sequence system added by this plugin
 * possible. These changes make it possible for the sprites to move anywhere on
 * the screen, jump, float, change visibility, and more.
 *
 * ---
 *
 * Change Battle Back in Battle
 * 
 * - By default, the Change Battle Back event command does not work in battle.
 * Any settings made to it will only reflect in the following battle. Now, if
 * the battle back event command is used during battle, it will reflect upon
 * any new changes immediately.
 *
 * ---
 *
 * Critical Hit - LUK Influence
 *
 * - The LUK Buffs now affect the critical hit rate based off how the formula
 * is now calculated. Each stack of a LUK Buff will double the critical hit
 * rate and compound upon that. That means a x1 LUK Buff stack will raise it by
 * x2, a x2 LUK Buff stack will raise the critical hit rate by x4, a x3 LUK
 * Buff Stack will raise the critical hit rate stack by x8, and so on.
 *
 * - LUK also plays a role in how much damage is dealt with critical hits. The
 * default critical hit multiplier has been reduced from x3 to x2. However, a
 * percentage of LUK will added on (based off the user's CRI rate) onto the
 * finalized critical damage. If the user's CRI rate is 4%, then 4% of the user
 * LUK value will also be added onto the damage.
 *
 * - This change can be altered through Plugin Parameters => Damage Settings =>
 * Critical Hits => JS: Rate Formula and JS: Damage Formula.
 *
 * ---
 * 
 * Damage Popups
 * 
 * - Damage popups are now formatted with + and - to determine healing and
 * damage. MP Damage will also include "MP" at the back. This is to make it
 * clearer what each colored variant of the damage popup means as well as help
 * color blind players read the on-screen data properly.
 * 
 * - Damage popups have also been rewritten to show all changed aspects instead
 * of just one. Previously with RPG Maker MZ, if an action would deal both HP
 * and MP damage, only one of them would show. Now, everything is separated and
 * both HP and MP changes will at a time.
 * 
 * ---
 * 
 * Dual Wielding
 * 
 * - Previously, RPG Maker MZ had "Dual Wielding" attack using both weapon
 * animations at once, with the combined ATK of each weapon. It's confusing to
 * look at and does not portray the nature of "Dual Wielding".
 * 
 * - Dual Wielding, or in the case of users adding in third and fourth weapons,
 * Multi Wielding is now changed. Each weapon is displayed individually, each
 * producing its own attack animation, showing each weapon type, and applying
 * only that weapon's ATK, Traits, and related effects. It is no longer a
 * combined effect to display everything at once like RPG Maker MZ default.
 * 
 * - If an actor has multiple weapon slots but some of them are unequipped,
 * then the action will treat the attack as a single attack. There will be no
 * barehanded attack to add on top of it. This is to match RPG Maker MZ's
 * decision to omit a second animation if the same scenario is applied.
 * 
 * ---
 *
 * Force Action
 *
 * - Previously, Forced Actions would interrupt the middle of an event to
 * perform an action. However, with the addition of more flexible Action
 * Sequences, the pre-existing Force Action system would not be able to exist
 * and would require being remade.
 *
 * - Forced Actions now are instead, added to a separate queue from the action
 * battler list. Whenever an action and/or common event is completed, then if
 * there's a Forced Action battler queued, then the Forced Action battler will
 * have its turn. This is the cleanest method available and avoids the most
 * conflicts possible.
 *
 * - This means if you planned to make cinematic sequences with Forced Actions,
 * you will need to account for the queued Force Actions. However, in the case
 * of battle cinematics, we would highly recommend that you use the newly added
 * Action Sequence Plugin Commands instead as those give you more control than
 * any Force Action ever could.
 *
 * ---
 *
 * Random Scope
 *
 * - The skill and item targeting scopes for Random Enemy, 2 Random Enemies,
 * 3 Random Enemies, 4 Random Enemies will now ignore TGR and utilize true
 * randomness.
 *
 * ---
 *
 * Spriteset_Battle Update
 *
 * - The spriteset now has extra containers to separate battlers (actors and
 * enemies), animations, and damage. This is to make actors and enemy battler
 * sprites more efficient to sort (if enabled), so that animations won't
 * interfere with and cover damage sprites, and to make sure damage sprites are
 * unaffected by screen tints in order to ensure the player will always have a
 * clear read on the information relaying sprites.
 *
 * ---
 * 
 * TPB/ATB Active Battle Actor Shifting
 * 
 * - Pressing cancel on the Actor Command Window no longer switches between
 * actors with a full TPB/ATB gauge before reaching the Party Command Window.
 * This is to accomplish a couple of things: 1) reduce the number of button
 * presses to reach the Party Command Window and 2) to prevent motion resets
 * and disrupting action sequences. If this feature is vital to your battle
 * system, we recommend that you do not use this plugin or any of the Battle
 * Core-required plugins.
 * 
 * ---
 *
 * Weather Displayed in Battle
 *
 * - Previously, weather has not been displayed in battle. This means that any
 * weather effects placed on the map do not transfer over to battle and causes
 * a huge disconnect for players. The Battle Core plugin will add weather
 * effects to match the map's weather conditions. Any changes made to weather
 * through event commands midway through battle will also be reflected.
 *
 * ---
 *
 * ============================================================================
 * Base Troops
 * ============================================================================
 *
 * Base Troops can be found, declared, and modified in the Plugin Parameters =>
 * Mechanics Settings => Base Troop ID's. All of the listed Troop ID's here
 * will have their page events replicated and placed under all other troops
 * found in the database.
 *
 * ---
 *
 * This means that if you have an event that runs on Turn 1 of a Base Troop,
 * then for every troop out there, that same event will also run on Turn 1,
 * as well. This is useful for those who wish to customize their battle system
 * further and to reduce the amount of work needed to copy/paste said event
 * pages into every database troop object manually.
 *
 * ---
 *
 * ============================================================================
 * Damage Styles
 * ============================================================================
 *
 * Damage Styles are a new feature added through the Battle Core plugin. When
 * using certain Battle Styles, you can completely ignore typing in the whole
 * damage formula inside the damage formula input box, and instead, insert
 * either a power amount or a multiplier depending on the Damage Style. The
 * plugin will then automatically calculate damage using that value factoring
 * in ATK, DEF, MAT, MDF values.
 *
 * ---
 *
 * Here is a list of the Damage Styles that come with this plugin by default.
 * You can add in your own and even edit them to your liking.
 * Or just remove them if you want.
 *
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
 * Style          Use Formula As   PH/MA Disparity   Stat Scale   Damage Scale
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
 * Standard       Formula          No                Varies       Varies
 * ArmorScaling   Formula          No                Varies       Varies
 * CT             Multiplier       Yes               Low          Normal
 * D4             Multiplier       No                High         Normal
 * DQ             Multiplier       No                Low          Low
 * FF7            Power            Yes               Low          High
 * FF8            Power            Yes               Medium       Normal
 * FF9            Power            Yes               Low          Normal
 * FF10           Power            Yes               Medium       High
 * MK             Multiplier       No                Medium       Low
 * MOBA           Multiplier       No                Medium       Normal
 * PKMN           Power            No                Low          Normal
 *
 * Use the above chart to figure out which Damage Style best fits your game,
 * if you plan on using them.
 *
 * The 'Standard' style is the same as the 'Manual' formula input, except that
 * it allows for the support of <Armor Penetration> and <Armor Reduction>
 * notetags.
 *
 * The 'Armor Scaling' style allows you to type in the base damage calculation
 * without the need to type in any defending modifiers.
 *
 * NOTE: While these are based off the damage formulas found in other games,
 * not all of them are exact replicas. Many of them are adapted for use in
 * RPG Maker MZ since not all RPG's use the same set of parameters and not all
 * external multipliers function the same way as RPG Maker MZ.
 * 
 * ---
 *
 * Style:
 * - This is what the Damage Style is.
 *
 * Use Formula As:
 * - This is what you insert into the formula box.
 * - Formula: Type in the formula for the action just as you would normally.
 * - Multiplier: Type in the multiplier for the action.
 *     Use float values. This means 250% is typed out as 2.50
 * - Power: Type in the power constant for the action.
 *     Use whole numbers. Type in something like 16 for a power constant.
 * 
 * PH/MA Disparity:
 * - Is there a disparity between how Physical Attacks and Magical Attacks
 *   are calculated?
 * - If yes, then physical attacks and magical attacks will have different
 *   formulas used.
 * - If no, then physical attacks and magical attacks will share similar
 *   formulas for how they're calculated.
 *
 * Stat Scale:
 * - How much should stats scale throughout the game?
 * - Low: Keep them under 100 for the best results.
 * - Medium: Numbers work from low to mid 400's for best results.
 * - High: The numbers really shine once they're higher.
 *
 * Damage Scale:
 * - How much does damage vary depending on small parameter changes?
 * - Low: Very little increase from parameter changes.
 * - Normal: Damage scales close to proportionally with parameter changes.
 * - High: Damage can boost itself drastically with parameter changes.
 *
 * ---
 *
 * To determine what kind of parameters are used for the Damage Styles, they
 * will depend on two things: the action's 'Hit Type' (ie Physical Attack,
 * Magical Attack, and Certain Hit) and the action's 'Damage Type' (ie. Damage,
 * Recovery, or Drain).
 *
 * Certain Hit tends to use whichever value is higher: ATK or MAT, and then
 * ignores the target's defense values. Use Certain Hits for 'True Damage'.
 *
 * Use the chart below to figure out everything else:
 * 
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
 * Hit Type      Damage Type   Attacker Parameter   Defender Parameter
 * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
 * Physical      Damage        ATK                  DEF
 * Magical       Damage        MAT                  MDF
 * Certain Hit   Damage        Larger (ATK, MAT)    -Ignores-
 * Physical      Recover       DEF                  -Ignores-
 * Magical       Recover       MDF                  -Ignores-
 * Certain Hit   Recover       Larger (ATK, MAT)    -Ignores-
 * Physical      Drain         ATK                  DEF
 * Magical       Drain         MAT                  MDF
 * Certain Hit   Drain         Larger (ATK, MAT)    -Ignores-
 *
 * These can be modified within the Plugin Parameters in the individual
 * Damage Styles themselves.
 *
 * ---
 *
 * Skills and Items can use different Damage Styles from the setting you've
 * selected in the Plugin Parameters. They can be altered to have different
 * Damage Styles through the usage of a notetag:
 *
 * <Damage Style: name>
 *
 * This will use whichever style is found in the Plugin Parameters.
 *
 * If "Manual" is used, then no style will be used and all calculations will be
 * made strictly based off the formula found inside the formula box.
 *
 * ---
 *
 * ============================================================================
 * VisuStella MZ Compatibility
 * ============================================================================
 *
 * While this plugin is compatible with the majority of the VisuStella MZ
 * plugin library, it is not compatible with specific plugins or specific
 * features. This section will highlight the main plugins/features that will
 * not be compatible with this plugin or put focus on how the make certain
 * features compatible.
 *
 * ---
 * 
 * VisuMZ_1_BattleCore
 * 
 * When using Action Sequences, Boost effects for damage, turn extensions,
 * analyze, etc. will not occur for anything other than the Action Sequence:
 * "MECH: Action Effect" in order to maintain controlled effects. However, if
 * you do want to apply bonuses for Boosts, utilize "MECH: Boost Store Data" to
 * store inside a variable how many times Boosts were used. This can be used
 * however which way you want it to as long as it is manageable through events
 * and Common Events.
 * 
 * ---
 *
 * ============================================================================
 * Notetags
 * ============================================================================
 *
 * The following are notetags that have been added through this plugin. These
 * notetags will not work with your game if this plugin is OFF or not present.
 * 
 * === HP Gauge-Related Notetags ===
 * 
 * The following notetags allow you to set whether or not HP Gauges can be
 * displayed by enemies regardless of Plugin Parameter settings.
 * 
 * ---
 *
 * <Show HP Gauge>
 *
 * - Used for: Enemy Notetags
 * - Will always show the HP Gauge for the enemy regardless of the defeat
 *   requirement setting.
 * - This does not bypass the player's Options preferences.
 * - This does not bypass disabling enemy HP Gauges as a whole.
 * 
 * ---
 *
 * <Hide HP Gauge>
 *
 * - Used for: Enemy Notetags
 * - Will always hide the HP Gauge for the enemy regardless of the defeat
 *   requirement setting.
 * - This does not bypass the player's Options preferences.
 * 
 * ---
 * 
 * <Battle UI Offset: +x, +y>
 * <Battle UI Offset: -x, -y>
 * 
 * <Battle UI Offset X: +x>
 * <Battle UI Offset X: -x>
 * 
 * <Battle UI Offset Y: +y>
 * <Battle UI Offset Y: -y>
 * 
 * - Used for: Actor and Enemy Notetags
 * - Adjusts the offset of HP Gauges and State Icons above the heads of actors
 *   and enemies.
 * - Replace 'x' with a number value that offsets the x coordinate.
 * - Negative x values offset left. Positive x values offset right.
 * - Replace 'y' with a number value that offsets the y coordinate.
 * - Negative y values offset up. Positive x values offset down.
 * 
 * ---
 *
 * === Animation-Related Notetags ===
 *
 * The following notetags allow you to set animations to play at certain
 * instances and/or conditions.
 *
 * ---
 *
 * <Slip Animation: x>
 *
 * - Requires VisuMZ_0_CoreEngine!
 * - Used for: Actor, Class, Weapon, Armor, Enemy, State Notetags
 * - During the phase at which the user regenerates HP, MP, or TP, this
 *   animation will play as long as the user is alive and visible.
 * - Replace 'x' with a number value representing the Animation ID to play.
 *
 * ---
 *
 * <Cast Animation: x>
 *
 * - Used for: Skill Notetags
 * - Plays a battle animation at the start of the skill.
 * - Replace 'x' with a number value representing the Animation ID to play.
 *
 * ---
 *
 * <Attack Animation: x>
 *
 * - Used for: Enemy Notetags
 * - Gives an enemy an attack animation to play for its basic attack.
 * - Replace 'x' with a number value representing the Animation ID to play.
 *
 * ---
 *
 * === Battleback-Related Notetags ===
 *
 * You can apply these notetags to have some control over the battlebacks that
 * appear in different regions of the map for random or touch encounters.
 *
 * ---
 *
 * <Region x Battleback1: filename>
 * <Region x Battleback2: filename>
 * 
 * - Used for: Map Notetags
 * - If the player starts a battle while standing on 'x' region, then the
 *   'filename' battleback will be used.
 * - Replace 'x' with a number representing the region ID you wish to use.
 * - Replace 'filename' with the filename of the graphic to use. Do not insert
 *   any extensions. This means the file 'Castle1.png' will be only inserted
 *   as 'Castle1' without the '.png' at the end.
 * - *NOTE: This will override any specified battleback settings.
 *
 * ---
 *
 * === Battle Command-Related Notetags ===
 *
 * You can use notetags to change how the battle commands of playable
 * characters appear in battle as well as whether or not they can be used.
 *
 * ---
 *
 * <Seal Attack>
 * <Seal Guard>
 * <Seal Item>
 *
 * - Used for: Actor, Class, Weapon, Armor, Enemy, State Notetags
 * - Prevents specific battle commands from being able to be used.
 *
 * ---
 *
 * <Battle Commands>
 *  Attack
 *  Skills
 *  SType: x
 *  SType: name
 *  All Skills
 *  Skill: x
 *  Skill: name
 *  Guard
 *  Item
 *  Party
 *  Escape
 *  Auto Battle
 *  Combat Log
 *  Talk
 *  Weapon Swap
 * </Battle Commands>
 *
 * - Used for: Class Notetags
 * - Changes which commands appear in the Actor Command Window in battle.
 *   If this notetag is not used, then the default commands determined in
 *   Plugin Parameters => Actor Command Window => Command List will be used.
 * - Add/remove/modify entries as needed.
 *
 * - Attack 
 *   - Adds the basic attack command.
 * 
 * - Skills
 *   - Displays all the skill types available to the actor.
 * 
 * - SType: x
 * - Stype: name
 *   - Adds in a specific skill type.
 *   - Replace 'x' with the ID of the skill type.
 *   - Replace 'name' with the name of the skill type (without text codes).
 *
 * - All Skills
 *   - Adds all usable battle skills as individual actions.
 * 
 * - Skill: x
 * - Skill: name
 *   - Adds in a specific skill as a usable action.
 *   - Replace 'x' with the ID of the skill.
 *   - Replace 'name' with the name of the skill.
 * 
 * - Guard
 *   - Adds the basic guard command.
 * 
 * - Item
 *   - Adds the basic item command.
 *
 * - Party
 *   - Requires VisuMZ_2_PartySystem.
 *   - Allows this actor to switch out with a different party member.
 * 
 * - Escape
 *   - Adds the escape command.
 * 
 * - Auto Battle
 *   - Adds the auto battle command.
 * 
 * - Combat Log
 *   - Requires VisuMZ_4_CombatLog.
 *   - Opens up the combat log.
 * 
 * - Talk
 *   - Requires VisuMZ_3_BattleCmdTalk!
 *   - Shows talk command if applicable.
 * 
 * - Weapon Swap
 *   - Requires VisuMZ_2_WeaponSwapSystem.
 *   - Swaps the current weapon.
 *
 * Example:
 *
 * <Battle Commands>
 *  Attack
 *  Skill: Heal
 *  Skills
 *  Guard
 *  Item
 *  Escape
 * </Battle Commands>
 *
 * ---
 *
 * <Command Text: x>
 *
 * - Used for: Skill Notetags
 * - When a skill is used in a <Battle Commands> notetag set, you can change
 *   the skill name text that appears to something else.
 * - Replace 'x' with the skill's name you want to shown in the Actor Battle
 *   Command window.
 * - Recommended Usage: Shorten skill names that are otherwise too big to fit
 *   inside of the Actor Battle Command window.
 *
 * ---
 *
 * <Command Icon: x>
 *
 * - Used for: Skill Notetags
 * - When a skill is used in a <Battle Commands> notetag set, you can change
 *   the skill icon that appears to something else.
 * - Replace 'x' with the ID of icon you want shown in the Actor Battle Command
 *   window to represent the skill.
 * 
 * ---
 * 
 * <Command Require Learn>
 * 
 * - Used for: Skill Notetags
 * - Determines if a battle command is visible or not by whether the actor has
 *   learned the skill.
 * - Learning the skill is a requirement. Acquiring the skill through traits
 *   does not count as learning the skill.
 * 
 * ---
 * 
 * <Command Require Access>
 * 
 * - Used for: Skill Notetags
 * - Determines if a battle command is visible or not by whether the actor has
 *   access to the skill.
 * - Having access to the skill can come through either learning the skill or
 *   temporarily acquiring it through trait objects.
 * 
 * ---
 * 
 * <Command Show Switch: x>
 * 
 * <Command Show All Switches: x,x,x>
 * <Command Show Any Switches: x,x,x>
 * 
 * - Used for: Skill Notetags
 * - Determines if a battle command is visible or not through switches.
 * - Replace 'x' with the switch ID to determine the skill's visibility.
 * - If 'All' notetag variant is used, item will be hidden until all
 *   switches are ON. Then, it would be shown.
 * - If 'Any' notetag variant is used, item will be shown if any of the
 *   switches are ON. Otherwise, it would be hidden.
 * - This can be applied to Attack and Guard commands, too.
 * 
 * ---
 * 
 * <Command Hide Switch: x>
 * 
 * <Command Hide All Switches: x,x,x>
 * <Command Hide Any Switches: x,x,x>
 * 
 * - Used for: Skill Notetags
 * - Determines if a battle command is visible or not through switches.
 * - Replace 'x' with the switch ID to determine the skill's visibility.
 * - If 'All' notetag variant is used, item will be shown until all
 *   switches are ON. Then, it would be hidden.
 * - If 'Any' notetag variant is used, item will be hidden if any of the
 *   switches are ON. Otherwise, it would be shown.
 * - This can be applied to Attack and Guard commands, too.
 * 
 * ---
 * 
 * <Battle Portrait: filename>
 *
 * - Used for: Actor
 * - This is used with the "Portrait" Battle Layout.
 * - Sets the battle portrait image for the actor to 'filename'.
 * - Replace 'filename' with a picture found within your game project's
 *   img/pictures/ folder. Filenames are case sensitive. Leave out the filename
 *   extension from the notetag.
 * - This will override any menu images used for battle only.
 * 
 * ---
 * 
 * <Battle Portrait Offset: +x, +y>
 * <Battle Portrait Offset: -x, -y>
 * 
 * <Battle Portrait Offset X: +x>
 * <Battle Portrait Offset X: -x>
 * 
 * <Battle Portrait Offset Y: +y>
 * <Battle Portrait Offset Y: -y>
 *
 * - Used for: Actor
 * - This is used with the "Portrait" and "Border" Battle Layouts.
 * - Offsets the X and Y coordinates for the battle portrait.
 * - Replace 'x' with a number value that offsets the x coordinate.
 * - Negative x values offset left. Positive x values offset right.
 * - Replace 'y' with a number value that offsets the y coordinate.
 * - Negative y values offset up. Positive x values offset down.
 * 
 * ---
 * 
 * === JavaScript Notetag: Battle Command-Related ===
 *
 * The following are notetags made for users with JavaScript knowledge to
 * determine if skill-based battle commands are visible or hidden.
 * 
 * ---
 * 
 * <JS Command Visible>
 *  code
 *  code
 *  visible = code;
 * </JS Command Visible>
 * 
 * - Used for: Skill Notetags
 * - The 'visible' variable is the final returned variable to determine the
 *   skill's visibility in the Battle Command Window.
 * - Replace 'code' with JavaScript code to determine the skill's visibility in
 *   the Battle Command Window.
 * - The 'user' variable represents the user who will perform the skill.
 * - The 'skill' variable represents the skill to be used.
 * 
 * ---
 *
 * === Targeting-Related Notetags ===
 *
 * The following notetags are related to the targeting aspect of skills and
 * items and may adjust the scope of how certain skills/items work.
 *
 * ---
 *
 * <Always Hit>
 *
 * <Always Hit Rate: x%>
 *
 * - Used for: Skill, Item Notetags
 * - Causes the action to always hit or to always have a hit rate of exactly
 *   the marked x%.
 * - Replace 'x' with a number value representing the hit success percentage.
 *
 * ---
 *
 * <Repeat Hits: x>
 *
 * - Used for: Skill, Item Notetags
 * - Changes the number of hits the action will produce.
 * - Replace 'x' with a number value representing the number of hits to incur.
 *
 * ---
 *
 * <Target: x Random Any>
 *
 * - Used for: Skill, Item Notetags
 * - Makes the skill pick 'x' random targets when used.
 * - Targets can be both actors and enemies.
 * - This will overwrite the existing database scope and ignore the database's
 *   existing scope in favor of this.
 * - Replace 'x' with a number value representing the number of random targets.
 *
 * ---
 *
 * <Target: x Random Enemies>
 *
 * - Used for: Skill, Item Notetags
 * - Makes the skill pick 'x' random targets when used.
 * - This will overwrite the existing database scope and ignore the database's
 *   existing scope in favor of this.
 * - Targets are only enemies.
 * - Replace 'x' with a number value representing the number of random targets.
 *
 * ---
 *
 * <Target: x Random Allies>
 *
 * - Used for: Skill, Item Notetags
 * - Makes the skill pick 'x' random targets when used.
 * - This will overwrite the existing database scope and ignore the database's
 *   existing scope in favor of this.
 * - Targets are only actors.
 * - Replace 'x' with a number value representing the number of random targets.
 *
 * ---
 *
 * <Target: All Allies But User>
 *
 * - Used for: Skill, Item Notetags
 * - Targets all allies with the exception of the user.
 * - This will overwrite the existing database scope and ignore the database's
 *   existing scope in favor of this.
 *
 * ---
 * 
 * <Target: Ally or Enemy>
 * 
 * - Used for: Skill, Item Notetags
 * - Allows the player to target allies or enemies with the skill/item.
 *   - Keep in mind this does NOT allow you to select dead party members.
 * - This will overwrite the existing database scope and ignore the database's
 *   existing scope in favor of this.
 * - Target selection emphasis will go to allies first.
 * - Ignored when used by enemies and will be treated as an ally scope.
 * - Auto-battle actors will also treat this action as an ally scope.
 * - For certain battle layouts in frontview, this will open the Actor Select
 *   window in order for Touch Input to be able to select actors.
 * 
 * ---
 * 
 * <Target: Enemy or Ally>
 * 
 * - Used for: Skill, Item Notetags
 * - Allows the player to target enemies or allies with the skill/item.
 *   - Keep in mind this does NOT allow you to select dead party members.
 * - This will overwrite the existing database scope and ignore the database's
 *   existing scope in favor of this.
 * - Target selection emphasis will go to enemies first.
 * - Ignored when used by enemies and will be treated as an enemy scope.
 * - Auto-battle actors will also treat this action as an enemy scope.
 * - For certain battle layouts in frontview, this will open the Actor Select
 *   window in order for Touch Input to be able to select actors.
 * 
 * ---
 * 
 * <Single or Multiple Select>
 * 
 * - Used for: Skill, Item Notetags
 * - Requires an original scope that can select individual targets.
 * - This will allow the skill/item to be able to select either single targets
 *   or multiple targets at once.
 *   - In order to select "all enemies", the player must press the "Page Up"
 *     keyboard button or the visual on screen "All Enemies" button.
 *   - In order to select "all allies", the player must press the "Page Down"
 *     keyboard button or the visual on screen "All Allies" button.
 *   - Those wondering why this isn't regulated to a command left or right of
 *     the enemies and actors is because mouse controls and touch controls
 *     would not be able to select all enemies or all allies that way.
 *   - This can NOT be used with single dead ally scopes.
 * - If there is an enemy with Taunt or Provoke, the option to select
 *   "All Enemies" does not become possible.
 * - The enemy AI and Auto-Battle actor AI will NOT make use of the ability to
 *   toggle between single and multiple target scopes. They will only use the
 *   single target versions of these skills.
 * 
 * ---
 * 
 * <Disperse Damage>
 * 
 * - Used for: Skill, Item Notetags
 * - This will cause any damage dealt by this skill to be split equally amongst
 *   all targets of the skill including repeats.
 *   - For basic attacks, any damage reduction added attack trait totals will
 *     by reverted.
 * - This does NOT have to be used with <Single or Multiple Select> notetag and
 *   can be used by itself for an "All" scope, making the skill/item deal less
 *   damage if there's more enemies and more damage if there's less enemies.
 * 
 * ---
 * 
 * <Cannot Target User>
 * 
 * - Used for: Skill, Item Notetags
 * - This will cause the action to be unable to select the user as the target.
 * - This is not a targeting scope. Instead, it is used in addition to any
 *   other targeting scopes out there.
 * - When used with "All" scopes, the user is removed from the target pool.
 * - This is also applied outside of battle.
 * - If the user somehow enters the target pool, the user is then replaced by
 *   a random ally found in the party.
 * 
 * ---
 *
 * === JavaScript Notetag: Targeting-Related ===
 *
 * ---
 * 
 * <JS Accuracy>
 *  code
 *  code
 *  rate = code;
 * </JS Accuracy>
 * 
 * - Used for: Skill, Item Notetags
 * - Only applies during battle.
 * - The 'rate' variable is the final returned amount to determine the
 *   accuracy hit success rate.
 *   - Base value comes from Game_Action.itemHit
 *   - Skill/Item <JS Accuracy> runs
 *   - Then <JS Accuracy as User/Target> notetags run
 * - Replace 'code' with JavaScript code to determine the final 'rate' to be
 *   returned as the accuracy hit success rate.
 * - The 'user' variable represents the one using the skill/item.
 * - The 'target' variable represents the one receiving the skill/item hit.
 * - Works best with VisuMZ Core Engine's "Improved Accuracy" QoL formula in
 *   order to consolidate both HIT and EVA.
 * 
 * ---
 * 
 * <JS Accuracy as User>
 *  code
 *  code
 *  rate = code;
 * </JS Accuracy as User>
 * 
 * <JS Accuracy as Target>
 *  code
 *  code
 *  rate = code;
 * </JS Accuracy as Target>
 * 
 * - Used for: Actor, Class, Weapon, Armor, Enemy, State Notetags
 * - Only applies during battle.
 * - The 'rate' variable is the final returned amount to determine the
 *   accuracy hit success rate.
 *   - Base value comes from Game_Action.itemHit
 *   - Skill/Item <JS Accuracy> runs
 *   - Then <JS Accuracy as User/Target> notetags run
 * - If used on trait objects, this will apply to any skills/items used as long
 *   as the unit affected by the trait object has access to the trait object.
 * - If the 'as User' notetag variant is used, this code will be run as a
 *   response to the action from the action user end.
 * - If the 'as Target' notetag variant is used, this code will be run as a
 *   response to the action from the action target end.
 * - Replace 'code' with JavaScript code to run desired effects.
 * - The 'user' variable represents the one using the skill/item.
 * - The 'target' variable represents the one receiving the skill/item hit.
 * 
 * ---
 * 
 * <JS Targets>
 *  code
 *  code
 *  targets = [code];
 * </JS Targets>
 *
 * - Used for: Skill, Item Notetags
 * - The 'targets' variable is an array that is returned to be used as a
 *   container for all the valid action targets.
 * - The 'targets' variable will include the original set of targets determined
 *   by the skill/item's original scale.
 * - If you wish to clear it out, simply do 'targets = []' first.
 * - Replace 'code' with JavaScript code to determine valid targets.
 *
 * ---
 *
 * === Damage-Related Notetags ===
 *
 * ---
 *
 * <Damage Style: name>
 *
 * - Used for: Skill, Item Notetags
 * - Replace 'name' with a Damage Style name to change the way calculations are
 *   made using the damage formula input box.
 * - Names can be found in Plugin Parameters => Damage Settings => Style List
 *
 * ---
 *
 * <Armor Reduction: x>
 * <Armor Reduction: x%>
 * - Used for: Actor, Class, Skill, Item, Weapon, Armor, Enemy, State Notetags
 * - If used on skills and/or items, sets the current skill/item's armor
 *   reduction properties to 'x' and/or 'x%'.
 * - If used on trait objects, adds 'x' and/or 'x%' armor reduction properties
 *   when calculating one's own armor.
 * - This applies to physical attacks.
 * - Use the 'x' notetag variant to determine a flat reduction value.
 * - Use the 'x%' notetag variant to determine a percentile reduction value.
 *
 * ---
 *
 * <Armor Penetration: x>
 * <Armor Penetration: x%>
 * - Used for: Actor, Class, Skill, Item, Weapon, Armor, Enemy, State Notetags
 * - If used on skills and/or items, sets the current skill/item's armor
 *   penetration properties to 'x' and/or 'x%'.
 * - If used on trait objects, adds 'x' and/or 'x%' armor penetration
 *   properties when calculating a target's armor.
 * - This applies to physical attacks.
 * - Use the 'x' notetag variant to determine a flat penetration value.
 * - Use the 'x%' notetag variant to determine a percentile penetration value.
 *
 * ---
 *
 * <Magic Reduction: x>
 * <Magic Reduction: x%>
 * - Used for: Actor, Class, Skill, Item, Weapon, Armor, Enemy, State Notetags
 * - If used on skills and/or items, sets the current skill/item's armor
 *   reduction properties to 'x' and/or 'x%'.
 * - If used on trait objects, adds 'x' and/or 'x%' armor reduction properties
 *   when calculating one's own armor.
 * - This applies to magical attacks.
 * - Use the 'x' notetag variant to determine a flat reduction value.
 * - Use the 'x%' notetag variant to determine a percentile reduction value.
 *
 * ---
 *
 * <Magic Penetration: x>
 * <Magic Penetration: x%>
 * - Used for: Actor, Class, Skill, Item, Weapon, Armor, Enemy, State Notetags
 * - If used on skills and/or items, sets the current skill/item's armor
 *   penetration properties to 'x' and/or 'x%'.
 * - If used on trait objects, adds 'x' and/or 'x%' armor penetration
 *   properties when calculating a target's armor.
 * - This applies to magical attacks.
 * - Use the 'x' notetag variant to determine a flat penetration value.
 * - Use the 'x%' notetag variant to determine a percentile penetration value.
 *
 * ---
 *
 * <Bypass Damage Cap>
 * 
 * - Used for: Actor, Class, Skill, Item, Weapon, Armor, Enemy, State Notetags
 * - If used on skills and/or items, this will cause the action to never have
 *   its damage capped.
 * - If used on trait objects, this will cause the affected unit to never have
 *   its damage capped.
 *
 * ---
 *
 * <Damage Cap: x>
 *
 * - Used for: Actor, Class, Skill, Item, Weapon, Armor, Enemy, State Notetags
 * - If used on skills and/or items, this will declare the hard damage cap to
 *   be the 'x' value.
 * - If used on trait objects, this will raise the affect unit's hard damage
 *   cap to 'x' value. If another trait object has a higher value, use that
 *   value instead.
 *
 * ---
 *
 * <Bypass Soft Damage Cap>
 *
 * - Used for: Actor, Class, Skill, Item, Weapon, Armor, Enemy, State Notetags
 * - If used on skills and/or items, this will cause the action to never have
 *   its damage scaled downward to the soft cap.
 * - If used on trait objects, this will cause the affected unit to never have
 *   its damage scaled downward to the soft cap.
 *
 * ---
 *
 * <Soft Damage Cap: +x%>
 * <Soft Damage Cap: -x%>
 *
 * - Used for: Actor, Class, Skill, Item, Weapon, Armor, Enemy, State Notetags
 * - If used on skills and/or items, this will increase/decrease the action's
 *   soft cap by x% where 'x' is a percentage value representing the increment
 *   changed by the hard cap value.
 * - If used on trait objects, this will raise the affect unit's soft damage
 *   limit by x% where 'x' is a percentage value representing the increment
 *   changed by the hard cap value.
 *
 * ---
 *
 * <Unblockable>
 *
 * - Used for: Skill, Item Notetags
 * - Using "Guard" against this skill will not reduce any damage.
 *
 * ---
 *
 * === Critical-Related Notetags ===
 *
 * The following notetags affect skill and item critical hit rates and the
 * critical damage multiplier.
 *
 * ---
 *
 * <Always Critical>
 *
 * - Used for: Skill, Item Notetags
 * - This skill/item will always land a critical hit regardless of the
 *   user's CRI parameter value.
 *
 * ---
 *
 * <Set Critical Rate: x%>
 *
 * - Used for: Skill, Item Notetags
 * - This skill/item will always have a x% change to land a critical hit
 *   regardless of user's CRI parameter value.
 * - Replace 'x' with a percerntage value representing the success rate.
 *
 * ---
 *
 * <Modify Critical Rate: x%>
 * <Modify Critical Rate: +x%>
 * <Modify Critical Rate: -x%>
 *
 * - Used for: Skill, Item Notetags
 * - Modifies the user's CRI parameter calculation for this skill/item.
 * - The 'x%' notetag variant will multiply the user's CRI parameter value
 *   for this skill/item.
 * - The '+x%' and '-x%' notetag variants will incremenetally increase/decrease
 *   the user's CRI parameter value for this skill/item.
 *
 * ---
 *
 * <Modify Critical Multiplier: x%>
 * <Modify Critical Multiplier: +x%>
 * <Modify Critical Multiplier: -x%>
 *
 * - Used for: Skill, Item Notetags
 * - These notetags determine the damage multiplier when a critical hit lands.
 * - The 'x%' notetag variant multiply the multiplier to that exact percentage.
 * - The '+x%' and '-x%' notetag variants will change the multiplier with an
 *   incremenetal rate for this skill/item.
 *
 * ---
 *
 * <Modify Critical Bonus Damage: x%>
 * <Modify Critical Bonus Damage: +x%>
 * <Modify Critical Bonus Damage: -x%>
 *
 * - Used for: Skill, Item Notetags
 * - These notetags determine the bonus damage added when a critical hit lands.
 * - The 'x%' notetag variant multiply the damage to that exact percentage.
 * - The '+x%' and '-x%' notetag variants will change the bonus damage with an
 *   incremenetal rate for this skill/item.
 *
 * ---
 *
 * === JavaScript Notetags: Critical-Related ===
 *
 * The following are notetags made for users with JavaScript knowledge to
 * determine how critical hit-related aspects are calculated.
 *
 * ---
 *
 * <JS Critical Rate>
 *  code
 *  code
 *  rate = code;
 * </JS Critical Rate>
 *
 * - Used for: Skill, Item Notetags
 * - The 'rate' variable is the final returned amount to determine the
 *   critical hit success rate.
 *   - Base value comes from Game_Action.itemCri
 *   - Skill/Item <JS Critical Rate> runs
 *   - Then <JS Critical Rate as User/Target> notetags run
 * - Replace 'code' with JavaScript code to determine the final 'rate' to be
 *   returned as the critical hit success rate.
 * - The 'user' variable represents the one using the skill/item.
 * - The 'target' variable represents the one receiving the skill/item hit.
 *
 * ---
 *
 * <JS Critical Rate as User>
 *  code
 *  code
 *  rate = code;
 * </JS Critical Rate as User>
 *
 * <JS Critical Rate as Target>
 *  code
 *  code
 *  rate = code;
 * </JS Critical Rate as Target>
 *
 * - Used for: Actor, Class, Weapon, Armor, Enemy, State Notetags
 * - Only applies during battle.
 * - The 'rate' variable is the final returned amount to determine the
 *   critical hit success rate.
 *   - Base value comes from Game_Action.itemCri
 *   - Skill/Item <JS Critical Rate> runs
 *   - Then <JS Critical Rate as User/Target> notetags run
 * - Replace 'code' with JavaScript code to determine the final 'rate' to be
 *   returned as the critical hit success rate.
 * - If used on trait objects, this will apply to any skills/items used as long
 *   as the unit affected by the trait object has access to the trait object.
 * - If the 'as User' notetag variant is used, this code will be run as a
 *   response to the action from the action user end.
 * - If the 'as Target' notetag variant is used, this code will be run as a
 *   response to the action from the action target end.
 * - Replace 'code' with JavaScript code to run desired effects.
 * - The 'user' variable represents the one using the skill/item.
 * - The 'target' variable represents the one receiving the skill/item hit.
 *
 * ---
 *
 * <JS Critical Damage>
 *  code
 *  code
 *  multiplier = code;
 *  bonusDamage = code;
 * </JS Critical Damage>
 *
 * - Used for: Skill, Item Notetags
 * - The 'multiplier' variable is returned later and used as the damage
 *   multiplier used to amplify the critical damage amount.
 * - The 'bonusDamage' variable is returned later and used as extra added
 *   damage for the critical damage amount.
 * - Replace 'code' with JavaScript code to determine how the 'multiplier' and
 *   'bonusDamage' variables are calculated.
 * - The 'user' variable represents the one using the skill/item.
 * - The 'target' variable represents the one receiving the skill/item hit.
 *
 * ---
 * 
 * === Life Steal-Related Notetags ===
 * 
 * ---
 * 
 * <HP Life Steal: x%>
 * <MP Life Steal: x%>
 * 
 * - Used for: Skill, Item Notetags
 * - Causes this skill/item to have Life Steal properties, allowing the user to
 *   take x% of the HP/MP Damage as recovered HP/MP.
 *   - HP Life Steal can only take HP from dealt HP damage.
 *   - MP Life Steal can only take MP from dealt MP damage.
 * - Replace 'x' with a number representing the percentage of the dealt damage
 *   used as HP/MP recovery.
 * - This cannot be used with skills/items with HP Drain/MP Drain. Life Steal
 *   is a different mechanic from HP Drain/MP Drain.
 * 
 * ---
 * 
 * <HP Life Steal Certain Hit: +x%>
 * <HP Life Steal Physical Hit: +x%>
 * <HP Life Steal Magical Hit: +x%>
 * 
 * <HP Life Steal Certain Hit: -x%>
 * <HP Life Steal Physical Hit: -x%>
 * <HP Life Steal Magical Hit: -x%>
 * 
 * <MP Life Steal Certain Hit: +x%>
 * <MP Life Steal Physical Hit: +x%>
 * <MP Life Steal Magical Hit: +x%>
 * 
 * <MP Life Steal Certain Hit: -x%>
 * <MP Life Steal Physical Hit: -x%>
 * <MP Life Steal Magical Hit: -x%>
 * 
 * - Used for: Used for: Actor, Class, Armor, Enemy, State Notetags
 * - The related battler's various trait properties can have passive life steal
 *   properties that will trigger upon using skills/items with matching hit
 *   types regardless of whether or not the skill/item innately has Life Steal.
 *   - Notetag variants with "Certain Hit" will only trigger from "Certain Hit"
 *     skill and item types. Same with "Physical" and "Magical" variants.
 *   - HP Life Steal can only take HP from dealt HP damage.
 *   - MP Life Steal can only take HP from dealt MP damage.
 * - Replace 'x' with a number representing the additive stacking percentage
 *   boost of the dealt damage used as HP/MP recovery. The effects will stack
 *   additively with other trait objects.
 * - This cannot be used with skills/items with HP Drain/MP Drain. Life Steal
 *   is a different mechanic from HP Drain/MP Drain.
 * 
 * ---
 * 
 * <Cancel Life Steal>
 * 
 * <Cancel HP Life Steal>
 * <Cancel MP Life Steal>
 * 
 * - Used for: Skill, Item Notetags
 * - Prevents this skill from allowing Life Steal effects to occur including
 *   the passive life steal calculators from the skill/item user.
 * - This does not affect HP Drain/MP Drain. Life Steal is a different mechanic
 *   from HP Drain/MP Drain.
 * 
 * ---
 * 
 * <Guard Life Steal>
 * 
 * <Guard HP Life Steal>
 * <Guard MP Life Steal>
 * 
 * - Used for: Used for: Actor, Class, Armor, Enemy, State Notetags
 * - If the related battler becomes the target of Life Steal, this will prevent
 *   the Life Steal effects from taking effect.
 * - This does not affect HP Drain/MP Drain. Life Steal is a different mechanic
 *   from HP Drain/MP Drain.
 * 
 * ---
 * 
 * <Disarm Life Steal>
 * 
 * <Disarm HP Life Steal>
 * <Disarm MP Life Steal>
 * 
 * - Used for: Used for: Actor, Class, Armor, Enemy, State Notetags
 * - Makes the related battler unable to HP/MP Life Steal regardless of the
 *   skill/item and its related properties like equipment.
 * - This does not prevent skills/items with innate Life Steal from being used.
 *   Only the Life Steal part of the skill/item will have no effect.
 * - This does not affect HP Drain/MP Drain. Life Steal is a different mechanic
 *   from HP Drain/MP Drain.
 * 
 * ---
 * 
 * <Negative Life Steal>
 * 
 * <Negative HP Life Steal>
 * <Negative MP Life Steal>
 * 
 * - Used for: Used for: Actor, Class, Armor, Enemy, State Notetags
 * - If the related battler becomes the target of Life Steal, this will invert
 *   the healing properties of Life Steal, causing the Life Steal user to
 *   instead take HP/MP damage.
 *   - This does NOT heal the target related battler.
 * - This does not prevent skills/items with innate Life Steal from being used.
 *   Only the Life Steal part of the skill/item will have no effect.
 * - This does not affect HP Drain/MP Drain. Life Steal is a different mechanic
 *   from HP Drain/MP Drain.
 * 
 * ---
 *
 * === Action Sequence-Related Notetags ===
 *
 * Action Sequences allow you full control over how a skill and/or item plays
 * through its course. These notetags give you control over various aspects of
 * those Action Sequences. More information is found in the Action Sequences
 * help section.
 *
 * ---
 *
 * <Custom Action Sequence>
 *
 * - Used for: Skill, Item Notetags
 * - Removes all automated Action Sequence parts from the skill.
 * - Everything Action Sequence-related will be done by Common Events.
 * - Insert Common Event(s) into the skill/item's effects list to make use of
 *   the Custom Action Sequences.
 * - This will prevent common events from loading in the Item Scene and Skill
 *   Scene when used outside of battle.
 *
 * ---
 * 
 * <Auto Action Sequence>
 * 
 * - Used for: Skill, Item Notetags
 * - If the Action Sequence Plugin Parameter "Auto Notetag" is enabled, this
 *   plugin will prevent custom action sequences from happening for the skill
 *   or item, and instead, use an Automatic Action Sequence instead.
 * - Ignore this if you have "Auto Notetag" disabled or set to false. By
 *   default, this setting is set to false. Please be aware of the changes
 *   you've made to your game before using it.
 * 
 * ---
 * 
 * <Bypass Auto Action Sequence>
 * 
 * - Used for: Skill, Item Notetags
 * - This notetag is used for the game devs that have the Action Sequence
 *   Plugin Parameter "Auto Notetag" on for applying <Custom Action Sequence>
 *   to everything.
 * - This will allow items and skills to be able to launch their common
 *   events from the menu scene regardless of the inherent restriction to
 *   prevent action sequence based skills/items with common events from
 *   launching.
 * - Ignore this if you have "Auto Notetag" disabled or set to false. By
 *   default, this setting is set to false. Please be aware of the changes
 *   you've made to your game before using it.
 * 
 * ---
 * 
 * <Common Event: name>
 *
 * - Used for: Skill, Item Notetags
 * - Battle only: calls forth a Common Event of a matching name.
 * - Replace 'name' with the name of a Common Event to call from when this
 *   skill/item is used in battle.
 *   - Remove any \I[x] in the name.
 * - Insert multiple notetags to call multiple Common Events in succession.
 * - This will occur after any Common Event Trait Effects for the skill/item's
 *   database entry.
 * - This is primarily used for users who are reorganizing around their Common
 *   Events and would still like to have their skills/items perform the correct
 *   Action Sequences in case the ID's are different.
 * 
 * ---
 *
 * <Display Icon: x>
 * <Display Text: string>
 *
 * - Used for: Skill, Item Notetags
 * - When displaying the skill/item name in the Action Sequence, determine the
 *   icon and/or text displayed.
 * - Replace 'x' with a number value representing the icon ID to be displayed.
 * - Replace 'string' with a text value representing the displayed name.
 *
 * ---
 * 
 * <Common Event Key: name>
 * <Common Event Keys: name, name, name>
 * 
 * <Common Event Keys>
 *  key
 *  key
 *  key
 * </Common Event Keys>
 * 
 * - Used for: Skill, Item Notetags
 * - Will generate Common Events for the skill/item with a corresponding key.
 * - Replace 'name' with the name of the Common Event's key that you want to
 *   reference. That key will be converted into a Common Event effect for the
 *   skill/item and be treated as an action sequence.
 *   - The notetag variants that use multiple keys will have the keys added in
 *     the order they are listed.
 *   - If keys do not reference any Common Events, no Common Events will be
 *     added for that key.
 * - To mark a Common Event with a key, insert inside a Common Event's name the
 *   [ and ] brackets around the text that will be used as the Common Event's
 *   key text.
 *   - For example, if Common Event's name is "Penta Slash [PENTA]", then the
 *     key used is "PENTA" without the quotes.
 *   - This key could then be referenced by <Common Event Key: PENTA> notetag.
 *   - Do not use commas (,) inside the key text as it will be automatically
 *     removed for the sake of consistency.
 * - This feature is made for make the process of sharing Action Sequences to
 *   become easier without needing to line up Common Event ID's.
 * 
 * ---
 *
 * === Animated Sideview Battler-Related Notetags ===
 *
 * Enemies can use Animated Sideview Actor graphics thanks to this plugin.
 * These notetags give you control over that aspect. Some of these also affect
 * actors in addition to enemies.
 *
 * ---
 *
 * <Sideview Battler: filename>
 *
 * <Sideview Battlers>
 *  filename: weight
 *  filename: weight
 *  filename: weight
 * </Sideview Battlers>
 *
 * - Used for: Enemy Notetags
 * - Replaces the enemy's battler graphic with an animated Sideview Actor
 *   graphic found in the img/sv_actors/ folder.
 * - Replace 'filename' with the filename of the graphic to use. Do not insert
 *   any extensions. This means the file 'Actor1_1.png' will be only inserted
 *   as 'Actor1_1' without the '.png' at the end.
 * - If the multiple notetag vaiant is used, then a random filename is selected
 *   from the list upon the enemy's creation.
 * - Replace 'weight' with a number value representing how often the 'filename'
 *   would come up. The higher the weight, the more often. You may omit this
 *   and the colon(:) and just type in the 'filename' instead.
 * - Add/remove lines as you see fit.
 *
 * Example:
 *
 * <Sideview Battlers>
 *  Actor1_1: 25
 *  Actor1_3: 10
 *  Actor1_5
 *  Actor1_7
 * </Sideview Battlers>
 *
 * ---
 *
 * <Sideview Anchor: x, y>
 *
 * - Used for: Actor, Enemy Notetags
 * - Sets the sprite anchor positions for the sideview sprite.
 * - Replace 'x' and 'y' with numbers depicting where the anchors should be for
 *   the sideview sprite.
 * - By default, the x and y anchors are 0.5 and 1.0.
 *
 * ---
 * 
 * <Sideview Home Offset: +x, +y>
 * <Sideview Home Offset: -x, -y>
 * 
 * - Used for: Actor, Class, Weapon, Armor, State Notetags
 * - Offsets the sideview actor sprite's home position by +/-x, +/-y.
 * - Replace 'x' and 'y' with numbers depicting how much to offset each of the
 *   coordinates by. For '0' values, use +0 or -0.
 * - This notetag will not work if you remove it from the JavaScript code in
 *   Plugin Parameters > Actor > JS:  Home Position
 * 
 * ---
 * 
 * <Sideview Weapon Offset: +x, +y>
 * <Sideview Weapon Offset: -x, -y>
 * 
 * - Used for: Actor, Class, Weapon, Armor, Enemy State Notetags
 * - Offsets the sideview weapon sprite's position by +/-x, +/-y.
 * - Replace 'x' and 'y' with numbers depicting how much to offset each of the
 *   coordinates by. For '0' values, use +0 or -0.
 * 
 * ---
 *
 * <Sideview Show Shadow>
 * <Sideview Hide Shadow>
 *
 * - Used for: Actor, Enemy Notetags
 * - Sets it so the sideview battler's shadow will be visible or hidden.
 *
 * ---
 * 
 * <Sideview Shadow Scale: x%>
 * <Sideview Shadow Scale: x.y>
 * 
 * - Used for: Actor, Enemy Notetags
 * - Adjusts the scaling size of the sideview battler's shadow.
 * - This affects both the X and Y scale.
 * 
 * ---
 * 
 * <Sideview Shadow Scale X: x%>
 * <Sideview Shadow Scale X: x.y>
 * 
 * <Sideview Shadow Scale Y: x%>
 * <Sideview Shadow Scale Y: x.y>
 * 
 * - Used for: Actor, Enemy Notetags
 * - Adjusts the scaling size of the sideview battler's shadow.
 * - These affect their respective X and Y scales separately.
 * 
 * ---
 *
 * <Sideview Collapse>
 * <Sideview No Collapse>
 *
 * - Used for: Enemy Notetags
 * - Either shows the collapse graphic or does not show the collapse graphic.
 * - Collapse graphic means the enemy will 'fade away' once it's defeated.
 * - No collapse graphic means the enemy's corpse will remain on the screen.
 *
 * ---
 *
 * <Sideview Idle Motion: name>
 *
 * <Sideview Idle Motions>
 *  name: weight
 *  name: weight
 *  name: weight
 * </Sideview Idle Motions>
 *
 * - Used for: Enemy Notetags
 * - Changes the default idle motion for the enemy.
 * - Replace 'name' with any of the following motion names:
 *   - 'walk', 'wait', 'chant', 'guard', 'damage', 'evade', 'thrust', 'swing',
 *     'missile', 'skill', 'spell', 'item', 'escape', 'victory', 'dying',
 *     'abnormal', 'sleep', 'dead'
 * - If the multiple notetag vaiant is used, then a random motion name is
 *   selected from the list upon the enemy's creation.
 * - Replace 'weight' with a number value representing how often the 'name'
 *   would come up. The higher the weight, the more often. You may omit this
 *   and the colon(:) and just type in the 'name' instead.
 * - Add/remove lines as you see fit.
 *
 * Example:
 *
 * <Sideview Idle Motions>
 *  walk: 25
 *  wait: 50
 *  guard
 *  victory
 *  abnormal
 * </Sideview Idle Motions>
 *
 * ---
 *
 * <Sideview Size: width, height>
 *
 * - Used for: Enemy Notetags
 * - When using a sideview battler, its width and height will default to the
 *   setting made in Plugin Parameters => Enemy Settings => Size: Width/Height.
 * - This notetag lets you change that value to something else.
 * - Replace 'width' and 'height' with numbers representing how many pixels
 *   wide/tall the sprite will be treated as.
 * - This does NOT change the image size. This only changes the HITBOX size.
 *
 * ---
 *
 * <Sideview Weapon: weapontype>
 *
 * <Sideview Weapons>
 *  weapontype: weight
 *  weapontype: weight
 *  weapontype: weight
 * </Sideview Weapons>
 *
 * - Used for: Enemy Notetags
 * - Give your sideview enemies weapons to use.
 * - Replace 'weapontype' with the name of the weapon type found under the
 *   Database => Types => Weapon Types list (without text codes).
 * - If the multiple notetag vaiant is used, then a random weapon type is
 *   selected from the list upon the enemy's creation.
 * - Replace 'weight' with a number value representing how often the weapontype
 *   would come up. The higher the weight, the more often. You may omit this
 *   and the colon(:) and just type in the 'weapontype' instead.
 * - Add/remove lines as you see fit.
 *
 * Example:
 *
 * <Sideview Weapons>
 *  Dagger: 25
 *  Sword: 25
 *  Axe
 * </Sideview Weapons>
 *
 * ---
 *
 * <traitname Sideview Battler: filename>
 *
 * <traitname Sideview Battlers>
 *  filename: weight
 *  filename: weight
 *  filename: weight
 * </traitname Sideview Battlers>
 *
 * - Used for: Enemy Notetags
 * - Requires VisuMZ_1_ElementStatusCore
 * - Allows certain Trait Sets to cause battlers to have a unique appearance.
 * - Replace 'filename' with the filename of the graphic to use. Do not insert
 *   any extensions. This means the file 'Actor1_1.png' will be only inserted
 *   as 'Actor1_1' without the '.png' at the end.
 * - If the multiple notetag vaiant is used, then a random filename is selected
 *   from the list upon the enemy's creation.
 * - Replace 'weight' with a number value representing how often the 'filename'
 *   would come up. The higher the weight, the more often. You may omit this
 *   and the colon(:) and just type in the 'filename' instead.
 * - Add/remove lines as you see fit.
 *
 * Examples:
 *
 * <Male Sideview Battlers>
 *  Actor1_1: 25
 *  Actor1_3: 10
 *  Actor1_5
 *  Actor1_7
 * </Male Sideview Battlers>
 *
 * <Female Sideview Battlers>
 *  Actor1_2: 25
 *  Actor1_4: 10
 *  Actor1_6
 *  Actor1_8
 * </Female Sideview Battlers>
 *
 * ---
 *
 * <traitname Sideview Idle Motion: name>
 *
 * <traitname Sideview Idle Motions>
 *  name: weight
 *  name: weight
 *  name: weight
 * </traitname Sideview Idle Motions>
 *
 * - Used for: Enemy Notetags
 * - Requires VisuMZ_1_ElementStatusCore
 * - Allows certain Trait Sets to cause battlers to have unique idle motions.
 * - Replace 'name' with any of the following motion names:
 *   - 'walk', 'wait', 'chant', 'guard', 'damage', 'evade', 'thrust', 'swing',
 *     'missile', 'skill', 'spell', 'item', 'escape', 'victory', 'dying',
 *     'abnormal', 'sleep', 'dead'
 * - If the multiple notetag vaiant is used, then a random motion name is
 *   selected from the list upon the enemy's creation.
 * - Replace 'weight' with a number value representing how often the 'name'
 *   would come up. The higher the weight, the more often. You may omit this
 *   and the colon(:) and just type in the 'name' instead.
 * - Add/remove lines as you see fit.
 *
 * Examples:
 *
 * <Jolly Sideview Idle Motions>
 *  wait: 25
 *  victory: 10
 *  walk
 * </Jolly Sideview Idle Motions>
 *
 * <Serious Sideview Idle Motions>
 *  walk: 25
 *  guard: 10
 *  wait
 * </Jolly Sideview Idle Motions>
 *
 * ---
 *
 * <traitname Sideview Weapon: weapontype>
 *
 * <traitname Sideview Weapons>
 *  weapontype: weight
 *  weapontype: weight
 *  weapontype: weight
 * </traitname Sideview Weapons>
 *
 * - Used for: Enemy Notetags
 * - Requires VisuMZ_1_ElementStatusCore
 * - Allows certain Trait Sets to cause battlers to have unique weapons.
 * - Replace 'weapontype' with the name of the weapon type found under the
 *   Database => Types => Weapon Types list (without text codes).
 * - If the multiple notetag vaiant is used, then a random weapon type is
 *   selected from the list upon the enemy's creation.
 * - Replace 'weight' with a number value representing how often the weapontype
 *   would come up. The higher the weight, the more often. You may omit this
 *   and the colon(:) and just type in the 'weapontype' instead.
 * - Add/remove lines as you see fit.
 *
 * Examples:
 *
 * <Male Sideview Weapons>
 *  Dagger: 25
 *  Sword: 25
 *  Axe
 * </Male Sideview Weapons>
 *
 * <Female Sideview Weapons>
 *  Dagger: 25
 *  Spear: 25
 *  Cane
 * </Female Sideview Weapons>
 *
 * ---
 *
 * === Enemy-Related Notetags ===
 *
 * ---
 *
 * <Battler Sprite Cannot Move>
 *
 * - Used for: Enemy Notetags
 * - Prevents the enemy from being able to move, jump, and/or float due to
 *   Action Sequences. Useful for rooted enemies.
 *
 * ---
 * 
 * <Battler Sprite Grounded>
 *
 * - Used for: Enemy Notetags
 * - Prevents the enemy from being able to jumping and/or floating due to
 *   Action Sequences but still able to move. Useful for rooted enemies.
 * 
 * ---
 *
 * <Swap Enemies>
 *  name: weight
 *  name: weight
 *  name: weight
 * </Swap Enemies>
 *
 * - Used for: Enemy Notetags
 * - Causes this enemy database object to function as a randomizer for any of
 *   the listed enemies inside the notetag. When the enemy is loaded into the
 *   battle scene, the enemy is immediately replaced with one of the enemies
 *   listed. The randomization is based off the 'weight' given to each of the
 *   enemy 'names'.
 * - Replace 'name' with the database enemy of the enemy you wish to replace
 *   the enemy with.
 * - Replace 'weight' with a number value representing how often the 'name'
 *   would come up. The higher the weight, the more often. You may omit this
 *   and the colon(:) and just type in the 'name' instead.
 * - Add/remove lines as you see fit.
 *
 * Example:
 *
 * <Swap Enemies>
 *  Bat: 50
 *  Slime: 25
 *  Orc
 *  Minotaur
 * </Swap Enemies>
 *
 * ---
 *
 * === JavaScript Notetags: Mechanics-Related ===
 *
 * These JavaScript notetags allow you to run code at specific instances during
 * battle provided that the unit has that code associated with them in a trait
 * object (actor, class, weapon, armor, enemy, or state). How you use these is
 * entirely up to you and will depend on your ability to understand the code
 * used and driven for each case.
 *
 * ---
 *
 * <JS Pre-Start Battle>
 *  code
 *  code
 *  code
 * </JS Pre-Start Battle>
 *
 * <JS Post-Start Battle>
 *  code
 *  code
 *  code
 * </JS Post-Start Battle>
 * 
 * - Used for: Actor, Class, Weapon, Armor, Enemy, State Notetags
 * - Runs JavaScript code at the start of battle aimed at the function:
 *   BattleManager.startBattle()
 *   - 'Pre' runs before the function runs.
 *   - 'Post' runs after the function runs.
 * - Replace 'code' with JavaScript code to run desired effects.
 * - The 'user' variable represents the one affected by the trait object.
 *
 * ---
 *
 * <JS Pre-Start Turn>
 *  code
 *  code
 *  code
 * </JS Pre-Start Turn>
 *
 * <JS Post-Start Turn>
 *  code
 *  code
 *  code
 * </JS Post-Start Turn>
 * 
 * - Used for: Actor, Class, Weapon, Armor, Enemy, State Notetags
 * - Runs JavaScript code at the start of a turn aimed at the function:
 *   BattleManager.startTurn()
 *   - 'Pre' runs before the function runs.
 *   - 'Post' runs after the function runs.
 * - Replace 'code' with JavaScript code to run desired effects.
 * - The 'user' variable represents the one affected by the trait object.
 *
 * ---
 *
 * <JS Pre-Start Action>
 *  code
 *  code
 *  code
 * </JS Pre-Start Action>
 *
 * <JS Post-Start Action>
 *  code
 *  code
 *  code
 * </JS Post-Start Action>
 * 
 * - Used for: Actor, Class, Skill, Item, Weapon, Armor, Enemy, State Notetags
 * - Runs JavaScript code at the start of an action aimed at the function:
 *   BattleManager.startAction()
 *   - 'Pre' runs before the function runs.
 *   - 'Post' runs after the function runs.
 * - If used on skills and/or items, this will only apply to the skill/item
 *   being used and does not affect other skills and items.
 * - If used on trait objects, this will apply to any skills/items used as long
 *   as the unit affected by the trait object has access to the trait object.
 * - Replace 'code' with JavaScript code to run desired effects.
 * - The 'user' variable represents the one affected by the trait object.
 *
 * ---
 *
 * <JS Pre-Apply>
 *  code
 *  code
 *  code
 * </JS Pre-Apply>
 * 
 * - Used for: Skill, Item Notetags
 * - Runs JavaScript code at the start of an action hit aimed at the function:
 *   Game_Action.prototype.apply()
 *   - 'Pre' runs before the function runs.
 * - If used on skills and/or items, this will only apply to the skill/item
 *   being used and does not affect other skills and items.
 * - Replace 'code' with JavaScript code to run desired effects.
 * - The 'user' variable represents the one using the skill/item.
 * - The 'target' variable represents the one receiving the skill/item hit.
 *
 * ---
 *
 * <JS Pre-Apply as User>
 *  code
 *  code
 *  code
 * </JS Pre-Apply as User>
 *
 * <JS Pre-Apply as Target>
 *  code
 *  code
 *  code
 * </JS Pre-Apply as Target>
 * 
 * - Used for: Actor, Class, Weapon, Armor, Enemy, State Notetags
 * - Runs JavaScript code at the start of an action hit aimed at the function:
 *   Game_Action.prototype.apply()
 *   - 'Pre' runs before the function runs.
 * - If used on trait objects, this will apply to any skills/items used as long
 *   as the unit affected by the trait object has access to the trait object.
 * - If the 'as User' notetag variant is used, this code will be run as a
 *   response to the action from the action user end.
 * - If the 'as Target' notetag variant is used, this code will be run as a
 *   response to the action from the action target end.
 * - Replace 'code' with JavaScript code to run desired effects.
 * - The 'user' variable represents the one using the skill/item.
 * - The 'target' variable represents the one receiving the skill/item hit.
 *
 * ---
 *
 * <JS Pre-Damage>
 *  code
 *  code
 *  code
 * </JS Pre-Damage>
 * 
 * - Used for: Skill, Item Notetags
 * - Runs JavaScript code before damage is dealt aimed at the function:
 *   Game_Action.prototype.executeDamage()
 *   - 'Pre' runs before the function runs.
 * - If used on skills and/or items, this will only apply to the skill/item
 *   being used and does not affect other skills and items.
 * - Replace 'code' with JavaScript code to run desired effects.
 * - The 'user' variable represents the one using the skill/item.
 * - The 'target' variable represents the one receiving the skill/item hit.
 * - The 'value' variable represents the damage being calculated up to this
 *   point (if any) and any changes made to the 'value' variable will reflect
 *   on the damage dealt/healed, too.
 *
 * ---
 *
 * <JS Pre-Damage as User>
 *  code
 *  code
 *  code
 * </JS Pre-Damage as User>
 *
 * <JS Pre-Damage as Target>
 *  code
 *  code
 *  code
 * </JS Pre-Damage as Target>
 * 
 * - Used for: Actor, Class, Weapon, Armor, Enemy, State Notetags
 * - Runs JavaScript code before damage is dealt aimed at the function:
 *   Game_Action.prototype.executeDamage()
 *   - 'Pre' runs before the function runs.
 * - If used on trait objects, this will apply to any skills/items used as long
 *   as the unit affected by the trait object has access to the trait object.
 * - If the 'as User' notetag variant is used, this code will be run as a
 *   response to the action from the action user end.
 * - If the 'as Target' notetag variant is used, this code will be run as a
 *   response to the action from the action target end.
 * - Replace 'code' with JavaScript code to run desired effects.
 * - The 'user' variable represents the one using the skill/item.
 * - The 'target' variable represents the one receiving the skill/item hit.
 * - The 'value' variable represents the damage being calculated up to this
 *   point (if any) and any changes made to the 'value' variable will reflect
 *   on the damage dealt/healed, too.
 *
 * ---
 *
 * <JS Post-Damage>
 *  code
 *  code
 *  code
 * </JS Post-Damage>
 * 
 * - Used for: Skill, Item Notetags
 * - Runs JavaScript code after damage is dealt aimed at the function:
 *   Game_Action.prototype.executeDamage()
 *   - 'Post' runs after the function runs.
 * - If used on skills and/or items, this will only apply to the skill/item
 *   being used and does not affect other skills and items.
 * - Replace 'code' with JavaScript code to run desired effects.
 * - The 'user' variable represents the one using the skill/item.
 * - The 'target' variable represents the one receiving the skill/item hit.
 * - The 'value' variable represents the damage/healing that has been last
 *   dealt through this action.
 *
 * ---
 *
 * <JS Post-Damage as User>
 *  code
 *  code
 *  code
 * </JS Post-Damage as User>
 *
 * <JS Post-Damage as Target>
 *  code
 *  code
 *  code
 * </JS Post-Damage as Target>
 * 
 * - Used for: Actor, Class, Weapon, Armor, Enemy, State Notetags
 * - Runs JavaScript code after damage is dealt aimed at the function:
 *   Game_Action.prototype.executeDamage()
 *   - 'Post' runs after the function runs.
 * - If used on trait objects, this will apply to any skills/items used as long
 *   as the unit affected by the trait object has access to the trait object.
 * - If the 'as User' notetag variant is used, this code will be run as a
 *   response to the action from the action user end.
 * - If the 'as Target' notetag variant is used, this code will be run as a
 *   response to the action from the action target end.
 * - Replace 'code' with JavaScript code to run desired effects.
 * - The 'user' variable represents the one using the skill/item.
 * - The 'target' variable represents the one receiving the skill/item hit.
 * - The 'value' variable represents the damage/healing that has been last
 *   dealt through this action.
 *
 * ---
 *
 * <JS Post-Apply>
 *  code
 *  code
 *  code
 * </JS Post-Apply>
 * 
 * - Used for: Skill, Item Notetags
 * - Runs JavaScript code at the end of an action hit aimed at the function:
 *   Game_Action.prototype.apply()
 *   - 'Post' runs after the function runs.
 * - If used on skills and/or items, this will only apply to the skill/item
 *   being used and does not affect other skills and items.
 * - Replace 'code' with JavaScript code to run desired effects.
 * - The 'user' variable represents the one using the skill/item.
 * - The 'target' variable represents the one receiving the skill/item hit.
 *
 * ---
 *
 * <JS Post-Apply as User>
 *  code
 *  code
 *  code
 * </JS Post-Apply as User>
 *
 * <JS Post-Apply as Target>
 *  code
 *  code
 *  code
 * </JS Post-Apply as Target>
 * 
 * - Used for: Actor, Class, Weapon, Armor, Enemy, State Notetags
 * - Runs JavaScript code at the end of an action hit aimed at the function:
 *   Game_Action.prototype.apply()
 *   - 'Post' runs after the function runs.
 * - If used on trait objects, this will apply to any skills/items used as long
 *   as the unit affected by the trait object has access to the trait object.
 * - If the 'as User' notetag variant is used, this code will be run as a
 *   response to the action from the action user end.
 * - If the 'as Target' notetag variant is used, this code will be run as a
 *   response to the action from the action target end.
 * - Replace 'code' with JavaScript code to run desired effects.
 *
 * ---
 *
 * <JS Pre-End Action>
 *  code
 *  code
 *  code
 * </JS Pre-End Action>
 *
 * <JS Post-End Action>
 *  code
 *  code
 *  code
 * </JS Post-End Action>
 * 
 * - Used for: Actor, Class, Weapon, Armor, Enemy, State Notetags
 * - Runs JavaScript code at the end of an action aimed at the function:
 *   BattleManager.endAction()
 *   - 'Pre' runs before the function runs.
 *   - 'Post' runs after the function runs.
 * - If used on trait objects, this will apply to any skills/items used as long
 *   as the unit affected by the trait object has access to the trait object.
 * - Replace 'code' with JavaScript code to run desired effects.
 * - The 'user' variable represents the one affected by the trait object.
 *
 * ---
 *
 * <JS Pre-End Turn>
 *  code
 *  code
 *  code
 * </JS Pre-End Turn>
 *
 * <JS Post-End Turn>
 *  code
 *  code
 *  code
 * </JS Post-End Turn>
 * 
 * - Used for: Actor, Class, Weapon, Armor, Enemy, State Notetags
 * - Runs JavaScript code at the end of a turn aimed at the function:
 *   Game_Battler.prototype.onTurnEnd()
 *   - 'Pre' runs before the function runs.
 *   - 'Post' runs after the function runs.
 * - Replace 'code' with JavaScript code to run desired effects.
 * - The 'user' variable represents the one affected by the trait object.
 *
 * ---
 *
 * <JS Pre-Regenerate>
 *  code
 *  code
 *  code
 * </JS Pre-Regenerate>
 *
 * <JS Post-Regenerate>
 *  code
 *  code
 *  code
 * </JS Post-Regenerate>
 * 
 * - Used for: Actor, Class, Weapon, Armor, Enemy, State Notetags
 * - Runs JavaScript code when a unit regenerates HP/MP aimed at the function:
 *   Game_Battler.prototype.regenerateAll()
 *   - 'Pre' runs before the function runs.
 *   - 'Post' runs after the function runs.
 * - Replace 'code' with JavaScript code to run desired effects.
 * - The 'user' variable represents the one affected by the trait object.
 *
 * ---
 *
 * <JS Battle Victory>
 *  code
 *  code
 *  code
 * </JS Battle Victory>
 * 
 * - Used for: Actor, Class, Weapon, Armor, Enemy, State Notetags
 * - Runs JavaScript code when a battle is won aimed at the function:
 *   BattleManager.processVictory()
 * - Replace 'code' with JavaScript code to run desired effects.
 * - The 'user' variable represents the one affected by the trait object.
 *
 * ---
 *
 * <JS Escape Success>
 *  code
 *  code
 *  code
 * </JS Escape Success>
 * 
 * - Used for: Actor, Class, Weapon, Armor, Enemy, State Notetags
 * - Runs JavaScript code when escaping succeeds aimed at the function:
 *   BattleManager.onEscapeSuccess()
 * - Replace 'code' with JavaScript code to run desired effects.
 * - The 'user' variable represents the one affected by the trait object.
 *
 * ---
 *
 * <JS Escape Failure>
 *  code
 *  code
 *  code
 * </JS Escape Failure>
 * 
 * - Used for: Actor, Class, Weapon, Armor, Enemy, State Notetags
 * - Runs JavaScript code when escaping fails aimed at the function:
 *   BattleManager.onEscapeFailure()
 * - Replace 'code' with JavaScript code to run desired effects.
 * - The 'user' variable represents the one affected by the trait object.
 *
 * ---
 *
 * <JS Battle Defeat>
 *  code
 *  code
 *  code
 * </JS Battle Defeat>
 * 
 * - Used for: Actor, Class, Weapon, Armor, Enemy, State Notetags
 * - Runs JavaScript code when a battle is lost aimed at the function:
 *   BattleManager.processDefeat()
 * - Replace 'code' with JavaScript code to run desired effects.
 * - The 'user' variable represents the one affected by the trait object.
 *
 * ---
 *
 * <JS Pre-End Battle>
 *  code
 *  code
 *  code
 * </JS Pre-End Battle>
 *
 * <JS Post-End Battle>
 *  code
 *  code
 *  code
 * </JS Post-End Battle>
 * 
 * - Used for: Actor, Class, Weapon, Armor, Enemy, State Notetags
 * - Runs JavaScript code when the battle is over aimed at the function:
 *   BattleManager.endBattle()
 *   - 'Pre' runs before the function runs.
 *   - 'Post' runs after the function runs.
 * - Replace 'code' with JavaScript code to run desired effects.
 * - The 'user' variable represents the one affected by the trait object.
 *
 * ---
 * 
 * === Battle Layout-Related Notetags ===
 * 
 * These tags will change the battle layout for a troop regardless of how the
 * plugin parameters are set up normally. Insert these tags in either the
 * noteboxes of maps or the names of troops for them to take effect. If both
 * are present for a specific battle, then priority goes to the setting found
 * in the troop name.
 * 
 * ---
 * 
 * <Layout: type>
 * <Battle Layout: type>
 * 
 * - Used for: Map Notetags, Troop Name Tags, and Troop Comment Tags
 * - Changes the battle layout style used for this specific map or battle.
 * - Replace 'type' with 'default', 'list', 'xp', 'portrait', or 'border'.
 * - Those with VisuMZ_3_FrontviewBattleUI can use 'frontview'.
 * - Those with VisuMZ_3_SideviewBattleUI can use 'sideview'.
 * - If using Troop Comment Tags, then as long as the tag appears in a comment
 *   found on any of the Troop's pages (even if they don't run), the tag will
 *   be considered in effect.
 * 
 * ---
 * 
 * === Troop Size Tags ===
 * 
 * ---
 * 
 * <Extend: x>
 * <Extend: x, x, x>
 * 
 * - Used for: Troop Name Tags and Troop Comment Tags
 * - Adds enemies from another troop to the current troop.
 * - Enemies from another troop will retain their database positions.
 * - Replace 'x' with the ID of the database troop entry you wish to add enemy
 *   members from.
 *   - Insert multiple x's to add from more troops.
 * - Extended troop members will be added in the order they're listed.
 * - Be cautious of how many enemies you add as too many will lag the battle
 *   system. We are not responsible for frame drops due to this.
 * 
 * ---
 * 
 * === Troop Comment Tags ===
 * 
 * Place these tags inside of a comment found in a troop page's event list.
 * 
 * ---
 * 
 * <Once Parallel When Start Battle>
 * 
 * - Used for: Troop Page Comment Tags
 * - Causes the troop page to immediately load the moment the battle scene
 *   begins to fade in (not after it fades in). This is faster than a turn 0
 *   condition troop page. Troop page conditions are ignored.
 * - This can be used for things like the Action Sequence Camera plugin, the
 *   Visual Battle Environment plugin, and/or initial battle poses and such in
 *   order to provide a near seamless battle transition experience.
 * - This does NOT trigger when coming out of the options menu or party menu.
 * - This WILL trigger when going from battle to battle nonstop via plugins
 *   like VisuStella MZ's Chain Battles.
 * - When actors are moving towards their home positions, it will take around
 *   30 frames by default. Use this information however you like.
 * 
 * ---
 *
 * ============================================================================
 * Action Sequence - Plugin Commands
 * ============================================================================
 *
 * Skills and items, when used in battle, have a pre-determined series of
 * actions to display to the player as a means of representing what's going on
 * with the action. For some game devs, this may not be enough and they would
 * like to get more involved with the actions themselves.
 *
 * Action Sequences, added through this plugin, enable this. To give a skill or
 * item a Custom Action Sequence, a couple of steps must be followed:
 *
 * ---
 *
 * 1. Insert the <Custom Action Sequence> notetag into the skill or item's
 *    notebox (or else this would not work as intended).
 * 2. Give that skill/item a Common Event through the Effects box. The selected
 *    Common Event will contain all the Action Sequence data.
 * 3. Create the Common Event with Action Sequence Plugin Commands and/or event
 *    commands to make the skill/item do what you want it to do.
 *
 * ---
 *
 * The Plugin Commands added through the Battle Core plugin focus entirely on
 * Action Sequences. However, despite the fact that they're made for skills and
 * items, some of these Action Sequence Plugin Commands can still be used for
 * regular Troop events and Common Events.
 *
 * ---
 *
 * === Action Sequence - Action Sets ===
 *
 * Action Sequence Action Sets are groups of commonly used
 * Action Sequence Commands put together for more efficient usage.
 *
 * ---
 *
 * ACSET: Setup Action Set
 * - The generic start to most actions.
 *
 *   Display Action:
 *   Immortal: On:
 *   Battle Step:
 *   Wait For Movement:
 *   Cast Animation:
 *   Wait For Animation:
 *   - Use this part of the action sequence?
 *
 * ---
 *
 * ACSET: All Targets Action Set
 * - Affects all targets simultaneously performing the following.
 *
 *   Dual/Multi Wield?
 *   - Add times struck based on weapon quantity equipped?
 * 
 *   Perform Action:
 *   Wait Count:
 *   Action Animation:
 *   Wait For Animation:
 *   Action Effect:
 *   Immortal: Off:
 *   - Use this part of the action sequence?
 *   - Insert values for the Wait Count(s).
 *
 * ---
 *
 * ACSET: Each Target Action Set
 * - Goes through each target one by one to perform the following.
 *
 *   Dual/Multi Wield?
 *   - Add times struck based on weapon quantity equipped?
 *
 *   Perform Action:
 *   Wait Count:
 *   Action Animation:
 *   Wait Count:
 *   Action Effect:
 *   Immortal: Off:
 *   - Use this part of the action sequence?
 *   - Insert values for the Wait Count(s).
 *
 * ---
 *
 * ACSET: Finish Action
 * - The generic ending to most actions.
 *
 *   Wait For New Line:
 *   Wait For Effects:
 *   Clear Battle Log:
 *   Home Reset:
 *   Wait For Movement:
 *   - Use this part of the action sequence?
 *
 * ---
 * 
 * === Action Sequences - Angle ===
 * 
 * These action sequences allow you to have control over the camera angle.
 * Requires VisuMZ_3_ActSeqCamera!
 * 
 * ---
 *
 * ANGLE: Change Angle
 * - Changes the camera angle.
 * - Requires VisuMZ_3_ActSeqCamera!
 *
 *   Angle:
 *   - Change the camera angle to this many degrees.
 *
 *   Duration:
 *   - Duration in frames to change camera angle.
 *
 *   Angle Easing:
 *   - Select which easing type you wish to apply.
 *   - Requires VisuMZ_0_CoreEngine.
 *
 *   Wait For Angle?:
 *   - Wait for angle changes to complete before performing next command?
 *
 * ---
 *
 * ANGLE: Reset Angle
 * - Reset any angle settings.
 * - Requires VisuMZ_3_ActSeqCamera!
 *
 *   Duration:
 *   - Duration in frames to reset camera angle.
 *
 *   Angle Easing:
 *   - Select which easing type you wish to apply.
 *   - Requires VisuMZ_0_CoreEngine.
 *
 *   Wait For Angle?:
 *   - Wait for angle changes to complete before performing next command?
 *
 * ---
 *
 * ANGLE: Wait For Angle
 * - Waits for angle changes to complete before performing next command.
 * - Requires VisuMZ_3_ActSeqCamera!
 *
 * ---
 *
 * === Action Sequences - Animations ===
 *
 * These Action Sequences are related to the 'Animations' that can be found in
 * the Animations tab of the Database.
 *
 * ---
 *
 * ANIM: Action Animation
 * - Plays the animation associated with the action.
 *
 *   Targets:
 *   - Select unit(s) to play the animation on.
 *
 *   Mirror Animation:
 *   - Mirror the animation?
 *
 *   Wait For Animation?:
 *   - Wait for animation to complete before performing next command?
 *
 * ---
 *
 * ANIM: Attack Animation
 * - Plays the animation associated with the user's weapon.
 *
 *   Targets:
 *   - Select unit(s) to play the animation on.
 *
 *   Mirror Animation:
 *   - Mirror the animation?
 *
 *   Wait For Animation?:
 *   - Wait for animation to complete before performing next command?
 *
 * ---
 *
 * ANIM: Attack Animation 2+
 * - Plays the animation associated with the user's other weapons.
 * - Plays nothing if there is no other weapon equipped.
 *
 *   Targets:
 *   - Select unit(s) to play the animation on.
 * 
 *   Slot:
 *   - Which weapon slot to get this data from?
 *   - Main-hand weapon is weapon slot 1.
 *
 *   Mirror Animation:
 *   - Mirror the animation?
 *
 *   Wait For Animation?:
 *   - Wait for animation to complete before performing next command?
 *
 * ---
 * 
 * ANIM: Balloon Animation
 * - Plays a balloon animation on target(s).
 * 
 *   Targets:
 *   - Select unit(s) to play the animation on.
 * 
 *   Balloon Type:
 *   - What kind of balloon should be played on target(s)?
 * 
 *   Wait for Completion:
 *   - Wait for balloon animation completion before continuing?
 * 
 * ---
 * 
 * ANIM: Balloon Icon (Single)
 * - Plays a balloon animation using an icon on target(s).
 * - Requires VisuMZ_4_IconBalloons!
 * 
 *   Targets:
 *   - Select unit(s) to play the animation on.
 * 
 *   Icon Index:
 *   - Insert the ID of the icon to show.
 *   - Tip: Right click > Insert Icon Index
 * 
 *   Wait for Completion:
 *   - Wait for balloon animation completion before continuing?
 * 
 * ---
 * 
 * ANIM: Balloon Icon (Range)
 * - Plays a balloon animation an icon range on target(s).
 * - Requires VisuMZ_4_IconBalloons!
 * 
 *   Targets:
 *   - Select unit(s) to play the animation on.
 * 
 *   Starting Icon Index:
 *   - Insert the ID of the icon to show.
 *   - Tip: Right click > Insert Icon Index
 * 
 *   Ending Icon Index:
 *   - Insert the ID of the icon to show.
 *   - Tip: Right click > Insert Icon Index
 * 
 *   Wait for Completion:
 *   - Wait for balloon animation completion before continuing?
 * 
 * ---
 * 
 * ANIM: Balloon Icon (Specific)
 * - Plays a balloon animation with specific icons on target(s).
 * - Requires VisuMZ_4_IconBalloons!
 * 
 *   Targets:
 *   - Select unit(s) to play the animation on.
 * 
 *   Icons:
 *   - Insert the ID(s) of the icon to show.
 *   - Tip: Right click > Insert Icon Index
 * 
 *   Wait for Completion:
 *   - Wait for balloon animation completion before continuing?
 * 
 * ---
 *
 * ANIM: Cast Animation
 * - Plays the cast animation associated with the action.
 *
 *   Targets:
 *   - Select unit(s) to play the animation on.
 *
 *   Mirror Animation:
 *   - Mirror the animation?
 *
 *   Wait For Animation?:
 *   - Wait for animation to complete before performing next command?
 *
 * ---
 *
 * ANIM: Change Battle Portrait
 * - Changes the battle portrait of the actor (if it's an actor).
 * - Can be used outside of battle/action sequences.
 *
 *   Targets:
 *   - Select unit(s) to play the animation on.
 *   - Valid units can only be actors.
 *
 *   Filename:
 *   - Select the file to change the actor's portrait to.
 * 
 * ---
 *
 * ANIM: Guard Animation
 * - Plays the animation associated with the user's guard action (if any).
 *
 *   Targets:
 *   - Select unit(s) to play the animation on.
 *
 *   Mirror Animation:
 *   - Mirror the animation?
 *
 *   Wait For Animation?:
 *   - Wait for animation to complete before performing next command?
 *
 * ---
 *
 * ANIM: Item Animation
 * - Plays the animation associated with a specific item.
 * 
 *   Item ID:
 *   - Which item ID will the animation come from?
 *
 *   Targets:
 *   - Select unit(s) to play the animation on.
 *
 *   Mirror Animation:
 *   - Mirror the animation?
 *
 *   Wait For Animation?:
 *   - Wait for animation to complete before performing next command?
 *
 * ---
 *
 * ANIM: Play at Coordinate
 * - Plays an animation on the screen at a specific x, y coordinate.
 * - Requires VisuMZ_0_CoreEngine!
 * 
 *   Animation ID:
 *   - Plays this animation.
 * 
 *   Coordinates:
 * 
 *     X:
 *     Y:
 *     - X/Y coordinate used for the animation.
 *       You may use JavaScript code.
 * 
 *   Mirror Animation?:
 *   - Mirror the animation?
 * 
 *   Mute Animation?:
 *   - Mute the animation?
 * 
 *   Wait for Completion?:
 *   - Wait the animation to finish before continuing?
 *
 * ---
 *
 * ANIM: Show Animation
 * - Plays the a specific animation on unit(s).
 *
 *   Targets:
 *   - Select unit(s) to play the animation on.
 *
 *   Animation ID:
 *   - Select which animation to play on unit(s).
 *
 *   Mirror Animation:
 *   - Mirror the animation?
 *
 *   Wait For Animation?:
 *   - Wait for animation to complete before performing next command?
 *
 * ---
 *
 * ANIM: Show Animation JS
 * - Plays the a specific animation on unit(s).
 * - Uses JavaScript to determine animation ID.
 *
 *   Targets:
 *   - Select unit(s) to play the animation on.
 *
 *   JS: Animation ID:
 *   - Select which animation to play on unit(s).
 *   - Uses JavaScript to determine animation ID.
 *
 *   Mirror Animation:
 *   - Mirror the animation?
 *
 *   Wait For Animation?:
 *   - Wait for animation to complete before performing next command?
 *
 * ---
 *
 * ANIM: Skill Animation
 * - Plays the animation associated with a specific skill.
 * 
 *   Skill ID:
 *   - Which skill ID will the animation come from?
 *
 *   Targets:
 *   - Select unit(s) to play the animation on.
 *
 *   Mirror Animation:
 *   - Mirror the animation?
 *
 *   Wait For Animation?:
 *   - Wait for animation to complete before performing next command?
 *
 * ---
 *
 * ANIM: Wait For Animation
 * - Causes the interpreter to wait for any animation(s) to finish.
 *
 * ---
 *
 * === Action Sequences - Battle Log ===
 *
 * These Action Sequences are related to the Battle Log Window, the window
 * found at the top of the battle screen.
 *
 * ---
 *
 * BTLOG: Add Text
 * - Adds a new line of text into the Battle Log.
 *
 *   Text:
 *   - Add this text into the Battle Log.
 *   - Text codes allowed.
 * 
 *   Copy to Combat Log?:
 *   - Copies text to the Combat Log.
 *   - Requires VisuMZ_4_CombatLog
 * 
 *     Combat Log Icon:
 *     - What icon would you like to bind to this entry?
 *     - Requires VisuMZ_4_CombatLog
 *
 * ---
 *
 * BTLOG: Clear Battle Log
 * - Clears all the text in the Battle Log.
 *
 * ---
 *
 * BTLOG: Display Action
 * - plays the current action in the Battle Log.
 *
 * ---
 *
 * BTLOG: Pop Base Line
 * - Removes the Battle Log's last added base line and  all text up to its
 *   former location.
 *
 * ---
 *
 * BTLOG: Push Base Line
 * - Adds a new base line to where the Battle Log currently is at.
 *
 * ---
 *
 * BTLOG: Refresh Battle Log
 * - Refreshes the Battle Log.
 *
 * ---
 *
 * BTLOG: UI Show/Hide
 * - Shows or hides the Battle UI (including the Battle Log).
 *
 *   Show/Hide?:
 *   - Shows/hides the Battle UI.
 *
 * ---
 *
 * BTLOG: Wait For Battle Log
 * - Causes the interpreter to wait for the Battle Log to finish.
 *
 * ---
 *
 * BTLOG: Wait For New Line
 * - Causes the interpreter to wait for a new line in the Battle Log.
 *
 * ---
 *
 * === Action Sequences - Camera ===
 *
 * These Action Sequences are battle camera-related.
 * Requires VisuMZ_3_ActSeqCamera!
 *
 * ---
 *
 * CAMERA: Clamp ON/OFF
 * - Turns battle camera clamping on/off.
 * - Requires VisuMZ_3_ActSeqCamera!
 *
 *   Setting:
 *   - Turns camera clamping on/off.
 *
 * ---
 *
 * CAMERA: Focus Point
 * - Focus the battle camera on a certain point in the screen.
 * - Requires VisuMZ_3_ActSeqCamera!
 *
 *   X Coordinate:
 *   - Insert the point to focus the camera on.
 *   - You may use JavaScript code.
 *
 *   Y Coordinate:
 *   - Insert the point to focus the camera on.
 *   - You may use JavaScript code.
 *
 *   Duration:
 *   - Duration in frames for camera focus change.
 *
 *   Camera Easing:
 *   - Select which easing type you wish to apply.
 *   - Requires VisuMZ_0_CoreEngine.
 *
 *   Wait For Camera?
 *   - Wait for camera changes to complete before performing next command?
 *
 * ---
 *
 * CAMERA: Focus Target(s)
 * - Focus the battle camera on certain battler target(s).
 * - Requires VisuMZ_3_ActSeqCamera!
 *
 *   Targets:
 *   - Select unit(s) to focus the battle camera on.
 *
 *   Duration:
 *   - Duration in frames for camera focus change.
 *
 *   Camera Easing:
 *   - Select which easing type you wish to apply.
 *   - Requires VisuMZ_0_CoreEngine.
 *
 *   Wait For Camera?
 *   - Wait for camera changes to complete before performing next command?
 *
 * ---
 *
 * CAMERA: Offset
 * - Offset the battle camera from the focus target.
 * - Requires VisuMZ_3_ActSeqCamera!
 *
 *   Offset X:
 *   - How much to offset the camera X by.
 *   - Negative: left. Positive: right.
 *
 *   Offset Y:
 *   - How much to offset the camera Y by.
 *   - Negative: up. Positive: down.
 *
 *   Duration:
 *   - Duration in frames for offset change.
 *
 *   Camera Easing:
 *   - Select which easing type you wish to apply.
 *   - Requires VisuMZ_0_CoreEngine.
 *
 *   Wait For Camera?
 *   - Wait for camera changes to complete before performing next command?
 *
 * ---
 *
 * CAMERA: Reset
 * - Reset the battle camera settings.
 * - Requires VisuMZ_3_ActSeqCamera!
 *
 *   Reset Focus?:
 *   - Reset the focus point?
 *
 *   Reset Offset?:
 *   - Reset the camera offset?
 *
 *   Duration:
 *   - Duration in frames for reset change.
 *
 *   Camera Easing:
 *   - Select which easing type you wish to apply.
 *   - Requires VisuMZ_0_CoreEngine.
 *
 *   Wait For Camera?
 *   - Wait for camera changes to complete before performing next command?
 *
 * ---
 *
 * CAMERA: Wait For Camera
 * - Waits for camera changes to complete before performing next command.
 * - Requires VisuMZ_3_ActSeqCamera!
 *
 * ---
 * 
 * === Action Sequences - Cutins ===
 * 
 * Allows you to have control over Visual Cutin Effects.
 * Requires VisuMZ_3_VisualCutinEffect!
 * 
 * ---
 * 
 * CUTIN: Add Visual Cutin Effect
 * - Adds the Visual Cutin Effect using these desired settings.
 * - Only one of each cutin-style type can be present at a time.
 * - Requires VisuMZ_3_VisualCutinEffect!
 * 
 *   Basic Settings:
 * 
 *     Cutin Style Type:
 *     - What Visual Cutin Effect style type do you wish to use?
 *     - Only one of each cutin-style type can be present.
 *     - Refer to VisuMZ wiki for visuals on styles.
 * 
 *     Portrait Target:
 *     - Select unit(s) to grab the Visual Cutin Effect portrait data from.
 *     - First unit will be used to make portrait.
 * 
 *     Parallax Filename:
 *     - Pick a parallax to use for the Visual Cutin Effect.
 *     - Pick (None) to not use a parallax.
 * 
 *     Background Color:
 *     - Use #rrggbb for custom colors or regular numbers for text colors from
 *       the Window Skin.
 *
 *   Extra Settings:
 *   - Extra Plugin Command settings pertaining to this Visual Cutin Effect.
 *   - An explanation for these settings are found in the Visual Cutin Effect
 *     help file and documentation.
 *   - Extra parameters are added for Parallax Scroll Inversion when the target
 *     is an enemy.
 * 
 *   Wait for Entrance:
 *   - Wait until cutin entrance is finished before performing the next
 *     event command?
 * 
 * ---
 *
 * CUTIN: End Visual Cutin Effect (All)
 * - Ends all Visual Cutin Effects currently present.
 * - Requires VisuMZ_3_VisualCutinEffect!
 * 
 *   Wait for Exit:
 *   - Wait until cutin exit is finished before performing the next
 *     event command?
 *
 * ---
 *
 * CUTIN: End Visual Cutin Effect (Type)
 * - Ends the Visual Cutin Effect with the matching type.
 * - Requires VisuMZ_3_VisualCutinEffect!
 *
 *   Cutin Style Type:
 *   - What Visual Cutin Effect style type do you wish to end?
 * 
 *   Wait for Exit:
 *   - Wait until cutin exit is finished before performing the next
 *     event command?
 *
 * ---
 * 
 * CUTIN: Wait for Cutin Entrance
 * - Wait until all cutin entrances are finished before performing the next
 *   event command.
 * - Requires VisuMZ_3_VisualCutinEffect!
 * 
 * ---
 * 
 * CUTIN: Wait for Cutin Exit
 * - Wait until all cutin exits are finished before performing the next
 *   event command.
 * - Requires VisuMZ_3_VisualCutinEffect!
 * 
 * ---
 *
 * === Action Sequences - Dragonbones ===
 *
 * These Action Sequences are Dragonbones-related.
 * Requires VisuMZ_2_DragonbonesUnion!
 *
 * ---
 *
 * DB: Dragonbones Animation
 * - Causes the unit(s) to play a Dragonbones motion animation.
 * - Requires VisuMZ_2_DragonbonesUnion!
 *
 *   Targets:
 *   - Select which unit(s) to perform a motion animation.
 *
 *   Motion Animation:
 *   - What is the name of the Dragonbones motion animation you wish to play?
 *
 * ---
 *
 * DB: Dragonbones Time Scale
 * - Causes the unit(s) to change their Dragonbones time scale.
 * - Requires VisuMZ_2_DragonbonesUnion!
 *
 *   Targets:
 *   - Select which unit(s) to perform a motion animation.
 *
 *   Time Scale:
 *   - Change the value of the Dragonbones time scale to this.
 *
 * ---
 *
 * === Action Sequences - Elements ===
 *
 * These Action Sequences can change up the element(s) used for the action's
 * damage calculation midway through an action.
 *
 * They also require the VisuMZ_1_ElementStatusCore plugin to be present in
 * order for them to work.
 *
 * ---
 *
 * ELE: Add Elements
 * - Adds element(s) to be used when calculating damage.
 * - Requires VisuMZ_1_ElementStatusCore!
 *
 *   Elements:
 *   - Select which element ID to add onto the action.
 *   - Insert multiple element ID's to add multiple at once.
 *
 * ---
 *
 * ELE: Clear Element Changes
 * - Clears all element changes made through Action Sequences.
 * - Requires VisuMZ_1_ElementStatusCore!
 *
 * ---
 *
 * ELE: Force Elements
 * - Forces only specific element(s) when calculating damage.
 * - Requires VisuMZ_1_ElementStatusCore!
 *
 *   Elements:
 *   - Select which element ID to force in the action.
 *   - Insert multiple element ID's to force multiple at once.
 *
 * ---
 *
 * ELE: Null Element
 * - Forces no element to be used when calculating damage.
 * - Requires VisuMZ_1_ElementStatusCore!
 *
 * ---
 * 
 * === Action Sequences - Grid ===
 * 
 * These Action Sequences are Battle Grid System-related.
 * Requires VisuMZ_2_BattleGridSystem!
 * 
 * ---
 * 
 * GRID: Action Animation at Node
 * - Plays action animation at target node.
 * - Requires VisuMZ_2_BattleGridSystem!
 * 
 *   Action-Selected Node?:
 *   - Use Action-Selected Node Coordinates if possible?
 *   - Requires "Empty" or "Any" for <Target: x Grid Node>
 *   - If the no action is in effect or the action doesn't use that target
 *     structure, use the node coordinates below:
 * 
 *     Unit:
 *     - Which unit's Node do you want to play an animation on?
 * 
 *     Rank:
 *     - Input the number representing the Rank of the Node you want to play an
 *       animation on.
 * 
 *     Flank:
 *     - Input the number representing the Flank of the Node you want to play
 *       an animation on.
 * 
 *   Offset X:
 *   - Offsets the animation x position.
 *   - Negative: left. Positive: right.
 * 
 *   Offset Y:
 *   - Offsets the animation y position.
 *   - Negative: up. Positive: down.
 * 
 * ---
 *
 * GRID: Add Passive State(s) to Node
 * - Adds Passive State(s) at target node.
 * - Requires VisuMZ_2_BattleGridSystem!
 *
 *   State ID(s):
 *   - Select which State ID(s) to add as a Passive State.
 * 
 *   Action-Selected Node?:
 *   - Use Action-Selected Node Coordinates if possible?
 *   - Requires "Empty" or "Any" for <Target: x Grid Node>
 *   - If the no action is in effect or the action doesn't use that target
 *     structure, use the node coordinates below:
 *
 *     Unit:
 *     - Which unit do you want to add the Passive State Node effect for?
 *
 *     Rank:
 *     - Input the number representing the Rank of the Node you want to add a
 *       Passive State(s) to.
 *
 *     Flank:
 *     - Input the number representing the Flank of the Node you want to add a
 *       Passive State(s) to.
 *
 * ---
 * 
 * GRID: Add Trigger to Node
 * - Adds Trigger to target node.
 * - Target node cannot have battler.
 * - Each node can only contain ONE trigger! 
 * - Otherwise, newly placed triggers will overwrite the old ones.
 * - Requires VisuMZ_2_BattleGridSystem!
 * 
 *   Skill ID:
 *   - Select which Skill ID(s) to add as the trigger.
 * 
 *   Action-Selected Node?:
 *   - Use Action-Selected Node Coordinates if possible?
 *   - Requires "Empty" or "Any" for <Target: x Grid Node>
 *   - If the no action is in effect or the action doesn't use that target
 *     structure, use the node coordinates below:
 * 
 *     Unit:
 *     - Which unit do you want to add the Trigger Node effect for?
 * 
 *     Rank:
 *     - Input the number representing the Rank of the Node you want to add a
 *       Trigger to.
 * 
 *     Flank:
 *     - Input the number representing the Flank of the Node you want to add a
 *       Trigger to.
 * 
 * ---
 * 
 * GRID: Add Trigger to Node JS
 * - Adds JS Trigger to target node.
 * - Target node cannot have battler.
 * - Each node can only contain ONE trigger! 
 * - Otherwise, newly placed triggers will overwrite the old ones.
 * - Requires VisuMZ_2_BattleGridSystem!
 * 
 *   JS: Skill ID:
 *   - Use JavaScript to determine what skill ID to add to this node.
 * 
 *   Action-Selected Node?:
 *   - Use Action-Selected Node Coordinates if possible?
 *   - Requires "Empty" or "Any" for <Target: x Grid Node>
 *   - If the no action is in effect or the action doesn't use that target
 *     structure, use the node coordinates below:
 * 
 *     Unit:
 *     - Which unit do you want to add the Trigger Node effect for?
 * 
 *     Rank:
 *     - Input the number representing the Rank of the Node you want to add a
 *       Trigger to.
 * 
 *     Flank:
 *     - Input the number representing the Flank of the Node you want to add a
 *       Trigger to.
 * 
 * ---
 * 
 * GRID: Animation ID at Node
 * - Plays specific animation ID at target node.
 * 
 *   Animation ID:
 *   - Play this animation at target node.
 * 
 *     Mirror?:
 *     - Mirror this animation?
 * 
 *     Mute?:
 *     - Mute this animation?
 * 
 *   Action-Selected Node?:
 *   - Use Action-Selected Node Coordinates if possible?
 *   - Requires "Empty" or "Any" for <Target: x Grid Node>
 *   - If the no action is in effect or the action doesn't use that target
 *     structure, use the node coordinates below:
 * 
 *     Unit:
 *     - Which unit's Node do you want to play an animation on?
 * 
 *     Rank:
 *     - Input the number representing the Rank of the Node you want to play an
 *       animation on.
 * 
 *     Flank:
 *     - Input the number representing the Flank of the Node you want to play
 *       an animation on.
 * 
 *   Offset X:
 *   - Offsets the animation x position.
 *   - Negative: left. Positive: right.
 * 
 *   Offset Y:
 *   - Offsets the animation y position.
 *   - Negative: up. Positive: down.
 * 
 * ---
 * 
 * GRID: Animation JS at Node
 * - Uses JS to calculate which animation to play at target node.
 * 
 *   JS: Animation ID:
 *   - Calculate which animation to play on unit(s).
 *   - Uses JavaScript to determine animation ID.
 * 
 *     Mirror?:
 *     - Mirror this animation?
 * 
 *     Mute?:
 *     - Mute this animation?
 * 
 *   Action-Selected Node?:
 *   - Use Action-Selected Node Coordinates if possible?
 *   - Requires "Empty" or "Any" for <Target: x Grid Node>
 *   - If the no action is in effect or the action doesn't use that target
 *     structure, use the node coordinates below:
 * 
 *     Unit:
 *     - Which unit's Node do you want to play an animation on?
 * 
 *     Rank:
 *     - Input the number representing the Rank of the Node you want to play an
 *       animation on.
 * 
 *     Flank:
 *     - Input the number representing the Flank of the Node you want to play
 *       an animation on.
 * 
 *   Offset X:
 *   - Offsets the animation x position.
 *   - Negative: left. Positive: right.
 * 
 *   Offset Y:
 *   - Offsets the animation y position.
 *   - Negative: up. Positive: down.
 * 
 * ---
 * 
 * GRID: Animation Type at Node
 * - Plays certain animation type at target node.
 * - Requires VisuMZ_2_BattleGridSystem!
 * 
 *   Type:
 *   - What is the animation type you would like to play?
 *     - Attack
 *     - Guard
 *     - Item
 *     - Skill
 * 
 *     Slot (Attack Type):
 *     - Which weapon slot to get this data from?
 *     - Main-hand weapon is weapon slot 1.
 * 
 *     Item ID (Item Type):
 *     - Which item ID will the animation come from?
 * 
 *     Skill ID (Skill Type):
 *     - Which skill ID will the animation come from?
 * 
 *   Action-Selected Node?:
 *   - Use Action-Selected Node Coordinates if possible?
 *   - Requires "Empty" or "Any" for <Target: x Grid Node>
 *   - If the no action is in effect or the action doesn't use that target
 *     structure, use the node coordinates below:
 * 
 *     Unit:
 *     - Which unit's Node do you want to play an animation on?
 * 
 *     Rank:
 *     - Input the number representing the Rank of the Node you want to play an
 *       animation on.
 * 
 *     Flank:
 *     - Input the number representing the Flank of the Node you want to play
 *       an animation on.
 * 
 *   Offset X:
 *   - Offsets the animation x position.
 *   - Negative: left. Positive: right.
 * 
 *   Offset Y:
 *   - Offsets the animation y position.
 *   - Negative: up. Positive: down.
 * 
 * ---
 * 
 * GRID: Move Target(s) In Direction
 * - Moves target(s) in a specific direction to other Nodes.
 * - Requires VisuMZ_2_BattleGridSystem!
 * - This will bypass the "once per action" condition used for both the
 *   <rule Move User Node direction: x> & <rule Move Target Node direction: x>
 *   notetags as this is not a notetag effect.
 * 
 *   Targets:
 *   - Select unit(s) to move.
 * 
 *   Movement Type:
 *   - Select the Movement type rulings.
 *   - See VisuMZ_2_BattleGridSystem help file for details.
 * 
 *     Direction:
 *     - Select the movement direction.
 * 
 *     Distance:
 *     - The number of nodes to be moved.
 *     - You may use JavaScript code.
 * 
 *   Duration:
 *   - Input the number representing the frames used to move.
 * 
 *   Silent Change?:
 *   - Silent: Discreet changes shown. More apparent later.
 *   - Visual: Instant changes shown.
 * 
 * ---
 * 
 * GRID: Pull To Target Node
 * - Pulls battlers towards target node.
 * - Requires VisuMZ_2_BattleGridSystem!
 * 
 *   Action-Selected Node?:
 *   - Use Action-Selected Node Coordinates if possible?
 *   - Requires "Empty" or "Any" for <Target: x Grid Node>
 *
 *     Unit:
 *     - Which unit do you want to pull on?
 *
 *     Rank:
 *     - Input the number representing the Rank of the Node you want to
 *       pull to.
 *
 *     Flank:
 *     - Input the number representing the Flank of the Node you want to
 *       pull to.
 * 
 *   Strength:
 *   - Input the strength level of the pull.
 * 
 *   Duration:
 *   - Input the number representing the frames used to move.
 * 
 * ---
 * 
 * GRID: Push From Target Node
 * - Pushes battlers away from target node.
 * - Requires VisuMZ_2_BattleGridSystem!
 * 
 *   Action-Selected Node?:
 *   - Use Action-Selected Node Coordinates if possible?
 *   - Requires "Empty" or "Any" for <Target: x Grid Node>
 *
 *     Unit:
 *     - Which unit do you want to push from?
 *
 *     Rank:
 *     - Input the number representing the Rank of the Node you want to
 *       push from.
 *
 *     Flank:
 *     - Input the number representing the Flank of the Node you want to
 *       push from.
 * 
 *   Strength:
 *   - Input the strength level of the push.
 * 
 *   Duration:
 *   - Input the number representing the frames used to move.
 * 
 * ---
 *
 * GRID: Remove All Passive States from Node
 * - Removes all Passive State effects at target node.
 * - Requires VisuMZ_2_BattleGridSystem!
 * 
 *   Action-Selected Node?:
 *   - Use Action-Selected Node Coordinates if possible?
 *   - Requires "Empty" or "Any" for <Target: x Grid Node>
 *   - If the no action is in effect or the action doesn't use that target
 *     structure, use the node coordinates below:
 *
 *     Unit:
 *     - Which unit do you want to clear the Node for?
 *
 *     Rank:
 *     - Input the number representing the Rank of the Node you want to clear
 *       Passive States from.
 *
 *     Flank:
 *     - Input the number representing the Flank of the Node you want to clear
 *       Passive States from.
 *
 * ---
 *
 * GRID: Remove Passive State(s) from Node
 * - Remove Passive State(s) at target node.
 * - Requires VisuMZ_2_BattleGridSystem!
 *
 *   State ID(s):
 *   - Select which State ID(s) to remove as a Passive State.
 * 
 *   Action-Selected Node?:
 *   - Use Action-Selected Node Coordinates if possible?
 *   - Requires "Empty" or "Any" for <Target: x Grid Node>
 *   - If the no action is in effect or the action doesn't use that target
 *     structure, use the node coordinates below:
 *
 *     Unit:
 *     - Which unit do you want to remove the Passive State Node effect for?
 *
 *     Rank:
 *     - Input the number representing the Rank of the Node you want to remove
 *       a Passive State(s) from.
 *
 *     Flank:
 *     - Input the number representing the Flank of the Node you want to remove
 *       a Passive State(s) from.
 *
 * ---
 * 
 * GRID: Remove Trigger from Node
 * - Removes Trigger at target node.
 * - Requires VisuMZ_2_BattleGridSystem!
 * 
 *   Action-Selected Node?:
 *   - Use Action-Selected Node Coordinates if possible?
 *   - Requires "Empty" or "Any" for <Target: x Grid Node>
 *   - If the no action is in effect or the action doesn't use that target
 *     structure, use the node coordinates below:
 * 
 *     Unit:
 *     - Which unit do you want to clear Triggers for?
 * 
 *     Rank:
 *     - Input the number representing the Rank of the Node you want to clear
 *       Triggers from.
 * 
 *     Flank:
 *     - Input the number representing the Flank of the Node you want to clear
 *       Triggers from.
 * 
 * ---
 * 
 * === Action Sequences - Horror Effects ===
 * 
 * These Action Sequences are Horror Effects-related.
 * Requires VisuMZ_2_HorrorEffects!
 * 
 * ---
 *
 * HORROR: Clear All Filters
 * - Clear all Horror Effects filters on the target battler(s).
 *
 *   Targets:
 *   - Select unit(s) to remove Horror Effects for.
 *
 * ---
 *
 * HORROR: Glitch Create
 * - Creates the glitch effect on the target battler(s).
 *
 *   Targets:
 *   - Select unit(s) to create the Horror Effect for.
 *
 *   Glitch Slices:
 *   - Glitch slices to be used with the target.
 *
 *   Glitch Offset:
 *   - Default offset value.
 *
 *   Glitch Animated?:
 *   - Animate the glitch effect?
 *
 *   Glitch Frequency:
 *   - If animated, how frequent to make the glitch effect?
 *   - Lower = often     Higher = rarer
 *
 *   Glitch Strength:
 *   - If animated, how strong is the glitch effect?
 *   - Lower = weaker     Higher = stronger
 *
 * ---
 *
 * HORROR: Glitch Remove
 * - Removes the glitch effect on the target battler(s).
 *
 *   Targets:
 *   - Select unit(s) to remove the Horror Effect for.
 *
 * ---
 *
 * HORROR: Noise Create
 * - Creates the noise effect on the target battler(s).
 *
 *   Targets:
 *   - Select unit(s) to create the Horror Effect for.
 *
 *   Noise Rate:
 *   - Noise rate to be used with the target.
 *
 *   Noise Animated:
 *   - Animate the noise for the target?
 *
 * ---
 *
 * HORROR: Noise Remove
 * - Removes the noise effect on the target battler(s).
 *
 *   Targets:
 *   - Select unit(s) to remove the Horror Effect for.
 *
 * ---
 *
 * HORROR: TV Create
 * - Creates the TV effect on the target battler(s).
 *
 *   Targets:
 *   - Select unit(s) to create the Horror Effect for.
 *
 *   TV Line Thickness:
 *   - Default TV line thickness
 *   - Lower = thinner     Higher = thicker
 *
 *   TV Corner Size:
 *   - Default TV line corner size
 *   - Lower = smaller     Higher = bigger
 *
 *   TV Animated:
 *   - Animate the TV?
 *
 *   TV Speed:
 *   - Speed used to animate the TV if animated
 *   - Lower = slower     Higher = faster
 *
 * ---
 *
 * HORROR: TV Remove
 * - Removes the TV effect on the target battler(s).
 *
 *   Targets:
 *   - Select unit(s) to remove the Horror Effect for.
 *
 * ---
 * 
 * === Action Sequences - Impact ===
 * 
 * These Action Sequences are related to creating impact.
 * Requires VisuMZ_3_ActSeqImpact!
 * 
 * ---
 *
 * IMPACT: Bizarro Inversion
 * - Swaps blue/red colors on the battlefield.
 * - Requires VisuMZ_3_ActSeqImpact!
 * - Created by Manu Gaming!
 *
 *   Bizarro?:
 *   - Enable Bizarro Inversion effect?
 *
 * ---
 *
 * IMPACT: Color Break
 * - Breaks the colors on the screen before reassembling.
 * - Requires VisuMZ_3_ActSeqImpact!
 *
 *   Intensity:
 *   - What is the intensity of the color break effect?
 *
 *   Duration:
 *   - What is the duration of the color break effect?
 *
 *   Easing Type:
 *   - Select which easing type you wish to apply.
 *
 * ---
 *
 * IMPACT: Desaturation
 * - Desaturates all colors on the battlefield.
 * - Requires VisuMZ_3_ActSeqImpact!
 * - Created by Manu Gaming!
 *
 *   Desaturate?:
 *   - Enable Desaturation effect?
 *
 * ---
 *
 * IMPACT: Motion Blur Screen
 * - Creates a motion blur on the whole screen.
 * - Requires VisuMZ_3_ActSeqImpact!
 *
 *   Angle:
 *   - Determine what angle to make the motion blur at.
 *
 *   Intensity Rate:
 *   - This determines intensity rate of the motion blur.
 *   - Use a number between 0 and 1.
 *
 *   Duration:
 *   - How many frames should the motion blur last?
 *   - What do you want to be its duration?
 *
 *   Easing Type:
 *   - Select which easing type you wish to apply.
 *
 * ---
 *
 * IMPACT: Motion Blur Target(s)
 * - Creates a motion blur on selected target(s).
 * - Requires VisuMZ_3_ActSeqImpact!
 *
 *   Targets:
 *   - Select unit(s) to create motion blur effects for.
 *
 *   Angle:
 *   - Determine what angle to make the motion blur at.
 *
 *   Intensity Rate:
 *   - This determines intensity rate of the motion blur.
 *   - Use a number between 0 and 1.
 *
 *   Duration:
 *   - How many frames should the motion blur last?
 *   - What do you want to be its duration?
 *
 *   Easing Type:
 *   - Select which easing type you wish to apply.
 *
 * ---
 *
 * IMPACT: Motion Trail Create
 * - Creates a motion trail effect for the target(s).
 * - Requires VisuMZ_3_ActSeqImpact!
 *
 *   Targets:
 *   - Select unit(s) to create motion trail effects for.
 *
 *   Delay:
 *   - How many frames to delay by when creating a motion trail?
 *   - The higher the delay, the less motion trails there are.
 *
 *   Duration:
 *   - How many frames should the motion trail last?
 *   - What do you want to be its duration?
 *
 *   Hue:
 *   - What do you want to be the hue for the motion trail?
 *
 *   Starting Opacity:
 *   - What starting opacity value do you want for the motion trail?
 *   - Opacity values decrease over time.
 *
 *   Tone:
 *   - What tone do you want for the motion trail?
 *   - Format: [Red, Green, Blue, Gray]
 *
 * ---
 *
 * IMPACT: Motion Trail Remove
 * - Removes the motion trail effect from the target(s).
 * - Requires VisuMZ_3_ActSeqImpact!
 *
 *   Targets:
 *   - Select unit(s) to clear motion trail effects for.
 *
 * ---
 *
 * IMPACT: Negative Inversion
 * - Inverts all the colors on the battlefield.
 * - Requires VisuMZ_3_ActSeqImpact!
 * - Created by Manu Gaming!
 *
 *   Negative?:
 *   - Enable Negative Inversion effect?
 *
 * ---
 *
 * IMPACT: Oversaturation
 * - Oversaturates colors on the battlefield.
 * - Requires VisuMZ_3_ActSeqImpact!
 *
 *   Oversaturate?:
 *   - Enable Oversaturation effect?
 *
 * ---
 *
 * IMPACT: Shockwave at Point
 * - Creates a shockwave at the designated coordinates.
 * - Requires VisuMZ_3_ActSeqImpact!
 *
 *   Point: X:
 *   Point: Y:
 *   - What x/y coordinate do you want to create a shockwave at?
 *   - You can use JavaScript code.
 *
 *   Amplitude:
 *   - What is the aplitude of the shockwave effect?
 *
 *   Wavelength:
 *   - What is the wavelength of the shockwave effect?
 *
 *   Duration:
 *   - What is the duration of the shockwave?
 *
 * ---
 *
 * IMPACT: Shockwave from Each Target(s)
 * - Creates a shockwave at each of the target(s) location(s).
 * - Requires VisuMZ_3_ActSeqImpact!
 *
 *   Targets:
 *   - Select unit(s) to start a shockwave from.
 *
 *   Target Location:
 *   - Select which part target group to start a shockwave from.
 * 
 *     Offset X:
 *     Offset Y:
 *     - How much to offset the shockwave X/Y point by.
 *
 *   Amplitude:
 *   - What is the aplitude of the shockwave effect?
 *
 *   Wavelength:
 *   - What is the wavelength of the shockwave effect?
 *
 *   Duration:
 *   - What is the duration of the shockwave?
 *
 * ---
 *
 * IMPACT: Shockwave from Target(s) Center
 * - Creates a shockwave from the center of the target(s).
 * - Requires VisuMZ_3_ActSeqImpact!
 *
 *   Targets:
 *   - Select unit(s) to start a shockwave from.
 *
 *   Target Location:
 *   - Select which part target group to start a shockwave from.
 * 
 *     Offset X:
 *     Offset Y:
 *     - How much to offset the shockwave X/Y point by.
 *
 *   Amplitude:
 *   - What is the aplitude of the shockwave effect?
 *
 *   Wavelength:
 *   - What is the wavelength of the shockwave effect?
 *
 *   Duration:
 *   - What is the duration of the shockwave?
 *
 * ---
 *
 * IMPACT: Time Scale
 * - Adjust time to go faster or slower!
 * - Requires VisuMZ_3_ActSeqImpact!
 * - Created by Manu Gaming!
 *
 *   Scale:
 *   - Adjusts how fast/slow time goes.
 *   - 1.00 is normal. Lower is slower. Higher is faster.
 *
 * ---
 *
 * IMPACT: Time Stop
 * - Stops time for a set amount of milliseconds.
 * - Requires VisuMZ_3_ActSeqImpact!
 * - Created by Manu Gaming!
 *
 *   Milliseconds:
 *   - How many milliseconds should time stop for?
 *   - 1000 milliseconds = 1 second.
 *
 * ---
 *
 * IMPACT: Zoom Blur at Point
 * - Creates a zoom blur at the designated coordinates.
 * - Requires VisuMZ_3_ActSeqImpact!
 *
 *   Point: X:
 *   Point: Y:
 *   - What x/y coordinate do you want to focus the zoom at?
 *   - You can use JavaScript code.
 *
 *   Zoom Strength:
 *   - What is the strength of the zoom effect?
 *   - Use a number between 0 and 1.
 *
 *   Visible Radius:
 *   - How much of a radius should be visible from the center?
 *
 *   Duration:
 *   - What is the duration of the zoom blur?
 *
 *   Easing Type:
 *   - Select which easing type you wish to apply.
 *
 * ---
 *
 * IMPACT: Zoom Blur at Target(s) Center
 * - Creates a zoom blur at the center of targets.
 * - Requires VisuMZ_3_ActSeqImpact!
 *
 *   Targets:
 *   - Select unit(s) to start a zoom blur from.
 *
 *   Target Location:
 *   - Select which part target group to start a zoom blur from.
 * 
 *     Offset X:
 *     Offset Y:
 *     - How much to offset the zoom blur X/Y point by.
 *
 *   Zoom Strength:
 *   - What is the strength of the zoom effect?
 *   - Use a number between 0 and 1.
 *
 *   Visible Radius:
 *   - How much of a radius should be visible from the center?
 *
 *   Duration:
 *   - What is the duration of the zoom blur?
 *
 *   Easing Type:
 *   - Select which easing type you wish to apply.
 *
 * ---
 *
 * === Action Sequences - Inject ===
 *
 * These Action Sequences are related to injecting sprite animations.
 * Requires VisuMZ_3_ActSeqImpact!
 *
 * ---
 * 
 * INJECT: Animation Begin
 * - Injects and plays a whole spritesheet animation.
 * - The spritesheet animation will play over the battler until it is finished.
 * - The battler's original sprite will be invisible until finished.
 * - Requires VisuMZ_3_ActSeqImpact!
 * 
 *   Targets:
 *   - Select unit(s) to inject the animation on.
 * 
 *   Filename:
 *   - Select the animation spritesheet file.
 *   - Located in the /img/sv_actors/ folder.
 * 
 *     Horizontal Cells:
 *     - How many horizontal cells (or columns) are there?
 * 
 *     Vertical Cells:
 *     - How many vertical cells (or rows) are there?
 * 
 *     Frame Delay:
 *     - How many frames are played inbetween cells?
 * 
 *     Smooth Bitmap?:
 *     - Smooth the spritesheet graphic?
 * 
 *   Offset:
 * 
 *     Offset X:
 *     - Offsets the X position of the injected animation.
 *     - Negative: left. Positive: right.
 * 
 *     Offset Y:
 *     - Offsets the Y position of the injected animation.
 *     - Negative: up. Positive: down.
 * 
 * ---
 * 
 * INJECT: Animation End
 * - Stops and ends any injected animations on target(s).
 * - Any inject animation will be prematurely terminated.
 * - Requires VisuMZ_3_ActSeqImpact!
 * 
 *   Targets:
 *   - Select unit(s) to stop injected animation(s).
 * 
 * ---
 * 
 * INJECT: Animation Pause/Resume
 * - Pauses/resumes any injected animations on target(s).
 * - Requires VisuMZ_3_ActSeqImpact!
 * 
 *   Targets:
 *   - Select unit(s) to pause/resume injected animation(s).
 * 
 *   Pause?:
 *   - Pause the injected animation?
 * 
 * ---
 * 
 * INJECT: Wait For Injected Animation
 * - Waits for injected animations to complete before performing next command.
 * - Requires VisuMZ_3_ActSeqImpact!
 * 
 * ---
 *
 * === Action Sequences - Mechanics ===
 *
 * These Action Sequences are related to various mechanics related to the
 * battle system.
 *
 * ---
 *
 * MECH: Action Effect
 * - Causes the unit(s) to take damage/healing from action and incurs any
 *   changes made such as buffs and states.
 *
 *   Targets:
 *   - Select unit(s) to receive the current action's effects.
 *
 * ---
 * 
 * MECH: Active Chain Input Disable
 * - Disables input for Active Chain Skills at this time.
 * - Requires VisuMZ_3_ActiveChainSkills!
 * 
 * ---
 *
 * MECH: Add Buff/Debuff
 * - Adds buff(s)/debuff(s) to unit(s). 
 * - Determine which parameters are affected and their durations.
 *
 *   Targets:
 *   - Select unit(s) to receive the buff(s) and/or debuff(s).
 *
 *   Buff Parameters:
 *   - Select which parameter(s) to buff.
 *   - Insert a parameter multiple times to raise its stacks.
 *
 *   Debuff Parameters:
 *   - Select which parameter(s) to debuff.
 *   - Insert a parameter multiple times to raise its stacks.
 *
 *   Turns:
 *   - Number of turns to set the parameter(s) buffs to.
 *   - You may use JavaScript code.
 *
 * ---
 *
 * MECH: Add State
 * - Adds state(s) to unit(s).
 *
 *   Targets:
 *   - Select unit(s) to receive the buff(s).
 *
 *   States:
 *   - Select which state ID(s) to add to unit(s).
 *   - Insert multiple state ID's to add multiple at once.
 *
 * ---
 * 
 * MECH: Analyze Weakness
 * - Reveal elemental weakness(es) from target(s).
 * - Requires VisuMZ_3_WeaknessDisplay!
 * 
 *   Targets:
 *   - Select unit(s) to reveal elemental weaknesses for.
 * 
 *   Reveal:
 *   - How many elemental weaknesses do you wish to reveal?
 *   - You may use JavaScript code.
 * 
 * ---
 *
 * MECH: Armor Penetration
 * - Adds an extra layer of defensive penetration/reduction.
 * - You may use JavaScript code for any of these.
 *
 *   Armor/Magic Penetration:
 *
 *     Rate:
 *     - Penetrates an extra multiplier of armor by this value.
 *
 *     Flat:
 *     - Penetrates a flat amount of armor by this value.
 *
 *   Armor/Magic Reduction:
 *
 *     Rate:
 *     - Reduces an extra multiplier of armor by this value.
 *
 *     Flat:
 *     - Reduces a flat amount of armor by this value.
 *
 * ---
 * 
 * MECH: ATB Gauge
 * - Alters the ATB/TPB Gauges.
 * - Requires VisuMZ_2_BattleSystemATB!
 * 
 *   Targets:
 *   - Select unit(s) to alter the ATB/TPB Gauges for.
 * 
 *   Charging:
 *   
 *     Charge Rate:
 *     - Changes made to the ATB Gauge if it is currently charging.
 * 
 *   Casting:
 *   
 *     Cast Rate:
 *     - Changes made to the ATB Gauge if it is currently casting.
 *   
 *     Interrupt?:
 *     - Interrupt the ATB Gauge if it is currently casting?
 * 
 * ---
 * 
 * MECH: Boost Points Change
 * - Changes Boost Points for target(s).
 * - Requires VisuMZ_3_BoostAction!
 * 
 *   Targets:
 *   - Select unit(s) to alter the Boost Points for.
 * 
 *   Alter Boost Points By:
 *   - Alters the unit(s) Boost Points.
 *   - Positive for gaining points. Negative for losing points.
 * 
 * ---
 * 
 * MECH: Boost Store Data
 * - Stores the number of Boosts used this action inside a variable.
 * - Requires VisuMZ_3_BoostAction!
 * 
 *   Variable ID:
 *   - Which variable do you want to store the data inside?
 * 
 * ---
 * 
 * MECH: Break Shield Change
 * - Changes Break Shields for target(s) if not Break Stunned.
 * - Requires VisuMZ_4_BreakShields!
 * 
 *   Targets:
 *   - Select unit(s) to alter the Break Shields for.
 * 
 *   Alter Break Shields By:
 *   - Alters the unit(s) Break Shields.
 *   - Positive for gaining shields. Negative for losing shields.
 * 
 * ---
 * 
 * MECH: Break Shield Reset
 * - Resets Break Shields for target(s) if not Break Stunned.
 * - Requires VisuMZ_4_BreakShields!
 * 
 *   Targets:
 *   - Select unit(s) to reset the Break Shields for.
 * 
 * ---
 * 
 * MECH: BTB Brave Points
 * - Alters the target(s) Brave Points to an exact value.
 * - Requires VisuMZ_2_BattleSystemBTB!
 * 
 *   Targets:
 *   - Select unit(s) to alter the ATB/TPB Gauges for.
 * 
 *   Alter Brave Points By:
 *   - Alters the target(s) Brave Points.
 *   - Positive for gaining BP.
 *   - Negative for losing BP.
 * 
 * ---
 *
 * MECH: Collapse
 * - Causes the unit(s) to perform its collapse animation if the unit(s)
 *   has died.
 *
 *   Targets:
 *   - Select unit(s) to process a death collapse.
 *
 *   Force Death:
 *   - Force death even if the unit has not reached 0 HP?
 *   - This will remove immortality.
 *
 *   Wait For Effect?:
 *   - Wait for the collapse effect to complete before performing next command?
 *
 * ---
 * 
 * MECH: CTB Order
 * - Alters the CTB Turn Order.
 * - Requires VisuMZ_2_BattleSystemCTB!
 * 
 *   Targets:
 *   - Select unit(s) to alter the CTB Turn Order for.
 * 
 *   Change Order By:
 *   - Changes turn order for target(s) by this amount.
 *   - Positive increases wait. Negative decreases wait.
 * 
 * ---
 * 
 * MECH: CTB Speed
 * - Alters the CTB Speed.
 * - Requires VisuMZ_2_BattleSystemCTB!
 * 
 *   Targets:
 *   - Select unit(s) to alter the CTB Speed for.
 * 
 *   Charge Rate:
 *   - Changes made to the CTB Speed if it is currently charging.
 * 
 *   Cast Rate:
 *   - Changes made to the CTB Speed if it is currently casting.
 * 
 * ---
 * 
 * MECH: Custom Damage Formula
 * - Changes the current action's damage formula to custom.
 * - This will assume the MANUAL damage style.
 * 
 *   Formula:
 *   - Changes the current action's damage formula to custom.
 *   - Use 'default' to revert the damage formula.
 * 
 * ---
 *
 * MECH: Damage Popup
 * - Causes the unit(s) to display the current state of damage received
 *   or healed.
 *
 *   Targets:
 *   - Select unit(s) to prompt a damage popup.
 *
 * ---
 *
 * MECH: Dead Label Jump
 * - If the active battler is dead, jump to a specific label in the
 *   common event.
 *
 *   Jump To Label:
 *   - If the active battler is dead, jump to this specific label in the
 *     common event.
 *
 * ---
 * 
 * MECH: Emulate Attack Effect
 * - Emulate an "Action Effect" but using a the user's attack skill instead of
 *   the current action.
 * - Essentially lets you perform the mechanics of another action without
 *   having to use another action or needing to pay that action's costs.
 * 
 *   User(s):
 *   - Select unit(s) to perform the action's effects.
 * 
 *   Targets:
 *   - Select unit(s) to receive the current action's effects.
 * 
 * ---
 * 
 * MECH: Emulate Guard Effect
 * - Emulate an "Action Effect" but using a the user's guard skill instead of
 *   the current action.
 * - Essentially lets you perform the mechanics of another action without
 *   having to use another action or needing to pay that action's costs.
 * 
 *   User(s):
 *   - Select unit(s) to perform the action's effects.
 * 
 *   Targets:
 *   - Select unit(s) to receive the current action's effects.
 * 
 * ---
 * 
 * MECH: Emulate Item Effect
 * - Emulate an "Action Effect" but using a specific item instead of the
 *   current action.
 * - Essentially lets you perform the mechanics of another action without
 *   having to use another action or needing to pay that action's costs.
 * 
 *   Item ID:
 *   - Which item ID will be emulated?
 * 
 *   User(s):
 *   - Select unit(s) to perform the action's effects.
 * 
 *   Targets:
 *   - Select unit(s) to receive the current action's effects.
 * 
 * ---
 * 
 * MECH: Emulate Skill Cost
 * - Pick a skill for target(s) to emulate paying the cost of.
 * - Lets you cause characters to perform paying the costs of a specific skill
 *   without needing to actually use them.
 * - This will include Skill Cooldowns and Limited Skill Uses.
 * 
 *   Skill ID:
 *   - Which skill ID will have its cost paid for?
 *   - Use 0 for current action's skill.
 * 
 *   User(s):
 *   - Select unit(s) to perform the action's effects.
 * 
 * ---
 * 
 * MECH: Emulate Skill Effect
 * - Emulate an "Action Effect" but using a specific skill instead of the
 *   current action.
 * - Essentially lets you perform the mechanics of another action without
 *   having to use another action or needing to pay that action's costs.
 * 
 *   Skill ID:
 *   - Which skill ID will be emulated?
 * 
 *   User(s):
 *   - Select unit(s) to perform the action's effects.
 * 
 *   Targets:
 *   - Select unit(s) to receive the current action's effects.
 * 
 * ---
 *
 * MECH: Enemy Escape
 * - Causes the enemy unit(s) to escape.
 *
 *   Targets:
 *   - Select unit(s) to escape.
 *
 * ---
 *
 * MECH: ETB Energy Count
 * - Alters the subject team's available Energy Count.
 * - Requires VisuMZ_2_BattleSystemETB!
 *
 *   Energy Count:
 *   - Alters the subject team's available Energy Count.
 *   - Positive for gaining energy. Negative for losing energy.
 *
 * ---
 *
 * MECH: FTB Action Count
 * - Alters the subject team's available Action Count.
 * - Requires VisuMZ_2_BattleSystemFTB!
 *
 *   Action Count:
 *   - Alters the subject team's available Action Count.
 *   - Positive for gaining actions. Negative for losing actions.
 *
 * ---
 *
 * MECH: HP, MP, TP
 * - Alters the HP, MP, and TP values for unit(s).
 * - Positive values for healing. Negative values for damage.
 *
 *   Targets:
 *   - Select unit(s) to receive the current action's effects.
 *
 *   HP, MP, TP:
 *
 *     Rate:
 *     - Changes made to the parameter based on rate.
 *     - Positive values for healing. Negative values for damage.
 *
 *     Flat:
 *     - Flat changes made to the parameter.
 *     - Positive values for healing. Negative values for damage.
 *
 *   Damage Popup?:
 *   - Display a damage popup after?
 *
 * ---
 *
 * MECH: Immortal
 * - Changes the immortal flag of targets. If immortal flag is removed and a
 *   unit would die, collapse that unit.
 *
 *   Targets:
 *   - Alter the immortal flag of these groups. If immortal flag is removed and
 *     a unit would die, collapse that unit.
 *
 *   Immortal:
 *   - Turn immortal flag for unit(s) on/off?
 *
 * ---
 *
 * MECH: Multipliers
 * - Changes the multipliers for the current action.
 * - You may use JavaScript code for any of these.
 *
 *   Critical Hit%:
 *
 *     Rate:
 *     - Affects chance to land a critical hit by this multiplier.
 *
 *     Flat:
 *     - Affects chance to land a critical hit by this flat bonus.
 *
 *   Critical Damage
 *
 *     Rate:
 *     - Affects critical damage by this multiplier.
 *
 *     Flat:
 *     - Affects critical damage by this flat bonus.
 *
 *   Damage/Healing
 *
 *     Rate:
 *     - Sets the damage/healing multiplier for current action.
 *
 *     Flat:
 *     - Sets the damage/healing bonus for current action.
 *
 *   Hit Rate
 *
 *     Rate:
 *     - Affects chance to connect attack by this multiplier.
 *
 *     Flat:
 *     - Affects chance to connect attack by this flat bonus.
 *
 * ---
 * 
 * MECH: Once Parallel
 * - Plays a Common Event parallel to the battle event once without repeating
 *   itself when done.
 * 
 *   Common Event ID:
 *   - The ID of the parallel Common Event to play.
 *   - Does NOT repeat itself when finished.
 *   - When exiting battle scene, all Once Parallels are cleared.
 *   - Once Parallels are not retained upon reentering the scene.
 *   - Once Parallels are not stored in memory and cannot be saved.
 * 
 * ---
 * 
 * MECH: OTB Order
 * - Alters the OTB Turn Order. Best used with single targets.
 * - Requires VisuMZ_2_BattleSystemOTB!
 * 
 *   Targets:
 *   - Select unit(s) to alter the OTB Turn Order for.
 * 
 *   Current Turn By:
 *   - Changes turn order for target(s) by this amount.
 *   - Positive increases wait. Negative decreases wait.
 * 
 *   Next Turn By:
 *   - Changes turn order for target(s) by this amount.
 *   - Positive increases wait. Negative decreases wait.
 * 
 *   Follow Turn By:
 *   - Changes turn order for target(s) by this amount.
 *   - Positive increases wait. Negative decreases wait.
 * 
 * ---
 * 
 * MECH: PTB Alter Cost
 * - Alters the action's cost settings.
 * - Requires VisuMZ_2_BattleSystemPTB!
 * 
 *   Override?:
 *   - Overrides any 'permanent' settings for Changeability?
 * 
 *   Alter Changeability:
 *   - Allow the cost type and value to be changeable?
 * 
 *   Alter Cost Type:
 *   - Change the cost type to this scenario.
 *   - Use 'Unchanged' for no changes.
 * 
 *   Alter Cost Value:
 *   - What is the default action cost for this scenario?
 * 
 *   Priority:
 *   - What is this scenario's priority? Scenario outcomes with equal or lower
 *     priorities cannot override types and costs.
 * 
 * ---
 * 
 * MECH: PTB Conversion
 * - Converts full actions into half actions.
 * - Requires VisuMZ_2_BattleSystemPTB!
 * 
 *   Conversion Count:
 *   - Converts full actions into half actions.
 *   - If not enough, consume half actions.
 * 
 * ---
 * 
 * MECH: PTB Full/Half Action(s)
 * - Alters the subject team's available Full/Half Actions.
 * - Requires VisuMZ_2_BattleSystemPTB!
 * 
 *   Full Actions:
 *   - Alters the subject team's available Full Actions.
 *   - Positive for gaining. Negative for losing.
 * 
 *   Half Actions:
 *   - Alters the subject team's available Half Actions.
 *   - Positive for gaining. Negative for losing.
 * 
 * ---
 *
 * MECH: Remove Buff/Debuff
 * - Removes buff(s)/debuff(s) from unit(s). 
 * - Determine which parameters are removed.
 *
 *   Targets:
 *   - Select unit(s) to have the buff(s) and/or debuff(s) removed.
 *
 *   Buff Parameters:
 *   - Select which buffed parameter(s) to remove.
 *
 *   Debuff Parameters:
 *   - Select which debuffed parameter(s) to remove.
 *
 * ---
 *
 * MECH: Remove State
 * - Remove state(s) from unit(s).
 *
 *   Targets:
 *   - Select unit(s) to have states removed from.
 *
 *   States:
 *   - Select which state ID(s) to remove from unit(s).
 *   - Insert multiple state ID's to remove multiple at once.
 *
 * ---
 * 
 * MECH: State Turns Change By
 * - Changes target(s) state turns by an amount.
 * - Requires VisuMZ_1_SkillsStatesCore!
 * 
 *   Targets:
 *   - Select unit(s) to affect state turns for.
 * 
 *   State ID:
 *   - What is the ID of the state you wish to change turns for?
 *   - Only works on states that can have turns.
 * 
 *   Change Turns By:
 *   - How many turns should the state be changed to?
 *   - You may use JavaScript code.
 * 
 *   Auto-Add State?:
 *   - Automatically adds state if actor(s) does not have it applied?
 * 
 * ---
 * 
 * MECH: State Turns Change To
 * - Changes target(s) state turns to a specific value.
 * - Requires VisuMZ_1_SkillsStatesCore!
 * 
 *   Targets:
 *   - Select unit(s) to affect state turns for.
 * 
 *   State ID:
 *   - What is the ID of the state you wish to change turns for?
 *   - Only works on states that can have turns.
 * 
 *   Change Turns To:
 *   - How many turns should the state be changed to?
 *   - You may use JavaScript code.
 * 
 *   Auto-Add State?:
 *   - Automatically adds state if target(s) does not have it applied?
 * 
 * ---
 * 
 * MECH: STB Exploit Effect
 * - Utilize the STB Exploitation mechanics!
 * - Requires VisuMZ_2_BattleSystemSTB!
 * 
 *   Target(s) Exploited?:
 *   - Exploit the below targets?
 * 
 *     Targets:
 *     - Select unit(s) to become exploited.
 * 
 *     Force Exploitation:
 *     - Force the exploited status?
 * 
 *   User Exploiter?:
 *   - Allow the user to become the exploiter?
 * 
 *     Force Exploitation:
 *     - Force the exploiter status?
 * 
 * ---
 * 
 * MECH: STB Extra Action
 * - Adds an extra action for the currently active battler.
 * - Requires VisuMZ_2_BattleSystemSTB!
 * 
 *   Extra Actions:
 *   - How many extra actions should the active battler gain?
 *   - You may use JavaScript code.
 * 
 * ---
 * 
 * MECH: STB Remove Excess Actions
 * - Removes excess actions from the active battler.
 * - Requires VisuMZ_2_BattleSystemSTB!
 * 
 *   Remove Actions:
 *   - How many actions to remove from the active battler?
 *   - You may use JavaScript code.
 * 
 * ---
 * 
 * MECH: Swap Weapon
 * - Causes the unit(s) to swap their weapon for another.
 * - Requires VisuMZ_2_WeaponSwapSystem!
 * 
 *   Targets:
 *   - Select unit(s) to swap weapons for.
 * 
 *   Weapon Type ID:
 *   - Which weapon type to swap to?
 *   - This is NOT the weapon's ID.
 *   - It's the weapon TYPE.
 * 
 * ---
 * 
 * MECH: Text Popup
 * - Causes the unit(s) to display a text popup.
 * 
 *   Targets:
 *   - Select unit(s) to prompt a text popup.
 * 
 *   Text:
 *   - What text do you wish to display?
 * 
 *   Text Color:
 *   - Use #rrggbb for custom colors or regular numbers for text colors from
 *     the Window Skin.
 * 
 *   Flash Color:
 *   - Adjust the popup's flash color.
 *   - Format: [red, green, blue, alpha]
 * 
 *   Flash Duration:
 *   - What is the frame duration of the flash effect?
 * 
 * ---
 * 
 * MECH: Variable Popup
 * - Causes the unit(s) to display a popup using the data stored inside
 *   a variable.
 * 
 *   Targets:
 *   - Select unit(s) to prompt a text popup.
 * 
 *   Variable:
 *   - Get data from which variable to display as a popup?
 * 
 *   Digit Grouping:
 *   - Use digit grouping to separate numbers?
 *   - Requires VisuMZ_0_CoreEngine!
 * 
 *   Text Color:
 *   - Use #rrggbb for custom colors or regular numbers for text colors from
 *     the Window Skin.
 * 
 *   Flash Color:
 *   - Adjust the popup's flash color.
 *   - Format: [red, green, blue, alpha]
 * 
 *   Flash Duration:
 *   - What is the frame duration of the flash effect?
 * 
 * ---
 *
 * MECH: Wait For Effect
 * - Waits for the effects to complete before performing next command.
 *
 * ---
 *
 * === Action Sequences - Motion ===
 *
 * These Action Sequences allow you the ability to control the motions of
 * sideview sprites.
 *
 * ---
 * 
 * MOTION: Clear Freeze Frame
 * - Clears any freeze frames from the unit(s).
 * - Only applies to sprite sheets.
 * - Does NOT work with Dragonbones.
 * - Use "DB: Dragonbones Time Scale" instead.
 * 
 *   Targets:
 *   - Select which unit(s) to clear freeze frames for.
 * 
 * ---
 * 
 * MOTION: Freeze Motion Frame
 * - Forces a freeze frame instantly at the selected motion.
 * - Automatically clears with a new motion.
 * - Only applies to sprite sheets.
 * - Does NOT work with Dragonbones.
 * - Use "DB: Dragonbones Time Scale" instead.
 * 
 *   Targets:
 *   - Select which unit(s) to freeze motions for.
 * 
 *   Motion Type:
 *   - Freeze this motion for the unit(s).
 * 
 *   Frame Index:
 *   - Which frame do you want to freeze the motion on?
 *   - Frame index values start at 0.
 * 
 *   Show Weapon?:
 *   - If using 'attack', 'thrust', 'swing', or 'missile', display the
 *     weapon sprite?
 * 
 * ---
 *
 * MOTION: Motion Type
 * - Causes the unit(s) to play the selected motion.
 *
 *   Targets:
 *   - Select which unit(s) to perform a motion.
 *
 *   Motion Type:
 *   - Play this motion for the unit(s).
 *
 *   Show Weapon?:
 *   - If using 'attack', 'thrust', 'swing', or 'missile', display the
 *     weapon sprite?
 *
 * ---
 *
 * MOTION: Perform Action
 * - Causes the unit(s) to play the proper motion based on the current action.
 *
 *   Targets:
 *   - Select which unit(s) to perform a motion.
 *
 * ---
 *
 * MOTION: Refresh Motion
 * - Cancels any set motions unit(s) has to do and use their most natural
 *   motion at the moment.
 *
 *   Targets:
 *   - Select which unit(s) to refresh their motion state.
 *
 * ---
 *
 * MOTION: Wait By Motion Frame
 * - Creates a wait equal to the number of motion frames passing.
 * - Time is based on Plugin Parameters => Actors => Motion Speed.
 *
 *   Motion Frames to Wait?:
 *   - Each "frame" is equal to the value found in 
 *     Plugin Parameters => Actors => Motion Speed
 *
 * ---
 *
 * === Action Sequences - Movement ===
 *
 * These Action Sequences allow you the ability to control the sprites of
 * actors and enemies in battle.
 *
 * ---
 *
 * MOVE: Battle Step
 * - Causes the unit(s) to move forward past their home position to prepare
 *   for action.
 *
 *   Targets:
 *   - Select which unit(s) to move.
 *
 *   Wait For Movement?:
 *   - Wait for movement to complete before performing next command?
 *
 * ---
 *
 * MOVE: Change Home By Distance
 * - Change unit(s)'s home position by a distance from their current home
 *   position(s).
 * - Sideview-only!
 *
 *   Targets:
 *   - Select which unit(s) to change home position(s) for.
 *
 *   Distance Adjustment:
 *   - Makes adjustments to distance values to determine which direction to
 *     change by.
 *     - Normal - No adjustments made
 *     - Horizontal - Actors adjust left, Enemies adjust right
 *     - Vertical - Actors adjust Up, Enemies adjust down
 *     - Both - Applies both Horizontal and Vertical
 *
 *     Distance: X:
 *     - Horizontal distance to move.
 *     - You may use JavaScript code.
 *
 *     Distance: Y:
 *     - Vertical distance to move.
 *     - You may use JavaScript code.
 *
 *   Duration:
 *   - Duration in frames for total change amount.
 *
 *   Face Destination?:
 *   - Turn and face the destination?
 *
 *   Movement Easing:
 *   - Select which easing type you wish to apply.
 *   - Requires VisuMZ_0_CoreEngine.
 *
 *   Movement Motion:
 *   - Play this motion for the unit(s).
 *
 *   Wait For Movement?:
 *   - Wait for movement to complete before performing next command?
 *
 * ---
 *
 * MOVE: Change Home To JS Coordinates
 * - Change home position(s) to specified JS Coordinates.
 * - Sideview-only! Uses JavaScript!
 *
 *   Targets:
 *   - Select which unit(s) to change home position(s) for.
 *
 *   JS: Coordinates:
 *   - Code used to determine the coordinates for the target(s)'s new home
 *     position.
 *
 *   Offset Adjustment:
 *   - Makes adjustments to offset values to determine which direction to
 *     adjust the destination by.
 *
 *     Offset: X:
 *     - Horizontal offset to move.
 *     - You may use JavaScript code.
 *
 *     Offset: Y:
 *     - Vertical offset to move.
 *     - You may use JavaScript code.
 *
 *   Duration:
 *   - Duration in frames for total change amount.
 *
 *   Face Destination?:
 *   - Turn and face the destination?
 *
 *   Movement Easing:
 *   - Select which easing type you wish to apply.
 *   - Requires VisuMZ_0_CoreEngine.
 *
 *   Movement Motion:
 *   - Play this motion for the unit(s).
 *
 *   Wait For Movement?:
 *   - Wait for movement to complete before performing next command?
 *
 * ---
 *
 * MOVE: Change Home To Point
 * - Change home position(s) to a target point on the screen.
 * - Sideview-only! Points based off Graphics.boxWidth/Height.
 *
 *   Targets:
 *   - Select which unit(s) to change home position(s) for.
 *
 *   Destination Point:
 *   - Select which point to face.
 *     - Center
 *     - Point X, Y
 *       - Replace 'x' and 'y' with coordinates
 *
 *   Offset Adjustment:
 *   - Makes adjustments to offset values to determine which direction to
 *     adjust the destination by.
 *
 *     Offset: X:
 *     - Horizontal offset to move.
 *     - You may use JavaScript code.
 *
 *     Offset: Y:
 *     - Vertical offset to move.
 *     - You may use JavaScript code.
 *
 *   Duration:
 *   - Duration in frames for total change amount.
 *
 *   Face Destination?:
 *   - Turn and face the destination?
 *
 *   Movement Easing:
 *   - Select which easing type you wish to apply.
 *   - Requires VisuMZ_0_CoreEngine.
 *
 *   Movement Motion:
 *   - Play this motion for the unit(s).
 *
 *   Wait For Movement?:
 *   - Wait for movement to complete before performing next command?
 *
 * ---
 *
 * MOVE: Change Home To Target(s)
 * - Moves unit(s) to another unit(s) on the battle field.
 * - Sideview-only!
 *
 *   Targets (Moving):
 *   - Select which unit(s) to change home position(s) for.
 *
 *   Targets (Destination):
 *   - Select which unit(s) to change home position to.
 *
 *     Target Location:
 *     - Select which part target group to change home position to.
 *       - front head
 *       - front center
 *       - front base
 *       - middle head
 *       - middle center
 *       - middle base
 *       - back head
 *       - back center
 *       - back base
 *
 *     Melee Distance:
 *     - The melee distance away from the target location in addition to the
 *       battler's width.
 *
 *   Offset Adjustment:
 *   - Makes adjustments to offset values to determine which direction to
 *     adjust the destination by.
 *
 *     Offset: X:
 *     - Horizontal offset to move.
 *     - You may use JavaScript code.
 *
 *     Offset: Y:
 *     - Vertical offset to move.
 *     - You may use JavaScript code.
 *
 *   Duration:
 *   - Duration in frames for total change amount.
 *
 *   Face Destination?:
 *   - Turn and face the destination?
 *
 *   Movement Easing:
 *   - Select which easing type you wish to apply.
 *   - Requires VisuMZ_0_CoreEngine.
 *
 *   Movement Motion:
 *   - Play this motion for the unit(s).
 *
 *   Wait For Movement?:
 *   - Wait for movement to complete before performing next command?
 *
 * ---
 *
 * MOVE: Face Direction
 * - Causes the unit(s) to face forward or backward.
 * - Sideview-only!
 *
 *   Targets:
 *   - Select which unit(s) to change direction.
 *
 *   Direction:
 *   - Select which direction to face.
 *
 * ---
 *
 * MOVE: Face JS Coordinates
 * - Causes the unit(s) to face specified JS Coordinates.
 * - Sideview-only! Uses JavaScript!
 *
 *   Targets:
 *   - Select which unit(s) to change direction.
 *
 *   JS: Coordinates:
 *   - Code used to determine the coordinates for the target(s) to face
 *     towards.
 *
 *   Face Away From?:
 *   - Face away from the point instead?
 *
 * ---
 *
 * MOVE: Face Point
 * - Causes the unit(s) to face a point on the screen.
 * - Sideview-only!
 *
 *   Targets:
 *   - Select which unit(s) to change direction.
 *
 *   Point:
 *   - Select which point to face.
 *     - Home
 *     - Center
 *     - Point X, Y
 *       - Replace 'x' and 'y' with coordinates
 *
 *   Face Away From?:
 *   - Face away from the point instead?
 *
 * ---
 *
 * MOVE: Face Target(s)
 * - Causes the unit(s) to face other targets on the screen.
 * - Sideview-only!
 *
 *   Targets (facing):
 *   - Select which unit(s) to change direction.
 *
 *   Targets (destination):
 *   - Select which unit(s) for the turning unit(s) to face.
 *
 *   Face Away From?:
 *   - Face away from the unit(s) instead?
 *
 * ---
 *
 * MOVE: Float
 * - Causes the unit(s) to float above the ground.
 * - Sideview-only!
 *
 *   Targets:
 *   - Select which unit(s) to make float.
 *
 *   Desired Height:
 *   - Vertical distance to float upward.
 *   - You may use JavaScript code.
 *
 *   Duration:
 *   - Duration in frames for total float amount.
 *
 *   Float Easing:
 *   - Select which easing type you wish to apply.
 *   - Requires VisuMZ_0_CoreEngine.
 *
 *   Wait For Float?:
 *   - Wait for floating to complete before performing next command?
 *
 * ---
 *
 * MOVE: Home Reset
 * - Causes the unit(s) to move back to their home position(s) and face back to
 *   their original direction(s).
 *
 *   Targets:
 *   - Select which unit(s) to move.
 *
 *   Wait For Movement?:
 *   - Wait for movement to complete before performing next command?
 *
 * ---
 *
 * MOVE: Jump
 * - Causes the unit(s) to jump into the air.
 * - Sideview-only!
 *
 *   Targets:
 *   - Select which unit(s) to make jump.
 *
 *   Desired Height:
 *   - Max jump height to go above the ground
 *   - You may use JavaScript code.
 *
 *   Duration:
 *   - Duration in frames for total jump amount.
 *
 *   Wait For Jump?:
 *   - Wait for jumping to complete before performing next command?
 *
 * ---
 *
 * MOVE: Move Distance
 * - Moves unit(s) by a distance from their current position(s).
 * - Sideview-only!
 *
 *   Targets:
 *   - Select which unit(s) to move.
 *
 *   Distance Adjustment:
 *   - Makes adjustments to distance values to determine which direction to
 *     move unit(s).
 *     - Normal - No adjustments made
 *     - Horizontal - Actors adjust left, Enemies adjust right
 *     - Vertical - Actors adjust Up, Enemies adjust down
 *     - Both - Applies both Horizontal and Vertical
 *
 *     Distance: X:
 *     - Horizontal distance to move.
 *     - You may use JavaScript code.
 *
 *     Distance: Y:
 *     - Vertical distance to move.
 *     - You may use JavaScript code.
 *
 *   Duration:
 *   - Duration in frames for total movement amount.
 *
 *   Face Destination?:
 *   - Turn and face the destination?
 *
 *   Movement Easing:
 *   - Select which easing type you wish to apply.
 *   - Requires VisuMZ_0_CoreEngine.
 *
 *   Movement Motion:
 *   - Play this motion for the unit(s).
 *
 *   Wait For Movement?:
 *   - Wait for movement to complete before performing next command?
 *
 * ---
 *
 * MOVE: Move To JS Coordinates
 * - Moves unit(s) to specified JS Coordinates.
 * - Sideview-only! Uses JavaScript!
 *
 *   Targets:
 *   - Select which unit(s) to move.
 *
 *   JS: Coordinates:
 *   - Code used to determine the coordinates for the target(s) to move to.
 *
 *   Offset Adjustment:
 *   - Makes adjustments to offset values to determine which direction to
 *     adjust the destination by.
 *
 *     Offset: X:
 *     - Horizontal offset to move.
 *     - You may use JavaScript code.
 *
 *     Offset: Y:
 *     - Vertical offset to move.
 *     - You may use JavaScript code.
 *
 *   Duration:
 *   - Duration in frames for total movement amount.
 *
 *   Face Destination?:
 *   - Turn and face the destination?
 *
 *   Movement Easing:
 *   - Select which easing type you wish to apply.
 *   - Requires VisuMZ_0_CoreEngine.
 *
 *   Movement Motion:
 *   - Play this motion for the unit(s).
 *
 *   Wait For Movement?:
 *   - Wait for movement to complete before performing next command?
 *
 * ---
 *
 * MOVE: Move To Point
 * - Moves unit(s) to a designated point on the screen.
 * - Sideview-only! Points based off Graphics.boxWidth/Height.
 *
 *   Targets:
 *   - Select which unit(s) to move.
 *
 *   Destination Point:
 *   - Select which point to face.
 *     - Home
 *     - Center
 *     - Point X, Y
 *       - Replace 'x' and 'y' with coordinates
 *
 *   Offset Adjustment:
 *   - Makes adjustments to offset values to determine which direction to
 *     adjust the destination by.
 *
 *     Offset: X:
 *     - Horizontal offset to move.
 *     - You may use JavaScript code.
 *
 *     Offset: Y:
 *     - Vertical offset to move.
 *     - You may use JavaScript code.
 *
 *   Duration:
 *   - Duration in frames for total movement amount.
 *
 *   Face Destination?:
 *   - Turn and face the destination?
 *
 *   Movement Easing:
 *   - Select which easing type you wish to apply.
 *   - Requires VisuMZ_0_CoreEngine.
 *
 *   Movement Motion:
 *   - Play this motion for the unit(s).
 *
 *   Wait For Movement?:
 *   - Wait for movement to complete before performing next command?
 *
 * ---
 *
 * MOVE: Move To Target(s)
 * - Moves unit(s) to another unit(s) on the battle field.
 * - Sideview-only!
 *
 *   Targets (Moving):
 *   - Select which unit(s) to move.
 *
 *   Targets (Destination):
 *   - Select which unit(s) to move to.
 *
 *     Target Location:
 *     - Select which part target group to move to.
 *       - front head
 *       - front center
 *       - front base
 *       - middle head
 *       - middle center
 *       - middle base
 *       - back head
 *       - back center
 *       - back base
 *
 *     Melee Distance:
 *     - The melee distance away from the target location in addition to the
 *       battler's width.
 *
 *   Offset Adjustment:
 *   - Makes adjustments to offset values to determine which direction to
 *     adjust the destination by.
 *
 *     Offset: X:
 *     - Horizontal offset to move.
 *     - You may use JavaScript code.
 *
 *     Offset: Y:
 *     - Vertical offset to move.
 *     - You may use JavaScript code.
 *
 *   Duration:
 *   - Duration in frames for total movement amount.
 *
 *   Face Destination?:
 *   - Turn and face the destination?
 *
 *   Movement Easing:
 *   - Select which easing type you wish to apply.
 *   - Requires VisuMZ_0_CoreEngine.
 *
 *   Movement Motion:
 *   - Play this motion for the unit(s).
 *
 *   Wait For Movement?:
 *   - Wait for movement to complete before performing next command?
 *
 * ---
 *
 * MOVE: Opacity
 * - Causes the unit(s) to change opacity.
 * - Sideview-only!
 *
 *   Targets:
 *   - Select which unit(s) to change opacity.
 *
 *   Desired Opacity:
 *   - Change to this opacity value.
 *   - You may use JavaScript code.
 *
 *   Duration:
 *   - Duration in frames for opacity change.
 *
 *   Opacity Easing:
 *   - Select which easing type you wish to apply.
 *   - Requires VisuMZ_0_CoreEngine.
 *
 *   Wait For Opacity?:
 *   - Wait for opacity changes to complete before performing next command?
 *
 * ---
 *
 * MOVE: Scale/Grow/Shrink
 * - Causes the unit(s) to scale, grow, or shrink?.
 * - Sideview-only!
 *
 *   Targets:
 *   - Select which unit(s) to change the scale of.
 *
 *   Scale X:
 *   Scale Y:
 *   - What target scale value do you want?
 *   - 1.0 is normal size.
 *
 *   Duration:
 *   - Duration in frames to scale for.
 *
 *   Scale Easing:
 *   - Select which easing type you wish to apply.
 *   - Requires VisuMZ_0_CoreEngine.
 *
 *   Wait For Scale?:
 *   - Wait for scaling to complete before performing next command?
 *
 * ---
 *
 * MOVE: Skew/Distort
 * - Causes the unit(s) to skew.
 * - Sideview-only!
 *
 *   Targets:
 *   - Select which unit(s) to skew.
 *
 *   Skew X:
 *   Skew Y:
 *   - What variance to skew?
 *   - Use small values for the best results.
 *
 *   Duration:
 *   - Duration in frames to skew for.
 *
 *   Skew Easing:
 *   - Select which easing type you wish to apply.
 *   - Requires VisuMZ_0_CoreEngine.
 *
 *   Wait For Skew?:
 *   - Wait for skew to complete before performing next command?
 *
 * ---
 *
 * MOVE: Spin/Rotate
 * - Causes the unit(s) to spin.
 * - Sideview-only!
 *
 *   Targets:
 *   - Select which unit(s) to spin.
 *
 *   Angle:
 *   - How many degrees to spin?
 *
 *   Duration:
 *   - Duration in frames to spin for.
 *
 *   Spin Easing:
 *   - Select which easing type you wish to apply.
 *   - Requires VisuMZ_0_CoreEngine.
 * 
 *   Revert Angle on Finish:
 *   - Upon finishing the spin, revert the angle back to 0.
 *
 *   Wait For Spin?:
 *   - Wait for spin to complete before performing next command?
 *
 * ---
 *
 * MOVE: Wait For Float
 * - Waits for floating to complete before performing next command.
 *
 * ---
 *
 * MOVE: Wait For Jump
 * - Waits for jumping to complete before performing next command.
 *
 * ---
 *
 * MOVE: Wait For Movement
 * - Waits for movement to complete before performing next command.
 *
 * ---
 *
 * MOVE: Wait For Opacity
 * - Waits for opacity changes to complete before performing next command.
 *
 * ---
 *
 * MOVE: Wait For Scale
 * - Waits for scaling to complete before performing next command.
 *
 * ---
 *
 * MOVE: Wait For Skew
 * - Waits for skewing to complete before performing next command.
 *
 * ---
 *
 * MOVE: Wait For Spin
 * - Waits for spinning to complete before performing next command.
 *
 * ---
 * 
 * === Action Sequences - Projectiles ===
 * 
 * Create projectiles on the screen and fire them off at a target.
 * Requires VisuMZ_3_ActSeqProjectiles!
 * 
 * ---
 *
 * PROJECTILE: Animation
 * - Create an animation projectile and fire it at a target.
 * - Requires VisuMZ_3_ActSeqProjectiles!
 *
 *   Coordinates:
 *
 *     Start Location:
 *     - Settings to determine where the projectile(s) start from.
 *
 *       Type:
 *       - Select where the projectile should start from.
 *         - Target - Start from battler target(s)
 *         - Point - Start from a point on the screen
 *
 *         Target(s):
 *         - Select which unit(s) to start the projectile from.
 *
 *           Centralize:
 *           - Create one projectile at the center of the targets?
 *           - Or create a projectile for each target?
 * 
 *           Target Location:
 *           - Select which part of the target to send the projectile from.
 *           - front head
 *           - front center
 *           - front base
 *           - middle head
 *           - middle center
 *           - middle base
 *           - back head
 *           - back center
 *           - back base
 *
 *         Point X:
 *         Point Y:
 *         - Insert the X/Y coordinate to start the projectile at.
 *         - You may use JavaScript code.
 *
 *       Offset X:
 *       Offset Y:
 *       - Insert how many pixels to offset the X/Y coordinate by.
 *       - You may use JavaScript code.
 *
 *     Goal Location:
 *     - Settings to determine where the projectile(s) start from.
 *
 *       Type:
 *       - Select where the projectile should go to.
 *         - Target - Goal is battler target(s)
 *         - Point - Goal is a point on the screen
 *
 *         Target(s):
 *         - Select which unit(s) for projectile to go to.
 *
 *           Centralize:
 *           - Create one projectile at the center of the targets?
 *           - Or create a projectile for each target?
 * 
 *           Target Location:
 *           - Select which part of the target to send the projectile to.
 *           - front head
 *           - front center
 *           - front base
 *           - middle head
 *           - middle center
 *           - middle base
 *           - back head
 *           - back center
 *           - back base
 *
 *         Point X:
 *         Point Y:
 *         - Insert the X/Y coordinate to send the projectile to.
 *         - You may use JavaScript code.
 *
 *       Offset X:
 *       Offset Y:
 *       - Insert how many pixels to offset the X/Y coordinate by.
 *       - You may use JavaScript code.
 *
 *   Settings:
 *
 *     Animation ID:
 *     - Determine which animation to use as a projectile.
 *
 *     Duration:
 *     - Duration for the projectile(s) to travel.
 *
 *     Wait For Projectile?:
 *     - Wait for projectile(s) to reach their destination before going onto
 *       the next command?
 * 
 *     Wait For Animation?:
 *     - Wait for animation to finish before going to the next command?
 *
 *     Extra Settings:
 *     - Add extra settings to the projectile?
 *
 *       Auto Angle?:
 *       - Automatically angle the projectile to tilt the direction
 *         it's moving?
 *
 *       Angle Offset:
 *       - Alter the projectile's tilt by this many degrees.
 *
 *       Arc Peak:
 *       - This is the height of the projectile's trajectory arc in pixels.
 *
 *       Easing:
 *       - Select which easing type to apply to the projectile's trajectory.
 *
 *       Spin Speed:
 *       - Determine how much angle the projectile spins per frame.
 *       - Does not work well with "Auto Angle".
 * 
 *     Effect Emulation:
 * 
 *       Action Effect?:
 *       - Emulate current Action Effect when projectile reaches target?
 *       - Only works with start and goal targets.
 * 
 *       Item Effect ID?:
 *       - Emulate an Item Effect when projectile reaches target?
 *       - Use 0 to not use.
 *       - Only works with start and goal targets.
 * 
 *       Skill Effect ID?:
 *       - Emulate a Skill Effect when projectile reaches target?
 *       - Use 0 to not use.
 *       - Only works with start and goal targets.
 * 
 *       Common Event ID:
 *       - Plays a Once Parallel Common Event upon reaching target.
 *       - Use 0 to not use.
 *       - Works regardless of start/goal targets.
 *
 * ---
 *
 * PROJECTILE: Icon
 * - Create an icon projectile and fire it at a target.
 * - Requires VisuMZ_3_ActSeqProjectiles!
 *
 *   Coordinates:
 *
 *     Start Location:
 *     - Settings to determine where the projectile(s) start from.
 *
 *       Type:
 *       - Select where the projectile should start from.
 *         - Target - Start from battler target(s)
 *         - Point - Start from a point on the screen
 *
 *         Target(s):
 *         - Select which unit(s) to start the projectile from.
 *
 *           Centralize:
 *           - Create one projectile at the center of the targets?
 *           - Or create a projectile for each target?
 * 
 *           Target Location:
 *           - Select which part of the target to send the projectile from.
 *           - front head
 *           - front center
 *           - front base
 *           - middle head
 *           - middle center
 *           - middle base
 *           - back head
 *           - back center
 *           - back base
 *
 *         Point X:
 *         Point Y:
 *         - Insert the X/Y coordinate to start the projectile at.
 *         - You may use JavaScript code.
 *
 *       Offset X:
 *       Offset Y:
 *       - Insert how many pixels to offset the X/Y coordinate by.
 *       - You may use JavaScript code.
 *
 *     Goal Location:
 *     - Settings to determine where the projectile(s) start from.
 *
 *       Type:
 *       - Select where the projectile should go to.
 *         - Target - Goal is battler target(s)
 *         - Point - Goal is a point on the screen
 *
 *         Target(s):
 *         - Select which unit(s) for projectile to go to.
 *
 *           Centralize:
 *           - Create one projectile at the center of the targets?
 *           - Or create a projectile for each target?
 * 
 *           Target Location:
 *           - Select which part of the target to send the projectile to.
 *           - front head
 *           - front center
 *           - front base
 *           - middle head
 *           - middle center
 *           - middle base
 *           - back head
 *           - back center
 *           - back base
 *
 *         Point X:
 *         Point Y:
 *         - Insert the X/Y coordinate to send the projectile to.
 *         - You may use JavaScript code.
 *
 *       Offset X:
 *       Offset Y:
 *       - Insert how many pixels to offset the X/Y coordinate by.
 *       - You may use JavaScript code.
 *
 *   Settings:
 *
 *     Icon:
 *     - Determine which icon to use as a projectile.
 *       - You may use JavaScript code.
 *
 *     Duration:
 *     - Duration for the projectile(s) to travel.
 *
 *     Wait For Projectile?:
 *     - Wait for projectile(s) to reach their destination before going onto
 *       the next command?
 *
 *     Extra Settings:
 *     - Add extra settings to the projectile?
 *
 *       Auto Angle?:
 *       - Automatically angle the projectile to tilt the direction
 *         it's moving?
 *
 *       Angle Offset:
 *       - Alter the projectile's tilt by this many degrees.
 *
 *       Arc Peak:
 *       - This is the height of the projectile's trajectory arc in pixels.
 *
 *       Blend Mode:
 *       - What kind of blend mode do you wish to apply to the projectile?
 *         - Normal
 *         - Additive
 *         - Multiply
 *         - Screen
 *
 *       Easing:
 *       - Select which easing type to apply to the projectile's trajectory.
 *
 *       Hue:
 *       - Adjust the hue of the projectile.
 *       - Insert a number between 0 and 360.
 *
 *       Scale:
 *       - Adjust the size scaling of the projectile.
 *       - Use decimals for exact control.
 *
 *       Spin Speed:
 *       - Determine how much angle the projectile spins per frame.
 *       - Does not work well with "Auto Angle".
 * 
 *     Effect Emulation:
 * 
 *       Action Effect?:
 *       - Emulate current Action Effect when projectile reaches target?
 *       - Only works with start and goal targets.
 * 
 *       Item Effect ID?:
 *       - Emulate an Item Effect when projectile reaches target?
 *       - Use 0 to not use.
 *       - Only works with start and goal targets.
 * 
 *       Skill Effect ID?:
 *       - Emulate a Skill Effect when projectile reaches target?
 *       - Use 0 to not use.
 *       - Only works with start and goal targets.
 * 
 *       Common Event ID:
 *       - Plays a Once Parallel Common Event upon reaching target.
 *       - Use 0 to not use.
 *       - Works regardless of start/goal targets.
 *
 * ---
 *
 * PROJECTILE: Picture
 * - Create a picture projectile and fire it at a target.
 * - Requires VisuMZ_3_ActSeqProjectiles!
 *
 *   Coordinates:
 *
 *     Start Location:
 *     - Settings to determine where the projectile(s) start from.
 *
 *       Type:
 *       - Select where the projectile should start from.
 *         - Target - Start from battler target(s)
 *         - Point - Start from a point on the screen
 *
 *         Target(s):
 *         - Select which unit(s) to start the projectile from.
 *
 *           Centralize:
 *           - Create one projectile at the center of the targets?
 *           - Or create a projectile for each target?
 * 
 *           Target Location:
 *           - Select which part of the target to send the projectile from.
 *           - front head
 *           - front center
 *           - front base
 *           - middle head
 *           - middle center
 *           - middle base
 *           - back head
 *           - back center
 *           - back base
 *
 *         Point X:
 *         Point Y:
 *         - Insert the X/Y coordinate to start the projectile at.
 *         - You may use JavaScript code.
 *
 *       Offset X:
 *       Offset Y:
 *       - Insert how many pixels to offset the X/Y coordinate by.
 *       - You may use JavaScript code.
 *
 *     Goal Location:
 *     - Settings to determine where the projectile(s) start from.
 *
 *       Type:
 *       - Select where the projectile should go to.
 *         - Target - Goal is battler target(s)
 *         - Point - Goal is a point on the screen
 *
 *         Target(s):
 *         - Select which unit(s) for projectile to go to.
 *
 *           Centralize:
 *           - Create one projectile at the center of the targets?
 *           - Or create a projectile for each target?
 * 
 *           Target Location:
 *           - Select which part of the target to send the projectile to.
 *           - front head
 *           - front center
 *           - front base
 *           - middle head
 *           - middle center
 *           - middle base
 *           - back head
 *           - back center
 *           - back base
 *
 *         Point X:
 *         Point Y:
 *         - Insert the X/Y coordinate to send the projectile to.
 *         - You may use JavaScript code.
 *
 *       Offset X:
 *       Offset Y:
 *       - Insert how many pixels to offset the X/Y coordinate by.
 *       - You may use JavaScript code.
 *
 *   Settings:
 *
 *     Picture Filename:
 *     - Determine which picture to use as a projectile.
 *
 *     Duration:
 *     - Duration for the projectile(s) to travel.
 *
 *     Wait For Projectile?:
 *     - Wait for projectile(s) to reach their destination before going onto
 *       the next command?
 *
 *     Extra Settings:
 *     - Add extra settings to the projectile?
 *
 *       Auto Angle?:
 *       - Automatically angle the projectile to tilt the direction
 *         it's moving?
 *
 *       Angle Offset:
 *       - Alter the projectile's tilt by this many degrees.
 *
 *       Arc Peak:
 *       - This is the height of the projectile's trajectory arc in pixels.
 *
 *       Blend Mode:
 *       - What kind of blend mode do you wish to apply to the projectile?
 *         - Normal
 *         - Additive
 *         - Multiply
 *         - Screen
 *
 *       Easing:
 *       - Select which easing type to apply to the projectile's trajectory.
 *
 *       Hue:
 *       - Adjust the hue of the projectile.
 *       - Insert a number between 0 and 360.
 *
 *       Scale:
 *       - Adjust the size scaling of the projectile.
 *       - Use decimals for exact control.
 *
 *       Spin Speed:
 *       - Determine how much angle the projectile spins per frame.
 *       - Does not work well with "Auto Angle".
 * 
 *     Effect Emulation:
 * 
 *       Action Effect?:
 *       - Emulate current Action Effect when projectile reaches target?
 *       - Only works with start and goal targets.
 * 
 *       Item Effect ID?:
 *       - Emulate an Item Effect when projectile reaches target?
 *       - Use 0 to not use.
 *       - Only works with start and goal targets.
 * 
 *       Skill Effect ID?:
 *       - Emulate a Skill Effect when projectile reaches target?
 *       - Use 0 to not use.
 *       - Only works with start and goal targets.
 * 
 *       Common Event ID:
 *       - Plays a Once Parallel Common Event upon reaching target.
 *       - Use 0 to not use.
 *       - Works regardless of start/goal targets.
 *
 * ---
 * 
 * === Action Sequences - Skew ===
 * 
 * These action sequences allow you to have control over the camera skew.
 * Requires VisuMZ_3_ActSeqCamera!
 * 
 * ---
 *
 * SKEW: Change Skew
 * - Changes the camera skew.
 * - Requires VisuMZ_3_ActSeqCamera!
 *
 *   Skew X:
 *   - Change the camera skew X to this value.
 *
 *   Skew Y:
 *   - Change the camera skew Y to this value.
 *
 *   Duration:
 *   - Duration in frames to change camera skew.
 *
 *   Skew Easing:
 *   - Select which easing type you wish to apply.
 *   - Requires VisuMZ_0_CoreEngine.
 *
 *   Wait For Skew?:
 *   - Wait for skew changes to complete before performing next command?
 *
 * ---
 *
 * SKEW: Reset Skew
 * - Reset any skew settings.
 * - Requires VisuMZ_3_ActSeqCamera!
 *
 *   Duration:
 *   - Duration in frames to reset camera skew.
 *
 *   Skew Easing:
 *   - Select which easing type you wish to apply.
 *   - Requires VisuMZ_0_CoreEngine.
 *
 *   Wait For Skew?:
 *   - Wait for skew changes to complete before performing next command?
 *
 * ---
 *
 * SKEW: Wait For Skew
 * - Waits for skew changes to complete before performing next command.
 * - Requires VisuMZ_3_ActSeqCamera!
 *
 * ---
 *
 * === Action Sequences - Target ===
 *
 * If using a manual target by target Action Sequence, these commands will give
 * you full control over its usage.
 *
 * ---
 *
 * TARGET: Current Index
 * - Sets the current index to this value.
 * - Then decide to jump to a label (optional).
 *
 *   Set Index To:
 *   - Sets current targeting index to this value.
 *   - 0 is the starting index of a target group.
 *
 *   Jump To Label:
 *   - If a target is found after the index change, jump to this label in the
 *     Common Event.
 *
 * ---
 *
 * TARGET: Next Target
 * - Moves index forward by 1 to select a new current target.
 * - Then decide to jump to a label (optional).
 *
 *   Jump To Label:
 *   - If a target is found after the index change, jump to this label in the
 *     Common Event.
 *
 * ---
 *
 * TARGET: Previous Target
 * - Moves index backward by 1 to select a new current target.
 * - Then decide to jump to a label (optional).
 *
 *   Jump To Label:
 *   - If a target is found after the index change, jump to this label in the
 *     Common Event.
 *
 * ---
 *
 * TARGET: Random Target
 * - Sets index randomly to determine new currernt target.
 * - Then decide to jump to a label (optional).
 *
 *   Force Random?:
 *   - Index cannot be its previous index amount after random.
 *
 *   Jump To Label:
 *   - If a target is found after the index change, jump to this label in the
 *     Common Event.
 *
 * ---
 * 
 * === Action Sequences - Voice ==
 * 
 * ---
 *
 * VOICE: Common Line
 * - Plays a common voice line from target battler(s).
 * - Requires VisuMZ_3_BattleVoices!
 *
 *   Speaker Target(s):
 *   - Select unit(s) to play voice lines from.
 *
 *   Voice Line:
 *   - What voice line do you wish to play?
 *
 * ---
 *
 * VOICE: Play Special Line
 * - Plays a special voice line from target battler(s).
 * - Requires VisuMZ_3_BattleVoices!
 *
 *   Speaker Target(s):
 *   - Select unit(s) to play voice lines from.
 *
 *   Voice Line Type:
 *   - What voice line type do you wish to play?
 *     - Action Name
 *     - Chant Line
 *     - Item Name
 *     - Skill Name
 *     - Spell Name
 *     - Unique Lines
 *
 *   Name / Letter:
 *   - What voice letter/name do you want to play?
 *
 * ---
 *
 * === Action Sequences - Weapon ===
 *
 * Allows for finer control over Dual/Multi Wielding actors.
 * Only works for Actors.
 *
 * ---
 *
 * WEAPON: Clear Weapon Slot
 * - Clears the active weapon slot (making others valid again).
 * - Only works for Actors.
 *
 *   Targets:
 *   - Select unit(s) to clear the active weapon slot for.
 *
 * ---
 *
 * WEAPON: Next Weapon Slot
 * - Goes to next active weapon slot (making others invalid).
 * - If next slot is weaponless, don't label jump.
 *
 *   Targets:
 *   - Select unit(s) to change the next active weapon slot for.
 *
 * ---
 *
 * WEAPON: Set Weapon Slot
 * - Sets the active weapon slot (making others invalid).
 * - Only works for Actors.
 *
 *   Targets:
 *   - Select unit(s) to change the active weapon slot for.
 *
 *   Weapon Slot ID:
 *   - Select weapon slot to make active (making others invalid).
 *   - Use 0 to clear and normalize. You may use JavaScript code.
 *
 * ---
 *
 * === Action Sequences - Zoom ===
 *
 * These Action Sequences are zoom-related.
 * Requires VisuMZ_3_ActSeqCamera!
 *
 * ---
 *
 * ZOOM: Change Scale
 * - Changes the zoom scale.
 * - Requires VisuMZ_3_ActSeqCamera!
 *
 *   Scale:
 *   - The zoom scale to change to.
 *
 *   Duration:
 *   - Duration in frames to reset battle zoom.
 *
 *   Zoom Easing:
 *   - Select which easing type you wish to apply.
 *   - Requires VisuMZ_0_CoreEngine.
 *
 *   Wait For Zoom?
 *   - Wait for zoom changes to complete before performing next command?
 *
 * ---
 *
 * ZOOM: Reset Zoom
 * - Reset any zoom settings.
 * - Requires VisuMZ_3_ActSeqCamera!
 *
 *   Duration:
 *   - Duration in frames to reset battle zoom.
 *
 *   Zoom Easing:
 *   - Select which easing type you wish to apply.
 *   - Requires VisuMZ_0_CoreEngine.
 *
 *   Wait For Zoom?
 *   - Wait for zoom changes to complete before performing next command?
 *
 * ---
 *
 * ZOOM: Wait For Zoom
 * - Waits for zoom changes to complete before performing next command.
 * Requires VisuMZ_3_ActSeqCamera!
 *
 * ---
 *
 * ============================================================================
 * Plugin Parameters: Auto Battle Settings
 * ============================================================================
 *
 * These Plugin Parameter settings allow you to change the aspects added by
 * this plugin that support Auto Battle and the Auto Battle commands.
 *
 * Auto Battle commands can be added to the Party Command Window and/or Actor
 * Command Window. The one used by the Party Command Window will cause the
 * whole party to enter an Auto Battle state until stopped by a button input.
 * The command used by the Actor Command Window, however, will cause the actor
 * to select an action based off the Auto Battle A.I. once for the current turn
 * instead.
 *
 * ---
 *
 * Battle Display
 * 
 *   Message:
 *   - Message that's displayed when Auto Battle is on.
 *     Text codes allowed. %1 - OK button, %2 - Cancel button
 * 
 *   OK Button:
 *   - Text used to represent the OK button.
 *   - If VisuMZ_0_CoreEngine is present, ignore this.
 * 
 *   Cancel Button:
 *   - Text used to represent the Cancel button.
 *   - If VisuMZ_0_CoreEngine is present, ignore this.
 * 
 *   Background Type:
 *   - Select background type for Auto Battle window.
 *     - 0 - Window
 *     - 1 - Dim
 *     - 2 - Transparent
 * 
 *   JS: X, Y, W, H:
 *   - Code used to determine the dimensions for this window.
 *
 * ---
 *
 * Options
 * 
 *   Add Option?:
 *   - Add the Auto Battle options to the Options menu?
 * 
 *   Adjust Window Height:
 *   - Automatically adjust the options window height?
 * 
 *   Startup Name:
 *   - Command name of the option.
 * 
 *   Style Name:
 *   - Command name of the option.
 * 
 *   OFF:
 *   - Text displayed when Auto Battle Style is OFF.
 * 
 *   ON:
 *   - Text displayed when Auto Battle Style is ON.
 *
 * ---
 *
 * ============================================================================
 * Plugin Parameters: Damage Settings
 * ============================================================================
 *
 * These Plugin Parameters add a variety of things to how damage is handled in
 * battle. These range from hard damage caps to soft damage caps to how damage
 * popups appear, how the formulas for various aspects are handled and more.
 *
 * Damage Styles are also a feature added through this plugin. More information
 * can be found in the help section above labeled 'Damage Styles'.
 *
 * ---
 *
 * Damage Styles
 * 
 *   Default Style:
 *   - Which Damage Style do you want to set as default?
 *   - Use 'Manual' to not use any styles at all.
 *     - The 'Manual' style will not support <Armor Penetration> notetags.
 *     - The 'Manual' style will not support <Armor Reduction> notetags.
 * 
 *   Style List:
 *   - A list of the damage styles available.
 *   - These are used to calculate base damage.
 * 
 *     Name:
 *     - Name of this Damage Style.
 *     -Used for notetags and such.
 * 
 *     JS: Formula:
 *     - The base formula for this Damage Style.
 * 
 *     Items & Equips Core:
 * 
 *       HP Damage:
 *       MP Damage:
 *       HP Recovery:
 *       MP Recovery:
 *       HP Drain:
 *       MP Drain:
 *       - Vocabulary used for this data entry.
 * 
 *       JS: Damage Display:
 *       - Code used the data displayed for this category.
 *
 * ---
 *
 * Damage Cap
 * 
 *   Enable Damage Cap?:
 *   - Put a maximum hard damage cap on how far damage can go?
 *   - This can be broken through the usage of notetags.
 * 
 *   Default Hard Cap:
 *   - The default hard damage cap used before applying damage.
 * 
 *   Enable Soft Cap?:
 *   - Soft caps ease in the damage values leading up to the  hard damage cap.
 *   - Requires hard Damage Cap enabled.
 * 
 *     Base Soft Cap Rate:
 *     - The default soft damage cap used before applying damage.
 * 
 *     Soft Scale Constant:
 *     - The default soft damage cap used before applying damage.
 *
 * ---
 *
 * Popups
 * 
 *   Popup Duration:
 *   - Adjusts how many frames a popup stays visible.
 * 
 *   Newest Popups Bottom:
 *   - Puts the newest popups at the bottom.
 * 
 *   End Battle Show?:
 *   - Show or hide popups upon victory or escape?
 *   - Used to hide battle-state removal popups.
 * 
 *   Offset X:
 *   Offset Y:
 *   - Sets how much to offset the sprites by horizontally/vertically.
 * 
 *   Shift X:
 *   Shift Y:
 *   - Sets how much to shift the sprites by horizontally/vertically.
 * 
 *   Shift Y:
 * 
 *   Critical Flash Color:
 *   - Adjust the popup's flash color.
 *   - Format: [red, green, blue, alpha]
 * 
 *   Critical Duration:
 *   - Adjusts how many frames a the flash lasts.
 *
 * ---
 *
 * Formulas
 * 
 *   JS: Overall Formula:
 *   - The overall formula used when calculating damage.
 * 
 *   JS: Variance Formula:
 *   - The formula used when damage variance.
 * 
 *   JS: Guard Formula:
 *   - The formula used when damage is guarded.
 *
 * ---
 *
 * Critical Hits
 * 
 *   JS: Rate Formula:
 *   - The formula used to calculate Critical Hit Rates.
 * 
 *   JS: Damage Formula:
 *   - The formula used to calculate Critical Hit Damage modification.
 *
 * ---
 *
 * ============================================================================
 * Plugin Parameters: Mechanics Settings
 * ============================================================================
 *
 * Some of the base settings for the various mechanics found in the battle
 * system can be altered here in these Plugin Parameters. Most of these will
 * involve JavaScript code and require you to have to good understanding of
 * how the RPG Maker MZ code works before tampering with it.
 *
 * ---
 *
 * Action Speed
 * 
 *   Allow Random Speed?:
 *   - Allow speed to be randomized base off the user's AGI?
 * 
 *   Turn End Buffs Expire?:
 *   - Normally, buffs expire after all actions end.
 *   - But here, you can have buffs expire on turn end.
 * 
 *   JS: Calculate:
 *   - Code used to calculate action speed.
 *
 * ---
 *
 * Base Troop
 * 
 *   Base Troop ID's:
 *   - Select the Troop ID(s) to duplicate page events from for all
 *     other troops.
 *   - More information can be found in the dedicated Help section above.
 *
 * ---
 * 
 * Common Events (on Map)
 * 
 *   Pre-Battle Event:
 *   Post-Battle Event:
 *   Victory Event:
 *   Defeat Event:
 *   Escape Success Event:
 *   Escape Fail Event:
 *   - Queued Common Event to run upon meeting the condition.
 *   - Use to 0 to not run any Common Event at all.
 *   - "Post-Battle Event" will always run regardless.
 *   - If any events are running before the battle, they will continue running
 *     to the end first before the queued Common Events will run.
 *   - These common events only run on the map scene. They're not meant to run
 *     in the battle scene.
 *   - If the "Defeat Event" has a common event attached to it, then random
 *     encounters will be changed to allow defeat without being sent to the
 *     Game Over scene. Instead, the game will send the player to the map scene
 *     where the Defeat Event will run.
 *
 * ---
 *
 * Escape
 * 
 *   JS: Calc Escape Ratio:
 *   - Code used to calculate the escape success ratio.
 * 
 *   JS: Calc Escape Raise:
 *   - Code used to calculate how much the escape success ratio raises upon
 *     each failure.
 * 
 * ---
 * 
 * Switches
 * 
 *   Switch: Critical:
 *   - Turns switch ON if the action performs a critical hit.
 *   - Switch reverts to OFF whenever an action starts.
 *   - If multiple targets/hits are struck, as long as one hit lands a critical
 *     hit, then the switch will remain ON for the rest of the action.
 * 
 *   Switch: Miss/Evade:
 *   - Turns switch ON if the action misses/is evaded.
 *   - Switch reverts to OFF whenever an action starts.
 *   - If multiple targets/hits are struck, as long as one hit fails to land,
 *     then the switch will remain ON for the rest of the action.
 * 
 * ---
 * 
 * Variables
 * 
 *   Variable: Damage:
 *   - Variable records target damage during action.
 *   - Variable reverts to 0 whenever an action starts.
 *   - If multiple targets/hits are struck, the variable will record the total
 *     amount of damage done for the remainder of the action (unless manually
 *     reseting to 0 during an Action Sequence).
 * 
 *   Variable: Healing:
 *   - Variable records target healing during action.
 *   - Variable reverts to 0 whenever an action starts.
 *   - If multiple targets/hits are struck, the variable will record the total
 *     amount of healing done for the remainder of the action (unless manually
 *     reseting to 0 during an Action Sequence).
 * 
 * ---
 *
 * JS: Battle-Related
 * 
 *   JS: Pre-Start Battle:
 *   - Target function: BattleManager.startBattle()
 *   - JavaScript code occurs before function is run.
 * 
 *   JS: Post-Start Battle:
 *   - Target function: BattleManager.startBattle()
 *   - JavaScript code occurs after function is run.
 * 
 *   JS: Battle Victory:
 *   - Target function: BattleManager.processVictory()
 *   - JavaScript code occurs before function is run.
 * 
 *   JS: Escape Success:
 *   - Target function: BattleManager.onEscapeSuccess()
 *   - JavaScript code occurs before function is run.
 * 
 *   JS: Escape Failure:
 *   - Target function: BattleManager.onEscapeFailure()
 *   - JavaScript code occurs before function is run.
 * 
 *   JS: Battle Defeat:
 *   - Target function: BattleManager.processDefeat()
 *   - JavaScript code occurs before function is run.
 * 
 *   JS: Pre-End Battle:
 *   - Target function: BattleManager.endBattle()
 *   - JavaScript code occurs before function is run.
 * 
 *   JS: Post-End Battle:
 *   - Target function: BattleManager.endBattle()
 *   - JavaScript code occurs after function is run.
 *
 * ---
 *
 * JS: Turn-Related
 * 
 *   JS: Pre-Start Turn:
 *   - Target function: BattleManager.startTurn()
 *   - JavaScript code occurs before function is run.
 * 
 *   JS: Post-Start Turn:
 *   - Target function: BattleManager.startTurn()
 *   - JavaScript code occurs after function is run.
 * 
 *   JS: Pre-End Turn:
 *   - Target function: Game_Battler.prototype.onTurnEnd()
 *   - JavaScript code occurs before function is run.
 * 
 *   JS: Post-End Turn:
 *   - Target function: Game_Battler.prototype.onTurnEnd()
 *   - JavaScript code occurs after function is run.
 * 
 *   JS: Pre-Regenerate:
 *   - Target function: Game_Battler.prototype.regenerateAll()
 *   - JavaScript code occurs before function is run.
 * 
 *   JS: Post-Regenerate:
 *   - Target function: Game_Battler.prototype.regenerateAll()
 *   - JavaScript code occurs after function is run.
 *
 * ---
 *
 * JS: Action-Related
 * 
 *   JS: Pre-Start Action:
 *   - Target function: BattleManager.startAction()
 *   - JavaScript code occurs before function is run.
 * 
 *   JS: Post-Start Action:
 *   - Target function: BattleManager.startAction()
 *   - JavaScript code occurs after function is run.
 * 
 *   JS: Pre-Apply:
 *   - Target function: Game_Action.prototype.apply()
 *   - JavaScript code occurs before function is run.
 * 
 *   JS: Pre-Damage:
 *   - Target function: Game_Action.prototype.executeDamage()
 *   - JavaScript code occurs before function is run.
 * 
 *   JS: Post-Damage:
 *   - Target function: Game_Action.prototype.executeDamage()
 *   - JavaScript code occurs after function is run.
 * 
 *   JS: Post-Apply:
 *   - Target function: Game_Action.prototype.apply()
 *   - JavaScript code occurs after function is run.
 * 
 *   JS: Pre-End Action:
 *   - Target function: BattleManager.endAction()
 *   - JavaScript code occurs before function is run.
 * 
 *   JS: Post-End Action:
 *   - DescriTarget function: BattleManager.endAction()
 *   - JavaScript code occurs after function is run.
 *
 * ---
 *
 * ============================================================================
 * Plugin Parameters: Battle Layout Settings
 * ============================================================================
 *
 * The Battle Layout Settings Plugin Parameter gives you control over the look,
 * style, and appearance of certain UI elements. These range from the way the
 * Battle Status Window presents its information to the way certain windows
 * like the Party Command Window and Actor Command Window appear.
 *
 * ---
 *
 * Battle Layout Style
 * - The style used for the battle layout.
 * 
 *   Default:
 *   - Shows actor faces in Battle Status.
 * 
 *   List:
 *   - Lists actors in Battle Status.
 * 
 *   XP:
 *   - Shows actor battlers in a stretched Battle Status.
 * 
 *   Portrait:
 *   - Shows portraits in a stretched Battle Status.
 * 
 *   Border:
 *   - Displays windows around the screen border.
 *
 * ---
 *
 * List Style
 * 
 *   Show Faces:
 *   - Shows faces in List Style?
 * 
 *   Command Window Width:
 *   - Determine the window width for the Party and Actor Command Windows.
 *   - Affects Default and List Battle Layout styles.
 *
 * ---
 *
 * XP Style
 * 
 *   Command Lines:
 *   - Number of action lines in the Actor Command Window for the XP Style.
 * 
 *   Sprite Height:
 *   - Default sprite height used when if the sprite's height has not been
 *     determined yet.
 * 
 *   Sprite Base Location:
 *   - Determine where the sprite is located on the Battle Status Window.
 *     - Above Name - Sprite is located above the name.
 *     - Bottom - Sprite is located at the bottom of the window.
 *     - Centered - Sprite is centered in the window.
 *     - Top - Sprite is located at the top of the window.
 *
 * ---
 *
 * Portrait Style
 * 
 *   Show Portraits?:
 *   - Requires VisuMZ_1_MainMenuCore.
 *   - Shows the actor's portrait instead of a face.
 * 
 *   Portrait Scaling:
 *   - If portraits are used, scale them by this much.
 *
 * ---
 *
 * Border Style
 * 
 *   Columns:
 *   - The total number of columns for Skill & Item Windows in the battle scene
 * 
 *   Show Portraits?:
 *   - Requires VisuMZ_1_MainMenuCore.
 *   - Shows the actor's portrait at the edge of the screen.
 * 
 *   Portrait Scaling:
 *   - If portraits are used, scale them by this much.
 *
 * ---
 *
 * Skill & Item Windows
 * 
 *   Middle Layout:
 *   - Shows the Skill & Item Windows in mid-screen?
 * 
 *   Columns:
 *   - The total number of columns for Skill & Item Windows in the battle scene
 *
 * ---
 * 
 * Status Window Elements
 * 
 *   Battler Name:
 *   Gauge 1 (HP):
 *   Gauge 2 (MP):
 *   Gauge 3 (TP):
 *   State Icon:
 *   TPB/ATB Gauge:
 * 
 *     Offset: X/Y:
 *     - Offset this Battle Status Window element's X/Y.
 *     - For X: Negative goes left. Positive goes right.
 *     - For Y: Negative goes up. Positive goes down.
 * 
 *   Window Skin:
 * 
 *     Filename:
 *     - Filename used for the Battle Status Window skin.
 *     - Leave this empty to use the default window skin.
 * 
 *     Hide Window Skin?:
 *     - Hide the window skin for the Battle Status Window?
 * 
 *   Selectable Background:
 * 
 *     Hide Selectable BG?:
 *     - Show/Hide the selectable background box for the Battle Status Window?
 * 
 *   Attachments:
 * 
 *     Back Attachment:
 * 
 *       Filename:
 *       - Filename used for an image to attach to the back of the Battle
 *         Status Window. Leave empty for none.
 * 
 *       Offset: X/Y:
 *       - Offset this Battle Status Window element's X/Y.
 *       - For X: Negative goes left. Positive goes right.
 *       - For Y: Negative goes up. Positive goes down.
 * 
 *     Front Attachment:
 * 
 *       Filename:
 *       - Filename used for an image to attach to the front of the Battle
 *         Status Window. Leave empty for none.
 * 
 * ---
 * 
 * UI Elements
 * 
 *   Anti-Tint UI?
 *   - Prevent UI Elements from being tinted?
 *   - This prevents UI Elements such as HP Gauges, Enemy Names, Battle Cursor,
 *     and Weakness Display from being affected by screen tint.
 * 
 * ---
 *
 * ============================================================================
 * Plugin Parameters: Battle Log Settings
 * ============================================================================
 *
 * These Plugin Parameters give you control over how the Battle Log Window, the
 * window shown at the top of the screen in the battle layout, appears, its
 * various properties, and which text will be displayed.
 *
 * The majority of the text has been disabled by default with this plugin to
 * make the flow of battle progress faster.
 *
 * ---
 *
 * General
 * 
 *   Back Color:
 *   - Use #rrggbb for a hex color.
 * 
 *   Max Lines:
 *   - Maximum number of lines to be displayed.
 * 
 *   Message Wait:
 *   - Number of frames for a usual message wait.
 * 
 *   Text Align:
 *   - Text alignment for the Window_BattleLog.
 * 
 *   JS: X, Y, W, H:
 *   - Code used to determine the dimensions for the battle log.
 *
 * ---
 *
 * Start Turn
 * 
 *   Show Start Turn?:
 *   - Display turn changes at the start of the turn?
 * 
 *   Start Turn Message:
 *   - Message displayed at turn start.
 *   - %1 - Turn Count
 * 
 *   Start Turn Wait:
 *   - Number of frames to wait after a turn started.
 *
 * ---
 *
 * Display Action
 * 
 *   Show Centered Action?:
 *   - Display a centered text of the action name?
 * 
 *   Show Skill Message 1?:
 *   - Display the 1st skill message?
 * 
 *   Show Skill Message 2?:
 *   - Display the 2nd skill message?
 * 
 *   Show Item Message?:
 *   - Display the item use message?
 *
 * ---
 *
 * Action Changes
 * 
 *   Show Counter?:
 *   - Display counter text?
 * 
 *   Show Reflect?:
 *   - Display magic reflection text?
 * 
 *   Show Substitute?:
 *   - Display substitute text?
 *
 * ---
 *
 * Action Results
 * 
 *   Show No Effect?:
 *   - Display no effect text?
 * 
 *   Show Critical?:
 *   - Display critical text?
 * 
 *   Show Miss/Evasion?:
 *   - Display miss/evasion text?
 * 
 *   Show HP Damage?:
 *   - Display HP Damage text?
 * 
 *   Show MP Damage?:
 *   - Display MP Damage text?
 * 
 *   Show TP Damage?:
 *   - Display TP Damage text?
 *
 * ---
 *
 * Display States
 * 
 *   Show Added States?:
 *   - Display added states text?
 * 
 *   Show Removed States?:
 *   - Display removed states text?
 * 
 *   Show Current States?:
 *   - Display the currently affected state text?
 * 
 *   Show Added Buffs?:
 *   - Display added buffs text?
 * 
 *   Show Added Debuffs?:
 *   - Display added debuffs text?
 * 
 *   Show Removed Buffs?:
 *   - Display removed de/buffs text?
 *
 * ---
 *
 * ============================================================================
 * Plugin Parameters: Battleback Scaling Settings
 * ============================================================================
 *
 * By default, the battlebacks in RPG Maker MZ scale as if the screen size is
 * a static 816x624 resolution, which isn't always the case. These settings
 * here allow you to dictate how you want the battlebacks to scale for the
 * whole game. These settings CANNOT be changed midgame or per battle.
 *
 * ---
 *
 * Settings
 * 
 *   Default Style:
 *   - The default scaling style used for battlebacks.
 *   - MZ (MZ's default style)
 *   - 1:1 (No Scaling)
 *   - Scale To Fit (Scale to screen size)
 *   - Scale Down (Scale Downward if Larger than Screen)
 *   - Scale Up (Scale Upward if Smaller than Screen)
 * 
 *   JS: 1:1:
 *   JS: Scale To Fit:
 *   JS: Scale Down:
 *   JS: Scale Up:
 *   - This code gives you control over the scaling for this style.
 *
 * ---
 *
 * ============================================================================
 * Plugin Parameters: Party Command Window
 * ============================================================================
 *
 * These Plugin Parameters allow you control over how the Party Command Window
 * operates in the battle scene. You can turn disable it from appearing or make
 * it so that it doesn't 
 *
 * ---
 *
 * Command Window
 * 
 *   Style:
 *   - How do you wish to draw commands in the Party Command Window?
 *   - Text Only: Display only the text.
 *   - Icon Only: Display only the icon.
 *   - Icon + Text: Display the icon first, then the text.
 *   - Auto: Determine which is better to use based on the size of the cell.
 * 
 *   Text Align:
 *   - Text alignment for the Party Command Window.
 * 
 *   Fight Icon:
 *   - The icon used for the Fight command.
 * 
 *   Add Auto Battle?:
 *   - Add the "Auto Battle" command to the Command Window?
 * 
 *     Auto Battle Icon:
 *     - The icon used for the Auto Battle command.
 * 
 *     Auto Battle Text:
 *     - The text used for the Auto Battle command.
 * 
 *   Add Options?:
 *   - Add the "Options" command to the Command Window?
 * 
 *     Options Icon:
 *     - The icon used for the Options command.
 * 
 *     Active TPB Message:
 *     - Message that will be displayed when selecting options during the
 *       middle of an action.
 * 
 *   Escape Icon:
 *   - The icon used for the Escape command.
 *
 * ---
 *
 * Access
 * 
 *   Skip Party Command:
 *   - DTB: Skip Party Command selection on turn start.
 *   - TPB: Skip Party Command selection at battle start.
 * 
 *   Disable Party Command:
 *   - Disable the Party Command Window entirely?
 *
 * ---
 *
 * Help Window
 * 
 *   Fight:
 *   - Text displayed when selecting a skill type.
 *   - %1 - Skill Type Name
 * 
 *   Auto Battle:
 *   - Text displayed when selecting the Auto Battle command.
 * 
 *   Options:
 *   - Text displayed when selecting the Options command.
 * 
 *   Escape:
 *   - Text displayed when selecting the escape command.
 *
 * ---
 *
 * ============================================================================
 * Plugin Parameters: Actor Command Window
 * ============================================================================
 *
 * These Plugin Parameters allow you to change various aspects regarding the
 * Actor Command Window and how it operates in the battle scene. This ranges
 * from how it appears to the default battle commands given to all players
 * without a custom <Battle Commands> notetag.
 *
 * ---
 *
 * Command Window
 * 
 *   Style:
 *   - How do you wish to draw commands in the Actor Command Window?
 *   - Text Only: Display only the text.
 *   - Icon Only: Display only the icon.
 *   - Icon + Text: Display the icon first, then the text.
 *   - Auto: Determine which is better to use based on the size of the cell.
 * 
 *   Text Align:
 *   - Text alignment for the Actor Command Window.
 * 
 *   Item Icon:
 *   - The icon used for the Item command.
 * 
 *   Normal SType Icon:
 *   - Icon used for normal skill types that aren't assigned any icons.
 *   - Ignore if VisuMZ_1_SkillsStatesCore is installed.
 * 
 *   Magic SType Icon:
 *   - Icon used for magic skill types that aren't assigned any icons.
 *   - Ignore if VisuMZ_1_SkillsStatesCore is installed.
 *
 * ---
 *
 * Battle Commands
 * 
 *   Command List:
 *   - List of battle commands that appear by default if the <Battle Commands>
 *     notetag isn't present.
 *
 *     - Attack 
 *       - Adds the basic attack command.
 * 
 *     - Skills
 *       - Displays all the skill types available to the actor.
 * 
 *     - SType: x
 *     - Stype: name
 *       - Adds in a specific skill type.
 *       - Replace 'x' with the ID of the skill type.
 *       - Replace 'name' with the name of the skill type (without text codes).
 *
 *     - All Skills
 *       - Adds all usable battle skills as individual actions.
 * 
 *     - Skill: x
 *     - Skill: name
 *       - Adds in a specific skill as a usable action.
 *       - Replace 'x' with the ID of the skill.
 *       - Replace 'name' with the name of the skill.
 * 
 *     - Guard
 *       - Adds the basic guard command.
 * 
 *     - Item
 *       - Adds the basic item command.
 * 
 *     - Escape
 *       - Adds the escape command.
 * 
 *     - Auto Battle
 *       - Adds the auto battle command.
 * 
 *     - Party
 *       - Requires VisuMZ_2_PartySystem!
 *       - Switches out the current actor for another.
 * 
 *     - Combat Log
 *       - Requires VisuMZ_4_CombatLog!
 *       - Shows combat log.
 * 
 *     - Talk
 *       - Requires VisuMZ_3_BattleCmdTalk!
 *       - Shows talk command if applicable.
 * 
 *     - Weapon Swap
 *       - Requires VisuMZ_2_WeaponSwapSystem!
 *       - Swaps current weapon for next one.
 * 
 *   Show Command Costs:
 *   - If a battle command has a resource cost, show it?
 *
 * ---
 *
 * Help Window
 * 
 *   Skill Types:
 *   - Text displayed when selecting a skill type.
 *   - %1 - Skill Type Name
 * 
 *   Items:
 *   - Text displayed when selecting the item command.
 * 
 *   Escape:
 *   - Text displayed when selecting the escape command.
 * 
 *   Auto Battle:
 *   - Text displayed when selecting the Auto Battle command.
 *
 * ---
 *
 * ============================================================================
 * Plugin Parameters: Multi-Target Windows Settings
 * ============================================================================
 *
 * Action Sequence Plugin Parameters adjust how the Multi-Target Windows appear
 * in battle. These windows are visible when selecting an enemy or actor while
 * using a skill/item that has the <Single or Multiple Select> notetag.
 * 
 * Those wondering why this isn't regulated to a command left or right of the
 * enemies and actors is because mouse controls and touch controls would not be
 * able to select all enemies or all allies that way.
 *
 * ---
 * 
 * Properties
 * 
 *   Window Width:
 *   - What is the width used for the Multi-Target Window?
 * 
 *   Background Type:
 *   - Select background type for these windows.
 * 
 *   Show Button:
 *   - Shows the keyboard/controller button to press?
 *   - Requires VisuMZ_0_CoreEngine!
 * 
 * ---
 * 
 * Vocab
 * 
 *   All Actors:
 *   - What is the text used for the "All Actors" button?
 * 
 *   All Enemies:
 *   - What is the text used for the "All Enemies" button?
 * 
 * ---
 * 
 * Offsets > Actor Offsets
 * Offsets > Enemy Offsets
 * 
 *   Offset X:
 *   - Offsets the button's x position.
 *   - Negative: left. Positive: right.
 * 
 *   Offset Y:
 *   - Offsets the button's y position.
 *   - Negative: up. Positive: down.
 * 
 * ---
 *
 * ============================================================================
 * Plugin Parameters: Damage Combo Window Settings
 * ============================================================================
 * 
 * If enabled, this window will display updated information about the total
 * amount of hits performed and total damage/healing value executed for HP.
 * 
 * This only applies when HP damage is directly dealt through action effects.
 * It does NOT apply for MP damage, TP damage, states, regeneration, or event
 * commands.
 * 
 * If you would like to adjust the Damage Combo Window mid-action, you can use
 * the following script calls to do so:
 * 
 *     $comboWindowReset()
 *     - Resets the all values found in the damage combo window.
 * 
 *     $comboWindowIncreaseHits(x)
 *     - Increases the current hit counter in the combo window by 'x'.
 *     - Insert a number for 'x'.
 *     - Example: $comboWindowIncreaseHits(2)
 * 
 *     $comboWindowIncreaseDamage(x)
 *     - Increases the current total damage counter in the combo window by 'x'.
 *     - Insert a number for 'x'.
 *     - This will offset any healing added in the damage counter window.
 *     - Example: $comboWindowIncreaseDamage(100)
 * 
 *     $comboWindowIncreaseHealing(x)
 *     - Increases the current total heal counter in the combo window by 'x'.
 *     - Insert a number for 'x'.
 *     - This will offset any damage added in the damage counter window.
 *     - Example: $comboWindowIncreaseHealing(200)
 * 
 * ---
 * 
 * General Settings:
 * 
 *   Enable?:
 *   - Add the Combo Window to show in battle?
 * 
 * ---
 * 
 * Appearance Settings:
 * 
 *   Custom Font:
 *   - Insert the custom font face name here.
 *   - Use VisuMZ_1_MessageCore to register new fonts.
 * 
 *   Text Align:
 *   - Text alignment for this window?
 * 
 *   JS: Draw Data:
 *   - Code used to draw the data in this window.
 * 
 * ---
 * 
 * Vocabulary:
 * 
 *   Damage Combo Format:
 *   - Text format used to display total hits for damage.
 *   - %1 - Total Hits
 * 
 *   Healing Combo Format:
 *   - Text format used to display total hits for healing.
 *   - %1 - Total Hits
 * 
 *   Damage Total Format:
 *   - Text format used to display total value for damage.
 *   - %1 - Total Damage
 * 
 *   Healing Total Format:
 *   - Text format used to display total value for healing.
 *   - %1 - Total Healing
 * 
 * ---
 * 
 * Position Settings:
 * 
 *   Fade Shift X:
 *   - Shifts the windows x position when fading.
 *   - Negative: left. Positive: right.
 * 
 *   Fade Shift Y:
 *   - Shifts the windows y position when fading.
 *   - Negative: up. Positive: down.
 * 
 *   Offset X:
 *   - Offsets the windows x position.
 *   - Negative: left. Positive: right.
 * 
 *   Offset Y:
 *   - Offsets the windows y position.
 *   - Negative: up. Positive: down.
 * 
 *   JS: X, Y, W, H:
 *   - Code used to determine the dimensions for this window.
 * 
 * ---
 * 
 * Updating Settings:
 * 
 *   Number Roll Duration:
 *   - Frame duration to roll damage numbers.
 *   - 60 frames = 1 second.
 * 
 *   Minimum Stay Duration:
 *   - Frame duration to stay visible minimum. 
 *   - 60 frames = 1 second.
 * 
 *   Minimum Hit Visible:
 *   - Minimum hits before combo window becomes visible?
 * 
 *   Opacity Speed:
 *   - Opacity speed when fading in/out.
 * 
 * ---
 *
 * ============================================================================
 * Plugin Parameters: Actor Battler Settings
 * ============================================================================
 *
 * These Plugin Parameter settings adjust how the sideview battlers behave for
 * the actor sprites. Some of these settings are shared with enemies if they
 * use sideview battler graphics.
 *
 * ---
 *
 * Flinch
 * 
 *   Flinch Distance X:
 *   - The normal X distance when flinching.
 * 
 *   Flinch Distance Y:
 *   - The normal Y distance when flinching.
 * 
 *   Flinch Duration:
 *   - The number of frames for a flinch to complete.
 * 
 *   Shake Flinch:
 *   - Perform a shake flinch when taking damage?
 * 
 *     Max Duration:
 *     - Maximum duration a shake flinch can have.
 *     - This is reduced relative to the amount of damage taken.
 * 
 *     Max Power:
 *     - The power rating of a shake flinch at full damage.
 *     - This is reduced relative to the amount of damage taken.
 *
 * ---
 *
 * Sideview Battlers
 * 
 *   Anchor:
 * 
 *     Anchor: X:
 *     - Default X anchor for Sideview Battlers.
 * 
 *     Anchor: Y:
 *     - Default Y anchor for Sideview Battlers.
 * 
 *   Chant Style:
 *   - What determines the chant motion?
 *   - Hit type or skill type?
 * 
 *   Motion Speed:
 *   - The number of frames in between each motion.
 * 
 *   Position:
 * 
 *     Offset X:
 *     - Offsets X position where actor is positioned.
 *     - Negative values go left. Positive values go right.
 * 
 *     Offset Y:
 *     - Offsets Y position where actor is positioned.
 *     - Negative values go up. Positive values go down.
 * 
 *   Priority: Active:
 *   - Place the active actor on top of actor and enemy sprites.
 * 
 *   Priority: Actors:
 *   - Prioritize actors over enemies when placing sprites on top of each other
 * 
 *   Shadow Visible:
 *   - Show or hide the shadow for Sideview Battlers.
 * 
 *   Smooth Image:
 *   - Smooth out the battler images or pixelate them?
 * 
 *   State Overlay:
 * 
 *     Offset X:
 *     - Offsets X position for state overlay on actor.
 *     - Negative values go left. Positive values go right.
 * 
 *     Offset Y:
 *     - Offsets Y position for state overlay on actor.
 *     - Negative values go up. Positive values go down.
 * 
 *   JS: Home Position:
 *   - Code used to calculate the home position of actors.
 *
 * ---
 *
 * ============================================================================
 * Plugin Parameters: Enemy Battler Settings
 * ============================================================================
 *
 * These Plugin Parameter settings adjust how enemies appear visually in the
 * battle scene. Some of these settings will override the settings used for
 * actors if used as sideview battlers. Other settings include changing up the
 * default attack animation for enemies, how the enemy select window functions,
 * and more.
 *
 * ---
 *
 * Visual
 * 
 *   Attack Animation:
 *   - Default attack animation used for enemies.
 *   - Use <Attack Animation: x> for custom animations.
 * 
 *   Emerge Text:
 *   - Show or hide the 'Enemy emerges!' text at the start of battle.
 * 
 *   Offset X:
 *   - Offsets X position where enemy is positioned.
 *   - Negative values go left. Positive values go right.
 * 
 *   Offset Y:
 *   - Offsets Y position where enemy is positioned.
 *   - Negative values go up. Positive values go down.
 * 
 *   Smooth Image:
 *   - Smooth out the battler images or pixelate them?
 *
 * ---
 *
 * Select Window
 * 
 *   Any: Last Selected:
 *   - Prioritize last selected enemy over front view or sideview settings?
 * 
 *   FV: Right Priority:
 *   - If using frontview, auto select the enemy furthest right.
 * 
 *   SV: Right Priority:
 *   - If using sideview, auto select the enemy furthest right.
 * 
 * ---
 * 
 * Name:
 * 
 *   Legacy Option:
 *   - Use the legacy version (window) or new version (sprite).
 *   - WARNING: Legacy version is no longer supported for bugs.
 *   - Not all settings available here in the Plugin Parameters will be
 *     available to the legacy version (ie Always Visible and Attach States).
 * 
 *   Font Size:
 *   - Font size used for enemy names.
 * 
 *   Name Position:
 * 
 *     Offset X:
 *     Offset Y:
 *     - Offset the enemy name's position by this much.
 *     - For X: Negative goes left. Positive goes right.
 *     - For Y: Negative goes up. Positive goes down.
 * 
 *   Name: Attach States:
 *   - Attach the enemy's state icon to the enemy name?
 * 
 *     Attach: Offset X:
 *     Attach: Offset Y:
 *     - How much to offset the attached icon's X/Y position by?
 *     - For X: Negative goes left. Positive goes right.
 *     - For Y: Negative goes up. Positive goes down.
 * 
 *   Name Visibility:
 * 
 *     Always Hidden:
 *     - Determines if the enemy name will always be visible.
 *     - Highest priority.
 * 
 *     Always Visible:
 *     - Determines if the enemy name will always be visible.
 *     - Medium priority.
 * 
 *     As Target:
 *     - Shows enemy name when enemy is a target.
 *     - Medium priority.
 * 
 *     By Selection?:
 *     - Determines the conditions for enemy name visibility.
 *     - Lowest priority.
 * 
 *     Temporary Visibility:
 *     - Number of frames enemy's name temporarily visible after taking an
 *       action effect in battle.
 *     - 60 frames = 1 second.
 *
 * ---
 *
 * Sideview Battlers
 * 
 *   Allow Collapse:
 *   - Causes defeated enemies with SV Battler graphics to "fade away"
 *     when defeated?
 * 
 *   Anchor: X:
 *   - Default X anchor for Sideview Battlers.
 *   - Use values between 0 and 1 to be safe.
 * 
 *   Anchor: Y:
 *   - Default Y anchor for Sideview Battlers.
 *   - Use values between 0 and 1 to be safe.
 * 
 *   Motion: Idle:
 *   - Sets default idle animation used by Sideview Battlers.
 * 
 *   Shadow Visible:
 *   - Show or hide the shadow for Sideview Battlers.
 * 
 *   Size: Width:
 *   - Default width for enemies that use Sideview Battlers.
 * 
 *   Size: Height:
 *   - Default height for enemies that use Sideview Battlers.
 * 
 *   Weapon Type:
 *   - Sets default weapon type used by Sideview Battlers.
 *   - Use 0 for Bare Hands.
 *
 * ---
 *
 * ============================================================================
 * Plugin Parameters: HP Gauge Settings
 * ============================================================================
 *
 * Settings that adjust the visual HP Gauge displayed in battle.
 *
 * ---
 *
 * Show Gauges For
 * 
 *   Actors:
 *   - Show HP Gauges over the actor sprites' heads?
 *   - Requires SV Actors to be visible.
 * 
 *   Enemies:
 *   - Show HP Gauges over the enemy sprites' heads?
 *   - Can be bypassed with <Hide HP Gauge> notetag.
 * 
 *     Requires Defeat?:
 *     - Requires defeating the enemy once to show HP Gauge?
 *     - Can be bypassed with <Show HP Gauge> notetag.
 * 
 *       Battle Test Bypass?:
 *       - Bypass the defeat requirement in battle test?
 *
 * ---
 *
 * Settings
 * 
 *   Animation Duration:
 *   - How many frames should gauges animate themselves?
 *   - Default: 20 frames.
 * 
 *   Anchor X:
 *   Anchor Y:
 *   - Where do you want the HP Gauge sprite's anchor X/Y to be?
 *     Use values between 0 and 1 to be safe.
 * 
 *   Scale:
 *   - How large/small do you want the HP Gauge to be scaled?
 * 
 *   Offset X:
 *   Offset Y:
 *   - How many pixels to offset the HP Gauge's X/Y by?
 *
 * ---
 *
 * Options
 * 
 *   Add Option?:
 *   - Add the 'Show HP Gauge' option to the Options menu?
 * 
 *   Adjust Window Height:
 *   - Automatically adjust the options window height?
 * 
 *   Option Name:
 *   - Command name of the option.
 *
 * ---
 *
 * ============================================================================
 * Plugin Parameters: Action Sequence Settings
 * ============================================================================
 *
 * Action Sequence Plugin Parameters allow you to decide if you want automatic
 * Action Sequences to be used for physical attacks, the default casting
 * animations used, how counters and reflects appear visually, and what the
 * default stepping distances are.
 *
 * ---
 *
 * Automatic Sequences
 * 
 *   Melee Single Target:
 *   - Allow this auto sequence for physical, single target actions?
 * 
 *   Melee Multi Target:
 *   - Allow this auto sequence for physical, multi-target actions?
 *
 * ---
 * 
 * Quality of Life
 * 
 *   Auto Notetag:
 *   - Automatically apply the <Custom Action Sequence> notetag effect to any
 *     item or skill that has a Common Event?
 *   - Any item or skill without a Common Event attached to it will use the
 *     Automatic Action Sequences instead.
 *   - The <Auto Action Sequence> notetag will disable this effect for that
 *     particular skill or item.
 * 
 * ---
 *
 * Cast Animations
 * 
 *   Certain Hit:
 *   - Cast animation for Certain Hit skills.
 * 
 *   Physical:
 *   - Cast animation for Physical skills.
 * 
 *   Magical:
 *   - Cast animation for Magical skills.
 *
 * ---
 *
 * Counter/Reflect
 * 
 *   Counter Back:
 *   - Play back the attack animation used?
 * 
 *   Reflect Animation:
 *   - Animation played when an action is reflected.
 * 
 *   Reflect Back:
 *   - Play back the attack animation used?
 *
 * ---
 *
 * Stepping
 * 
 *   Melee Distance:
 *   - Minimum distance in pixels for Movement Action Sequences.
 * 
 *   Step Distance X:
 *   - The normal X distance when stepping forward.
 * 
 *   Step Distance Y:
 *   - The normal Y distance when stepping forward.
 * 
 *   Step Duration:
 *   - The number of frames for a stepping action to complete.
 *
 * ---
 *
 * ============================================================================
 * Terms of Use
 * ============================================================================
 *
 * 1. These plugins may be used in free or commercial games provided that they
 * have been acquired through legitimate means at VisuStella.com and/or any
 * other official approved VisuStella sources. Exceptions and special
 * circumstances that may prohibit usage will be listed on VisuStella.com.
 * 
 * 2. All of the listed coders found in the Credits section of this plugin must
 * be given credit in your games or credited as a collective under the name:
 * "VisuStella".
 * 
 * 3. You may edit the source code to suit your needs, so long as you do not
 * claim the source code belongs to you. VisuStella also does not take
 * responsibility for the plugin if any changes have been made to the plugin's
 * code, nor does VisuStella take responsibility for user-provided custom code
 * used for custom control effects including advanced JavaScript notetags
 * and/or plugin parameters that allow custom JavaScript code.
 * 
 * 4. You may NOT redistribute these plugins nor take code from this plugin to
 * use as your own. These plugins and their code are only to be downloaded from
 * VisuStella.com and other official/approved VisuStella sources. A list of
 * official/approved sources can also be found on VisuStella.com.
 *
 * 5. VisuStella is not responsible for problems found in your game due to
 * unintended usage, incompatibility problems with plugins outside of the
 * VisuStella MZ library, plugin versions that aren't up to date, nor
 * responsible for the proper working of compatibility patches made by any
 * third parties. VisuStella is not responsible for errors caused by any
 * user-provided custom code used for custom control effects including advanced
 * JavaScript notetags and/or plugin parameters that allow JavaScript code.
 *
 * 6. If a compatibility patch needs to be made through a third party that is
 * unaffiliated with VisuStella that involves using code from the VisuStella MZ
 * library, contact must be made with a member from VisuStella and have it
 * approved. The patch would be placed on VisuStella.com as a free download
 * to the public. Such patches cannot be sold for monetary gain, including
 * commissions, crowdfunding, and/or donations.
 *
 * ============================================================================
 * Credits
 * ============================================================================
 * 
 * If you are using this plugin, credit the following people in your game:
 * 
 * Team VisuStella
 * * Yanfly
 * * Arisu
 * * Olivia
 * * Irina
 *
 * ============================================================================
 * Changelog
 * ============================================================================
 * 
 * Version 1.83: May 16, 2024
 * * Bug Fixes!
 * ** Fixed a bug where sometimes, a battler in Active TPB would not refresh
 *    their motion after a state has been removed. Fix made by Olivia.
 * * Documentation Update!
 * ** Help file updated for new features.
 * ** Fixed a typo with MP Life Steal notetag entry.
 * * Feature Updates!
 * ** Added fail safes for some plugin parameters in case users outright delete
 *    plugin parameter values without introducing something to replace them.
 *    Update made by Olivia.
 * * New Features!
 * ** New Action Sequence added by Olivia:
 * *** GRID: Add Trigger to Node JS
 * **** Adds JS Trigger to target node. Target node cannot have battler.
 * **** Requires VisuMZ_2_BattleGridSystem!
 * ** New notetags added by Olivia:
 * *** <JS Accuracy>
 * *** <JS Accuracy as User>
 * *** <JS Accuracy as Target>
 * **** Allows usage of JavaScript code to modify accuracy rates of actions in
 *      battle through skills, items, and trait objects.
 * *** <JS Critical Rate as User>
 * *** <JS Critical Rate as Target>
 * **** Allows usage of JavaScript code to modify critical rate of actions in
 *      battle through skills, items, and trait objects.
 * **** <JS Critical Rate> version already exists.
 * ** New Plugin Parameters added by Olivia
 * *** Plugin Parameters > Damage Combo Window
 * **** If enabled, this window will display updated information about the
 *      total amount of hits performed and total damage/healing value executed
 *      for HP.
 * *** Plugin Parameters > Actor Battler Settings > Sideview Battlers >
 *     State Overlay > Offset X/Y
 * **** Offsets X/Y position for state overlay on actor.
 * *** Plugin Parameters > Enemy Battler Settings > Name Visibility >
 *     As Target
 * **** Shows enemy name when enemy is a target.
 * *** Plugin Parameters > Enemy Battler Settings > Name Visibility >
 *     Temporary Visibility
 * **** Number of frames enemy's name temporarily visible after taking an
 *      action effect in battle.
 * 
 * Version 1.82: March 14, 2024
 * * Bug Fixes!
 * ** Home movement changes did not acknowledge actor and enemy offset X/Y
 *    positions. This should now be reflected properly. Fix made by Irina.
 * ** Fixed a bug where in active TPB/ATB, revived actors may not resume normal
 *    motions after collapsing. Fix made by Olivia.
 * 
 * Version 1.81: February 15, 2024
 * * Bug Fixes!
 * ** Fixed a bug that would cause active TPB inputting actors to not show
 *    their damage or evasion motions. Fix made by Olivia.
 * ** Fixed a bug that would cause a crash upon motion changes. Fix by Olivia.
 * ** Fixed an incorrect spelling of "Anger" for "ANIM: Balloon Animation" that
 *    prevented it from working properly.
 * * Compatibility Update!
 * ** Added compatibility functionality for future plugins.
 * * Documentation Update!
 * ** Help file updated for new features.
 * * New Features!
 * ** New Action Sequences added by Olivia:
 * *** ANIM: Show Animation JS
 * **** Plays the a specific animation on unit(s). Uses JavaScript to determine
 *      animation ID.
 * ** New Action Sequences added for future plugin: VisuMZ_2_BattleGridSystem
 * *** GRID: Action Animation at Node
 * *** GRID: Add Passive State(s) to Node
 * *** GRID: Add Trigger to Node
 * *** GRID: Animation ID at Node
 * *** GRID: Animation JS at Node
 * *** GRID: Animation Type at Node
 * *** GRID: Move Target(s) In Direction
 * *** GRID: Pull To Target Node
 * *** GRID: Push From Target Node
 * *** GRID: Remove All Passive States from Node
 * *** GRID: Remove Passive State(s) from Node
 * *** GRID: Remove Trigger from Node
 * *** GRID: Teleport To Node
 * *** GRID: Traverse To Node
 * **** Requires the future plugin VisuMZ_2_BattleGridSystem!
 * **** Read the help section for more information on these.
 * 
 * Version 1.80: January 18, 2024
 * * Bug Fixes!
 * ** Fixed a crash that would occur with <Disperse Damage> when used outside
 *    of battle. Fix made by Irina.
 * ** Fixed a crash that would occur with certain enemy graphics when images
 *    used for them would disappear. Fix made by Olivia.
 * * Documentation Update!
 * ** Help file updated for new features.
 * * New Features!
 * ** New Action Sequences added by Olivia:
 * *** ANIM: Guard Animation
 * *** ANIM: Item Animation
 * *** ANIM: Skill Animation
 * **** Plays the animation associated with the user's guard action (if any),
 *      or a specific item/skill.
 * *** MECH: Emulate Attack Effect
 * *** MECH: Emulate Guard Effect
 * *** MECH: Emulate Item Effect
 * *** MECH: Emulate Skill Effect
 * **** Emulate an "Action Effect" but using a the user's attack skill, guard
 *      skill, specific item, or specific skill instead of the current action.
 * **** Essentially lets you perform the mechanics of another action without
 *      having to use another action or needing to pay that action's costs.
 * *** MECH: Emulate Skill Cost
 * **** Pick a skill for target(s) to emulate paying the cost of.
 * **** Includes cooldowns and limited uses.
 * *** MECH: State Turns Change By
 * *** MECH: State Turns Change To
 * **** Changes target(s) state turns by an amount/to a certain value.
 * **** Requires VisuMZ_1_SkillsStatesCore!
 * *** Projectile action sequences have new Extra Features!
 * **** See v1.08 changes for VisuMZ_3_ActSeqProjectiles.
 * 
 * Version 1.79: December 14, 2023
 * * Documentation Update!
 * ** Help file updated for new features.
 * * New Features!
 * ** New Action Sequences added by Arisu:
 * *** ANIM: Balloon Animation
 * **** Plays a balloon animation on target(s).
 * *** ANIM: Balloon Icon (Single)
 * *** ANIM: Balloon Icon (Range)
 * *** ANIM: Balloon Icon (Specific)
 * **** Plays a balloon animation using an icon on target(s).
 * **** Requires VisuMZ_4_IconBalloons!
 * 
 * Version 1.78: October 12, 2023
 * * Bug Fixes!
 * ** Fixed a bug that is caused by using the actor escape command not escaping
 *    properly in battle and causing a freeze. Fix made by Olivia.
 * * Compatibility Update!
 * ** Added compatibility functionality for future plugins.
 * * Documentation Update!
 * ** Help file updated for new features.
 * * New Features!
 * ** New Plugin Parameter added by Olivia:
 * *** Parameters > Mechanics > Turn End Buffs Expire?
 * **** Normally, buffs expire after all actions end.
 * **** But here, you can have buffs expire on turn end.
 * * Optimization Update!
 * ** Plugin should run more optimized.
 * 
 * Version 1.77: August 17, 2023
 * * Bug Fixes!
 * ** Fixed a bug where for TPB, actions aimed at dead targets would not
 *    redirect to suitable targets. Fix made by Olivia.
 * ** Fixed a bug where dual wielding would not use a weapon if it was equipped
 *    in the second weapon slot if the first weapon slot was empty. Fix made
 *    by Olivia.
 * * Compatibility Update!
 * ** Added compatibility functionality for future plugins.
 * ** Added compatibility for VisuStella MZ Battle Voices Action Sequences.
 * * Documentation Update!
 * ** Help file updated for new features.
 * 
 * Version 1.76: July 13, 2023
 * * Documentation Update!
 * ** Help file updated for new features.
 * * New Features!
 * ** New Action Sequences added by Olivia and sponsored by NSG:
 * *** MOVE: Change Home To JS Coordinates
 * **** Change home position(s) to specified JS Coordinates. Sideview-only!
 *      Uses JS!
 * *** MOVE: Face JS Coordinates
 * **** Causes the unit(s) to face specified JS Coordinates. Sideview-only!
 *      Uses JS!
 * *** MOVE: Move To JS Coordinates
 * **** Moves unit(s) to specified JS Coordinates. Sideview-only! Uses JS!
 * 
 * Version 1.75: March 16, 2023
 * * Documentation Update!
 * ** Help file updated for new features.
 * * New Features!
 * ** New notetags added by Olivia and sponsored by Anon:
 * *** <HP Life Steal: x%>
 * *** <MP Life Steal: x%>
 * *** <HP Life Steal hitType: +/-x%>
 * *** <MP Life Steal hitType: +/-x%>
 * *** <Cancel Life Steal>
 * *** <Guard Life Steal>
 * *** <Disarm Life Steal>
 * *** <Negative Life Steal>
 * **** Life Steal properties involving HP/MP are now added. They will restore
 *      a portion of the dealt HP/MP damage to the target.
 * **** This is a different mechanic from Drain HP/Drain MP and cannot be used
 *      together to prevent clashing.
 * **** Read the help file for more information.
 * 
 * Version 1.74: February 16, 2023
 * * Bug Fixes!
 * ** Fixed a bug that would cause a crash if your basic attack skill somehow
 *    manages to target neither an enemy nor an actor. Fix made by Olivia.
 * * Documentation Update!
 * ** Help file updated for new features.
 * * Feature Update!
 * ** Auto-action sequence for jumping forward and attacking is now reinstated
 *    so that it's only disabled when the target and user are on the same side.
 *    If there is no target, a jump still occurs for visual player feedback.
 *    Update made by Olivia.
 * * New Features!
 * ** New notetag effect added by Olivia and sponsored by AndyL:
 * *** <Cannot Target User>
 * **** This will cause the action to be unable to select the user as target.
 * **** This is not a targeting scope. Instead, it is used in addition to any
 *      other targeting scopes out there.
 * 
 * Version 1.73: January 20, 2023
 * * Bug Fixes!
 * ** Active TPB custom action sequences will no longer play differently due to
 *    queued inputting actors causing motion refreshes. Fix made by Arisu.
 * ** Corrected and updated Anti-Tint UI animation offsets for MV animations.
 *    Fix made by Irina.
 * ** Fixed a problem with Sideview Battlers not working properly. Fix made
 *    by Irina.
 * * Compatibility Update!
 * ** Added compatibility functionality for future plugins.
 * * Documentation Update!
 * ** Help file updated for new features.
 * ** Help file updated for to add the following text to the <Target: x>
 *    notetag entries in order to avoid confusion.
 * *** This will overwrite the existing database scope and ignore the
 *     database's existing scope in favor of this.
 * * Feature Update!
 * ** <Extend: x> Troop Name Tag is now also usable as a Troop Comment Tag.
 * ** Action Sequence targeting has been updated with two new types "special"
 *    and "special x", to be used for future plugins.
 * * New Features!
 * ** New Notetags added by Irina and sponsored by AndyL:
 * *** <Target: Ally or Enemy>
 * *** <Target: Enemy or Ally>
 * **** Allows the player to target allies or enemies with the skill/item.
 * **** See help file for more information.
 * *** <Single or Multiple Select>
 * **** This will allow the skill/item to be able to select either single
 *      targets or multiple targets at once.
 * **** See help file for more information.
 * *** <Disperse Damage>
 * **** This will cause any damage dealt by this skill to be split equally
 *      amongst all targets of the skill including repeats.
 * ** New Plugin Parameters added by Irina and sponsored by AndyL:
 * *** Plugin Parameters > Multi-Target Windows
 * **** Settings that alter the Multi-Target Windows in battle.
 * 
 * Version 1.72: December 15, 2022
 * * Bug Fixes!
 * ** Fixed a transformation of a sideview enemy to a static enemy and back not
 *    working properly. Fix made by Irina.
 * * Documentation Update!
 * ** Help file updated for new features.
 * * New Feature!
 * ** New Plugin Parameter added by Irina!
 * *** Plugin Parameters > HP Gauges > Settings > Animation Duration
 * **** How many frames should gauges animate themselves? Default: 20 frames.
 * ** New Plugin Parameters added by Yanfly!
 * *** Plugin Parameters > Actor Battler Settings > Shake Flinch
 * *** Plugin Parameters > Actor Battler Settings > Shake Flinch > Max Power
 * *** Plugin Parameters > Actor Battler Settings > Shake Flinch > Max Duration
 * **** These new plugin parameters will cause targets that take HP damage to
 *      shake (in addition to a regular flinch) to provide better visual
 *      feedback to the player.
 * **** Shake Flinch will be kept disabled by default and only turned on when
 *      you want it to be.
 * * Optimization Update!
 * ** Plugin should run more optimized.
 * 
 * Version 1.71: November 10, 2022
 * ** Fixed a problem with repeating animations from Visual State Effects
 *    causing softlocks. Fix made by Olivia.
 * 
 * Version 1.70: October 6, 2022
 * * Bug Fixes!
 * ** Fixed a problem with the "Border" style where if a battle portrait
 *    changed midway through the battle, the portrait shown didn't actually
 *    update properly. Fix made by Irina.
 * * Documentation Update!
 * ** Help file updated for new features.
 * * New Features!
 * ** New Action Sequence added by Olivia:
 * *** MECH: Active Chain Input Disable
 * **** Disables input for Active Chain Skills at this time.
 * **** Requires VisuMZ_3_ActiveChainSkills!
 * ** New Plugin Parameter added by Olivia and sponsored by Anon:
 * *** Plugin Parameters > Damage Settings > Popups > End Battle Show?
 * **** Show or hide popups upon victory or escape?
 * **** Used to hide battle-state removal popups.
 * 
 * Version 1.69: September 7, 2022
 * * Compatibility Update!
 * ** Better compatibility with VisuMZ Active Chain Skills.
 * ** Compatibility will be seen with VisuMZ_3_ActiveChainSkills version 1.02.
 * * Documentation Update!
 * ** Added notes to the following Action Sequences:
 * *** MOTION: Clear Freeze Frame and MOTION: Freeze Motion Frame
 * **** Only applies to sprite sheets.
 * **** Does NOT work with Dragonbones.
 * **** Use "DB: Dragonbones Time Scale" instead.
 * * Feature Update!
 * ** Reduced MV Animation misalignment when Screen Resolution does not match
 *    the UI Area Resolution. Update by Arisu.
 * ** Command Remember will now remember the locations of single skills. Update
 *    made by Olivia.
 * 
 * Version 1.68: August 4, 2022
 * * Feature Update!
 * ** Damage popups are now automatically cleared upon starting battles. This
 *    is to ensure that, if for some reason, residual damage popup requests
 *    will not be retained. Update made by Olivia.
 * 
 * Version 1.67: July 28, 2022
 * * Feature Updates!
 * ** Rounding window coordinates have been added for for 'XP' and 'Portrait'
 *    styles when window sizes happen to land on non-divisible numbers. Update
 *    made by Irina.
 * ** Enemy name position rounding is now enforced. Update made by Irina.
 * 
 * Version 1.66: July 14, 2022
 * * Bug Fixes!
 * ** Fixed a bug that caused the various Battleback Scaling JS custom plugin
 *    parameters to not work properly. Fix made by Irina.
 * 
 * Version 1.65: July 7, 2022
 * * Documentation Update!
 * ** Help file updated for new features.
 * * Feature Updates!
 * ** Automatic action motions for HP and MP Recovery (Certain Hit type) will
 *    now use the "skill" cast SV animation instead of attack animation to
 *    better match the default RPG Maker MZ cast animation. Update by Olivia.
 * * New Features!
 * ** New troop name tag added by Olivia:
 * *** <Extend: x> and <Extend: x, x, x>
 * **** Adds enemies from another troop to the current troop.
 * **** Enemies from another troop will retain their database positions.
 * **** Extended troop members will be added in the order they're listed.
 * **** Be cautious of how many enemies you add as too many will lag the battle
 *      system. We are not responsible for frame drops due to this.
 * 
 * Version 1.64: June 16, 2022
 * * Bug Fixes!
 * ** "All Skills" battle command should now work with the updated version of
 *    VisuMZ Skills & States Core. Fix madde by Olivia.
 * * Compatibility Update
 * ** Plugins should be more compatible with one another.
 * 
 * Version 1.63: May 26, 2022
 * * Documentation Update!
 * ** Help file updated for new features.
 * * Feature Update!
 * ** HP Gauge sprite now properly synchs with battler location.
 * * New Features!
 * ** New Action Sequence Effects added by Irina and sponsored by MirageV:
 * *** INJECT action sequence series
 * **** See the Action Sequence Impact changelog for details.
 * 
 * Version 1.62: April 22, 2022
 * * Bug Fixes!
 * ** RPG Maker MZ Bug Fix!
 * *** Battle Forced End Action Crash
 * **** Depending on various circumstances, currently active battlers can be
 *      cleared from the battle system at will due to a number of reasons.
 *      However, if it just so happens that the targets are cleared, too, with
 *      actions remaining, then a crash will follow up. This plugin will
 *      prevent that change. Fix made by Olivia.
 * 
 * Version 1.61: April 14, 2022
 * * Documentation Update!
 * ** Help file updated for new features.
 * * New Features!
 * ** New Impact Effects added by Irina and collaborating with Manu Gaming!
 * *** Impact: Bizarro Inversion
 * *** Impact: Desaturation
 * *** Impact: Negative Inversion
 * *** Impact: Oversaturation
 * *** Impact: Time Scale
 * *** Impact: Time Stop
 * 
 * Version 1.60: April 7, 2022
 * * Bug Fixes!
 * ** <Bypass Soft Damage Cap> notetag should no longer cause crashes. Fix made
 *    by Olivia.
 * * Feature Update!
 * ** Removed one of the forced log window clear events that have made log
 *    window messages impossible to utilize for certain settings. Update made
 *    by Olivia.
 * 
 * Version 1.59: March 31, 2022
 * * Bug Fixes!
 * ** Escape failure will no longer trigger Post-Battle Common Events. Fix
 *    made by Arisu.
 * 
 * Version 1.58: March 24, 2022
 * * Documentation Update:
 * ** Added extra clarity to <Sideview Size: width, height> notetag:
 * *** This does NOT change the image size. This only changes the HITBOX size.
 * * Feature Update!
 * ** Added failsafes to prevent battlers from moving to non-finite coordinates
 *    if calculations are made for non-existent targets. Updated by Olivia.
 * ** Regeneration timing for TPB-based battle systems will now occur based on
 *    individual turn counts instead of global turn counts for initial turn 0
 *    checks. Updated by Olivia.
 * 
 * Version 1.57: February 17, 2022
 * * Feature Update!
 * ** Adjusted the offset properties for the anti-tint UI container to properly
 *    match the UI offsets if the anti-tint were to be off. Update by Irina.
 * 
 * Version 1.56: February 10, 2022
 * * Documentation Update!
 * ** Help file updated for new features.
 * * Feature Update!
 * ** Once Parallels for battle now operate outside of the battle process.
 *    Update made by Olivia.
 * * New Features!
 * ** New Troop Page comment tag added by Olivia and sponsored by Puddor:
 * *** <Once Parallel When Start Battle>
 * **** Causes the troop page to immediately run the moment the battle scene
 *      begins to fade in (not after it fades in). This is faster than a turn 0
 *      condition troop page. Troop page conditions are ignored.
 * **** This can be used for things like the Action Sequence Camera plugin, the
 *      Visual Battle Environment plugin, and/or initial battle poses and such
 *      in order to provide a near seamless battle transition experience.
 * **** This does NOT trigger when coming out of the options menu or party
 *      menu screens.
 * **** This WILL trigger when going from battle to battle nonstop via plugins
 *      like VisuStella MZ's Chain Battles.
 * **** When actors are moving towards their home positions, it will take
 *      around 30 frames by default. Use this information however you like.
 * * Optimization Update!
 * ** Plugin should run more optimized.
 * 
 * Version 1.55: January 27 2022
 * * Compatibility Update!
 * ** RPG Maker MV animations with front view should now play in the correct
 *    area against actor faces. Update made by Olivia.
 * * Documentation Update!
 * ** Help file updated for new features.
 * * Feature Update!
 * ** Animations now play on top of all actor faces/portraits regardless of the
 *    battle layout style. Update made by Olivia.
 * * New Features!
 * ** New notetag added by Arisu.
 * *** <Bypass Auto Action Sequence>
 * **** This notetag is used for the game devs that have the Action Sequence
 *      Plugin Parameter "Auto Notetag" on for applying the notetag
 *      <Custom Action Sequence> to every skill and item with common events.
 * **** This will allow items and skills to be able to launch their common
 *      events from the menu scene regardless of the inherent restriction to
 *      prevent action sequence based skills/items with common events from
 *      launching.
 * **** Ignore this if you have "Auto Notetag" disabled or set to false. By
 *      default, this setting is set to false. Please be aware of the changes
 *      you've made to your game before using it.
 * 
 * Version 1.54: January 13, 2022
 * * Bug Fixes!
 * ** RPG Maker MZ Bug Fix!
 * *** Overly-Protective Substitute
 * *** When an ally with critical health is being targeted by a friendly non-
 *     Certain Hit skill (such as a heal or buff) and another ally has the
 *     substitute state, the other ally would "protect" the originally targeted
 *     ally and take the heal or buff.
 * *** The new changed behavior is that now, substitute will not trigger for
 *     any actions whose scope targets allies.
 * *** Fix made by Olivia.
 * 
 * Version 1.53: December 30, 2021
 * * Documentation Update!
 * ** Help file updated for new features.
 * ** Help file updated for updated features.
 * * New Features!
 * ** New Plugin Parameter added by Olivia:
 * *** Plugin Parameters > Battle Layout > UI Elements > Anti-Tint UI?
 * **** Prevent UI Elements from being tinted?
 * **** This prevents UI Elements such as HP Gauges, Enemy Names, Battle
 *      Cursor, and Weakness Display from being affected by screen tint.
 * * Updated Feature!
 * ** Updated Plugin Command "PROJECTILE: Animation" by Arisu!
 * *** New Parameter: Wait For Animation?
 * **** Wait for animation to finish before going to the next command?
 * 
 * Version 1.52: December 16, 2021
 * * Compatibility Update!
 * ** RPG Maker MZ 1.4.0 compatibility update!
 * *** MV Animations played on screen level will now show up properly in the
 *     center of the screen.
 * 
 * Version 1.51: December 9, 2021
 * * Documentation Update!
 * ** Help file updated for new features.
 * * New Features!
 * ** New Action Sequence Plugin Commands added by Arisu:
 * *** MOVE: Change Home By Distance
 * *** MOVE: Change Home To Point
 * *** MOVE: Change Home To Target(s)
 * **** These Plugin Commands allow you to adjust the home position of
 *      battlers in sideview battle.
 * **** This is sideview only!
 * **** This does NOT work with front view!
 * **** For those wondering, going to the options screen, party screen, etc.
 *      won't reset the home positions like regular movement changes do.
 * **** Merry Christmas, Harold-gang!
 * 
 * Version 1.50: November 4, 2021
 * * Bug Fixes!
 * ** <Seal Attack> and <Seal Guard> should no longer be bypassed by
 *    auto-battle status. Fix made by Yanfly.
 * 
 * Version 1.49: October 28, 2021
 * * Documentation Update!
 * ** Help file updated for new features.
 * * Feature Update!
 * ** Action Sequence: MOTION: Freeze Motion Frame will now only show weapons
 *    when using a motion that is named either "attack", "thrust", "swing", or
 *    "missile". Update made by Irina.
 * ** Fail safe added to prevent Scene_Battle going into unsupported scenes
 *    like Scene_Equip and Scene_Skill. Update made by Olivia.
 * * New Feature!
 * ** New Action Sequence Plugin Command added by Arisu and sponsored by Anon:
 * *** MECH: Once Parallel
 * **** Plays a Common Event parallel to the battle event once without
 *      repeating itself when done.
 * **** When exiting battle scene, all Once Parallels are cleared.
 * **** Once Parallels are not retained upon reentering the scene.
 * **** Once Parallels are not stored in memory and cannot be saved.
 * 
 * Version 1.48: October 21, 2021
 * * Feature Update!
 * ** Animations are now played on top of battlers in the Front View XP Battle
 *    Layout appearance. Update made by Irina.
 * ** Battle Log, if decided to be shown, now updates faster. Update by Irina.
 * ** Default Critical Damage Bonus increase is now updated to account for
 *    HP Healing and MP Recovery. To update this, create a new project, with
 *    the newest version of Battle Core installed. Copy over the Plugin
 *    Parameters for the Damage Settings > Critical Hits > JS: Damage Formula
 *    to your own project's version. Update made by Irina.
 * 
 * Version 1.47: October 14, 2021
 * * Compatibility Update!
 * ** Added compatibility functionality for future plugins.
 * * Feature Update!
 * ** Back attachment sprites are now automatically updated with sprite
 *    battlers to be shifted towards the very back.
 * 
 * Version 1.46: September 23, 2021
 * * Bug Fixes!
 * ** Fixed problem with skills and items without action sequences preventing
 *    actions from occurring. Fix made by Yanfly.
 * 
 * Version 1.45: September 17, 2021
 * * Bug Fixes!
 * ** <JS Pre-End Action> and <JS Post-End Action> effects now have multiple
 *    checks to make sure that they don't launch multiple times when a battler
 *    without actions has a turn after one that does. Fix made by Olivia.
 * * Documentation Update!
 * ** Help file updated for new features.
 * * New Features!
 * ** New Action Sequence notetags added by Yanfly and Arisu:
 * *** <Common Event Key: name>
 * *** <Common Event Keys: name, name, name>
 * *** <Common Event Keys>
 *      key
 *      key
 *      key
 *     </Common Event Keys>
 * **** Will generate Common Events for the skill/item with a corresponding
 *      key.
 * **** More information will be explained inside of the help file.
 * **** This feature is made for make the process of sharing Action Sequences
 *      to become easier without needing to line up Common Event ID's.
 * 
 * Version 1.44: August 20, 2021
 * * Documentation Update!
 * ** Help file updated for new features.
 * * New Features!
 * ** New Action Sequence added by Irina and sponsored by Anon.
 * *** "ANIM: Play at Coordinate"
 * **** Plays an animation on the screen at a specific x, y coordinate even if
 *      there is no sprite attached.
 * **** Requires VisuMZ_0_CoreEngine!
 * 
 * Version 1.43: July 23, 2021
 * * Feature Update!
 * ** Immortality now works different with instant death mechanics. Skill
 *    effects that apply instant death or attack states that apply instant
 *    death will now trigger a flag instead of cancelling immortality. The
 *    flag will remain until immortality is manually cancelled via Action
 *    Sequence and then proc the death effect. This way, animations can remain
 *    to the end with instant death mechanics in mind. This does not affect
 *    script calls.
 * 
 * Version 1.42: July 16, 2021
 * * Bug Fixes!
 * ** Added another fail safe for empty common events used for pre-battle
 *    common events. Fix made by Olivia.
 * 
 * Version 1.41: July 2, 2021
 * * Documentation Update!
 * ** Help file updated for new features.
 * ** Added entries to <Battle Command> notetags and Plugin Parameters for
 *    "Party", "Combat Log", and "Weapon Swap" which weren't updated before.
 * * Optimization Update!
 * ** Plugin should run more optimized.
 * * New Features!
 * ** New Action Sequence added by Arisu:
 * *** MECH: Enemy Escape
 * **** Causes the enemy unit(s) to escape.
 * 
 * Version 1.40: June 25, 2021
 * * Bug Fixes!
 * ** Transformations from static enemies to and from animated SV enemies
 *    should no longer show both sprites. Fix made by Irina.
 * * Compatibility Update
 * ** Compatibility update with RPG Maker MZ 1.3.0+.
 * 
 * Version 1.39: June 18, 2021
 * * Bug Fixes!
 * ** MOVE: Home Reset should no longer trigger an end action function and
 *    cause plugins such as "Boost Action" to malfunction. Fix made by Olivia.
 * * Compatibility Update
 * ** Added compatibility functionality for future plugins.
 * * Documentation Update!
 * ** Help file updated for updated features.
 * * Feature Update!
 * ** <Battle Layout: x> Troop Name tags can now work with comment tags. Update
 *    made by Irina.
 * ** Random encounter lists are now better shuffled for more variety with how
 *    the RNG seed works. Update made by Arisu.
 * 
 * Version 1.38: June 11, 2021
 * * Documentation Update!
 * ** Help file updated for new features.
 * * Feature Updates!
 * ** Location calculations will now be based off the a battler's base position
 *    in order for animations, popups, and other aspects to line up properly
 *    when scaled. Update made by Irina.
 * ** Plugin Parameters for Enemy Battler Settings > Name have been rearranged
 *    for better organization. Update by Olivia.
 * * New Features!
 * ** New Notetags added by Olivia and sponsored by NSG:
 * *** <Sideview Shadow Scale X: x%>
 * *** <Sideview Shadow Scale X: x.y>
 * *** <Sideview Shadow Scale Y: x%>
 * *** <Sideview Shadow Scale Y: x.y>
 * **** These new notetags allow you to adjust the X and Y scale of the SV
 *      shadow sprite separately.
 * ** New Plugin Parameters added by Olivia and sponsored by NSG:
 * *** Enemy Battler Settings > Name > Name Visibility > Always Hidden
 * *** Enemy Battler Settings > Name > Name Visibility > By Selection?
 * **** Choose to have the names always hidden or by selection.
 * **** These are adjusted on a priority list.
 * 
 * Version 1.37: May 21, 2021
 * * Documentation Update!
 * ** Help file updated for new features.
 * * New Features!
 * ** New notetags added by Olivia.
 * *** <Command Require Learn>
 * *** <Command Require Access>
 * **** These two commands determine the visibility of a battle command by
 *      whether or not the skill has been learned or accessible.
 * * Feature Update!
 * ** For those using TPB, each battler's regeneration phase will no longer
 *    tick multiple times in a single frame to prevent irregularities. Update
 *    made by Olivia.
 * 
 * Version 1.36: May 14, 2021
 * * Bug Fixes!
 * ** Reversed an HP/MP regeneration bug that was incorrectly reported for TPB.
 *    Fix made by Olivia.
 * * Documentation Update
 * ** Added "TPB/ATB Active Battle Actor Shifting" to Major Changes section:
 * *** This change has been active since the start of this plugin. It was not
 *     documented until now.
 * *** Pressing cancel on the Actor Command Window no longer switches between
 *     actors with a full TPB/ATB gauge before reaching the Party Command
 *     Window. This is to accomplish a couple of things: 1) reduce the number
 *     of button presses to reach the Party Command Window and 2) to prevent
 *     motion resets and disrupting action sequences. If this feature is vital
 *     to your battle system, we recommend that you do not use this plugin or
 *     any of the Battle Core-required plugins.
 * ** Feature Updates
 * *** Distortion sprite Y calculations will now be rounded upward for better
 *     visuals and prevent odd pixelation effects. Update made by Irina.
 * 
 * Version 1.35: May 7, 2021
 * * Bug Fixes!
 * ** Pre-Battle Common Events without a wait command at the end should no
 *    longer lock up by coincidentally pressing the menu key at the same time.
 *    Fix made by Olivia.
 * * Feature Update!
 * ** Added an extra check for TPB-based battle systems to not run turn end
 *    functions when it's not actually the actual turn end timing. Update made
 *    by Olivia.
 * ** "Damage Styles" plugin parameters are now moved to the top of the
 *    Damage Settings category. This should make it easier to acknowledge the
 *    existence of and not have it be an unknown entity. Update made by Irina.
 * 
 * Version 1.34: April 23, 2021
 * * Documentation Update!
 * ** Help file updated for new features.
 * * Feature Update!
 * ** Uses a better algorithm for determining shadow positioning. Update made
 *    by Olivia.
 * * New Features!
 * ** New additions made for Projectile action sequences.
 * ** "Start Location" and "Goal Location" now have "Target Location" parameter
 *    to determine which part of the target's body to send the projectile from
 *    or towards. Added by Olivia.
 * ** Requires VisuMZ_1_BattleCore version 1.34 to have affect.
 * 
 * Version 1.33: April 9, 2021
 * * Bug Fixes!
 * ** Skill costs should now be displayed on battle commands again. Bug fix
 *    made by Olivia.
 * ** Pre-Battle Common Events should no longer cause stalling when used with
 *    specific event commands. Bug fix made by Olivia.
 * * Compatibility Update!
 * ** Added "Weapon Swap" to the list of battle commands that can be added.
 * * Documentation Update!
 * ** Added "Weapon Swap" and "Combat Log" to the list of <Battle Commands> in
 *    the notetags section.
 * ** Help file updated for new features.
 * * New Features!
 * ** New notetags added by Olivia:
 * *** <Sideview Shadow Scale: x%> and <Sideview Shadow Scale: x.y>
 * **** Used for: Actor, Enemy Notetags
 * **** Adjusts the scaling size of the sideview battler's shadow.
 * 
 * Version 1.32: April 2, 2021
 * * Feature Update!
 * ** Sideview battler sprites when using front view will now factor in the
 *    window padding and appear properly centered to their focus point. Update
 *    made by Olivia.
 * 
 * Version 1.31: March 26, 2021
 * * Compatibility Update!
 * ** Added compatibility functionality for future plugins.
 * * Documentation Update!
 * ** Added "VisuStella MZ Compatibility" section for detailed compatibility
 *    explanations with the VisuMZ_3_BoostAction plugin.
 * 
 * Version 1.30: March 19, 2021
 * * Documentation Update!
 * ** Help file updated for updated features.
 * * Feature Update!
 * ** <JS Targets> is now updated to include the default set of targets
 *    selected by the skill/item's original scope. Update made by Yanfly.
 * *** If you wish to clear it out, simply do 'targets = []' first.
 * 
 * Version 1.29: March 12, 2021
 * * Compatibility Update!
 * ** Added compatibility functionality for future plugins.
 * * Documentation Update!
 * ** Help file updated for new features.
 * * New Features!
 * ** New Plugin Parameter added by Olivia:
 * *** Plugin Parameters > Enemy Battler Settings > Name > Legacy Option
 * **** Use the legacy version (window) or new version (sprite).
 * **** WARNING: Legacy version is no longer supported for bugs.
 * **** Not all settings available here in the Plugin Parameters will be
 *      available to the legacy version (ie Always Visible and Attach States).
 * 
 * Version 1.28: March 5, 2021
 * * Compatibility Update!
 * ** Added compatibility functionality for future plugins.
 * * Documentation Update!
 * ** Help file updated for new features.
 * * New Features!
 * ** New Plugin Parameters added by Arisu:
 * *** Plugin Parameters > Actor Command > Show Command Costs
 * **** If you don't want to show skill costs for your commands in the Actor
 *      Command Window, you can now hide them.
 * ** New Plugin Parameters added by Irina:
 * *** Plugin Parameters > Battle Layout Settings > Status Window Elements
 * *** Battle Layout Settings > Status Window Elements > Battler Name
 * *** Battle Layout Settings > Status Window Elements > Gauge 1 (HP)
 * *** Battle Layout Settings > Status Window Elements > Gauge 2 (MP)
 * *** Battle Layout Settings > Status Window Elements > Gauge 3 (TP)
 * *** Battle Layout Settings > Status Window Elements > State Icon
 * *** Battle Layout Settings > Status Window Elements > TPB/ATB Gauge
 * **** These new Plugin Parameters allow you to offset the positions of the
 *      various Battle Status Window elements. Their base positions will be
 *      calculated by the Battle Layout used and then offset from there.
 * *** Battle Layout Settings > Status Window Elements > Window Skin
 * **** These settings allow you to set a specific window skin for the
 *      Battle Status Window or hide it from view completely.
 * *** Battle Layout Settings > Status Window Elements > Selectable Background
 * **** This option allows you to hide the black box that comes with the
 *      majority of selectable elements found in RPG Maker MZ in case it does
 *      not fit with how you want the Battle Status Window to look.
 * *** Battle Layout Settings > Status Window Elements > Back Attachment
 * *** Battle Layout Settings > Status Window Elements > Front Attachment
 * **** These settings allow you to attach images to the back/front of the
 *      Battle Status Window from the img/system/ folder.
 * **** You may offset X and Y positions for them as well.
 * ** New Plugin Parameters added by Olivia:
 * *** Plugin Parameters > Enemy Settings > Name: Always Visible
 * **** Determines if the enemy name will always be visible.
 * *** Plugin Parameters > Enemy Settings > Name: Attach States
 * **** Attach the enemy's state icon to the enemy name?
 * *** Plugin Parameters > Enemy Settings > Attach: Offset X/Y
 * **** Offset the attached state icon's position.
 * * Feature Update!
 * ** Switched drawing enemy names on the screen from window to sprite to
 *    reduce lag and for better screen positioning accuracy especially during
 *    screen zooming. Update by Olivia.
 * 
 * Version 1.27: February 26, 2021
 * * Compatibility Update!
 * ** Added compatibility functionality for future plugins.
 * * Documentation Update!
 * ** Help file updated for new features.
 * * New Features!
 * ** New Plugin Parameters added by Irina and sponsored by AndyL:
 * *** Plugin Parameters > Mechanics Settings > Switches > Switch: Critical
 * *** Plugin Parameters > Mechanics Settings > Switches > Switch: Miss/Evade
 * **** Turns Switches ON if the action performs a critical hit, misses, or is
 *      evaded at any point.
 * **** Switch reverts to OFF whenever an action starts.
 * **** If multiple targets/hits are struck, as long as one hit respectively
 *      lands a critical hit, fails to land, then the switch will remain ON for
 *      the rest of the action.
 * *** Plugin Parameters > Mechanics Settings > Variables > Variable: Damage
 * *** Plugin Parameters > Mechanics Settings > Variables > Variable: Healing
 * **** Variable records target damage/healing during action.
 * **** Variable reverts to 0 whenever an action starts.
 * **** If multiple targets/hits are struck, the variable will record the total
 *      amount of damage/healing done for the remainder of the action (unless
 *      manually reseting to 0 during an Action Sequence).
 * 
 * Version 1.26: February 19, 2021
 * * Bug Fixes!
 * ** Battles with branching event paths found within a conditional branch or
 *    choice tree will no longer be skipped over. Fix made by Arisu.
 * * Compatibility Update
 * ** Returning to the battle scene from the options scene in a Tpb-base battle
 *    system now links the current actor. Update by Irina.
 * 
 * Version 1.25: February 5, 2021
 * * Compatibility Update
 * ** Added compatibility update with VisuStella MZ Skills and States Core's
 *    Plugin Parameter > State Settings > Action End Update
 * * Feature Update!
 * ** <Common Event: name> notetag no longer requires <Custom Action Sequence>
 *    notetag if the Plugin Parameter: Auto Notetag is enabled.
 * 
 * Version 1.24: January 29, 2021
 * * Documentation Update!
 * ** Help file updated for new features.
 * * Feature Update!
 * ** MOVE: Move To Point and MOVE: Move To Target(s) Action Sequences'
 *    "Offset Adjustment" normal setting will now factor in Offset X and
 *    Offset Y positions unlike before where it cancels them. Update by Irina.
 * * New Features!
 * ** New notetag added by Arisu:
 * *** <Common Event: name>
 * **** Battle only: calls forth a Common Event of a matching name.
 * **** This is primarily used for users who are reorganizing around their
 *      Common Events and would still like to have their skills/items perform
 *      the correct Action Sequences in case the ID's are different.
 * 
 * Version 1.23: January 22, 2021
 * * Documentation Update!
 * ** Help file updated for new features.
 * * Feature Update!
 * ** ACSET: All Targets Action Set and ACSET: Each Target Action Set updated
 * *** New parameter added: Dual/Multi Wield?
 * **** Add times struck based on weapon quantity equipped?
 * * New Features!
 * ** Dual Wielding now functions differently. Made by Olivia.
 * *** Previously, RPG Maker MZ had "Dual Wielding" attack using both weapon
 *     animations at once, with the combined ATK of each weapon. It's confusing
 *     to look at and does not portray the nature of "Dual Wielding".
 * *** Dual Wielding, or in the case of users adding in third and fourth
 *     weapons, Multi Wielding is now changed. Each weapon is displayed
 *     individually, each producing its own attack animation, showing each
 *     weapon type, and applying only that weapon's ATK, Traits, and related
 *     effects. It is no longer a combined effect to display everything at once
 *     like RPG Maker MZ default.
 * *** If an actor has multiple weapon slots but some of them are unequipped,
 *     then the action will treat the attack as a single attack. There will be
 *     no barehanded attack to add on top of it. This is to match RPG Maker
 *     MZ's decision to omit a second animation if the same scenario is
 *     applied.
 * ** New Action Sequence Plugin Commands added by Yanfly
 * *** ANIM: Attack Animation 2+
 * **** Plays the animation associated with the user's 2nd weapon.
 *      Plays nothing if there is no 2nd weapon equipped.
 * ** New Action Sequence Plugin Commands added by Olivia
 * *** WEAPON: Clear Weapon Slot
 * *** WEAPON: Next Weapon Slot
 * *** WEAPON: Set Weapon Slot
 * **** These are Action Sequence Plugin Commands for devs who want finer
 *      control over Dual/Multi Wielding weapons.
 * 
 * Version 1.22: January 15, 2021
 * * Compatibility Update
 * ** Compatibility with "All Skills" Actor Command should now work with the
 *    Skills & States Core hide skill notetags.
 * 
 * Version 1.21: January 8, 2021
 * * Bug Fixes!
 * ** "MOVE: Home Reset" Plugin Command Action Sequence should work properly.
 *    Fix made by Yanfly.
 * * Documentation Update!
 * ** Added documentation for new feature(s)!
 * * New Features!
 * ** New Notetag snuck in by Arisu
 * *** <Auto Action Sequence>
 * **** Used for those who have the "Auto Notetag" Plugin Parameter enabled and
 *      just want to use an automatic Action Sequence instead.
 * ** New Plugin Parameter snuck in by Arisu!
 * *** Plugin Parameters > Action Sequences > Quality of Life > Auto Notetag
 * **** Automatically apply the <Custom Action Sequence> notetag effect to any
 *      item or skill that has a Common Event?
 * **** Any item or skill without a Common Event attached to it will use the
 *      Automatic Action Sequences instead.
 * **** The <Auto Action Sequence> notetag will disable this effect for that
 *      particular skill or item.
 * ** Arisu, you're going to be responsible for any bugs these may cause.
 * *** Bring it!!!!
 * **** And handling any bug report emails that are sent because this was
 *      turned on by accident.
 * ***** Please read the documentation, guys!
 * 
 * Version 1.20: January 1, 2021
 * * Bug Fixes!
 * ** For TPB Active or ATB Active, inputting actors that have received damage
 *    will return back to place after flinching. Fix made by Yanfly.
 * * Documentation Update!
 * ** Added documentation for new feature(s)!
 * * New Features!
 * ** New notetags added by Yanfly:
 * *** <Battle Portrait Offset: +x, +y>
 * *** <Battle Portrait Offset X: +x>
 * *** <Battle Portrait Offset Y: +y>
 * **** This is used with the "Portrait" and "Border" Battle Layouts.
 * **** Offsets the X and Y coordinates for the battle portrait.
 * 
 * Version 1.19: December 25, 2020
 * * Bug Fixes!
 * ** Removing a state from a Sideview Enemy during the middle of their a non-
 *    looping motion will no longer reset their motion to neutral.
 *    Fix made by Yanfly.
 * * Compatibility Update!
 * ** Plugins should be more compatible with one another.
 * * Documentation Update!
 * ** Added documentation for updated feature(s)!
 * * Feature Update!
 * ** Action Sequence "PROJECTILE: Icon" now supports code for the "Icon"
 *    parameter. Update made by Yanfly.
 * 
 * Version 1.18: December 18, 2020
 * * Bug Fixes!
 * ** For TPB Active or ATB Active, inputting actors will no longer step back
 *    after an enemy's action is finished. Fix made by Yanfly and Shiro.
 * * Documentation Update!
 * ** Added documentation for new feature(s)!
 * * New Features!
 * ** Action Sequence "BTLOG: Add Text" is updated for the convenience of a new
 *    option to quickly copy the displayed text to the VisuStella MZ Combat Log
 *    if that plugin is installed. Added by Yanfly.
 * 
 * Version 1.17: December 11, 2020
 * * Bug Fixes!
 * ** Common Events in TPB Active that cause forced actions will no longer
 *    cause currently inputting actors that match the forced action battler to
 *    crash the game. Fix made by Yanfly and Shiro.
 * * Compatibility Update!
 * ** Added compatibility functionality for future plugins.
 * ** Plugins should be more compatible with one another.
 * * Documentation Update!
 * ** Added documentation for new feature(s)!
 * * Feature Update!
 * ** Action Sequence Impact Action Sequences "Shockwave from Each Target(s)",
 *    "Shockwave from Target(s) Center", and "Zoom Blur at Target(s) Center"
 *    now have "Offset X" and "Offset Y" plugin parameters. Added by Yanfly.
 * ** Action Sequence "MOVE: Move To Target(s)" is now changed so that if the
 *    "Melee Distance" value is set to 0, battlers will no longer stand a half
 *    body distance away. Added by Yanfly.
 * 
 * Version 1.16: December 4, 2020
 * * Bug Fixes!
 * ** Bug fixes made for the RPG Maker MZ base code. If a battler has no
 *    actions, then their action speed will not be Infinity. Fix by Olivia.
 * * Compatibility Update!
 * ** Plugins should be more compatible with one another.
 * * Optimization Update!
 * ** Plugin should run more optimized.
 * 
 * Version 1.15: November 29, 2020
 * * Bug Fixes!
 * ** Completely replacing the whole party at once will no longer cause the
 *    battle system to crash. Fix made by Olivia.
 * ** Pre-Battle Common Events will no longer cancel out any win/lose branches.
 *    Fix made by Arisu.
 * * Feature Update!
 * ** Custom Action Sequences will no longer close the Actor Command Input
 *    window unless absolutely necessary (like for Show Message events) during
 *    Active TPB/ATB. Change made by Arisu.
 * 
 * Version 1.14: November 22, 2020
 * * Feature Update!
 * ** Natural Miss and Evasion motions now have flinch distance.
 *    Added by Yanfly.
 * 
 * Version 1.13: November 15, 2020
 * * Optimization Update!
 * ** Plugin should run more optimized.
 * 
 * Version 1.12: November 8, 2020
 * * Bug Fixes!
 * ** Failsafes added to prevent common events from running if they're empty.
 *    Fix made by Irina.
 * ** Skip Party Command will now work properly with TPB-based battle systems.
 *    Fix made by Yanfly.
 * * Compatibility Update!
 * ** Plugins should be more compatible with one another.
 * * Documentation Update!
 * ** In preparation for upcoming VisuStella MZ plugins.
 * 
 * Version 1.11: November 1, 2020
 * * Compatibility Update!
 * ** Plugins should be more compatible with one another.
 * * Documentation Update!
 * ** Added clarity for the Plugin Parameters for the Common Events settings
 *    found in the mechanics section. The common events are only meant to run
 *    in the map scene and not for the battle scene. Update made by Irina.
 * * Feature Update!
 * ** The Plugin Parameter for Mechanics, Common Events (on Map), Defeat Event
 *    now has updated functionality. If this has a common event attached to it,
 *    then losing to random encounters will no longer send the player to the
 *    Game Over scene, but instead, send the player back to the map scene,
 *    where the Defeat Common Event will run. Update made by Irina.
 * 
 * Version 1.10: October 25, 2020
 * * Documentation Update!
 * ** Added documentation for new feature(s)!
 * * New Features!
 * ** New Action Sequence Plugin Command added by Olivia:
 * *** MECH: Custom Damage Formula
 * **** Changes the current action's damage formula to custom.
 *      This will assume the MANUAL damage style.
 * ** New Notetag added by Irina:
 * ** New Plugin Parameters added by Irina:
 * *** Plugin Parameters > Battleback Scaling Settings
 * **** These settings allow you to adjust how battlebacks scale to the screen
 *      in the game.
 * *** <Battler Sprite Grounded>
 * **** Prevents the enemy from being able to jumping and/or floating due to
 *      Action Sequences but still able to move. Useful for rooted enemies.
 * 
 * Version 1.09: October 18, 2020
 * * Bug Fixes!
 * ** Exiting out of the Options menu scene or Party menu scene will no longer
 *    cause party members to reset their starting position. Fix made by Arisu
 * * Documentation Update!
 * ** Added documentation for new feature(s)!
 * ** There was a documentation error with <JS Pre-Regenerate> and
 *    <JS Post-Regenerate>. Fix made by Yanfly.
 * *** Before, these were written as <JS Pre-Regenerate Turn> and
 *     <JS Post-Regenerate Turn>. The "Turn" part of the notetag has been
 *     removed in the documentation.
 * * Feature Update!
 * ** Damage sprites on actors are now centered relative to the actor's anchor.
 *    Change made by Yanfly.
 * * New Features!
 * ** New Action Sequence Plugin Command added by Yanfly:
 * *** MECH: Variable Popup
 * **** Causes the unit(s) to display a popup using the data stored inside
 *      a variable.
 * 
 * Version 1.08: October 11, 2020
 * * Bug Fixes!
 * ** Dead party members at the start of battle no longer start offscreen.
 *    Fix made by Arisu.
 * ** Removed party members from battle no longer count as moving battlers.
 *    Fix made by Yanfly.
 * ** Using specific motions should now have the weapons showing and not
 *    showing properly. Fix made by Yanfly.
 * 
 * Version 1.07: October 4, 2020
 * * Bug Fixes!
 * ** Adding and removing actors will now refresh the battle status display.
 *    Fix made by Irina.
 * ** Adding new states that would change the affected battler's state motion
 *    will automatically refresh the battler's motion. Fix made by Irina.
 * ** Boss Collapse animation fixed and will sink into the ground.
 *    Fix made by Irina.
 * ** Failsafes added for certain animation types. Fix made by Yanfly.
 * ** Freeze Motion for thrust, swing, and missile animations will now show the
 *    weapons properly. Fix made by Yanfly.
 * ** The Guard command will no longer display the costs of the Attack command.
 *    Fix made by Irina.
 * * Documentation Update!
 * ** Updated help file for newly added plugin parameters.
 * * Feature Updates!
 * ** When using the Change Battleback event command in battle, the game client
 *    will wait until both battlebacks are loaded before changing the both of
 *    them so that the appearance is synched together. Change made by Yanfly.
 * * New Features!
 * ** New plugin parameters added by Irina!
 * *** Plugin Parameters > Actor Battler Settings > Chant Style
 * **** What determines the chant motion? Hit type or skill type?
 * 
 * Version 1.06: September 27, 2020
 * * Bug Fixes!
 * ** Enemy Battler Plugin Parameter "Shadow Visible" should now work again.
 *    Fix made by Irina.
 * * Compatibility Update!
 * ** Added compatibility functionality for future plugins. Added by Yanfly.
 * * Documentation Update!
 * ** Updated the help file for all the new plugin parameters.
 * * Feature Update!
 * ** Action Sequence "MECH: HP, MP, TP" will now automatically collapse an
 *    enemy if it has been killed by the effect.
 * ** All battle systems for front view will now have damage popups appear
 *    in front of the status window instead of just the Portrait battle layout.
 *    Update made by Yanfly.
 * * New Features!
 * ** New Action Sequence Plugin Commands from Irina!
 * *** MOTION: Clear Freeze Frame
 * *** MOTION: Freeze Motion Frame
 * **** You can freeze a battler's sprite's motion with a specific frame.
 * ** New notetags for Maps and name tags for Troops added by Yanfly!
 * *** <Battle Layout: type> to change the battle layout style used for
 *     specific maps and/or troops.
 * ** New plugin parameters added by Yanfly!
 * *** Plugin Parameters > Battle Layout Settings > Command Window Width
 * **** This plugin parameter lets you adjust the window width for Party and
 *      Actor Command windows in the Default and List Battle Layout styles.
 * *** Plugin Parameters > Enemy Battler Settings > Name: Offset X
 * *** Plugin Parameters > Enemy Battler Settings > Name: Offset Y
 * **** These plugin parameters allow you to offset the position of the enemy
 *      name positions on the screen by a specific amount.
 * 
 * Version 1.05: September 20, 2020
 * * Bug Fixes!
 * ** Actors now use their casting or charging animations again during TPB/ATB.
 *    Fix made by Yanfly.
 * ** Defeat requirement for enemies will no longer crash the game if turned on
 *    after creating
 * ** Escaping animation no longer has actors stay in place. Fixed by Yanfly.
 * ** Failsafes added for newly added weapon types that have not been adjusted
 *    in the Database > System 2 tab. Fixed by Irina.
 * ** Shadows now appear under the actor sprites. Fix made by Yanfly.
 * ** Victory during TPB will no longer cancel the victory animations of
 *    actors that will have their turn after. Fixed by Yanfly.
 * * Documentation Update!
 * ** All Anchor Plugin Parameter descriptions now state to use values between
 *    0 and 1 to be safe. Update made by Yanfly.
 * * Feature Update!
 * ** During Active TPB / ATB, canceling out of the actor command window will
 *    go directly into the party window without having to sort through all of
 *    the available active actors.
 * ** Going from the Party Command Window's Fight command will immediately
 *    return back to the actor command window that was canceled from.
 * * New Features!
 * ** Action Sequence Plugin Command "MOVE: Spin/Rotate" has been updated.
 * *** A new parameter has been added: "Revert Angle on Finish"
 * *** Added by Yanfly.
 * ** New plugin parameters have been added to Damage Settings.
 * *** Appear Position: Selects where you want popups to appear relative to the
 *     battler. Head, Center, Base. Added by Yanfly.
 * *** Offset X: Sets how much to offset the sprites by vertically.
 *     Added by Yanfly.
 * *** Offset Y: Sets how much to offset the sprites by horizontally.
 *     Added by Yanfly.
 * ** New plugin parameters have been added to Actor Battler Settings.
 * *** Priority: Active - Place the active actor on top of actor and
 *     enemy sprites. Added by Yanfly.
 * *** Priority: Actors - Prioritize actors over enemies when placing 
 *     sprites on top of each other. Added by Yanfly.
 * 
 * Version 1.04: September 13, 2020
 * * Bug Fixes!
 * ** Active Battler Sprites now remain on top and won't be hidden behind
 *    other sprites for better visual clarity. Fix made by Arisu.
 * ** Collapsing battlers will now show the dead motion properly. Fix made by
 *    Olivia.
 * ** Dead battlers can no longer be given immortality. Fix made by Olivia.
 * ** Going into the Options menu with no battleback set will no longer set a
 *    battle snapshot.
 * ** HP Gauges for Sideview Enemies are no longer flipped! Fix made by Yanfly.
 * ** Moving a dead battler would no longer reset their animation. Fix made by
 *    Olivia.
 * ** Pre-Battle Common Events now work with events instead of just random
 *    encounters. Fix made by Yanfly.
 * ** Sideview Enemy shadows no longer twitch. Fix made by Irina.
 * * Documentation Updates!
 * ** Added further explanations for Anchor X and Anchor Y plugin parameters.
 *    This is because there's a lot of confusion for users who aren't familiar
 *    with how sprites work. Added by Irina.
 * ** <Magic Reduction: x> notetag updated to say magical damage instead of
 *    physical damage. Fix made by Yanfly.
 * * New Features!
 * ** Additional Action Sequence Plugin Commands have been added in preparation
 *    of upcoming plugins! Additions made by Irina.
 * *** Action Sequences - Angle (for VisuMZ_3_ActSeqCamera)
 * *** Action Sequences - Camera (for VisuMZ_3_ActSeqCamera)
 * *** Action Sequences - Skew (for VisuMZ_3_ActSeqCamera)
 * *** Action Sequences - Zoom (for VisuMZ_3_ActSeqCamera)
 * ** Additional Action Sequence Plugin Commands have been made available now
 *    and added to Battle Core! Additions made by Irina.
 * *** MOVE: Scale/Grow/Shrink
 * *** MOVE: Skew/Distort
 * *** MOVE: Spin/Rotate
 * *** MOVE: Wait For Scale
 * *** MOVE: Wait For Skew
 * *** MOVE: Wait For Spin
 * ** Plugin Parameters Additions. Additions made by Irina.
 * *** Plugin Params > Actor Battler Settings > Offset X
 * *** Plugin Params > Actor Battler Settings > Offset Y
 * *** Plugin Params > Actor Battler Settings > Smooth Image
 * *** Plugin Params > Enemy Battler Settings > Offset X
 * *** Plugin Params > Enemy Battler Settings > Offset Y
 * *** Plugin Params > Enemy Battler Settings > Smooth Image
 * 
 * Version 1.03: September 6, 2020
 * * Bug Fixes!
 * ** Animated Battlers will refresh their motions from the death motion once
 *    they're revived instead of waiting for their next input phase. Fix made
 *    by Yanfly.
 * ** Battle Log speed sometimes went by too fast for certain enabled messages.
 *    Wait timers are now added to them, like state results, buff results, and
 *    debuff results. Fix made by Yanfly.
 * ** Boss Collapse animation now works properly. Fix made by Yanfly.
 * ** Freeze fix for TPB (Wait) if multiple actors get a turn at the same time.
 *    Fix made by Olivia.
 * ** Pressing cancel on a target window after selecting a single skill no
 *    longer causes the status window to twitch.
 * ** Sideview Enemies had a split frame of being visible if they were to start
 *    off hidden in battle. Fix made by Shaz.
 * * Compatibility Update:
 * ** Battle Core's Sprite_Damage.setup() function is now separated fro the
 *    default to allow for better compatibility. Made by Yanfly.
 * * Documentation Update:
 * ** Inserted more information for "Damage Popups" under "Major Changes"
 * * New Features!
 * ** <Magic Penetration: x>, <Magic Penetration: x%> notetags added.
 * ** <Magic Reduction: x>, <Magic Reduction: x%> notetags added.
 * ** <Battle UI Offset: +x, +y>, <Battle UI Offset X: +x>, and
 *    <Battle UI Offset Y: +y> notetags added for adjusting the positions of
 *    HP Gauges and State Icons.
 * *** Notetags added by Yanfly.
 * 
 * Version 1.02: August 30, 2020
 * * Bug Fixes!
 * ** Failsafes added for parsing battle targets. Fix made by Yanfly.
 * ** Immortality is no longer ignored by skills/items with the Normal Attack
 *    state effect. Fix made by Yanfly.
 * ** Miss and Evasion sound effects work again! Fix made by Yanfly.
 * ** Selecting "Escape" from the Actor Command Window will now have the
 *    Inputting Battler show its escape motion. Fix made by Yanfly.
 * ** Wait for Movement now applies to SV Enemies. Fix made by Yanfly.
 * * New Features!
 * ** Plugin Command "ACSET: Finish Action" now has an option to turn off the
 *    Immortality of targets. Feature added by Yanfly.
 * * Optimization Update
 * ** Uses less resources when making checks for Pre-Battle Battle Start events
 * 
 * Version 1.01: August 23, 2020
 * * Bug Fixes!
 * ** Plugin Parameters > Damage Settings > Damage Formats are now fixed.
 *    Fix made by Olivia.
 * ** TPB Battle System with Disable Party Command fixed. Fix made by Olivia.
 * ** States now show in list format if faces are disabled. Fix made by Yanfly.
 * ** The default damage styles were missing the 'v' variable to allow for
 *    variable data input. These are back now. Fix made by Yanfly.
 * *** Users updating from version 1.00 will need to fix this problem by either
 *     removing the plugin from the Plugin Manager list and reinstalling it, or
 *     going to Plugin Parameters > Damage Settings > Style List > the style
 *     you want, and adding "const v = $gameVariables._data;" to JS: Formula
 * * New Notetags Added:
 * ** <Command Show Switch: x> added by Olivia
 * ** <Command Show All Switches: x,x,x> added by Olivia
 * ** <Command Show Any Switches: x,x,x> added by Olivia
 * ** <Command Hide Switch: x> added by Olivia
 * ** <Command Hide All Switches: x,x,x> added by Olivia
 * ** <Command Hide Any Switches: x,x,x> added by Olivia
 * ** <JS Command Visible> added by Olivia
 *
 * Version 1.00: August 20, 2020
 * * Finished Plugin!
 *
 * ============================================================================
 * End of Helpfile
 * ============================================================================
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActionSequenceSpaceStart
 * @text -
 * @desc The following are Action Sequences commands/sets.
 * These Plugin Commands only work in battle.
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActionSequenceBreakSet
 * @text Action Sequence - Action Sets
 * @desc Action Sequence Action Sets are groups of commonly used
 * Action Sequence Commands put together for more efficient usage.
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Set_SetupAction
 * @text ACSET: Setup Action Set
 * @desc The generic start to most actions.
 * 
 * @arg DisplayAction:eval
 * @text Display Action
 * @type boolean
 * @on Use
 * @off Don't Use
 * @desc Use this part of the action sequence?
 * @default true
 * 
 * @arg ApplyImmortal:eval
 * @text Immortal: On
 * @type boolean
 * @on Use
 * @off Don't Use
 * @desc Use this part of the action sequence?
 * @default true
 * 
 * @arg ActionStart:eval
 * @text Battle Step
 * @type boolean
 * @on Use
 * @off Don't Use
 * @desc Use this part of the action sequence?
 * @default true
 * 
 * @arg WaitForMovement:eval
 * @text Wait For Movement
 * @type boolean
 * @on Use
 * @off Don't Use
 * @desc Use this part of the action sequence?
 * @default true
 * 
 * @arg CastAnimation:eval
 * @text Cast Animation
 * @type boolean
 * @on Use
 * @off Don't Use
 * @desc Use this part of the action sequence?
 * @default true
 * 
 * @arg WaitForAnimation:eval
 * @text Wait For Animation
 * @type boolean
 * @on Use
 * @off Don't Use
 * @desc Use this part of the action sequence?
 * @default true
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Set_WholeActionSet
 * @text ACSET: All Targets Action Set
 * @desc Affects all targets simultaneously performing the following.
 * 
 * @arg DualWield:eval
 * @text Dual/Multi Wield?
 * @type boolean
 * @on Apply
 * @off Don't
 * @desc Add times struck based on weapon quantity equipped?
 * @default false
 * 
 * @arg PerformAction:eval
 * @text Perform Action
 * @type boolean
 * @on Use
 * @off Don't Use
 * @desc Use this part of the action sequence?
 * @default true
 * 
 * @arg WaitCount:eval
 * @text Wait Count
 * @desc How many frames should the action sequence wait?
 * You may use JavaScript code.
 * @default Sprite_Battler._motionSpeed
 * 
 * @arg ActionAnimation:eval
 * @text Action Animation
 * @type boolean
 * @on Use
 * @off Don't Use
 * @desc Use this part of the action sequence?
 * @default true
 * 
 * @arg WaitForAnimation:eval
 * @text Wait For Animation
 * @type boolean
 * @on Use
 * @off Don't Use
 * @desc Use this part of the action sequence?
 * @default true
 * 
 * @arg ActionEffect:eval
 * @text Action Effect
 * @type boolean
 * @on Use
 * @off Don't Use
 * @desc Use this part of the action sequence?
 * @default true
 * 
 * @arg ApplyImmortal:eval
 * @text Immortal: Off
 * @type boolean
 * @on Use
 * @off Don't Use
 * @desc Use this part of the action sequence?
 * @default true
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Set_TargetActionSet
 * @text ACSET: Each Target Action Set
 * @desc Goes through each target one by one to perform the following.
 * 
 * @arg DualWield:eval
 * @text Dual/Multi Wield?
 * @type boolean
 * @on Apply
 * @off Don't
 * @desc Add times struck based on weapon quantity equipped?
 * @default false
 * 
 * @arg PerformAction:eval
 * @text Perform Action
 * @type boolean
 * @on Use
 * @off Don't Use
 * @desc Use this part of the action sequence?
 * @default true
 * 
 * @arg WaitCount1:eval
 * @text Wait Count
 * @desc How many frames should the action sequence wait?
 * You may use JavaScript code.
 * @default Sprite_Battler._motionSpeed
 * 
 * @arg ActionAnimation:eval
 * @text Action Animation
 * @type boolean
 * @on Use
 * @off Don't Use
 * @desc Use this part of the action sequence?
 * @default true
 * 
 * @arg WaitCount2:eval
 * @text Wait Count
 * @desc How many frames should the action sequence wait?
 * You may use JavaScript code.
 * @default Sprite_Battler._motionSpeed * 2
 * 
 * @arg ActionEffect:eval
 * @text Action Effect
 * @type boolean
 * @on Use
 * @off Don't Use
 * @desc Use this part of the action sequence?
 * @default true
 * 
 * @arg ApplyImmortal:eval
 * @text Immortal: Off
 * @type boolean
 * @on Use
 * @off Don't Use
 * @desc Use this part of the action sequence?
 * @default true
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Set_FinishAction
 * @text ACSET: Finish Action
 * @desc The generic ending to most actions.
 * 
 * @arg ApplyImmortal:eval
 * @text Immortal: Off
 * @type boolean
 * @on Use
 * @off Don't Use
 * @desc Use this part of the action sequence?
 * @default true
 * 
 * @arg WaitForNewLine:eval
 * @text Wait For New Line
 * @type boolean
 * @on Use
 * @off Don't Use
 * @desc Use this part of the action sequence?
 * @default true
 * 
 * @arg WaitForEffect:eval
 * @text Wait For Effects
 * @type boolean
 * @on Use
 * @off Don't Use
 * @desc Use this part of the action sequence?
 * @default true
 * 
 * @arg ClearBattleLog:eval
 * @text Clear Battle Log
 * @type boolean
 * @on Use
 * @off Don't Use
 * @desc Use this part of the action sequence?
 * @default true
 * 
 * @arg ActionEnd:eval
 * @text Home Reset
 * @type boolean
 * @on Use
 * @off Don't Use
 * @desc Use this part of the action sequence?
 * @default true
 * 
 * @arg WaitForMovement:eval
 * @text Wait For Movement
 * @type boolean
 * @on Use
 * @off Don't Use
 * @desc Use this part of the action sequence?
 * @default true
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActionSequenceSpaceAngle
 * @text -
 * @desc -
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActionSequenceBreakAngle
 * @text Action Sequences - Angle
 * @desc Allows you to have control over the camera angle.
 * Requires VisuMZ_3_ActSeqCamera!
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_ChangeAngle
 * @text ANGLE: Change Angle
 * @desc Changes the camera angle.
 * Requires VisuMZ_3_ActSeqCamera!
 * 
 * @arg Angle:eval
 * @text Angle
 * @desc Change the camera angle to this many degrees.
 * @default 0
 * 
 * @arg Duration:eval
 * @text Duration
 * @desc Duration in frames to change camera angle.
 * @default 60
 *
 * @arg EasingType:str
 * @text Angle Easing
 * @type combo
 * @option Linear
 * @option InSine
 * @option OutSine
 * @option InOutSine
 * @option InQuad
 * @option OutQuad
 * @option InOutQuad
 * @option InCubic
 * @option OutCubic
 * @option InOutCubic
 * @option InQuart
 * @option OutQuart
 * @option InOutQuart
 * @option InQuint
 * @option OutQuint
 * @option InOutQuint
 * @option InExpo
 * @option OutExpo
 * @option InOutExpo
 * @option InCirc
 * @option OutCirc
 * @option InOutCirc
 * @option InBack
 * @option OutBack
 * @option InOutBack
 * @option InElastic
 * @option OutElastic
 * @option InOutElastic
 * @option InBounce
 * @option OutBounce
 * @option InOutBounce
 * @desc Select which easing type you wish to apply.
 * Requires VisuMZ_0_CoreEngine.
 * @default InOutSine
 * 
 * @arg WaitForAngle:eval
 * @text Wait For Angle?
 * @type boolean
 * @on On
 * @off Off
 * @desc Wait for angle changes to complete before performing next command?
 * @default true
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Angle_Reset
 * @text ANGLE: Reset Angle
 * @desc Reset any angle settings.
 * Requires VisuMZ_3_ActSeqCamera!
 * 
 * @arg Duration:eval
 * @text Duration
 * @desc Duration in frames to reset camera angle.
 * @default 60
 *
 * @arg EasingType:str
 * @text Angle Easing
 * @type combo
 * @option Linear
 * @option InSine
 * @option OutSine
 * @option InOutSine
 * @option InQuad
 * @option OutQuad
 * @option InOutQuad
 * @option InCubic
 * @option OutCubic
 * @option InOutCubic
 * @option InQuart
 * @option OutQuart
 * @option InOutQuart
 * @option InQuint
 * @option OutQuint
 * @option InOutQuint
 * @option InExpo
 * @option OutExpo
 * @option InOutExpo
 * @option InCirc
 * @option OutCirc
 * @option InOutCirc
 * @option InBack
 * @option OutBack
 * @option InOutBack
 * @option InElastic
 * @option OutElastic
 * @option InOutElastic
 * @option InBounce
 * @option OutBounce
 * @option InOutBounce
 * @desc Select which easing type you wish to apply.
 * Requires VisuMZ_0_CoreEngine.
 * @default InOutSine
 * 
 * @arg WaitForAngle:eval
 * @text Wait For Angle?
 * @type boolean
 * @on On
 * @off Off
 * @desc Wait for angle changes to complete before performing next command?
 * @default true
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Angle_WaitForAngle
 * @text ANGLE: Wait For Angle
 * @desc Waits for angle changes to complete before performing next command.
 * Requires VisuMZ_3_ActSeqCamera!
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActionSequenceSpaceAnimation
 * @text -
 * @desc -
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActionSequenceBreakAnimation
 * @text Action Sequences - Animations
 * @desc These Action Sequences are related to the 'Animations' that
 * can be found in the Animations tab of the Database.
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Animation_ActionAnimation
 * @text ANIM: Action Animation
 * @desc Plays the animation associated with the action.
 * 
 * @arg Targets:arraystr
 * @text Targets
 * @type combo[]
 * @option user
 * @option current target
 * @option prev target
 * @option next target
 * @option all targets
 * @option focus
 * @option not focus
 * @option
 * @option special
 * @option special x
 * @option 
 * @option alive friends
 * @option alive friends not user
 * @option alive friends not target
 * @option dead friends
 * @option friend index x
 * @option 
 * @option alive opponents
 * @option alive opponents not target
 * @option dead opponents
 * @option opponent index x
 * @option 
 * @option alive actors
 * @option alive actors not user
 * @option alive actors not target
 * @option dead actors
 * @option actor index x
 * @option actor ID x
 * @option 
 * @option alive enemies
 * @option alive enemies not user
 * @option alive enemies not target
 * @option dead enemies
 * @option enemy index x
 * @option enemy ID x
 * @option 
 * @option alive battlers
 * @option alive battlers not user
 * @option alive battlers not target
 * @option dead battlers
 * @option 
 * @desc Select unit(s) to play the animation on.
 * @default ["all targets"]
 * 
 * @arg Mirror:eval
 * @text Mirror Animation
 * @type boolean
 * @on Mirror
 * @off Normal
 * @desc Mirror the animation?
 * @default false
 * 
 * @arg WaitForAnimation:eval
 * @text Wait For Animation?
 * @type boolean
 * @on On
 * @off Off
 * @desc Wait for animation to complete before performing next command?
 * @default true
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Animation_AttackAnimation
 * @text ANIM: Attack Animation
 * @desc Plays the animation associated with the user's 1st weapon.
 * 
 * @arg Targets:arraystr
 * @text Targets
 * @type combo[]
 * @option user
 * @option current target
 * @option prev target
 * @option next target
 * @option all targets
 * @option focus
 * @option not focus
 * @option
 * @option special
 * @option special x
 * @option 
 * @option alive friends
 * @option alive friends not user
 * @option alive friends not target
 * @option dead friends
 * @option friend index x
 * @option 
 * @option alive opponents
 * @option alive opponents not target
 * @option dead opponents
 * @option opponent index x
 * @option 
 * @option alive actors
 * @option alive actors not user
 * @option alive actors not target
 * @option dead actors
 * @option actor index x
 * @option actor ID x
 * @option 
 * @option alive enemies
 * @option alive enemies not user
 * @option alive enemies not target
 * @option dead enemies
 * @option enemy index x
 * @option enemy ID x
 * @option 
 * @option alive battlers
 * @option alive battlers not user
 * @option alive battlers not target
 * @option dead battlers
 * @option 
 * @desc Select unit(s) to play the animation on.
 * @default ["all targets"]
 * 
 * @arg Mirror:eval
 * @text Mirror Animation
 * @type boolean
 * @on Mirror
 * @off Normal
 * @desc Mirror the animation?
 * @default false
 * 
 * @arg WaitForAnimation:eval
 * @text Wait For Animation?
 * @type boolean
 * @on On
 * @off Off
 * @desc Wait for animation to complete before performing next command?
 * @default true
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Animation_AttackAnimation2
 * @text ANIM: Attack Animation 2+
 * @desc Plays the animation associated with the user's other weapons.
 * Plays nothing if there is no other weapon equipped.
 * 
 * @arg Targets:arraystr
 * @text Targets
 * @type combo[]
 * @option user
 * @option current target
 * @option prev target
 * @option next target
 * @option all targets
 * @option focus
 * @option not focus
 * @option
 * @option special
 * @option special x
 * @option 
 * @option alive friends
 * @option alive friends not user
 * @option alive friends not target
 * @option dead friends
 * @option friend index x
 * @option 
 * @option alive opponents
 * @option alive opponents not target
 * @option dead opponents
 * @option opponent index x
 * @option 
 * @option alive actors
 * @option alive actors not user
 * @option alive actors not target
 * @option dead actors
 * @option actor index x
 * @option actor ID x
 * @option 
 * @option alive enemies
 * @option alive enemies not user
 * @option alive enemies not target
 * @option dead enemies
 * @option enemy index x
 * @option enemy ID x
 * @option 
 * @option alive battlers
 * @option alive battlers not user
 * @option alive battlers not target
 * @option dead battlers
 * @option 
 * @desc Select unit(s) to play the animation on.
 * @default ["all targets"]
 * 
 * @arg Slot:eval
 * @text Slot
 * @desc Which weapon slot to get this data from?
 * Main-hand weapon is weapon slot 1.
 * @default 2
 * 
 * @arg Mirror:eval
 * @text Mirror Animation
 * @type boolean
 * @on Mirror
 * @off Normal
 * @desc Mirror the animation?
 * @default true
 * 
 * @arg WaitForAnimation:eval
 * @text Wait For Animation?
 * @type boolean
 * @on On
 * @off Off
 * @desc Wait for animation to complete before performing next command?
 * @default true
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Animation_BalloonAnimation
 * @text ANIM: Balloon Animation
 * @desc Plays a balloon animation on target(s).
 * 
 * @arg Targets:arraystr
 * @text Targets
 * @type combo[]
 * @option user
 * @option current target
 * @option prev target
 * @option next target
 * @option all targets
 * @option focus
 * @option not focus
 * @option
 * @option special
 * @option special x
 * @option 
 * @option alive friends
 * @option alive friends not user
 * @option alive friends not target
 * @option dead friends
 * @option friend index x
 * @option 
 * @option alive opponents
 * @option alive opponents not target
 * @option dead opponents
 * @option opponent index x
 * @option 
 * @option alive actors
 * @option alive actors not user
 * @option alive actors not target
 * @option dead actors
 * @option actor index x
 * @option actor ID x
 * @option 
 * @option alive enemies
 * @option alive enemies not user
 * @option alive enemies not target
 * @option dead enemies
 * @option enemy index x
 * @option enemy ID x
 * @option 
 * @option alive battlers
 * @option alive battlers not user
 * @option alive battlers not target
 * @option dead battlers
 * @option 
 * @desc Select unit(s) to play the animation on.
 * @default ["user"]
 *
 * @arg Balloon:str
 * @text Balloon Type
 * @type select
 * @option Exclamation
 * @option Question
 * @option Music Note
 * @option Heart
 * @option Anger
 * @option Sweat
 * @option Frustration
 * @option Silence
 * @option Light Bulb
 * @option Zzz
 * @option User-defined 1
 * @option User-defined 2
 * @option User-defined 3
 * @option User-defined 4
 * @option User-defined 5
 * @desc What kind of balloon should be played on target(s)?
 * @default Exclamation
 *
 * @arg WaitComplete:eval
 * @text Wait for Completion
 * @type boolean
 * @on Wait
 * @off Don't Wait
 * @desc Wait for balloon animation completion before continuing?
 * @default true
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Animation_BalloonIcon
 * @text ANIM: Balloon Icon (Single)
 * @desc Plays a balloon animation using an icon on target(s).
 * Requires VisuMZ_4_IconBalloons!
 * 
 * @arg Targets:arraystr
 * @text Targets
 * @type combo[]
 * @option user
 * @option current target
 * @option prev target
 * @option next target
 * @option all targets
 * @option focus
 * @option not focus
 * @option
 * @option special
 * @option special x
 * @option 
 * @option alive friends
 * @option alive friends not user
 * @option alive friends not target
 * @option dead friends
 * @option friend index x
 * @option 
 * @option alive opponents
 * @option alive opponents not target
 * @option dead opponents
 * @option opponent index x
 * @option 
 * @option alive actors
 * @option alive actors not user
 * @option alive actors not target
 * @option dead actors
 * @option actor index x
 * @option actor ID x
 * @option 
 * @option alive enemies
 * @option alive enemies not user
 * @option alive enemies not target
 * @option dead enemies
 * @option enemy index x
 * @option enemy ID x
 * @option 
 * @option alive battlers
 * @option alive battlers not user
 * @option alive battlers not target
 * @option dead battlers
 * @option 
 * @desc Select unit(s) to play the animation on.
 * @default ["user"]
 *
 * @arg IconIndex:num
 * @text Icon Index
 * @desc Insert the ID of the icon to show.
 * Tip: Right click > Insert Icon Index
 * @default 0
 *
 * @arg WaitComplete:eval
 * @text Wait for Completion
 * @type boolean
 * @on Wait
 * @off Don't Wait
 * @desc Wait for balloon animation completion before continuing?
 * @default true
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Animation_BalloonIconRange
 * @text ANIM: Balloon Icon (Range)
 * @desc Plays a balloon animation an icon range on target(s).
 * Requires VisuMZ_4_IconBalloons!
 * 
 * @arg Targets:arraystr
 * @text Targets
 * @type combo[]
 * @option user
 * @option current target
 * @option prev target
 * @option next target
 * @option all targets
 * @option focus
 * @option not focus
 * @option
 * @option special
 * @option special x
 * @option 
 * @option alive friends
 * @option alive friends not user
 * @option alive friends not target
 * @option dead friends
 * @option friend index x
 * @option 
 * @option alive opponents
 * @option alive opponents not target
 * @option dead opponents
 * @option opponent index x
 * @option 
 * @option alive actors
 * @option alive actors not user
 * @option alive actors not target
 * @option dead actors
 * @option actor index x
 * @option actor ID x
 * @option 
 * @option alive enemies
 * @option alive enemies not user
 * @option alive enemies not target
 * @option dead enemies
 * @option enemy index x
 * @option enemy ID x
 * @option 
 * @option alive battlers
 * @option alive battlers not user
 * @option alive battlers not target
 * @option dead battlers
 * @option 
 * @desc Select unit(s) to play the animation on.
 * @default ["user"]
 *
 * @arg startIcon:num
 * @text Starting Icon Index
 * @desc Insert the ID of the icon to show.
 * Tip: Right click > Insert Icon Index
 * @default 0
 *
 * @arg endIcon:num
 * @text Ending Icon Index
 * @desc Insert the ID of the icon to show.
 * Tip: Right click > Insert Icon Index
 * @default 0
 *
 * @arg WaitComplete:eval
 * @text Wait for Completion
 * @type boolean
 * @on Wait
 * @off Don't Wait
 * @desc Wait for balloon animation completion before continuing?
 * @default true
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Animation_BalloonIconSpecific
 * @text ANIM: Balloon Icon (Specific)
 * @desc Plays a balloon animation with specific icons on target(s).
 * Requires VisuMZ_4_IconBalloons!
 * 
 * @arg Targets:arraystr
 * @text Targets
 * @type combo[]
 * @option user
 * @option current target
 * @option prev target
 * @option next target
 * @option all targets
 * @option focus
 * @option not focus
 * @option
 * @option special
 * @option special x
 * @option 
 * @option alive friends
 * @option alive friends not user
 * @option alive friends not target
 * @option dead friends
 * @option friend index x
 * @option 
 * @option alive opponents
 * @option alive opponents not target
 * @option dead opponents
 * @option opponent index x
 * @option 
 * @option alive actors
 * @option alive actors not user
 * @option alive actors not target
 * @option dead actors
 * @option actor index x
 * @option actor ID x
 * @option 
 * @option alive enemies
 * @option alive enemies not user
 * @option alive enemies not target
 * @option dead enemies
 * @option enemy index x
 * @option enemy ID x
 * @option 
 * @option alive battlers
 * @option alive battlers not user
 * @option alive battlers not target
 * @option dead battlers
 * @option 
 * @desc Select unit(s) to play the animation on.
 * @default ["user"]
 *
 * @arg icons:arraynum
 * @text Icons
 * @type string[]
 * @desc Insert the ID(s) of the icon to show.
 * Tip: Right click > Insert Icon Index
 * @default []
 *
 * @arg WaitComplete:eval
 * @text Wait for Completion
 * @type boolean
 * @on Wait
 * @off Don't Wait
 * @desc Wait for balloon animation completion before continuing?
 * @default true
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Animation_CastAnimation
 * @text ANIM: Cast Animation
 * @desc Plays the cast animation associated with the action.
 * 
 * @arg Targets:arraystr
 * @text Targets
 * @type combo[]
 * @option user
 * @option current target
 * @option prev target
 * @option next target
 * @option all targets
 * @option focus
 * @option not focus
 * @option
 * @option special
 * @option special x
 * @option 
 * @option alive friends
 * @option alive friends not user
 * @option alive friends not target
 * @option dead friends
 * @option friend index x
 * @option 
 * @option alive opponents
 * @option alive opponents not target
 * @option dead opponents
 * @option opponent index x
 * @option 
 * @option alive actors
 * @option alive actors not user
 * @option alive actors not target
 * @option dead actors
 * @option actor index x
 * @option actor ID x
 * @option 
 * @option alive enemies
 * @option alive enemies not user
 * @option alive enemies not target
 * @option dead enemies
 * @option enemy index x
 * @option enemy ID x
 * @option 
 * @option alive battlers
 * @option alive battlers not user
 * @option alive battlers not target
 * @option dead battlers
 * @option 
 * @desc Select unit(s) to play the animation on.
 * @default ["user"]
 * 
 * @arg Mirror:eval
 * @text Mirror Animation
 * @type boolean
 * @on Mirror
 * @off Normal
 * @desc Mirror the animation?
 * @default false
 * 
 * @arg WaitForAnimation:eval
 * @text Wait For Animation?
 * @type boolean
 * @on On
 * @off Off
 * @desc Wait for animation to complete before performing next command?
 * @default true
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Animation_ChangeBattlePortrait
 * @text ANIM: Change Battle Portrait
 * @desc Changes the battle portrait of the actor (if it's an actor).
 * Can be used outside of battle/action sequences.
 * 
 * @arg Targets:arraystr
 * @text Targets
 * @type combo[]
 * @option user
 * @option current target
 * @option prev target
 * @option next target
 * @option all targets
 * @option focus
 * @option not focus
 * @option
 * @option special
 * @option special x
 * @option 
 * @option alive friends
 * @option alive friends not user
 * @option alive friends not target
 * @option dead friends
 * @option friend index x
 * @option 
 * @option alive opponents
 * @option alive opponents not target
 * @option dead opponents
 * @option opponent index x
 * @option 
 * @option alive actors
 * @option alive actors not user
 * @option alive actors not target
 * @option dead actors
 * @option actor index x
 * @option actor ID x
 * @option 
 * @option alive enemies
 * @option alive enemies not user
 * @option alive enemies not target
 * @option dead enemies
 * @option enemy index x
 * @option enemy ID x
 * @option 
 * @option alive battlers
 * @option alive battlers not user
 * @option alive battlers not target
 * @option dead battlers
 * @option 
 * @desc Select unit(s) to change the portraits for.
 * Valid units can only be actors.
 * @default ["user"]
 * 
 * @arg Filename:str
 * @text Filename
 * @type file
 * @dir img/pictures/
 * @desc Select the file to change the actor's portrait to.
 * @default Untitled
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Animation_GuardAnimation
 * @text ANIM: Guard Animation
 * @desc Plays the animation associated with the user's guard action (if any).
 * 
 * @arg Targets:arraystr
 * @text Targets
 * @type combo[]
 * @option user
 * @option current target
 * @option prev target
 * @option next target
 * @option all targets
 * @option focus
 * @option not focus
 * @option
 * @option special
 * @option special x
 * @option 
 * @option alive friends
 * @option alive friends not user
 * @option alive friends not target
 * @option dead friends
 * @option friend index x
 * @option 
 * @option alive opponents
 * @option alive opponents not target
 * @option dead opponents
 * @option opponent index x
 * @option 
 * @option alive actors
 * @option alive actors not user
 * @option alive actors not target
 * @option dead actors
 * @option actor index x
 * @option actor ID x
 * @option 
 * @option alive enemies
 * @option alive enemies not user
 * @option alive enemies not target
 * @option dead enemies
 * @option enemy index x
 * @option enemy ID x
 * @option 
 * @option alive battlers
 * @option alive battlers not user
 * @option alive battlers not target
 * @option dead battlers
 * @option 
 * @desc Select unit(s) to play the animation on.
 * @default ["all targets"]
 * 
 * @arg Mirror:eval
 * @text Mirror Animation
 * @type boolean
 * @on Mirror
 * @off Normal
 * @desc Mirror the animation?
 * @default false
 * 
 * @arg WaitForAnimation:eval
 * @text Wait For Animation?
 * @type boolean
 * @on On
 * @off Off
 * @desc Wait for animation to complete before performing next command?
 * @default true
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Animation_ItemAnimation
 * @text ANIM: Item Animation
 * @desc Plays the animation associated with a specific item.
 * 
 * @arg ItemID:eval
 * @text Item ID
 * @type item
 * @desc Which item ID will the animation come from?
 * @default 7
 * 
 * @arg Targets:arraystr
 * @text Targets
 * @type combo[]
 * @option user
 * @option current target
 * @option prev target
 * @option next target
 * @option all targets
 * @option focus
 * @option not focus
 * @option
 * @option special
 * @option special x
 * @option 
 * @option alive friends
 * @option alive friends not user
 * @option alive friends not target
 * @option dead friends
 * @option friend index x
 * @option 
 * @option alive opponents
 * @option alive opponents not target
 * @option dead opponents
 * @option opponent index x
 * @option 
 * @option alive actors
 * @option alive actors not user
 * @option alive actors not target
 * @option dead actors
 * @option actor index x
 * @option actor ID x
 * @option 
 * @option alive enemies
 * @option alive enemies not user
 * @option alive enemies not target
 * @option dead enemies
 * @option enemy index x
 * @option enemy ID x
 * @option 
 * @option alive battlers
 * @option alive battlers not user
 * @option alive battlers not target
 * @option dead battlers
 * @option 
 * @desc Select unit(s) to play the animation on.
 * @default ["all targets"]
 * 
 * @arg Mirror:eval
 * @text Mirror Animation
 * @type boolean
 * @on Mirror
 * @off Normal
 * @desc Mirror the animation?
 * @default false
 * 
 * @arg WaitForAnimation:eval
 * @text Wait For Animation?
 * @type boolean
 * @on On
 * @off Off
 * @desc Wait for animation to complete before performing next command?
 * @default true
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Animation_PlayAtCoordinate
 * @text ANIM: Play at Coordinate
 * @desc Plays an animation on the screen at a specific x, y coordinate.
 * Requires VisuMZ_0_CoreEngine!
 *
 * @arg AnimationID:num
 * @text Animation ID
 * @parent Animation
 * @type animation
 * @desc Plays this animation.
 * @default 1
 * 
 * @arg Coordinates
 *
 * @arg pointX:eval
 * @text X
 * @parent Coordinates
 * @desc X coordinate used for the animation.
 * You may use JavaScript code.
 * @default Graphics.width / 2
 *
 * @arg pointY:eval
 * @text Y
 * @parent Coordinates
 * @desc Y coordinate used for the animation.
 * You may use JavaScript code.
 * @default Graphics.height / 2
 *
 * @arg Mirror:eval
 * @text Mirror Animation?
 * @parent Animation
 * @type boolean
 * @on Mirror
 * @off Normal
 * @desc Mirror the animation?
 * @default false
 *
 * @arg Mute:eval
 * @text Mute Animation?
 * @parent Animation
 * @type boolean
 * @on Mute
 * @off Normal
 * @desc Mute the animation?
 * @default false
 *
 * @arg WaitComplete:eval
 * @text Wait for Completion?
 * @parent Animation
 * @type boolean
 * @on Wait
 * @off Normal
 * @desc Wait the animation to finish before continuing?
 * @default false
 * 
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Animation_ShowAnimation
 * @text ANIM: Show Animation
 * @desc Plays the a specific animation on unit(s).
 * 
 * @arg Targets:arraystr
 * @text Targets
 * @type combo[]
 * @option user
 * @option current target
 * @option prev target
 * @option next target
 * @option all targets
 * @option focus
 * @option not focus
 * @option
 * @option special
 * @option special x
 * @option 
 * @option alive friends
 * @option alive friends not user
 * @option alive friends not target
 * @option dead friends
 * @option friend index x
 * @option 
 * @option alive opponents
 * @option alive opponents not target
 * @option dead opponents
 * @option opponent index x
 * @option 
 * @option alive actors
 * @option alive actors not user
 * @option alive actors not target
 * @option dead actors
 * @option actor index x
 * @option actor ID x
 * @option 
 * @option alive enemies
 * @option alive enemies not user
 * @option alive enemies not target
 * @option dead enemies
 * @option enemy index x
 * @option enemy ID x
 * @option 
 * @option alive battlers
 * @option alive battlers not user
 * @option alive battlers not target
 * @option dead battlers
 * @option 
 * @desc Select unit(s) to play the animation on.
 * @default ["all targets"]
 * 
 * @arg AnimationID:num
 * @text Animation ID
 * @type animation
 * @desc Select which animation to play on unit(s).
 * @default 1
 * 
 * @arg Mirror:eval
 * @text Mirror Animation
 * @type boolean
 * @on Mirror
 * @off Normal
 * @desc Mirror the animation?
 * @default false
 * 
 * @arg WaitForAnimation:eval
 * @text Wait For Animation?
 * @type boolean
 * @on On
 * @off Off
 * @desc Wait for animation to complete before performing next command?
 * @default true
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Animation_ShowAnimationJS
 * @text ANIM: Show Animation JS
 * @desc Plays the a specific animation on unit(s).
 * Uses JavaScript to determine animation ID.
 * 
 * @arg Targets:arraystr
 * @text Targets
 * @type combo[]
 * @option user
 * @option current target
 * @option prev target
 * @option next target
 * @option all targets
 * @option focus
 * @option not focus
 * @option
 * @option special
 * @option special x
 * @option 
 * @option alive friends
 * @option alive friends not user
 * @option alive friends not target
 * @option dead friends
 * @option friend index x
 * @option 
 * @option alive opponents
 * @option alive opponents not target
 * @option dead opponents
 * @option opponent index x
 * @option 
 * @option alive actors
 * @option alive actors not user
 * @option alive actors not target
 * @option dead actors
 * @option actor index x
 * @option actor ID x
 * @option 
 * @option alive enemies
 * @option alive enemies not user
 * @option alive enemies not target
 * @option dead enemies
 * @option enemy index x
 * @option enemy ID x
 * @option 
 * @option alive battlers
 * @option alive battlers not user
 * @option alive battlers not target
 * @option dead battlers
 * @option 
 * @desc Select unit(s) to play the animation on.
 * @default ["all targets"]
 * 
 * @arg AnimationID:eval
 * @text JS: Animation ID
 * @desc Select which animation to play on unit(s).
 * Uses JavaScript to determine animation ID.
 * @default 1
 * 
 * @arg Mirror:eval
 * @text Mirror Animation
 * @type boolean
 * @on Mirror
 * @off Normal
 * @desc Mirror the animation?
 * @default false
 * 
 * @arg WaitForAnimation:eval
 * @text Wait For Animation?
 * @type boolean
 * @on On
 * @off Off
 * @desc Wait for animation to complete before performing next command?
 * @default true
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Animation_SkillAnimation
 * @text ANIM: Skill Animation
 * @desc Plays the animation associated with a specific skill.
 * 
 * @arg SkillID:eval
 * @text Skill ID
 * @type skill
 * @desc Which skill ID will the animation come from?
 * @default 99
 * 
 * @arg Targets:arraystr
 * @text Targets
 * @type combo[]
 * @option user
 * @option current target
 * @option prev target
 * @option next target
 * @option all targets
 * @option focus
 * @option not focus
 * @option
 * @option special
 * @option special x
 * @option 
 * @option alive friends
 * @option alive friends not user
 * @option alive friends not target
 * @option dead friends
 * @option friend index x
 * @option 
 * @option alive opponents
 * @option alive opponents not target
 * @option dead opponents
 * @option opponent index x
 * @option 
 * @option alive actors
 * @option alive actors not user
 * @option alive actors not target
 * @option dead actors
 * @option actor index x
 * @option actor ID x
 * @option 
 * @option alive enemies
 * @option alive enemies not user
 * @option alive enemies not target
 * @option dead enemies
 * @option enemy index x
 * @option enemy ID x
 * @option 
 * @option alive battlers
 * @option alive battlers not user
 * @option alive battlers not target
 * @option dead battlers
 * @option 
 * @desc Select unit(s) to play the animation on.
 * @default ["all targets"]
 * 
 * @arg Mirror:eval
 * @text Mirror Animation
 * @type boolean
 * @on Mirror
 * @off Normal
 * @desc Mirror the animation?
 * @default false
 * 
 * @arg WaitForAnimation:eval
 * @text Wait For Animation?
 * @type boolean
 * @on On
 * @off Off
 * @desc Wait for animation to complete before performing next command?
 * @default true
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Animation_WaitForAnimation
 * @text ANIM: Wait For Animation
 * @desc Causes the interpreter to wait for any animation(s) to finish.
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActionSequenceSpaceBattleLog
 * @text -
 * @desc -
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActionSequenceBreakBattleLog
 * @text Action Sequences - Battle Log
 * @desc These Action Sequences are related to the Battle Log Window,
 * the window found at the top of the battle screen.
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_BattleLog_AddText
 * @text BTLOG: Add Text
 * @desc Adds a new line of text into the Battle Log.
 * 
 * @arg Text:str
 * @text Text
 * @desc Add this text into the Battle Log.
 * Text codes allowed.
 * @default Insert text here.
 * 
 * @arg CopyCombatLog:eval
 * @text Copy to Combat Log?
 * @type boolean
 * @on Copy Text
 * @off Don't Copy
 * @desc Copies text to the Combat Log.
 * Requires VisuMZ_4_CombatLog
 * @default true
 *
 * @arg CombatLogIcon:num
 * @text Combat Log Icon
 * @parent CopyCombatLog:eval
 * @desc What icon would you like to bind to this entry?
 * Requires VisuMZ_4_CombatLog
 * @default 87
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_BattleLog_Clear
 * @text BTLOG: Clear Battle Log
 * @desc Clears all the text in the Battle Log.
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_BattleLog_DisplayAction
 * @text BTLOG: Display Action
 * @desc Displays the current action in the Battle Log.
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_BattleLog_PopBaseLine
 * @text BTLOG: Pop Base Line
 * @desc Removes the Battle Log's last added base line and 
 * all text up to its former location.
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_BattleLog_PushBaseLine
 * @text BTLOG: Push Base Line
 * @desc Adds a new base line to where the Battle Log currently is at.
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_BattleLog_Refresh
 * @text BTLOG: Refresh Battle Log
 * @desc Refreshes the Battle Log.
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_BattleLog_UI
 * @text BTLOG: UI Show/Hide
 * @desc Shows or hides the Battle UI (including the Battle Log).
 * 
 * @arg ShowHide:eval
 * @text Show/Hide?
 * @type boolean
 * @on Show
 * @off Hide
 * @desc Shows/hides the Battle UI.
 * @default true
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_BattleLog_WaitForBattleLog
 * @text BTLOG: Wait For Battle Log
 * @desc Causes the interpreter to wait for the Battle Log to finish.
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_BattleLog_WaitForNewLine
 * @text BTLOG: Wait For New Line
 * @desc Causes the interpreter to wait for a new line in the Battle Log.
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActionSequenceSpaceCamera
 * @text -
 * @desc -
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActionSequenceBreakCamera
 * @text Action Sequences - Camera
 * @desc Allows you to have control over the camera.
 * Requires VisuMZ_3_ActSeqCamera!
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Camera_Clamp
 * @text CAMERA: Clamp ON/OFF
 * @desc Turns battle camera clamping on/off.
 * Requires VisuMZ_3_ActSeqCamera!
 * 
 * @arg Setting:eval
 * @text ON/OFF
 * @type boolean
 * @on ON
 * @off OFF
 * @desc Turns camera clamping on/off.
 * @default true
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Camera_FocusPoint
 * @text CAMERA: Focus Point
 * @desc Focus the battle camera on a certain point in the screen.
 * Requires VisuMZ_3_ActSeqCamera!
 * 
 * @arg FocusX:eval
 * @text X Coordinate
 * @desc Insert the point to focus the camera on.
 * You may use JavaScript code.
 * @default Graphics.width / 2
 * 
 * @arg FocusY:eval
 * @text Y Coordinate
 * @desc Insert the point to focus the camera on.
 * You may use JavaScript code.
 * @default Graphics.height / 2
 * 
 * @arg Duration:eval
 * @text Duration
 * @desc Duration in frames for camera focus change.
 * @default 60
 *
 * @arg EasingType:str
 * @text Camera Easing
 * @type combo
 * @option Linear
 * @option InSine
 * @option OutSine
 * @option InOutSine
 * @option InQuad
 * @option OutQuad
 * @option InOutQuad
 * @option InCubic
 * @option OutCubic
 * @option InOutCubic
 * @option InQuart
 * @option OutQuart
 * @option InOutQuart
 * @option InQuint
 * @option OutQuint
 * @option InOutQuint
 * @option InExpo
 * @option OutExpo
 * @option InOutExpo
 * @option InCirc
 * @option OutCirc
 * @option InOutCirc
 * @option InBack
 * @option OutBack
 * @option InOutBack
 * @option InElastic
 * @option OutElastic
 * @option InOutElastic
 * @option InBounce
 * @option OutBounce
 * @option InOutBounce
 * @desc Select which easing type you wish to apply.
 * Requires VisuMZ_0_CoreEngine.
 * @default InOutSine
 * 
 * @arg WaitForCamera:eval
 * @text Wait For Camera?
 * @type boolean
 * @on On
 * @off Off
 * @desc Wait for camera changes to complete before performing next command?
 * @default true
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Camera_FocusTarget
 * @text CAMERA: Focus Target(s)
 * @desc Focus the battle camera on certain battler target(s).
 * Requires VisuMZ_3_ActSeqCamera!
 * 
 * @arg Targets:arraystr
 * @text Targets
 * @type combo[]
 * @option user
 * @option current target
 * @option prev target
 * @option next target
 * @option all targets
 * @option focus
 * @option not focus
 * @option
 * @option special
 * @option special x
 * @option 
 * @option alive friends
 * @option alive friends not user
 * @option alive friends not target
 * @option dead friends
 * @option friend index x
 * @option 
 * @option alive opponents
 * @option alive opponents not target
 * @option dead opponents
 * @option opponent index x
 * @option 
 * @option alive actors
 * @option alive actors not user
 * @option alive actors not target
 * @option dead actors
 * @option actor index x
 * @option actor ID x
 * @option 
 * @option alive enemies
 * @option alive enemies not user
 * @option alive enemies not target
 * @option dead enemies
 * @option enemy index x
 * @option enemy ID x
 * @option 
 * @option alive battlers
 * @option alive battlers not user
 * @option alive battlers not target
 * @option dead battlers
 * @option 
 * @desc Select unit(s) to focus the battle camera on.
 * @default ["user"]
 * 
 * @arg Duration:eval
 * @text Duration
 * @desc Duration in frames for camera focus change.
 * @default 60
 *
 * @arg EasingType:str
 * @text Camera Easing
 * @type combo
 * @option Linear
 * @option InSine
 * @option OutSine
 * @option InOutSine
 * @option InQuad
 * @option OutQuad
 * @option InOutQuad
 * @option InCubic
 * @option OutCubic
 * @option InOutCubic
 * @option InQuart
 * @option OutQuart
 * @option InOutQuart
 * @option InQuint
 * @option OutQuint
 * @option InOutQuint
 * @option InExpo
 * @option OutExpo
 * @option InOutExpo
 * @option InCirc
 * @option OutCirc
 * @option InOutCirc
 * @option InBack
 * @option OutBack
 * @option InOutBack
 * @option InElastic
 * @option OutElastic
 * @option InOutElastic
 * @option InBounce
 * @option OutBounce
 * @option InOutBounce
 * @desc Select which easing type you wish to apply.
 * Requires VisuMZ_0_CoreEngine.
 * @default InOutSine
 * 
 * @arg WaitForCamera:eval
 * @text Wait For Camera?
 * @type boolean
 * @on On
 * @off Off
 * @desc Wait for camera changes to complete before performing next command?
 * @default true
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Camera_Offset
 * @text CAMERA: Offset
 * @desc Offset the battle camera from the focus target.
 * Requires VisuMZ_3_ActSeqCamera!
 * 
 * @arg OffsetX:eval
 * @text Offset X
 * @desc How much to offset the camera X by.
 * Negative: left. Positive: right.
 * @default +0
 * 
 * @arg OffsetY:eval
 * @text Offset Y
 * @desc How much to offset the camera Y by.
 * Negative: up. Positive: down.
 * @default +0
 * 
 * @arg Duration:eval
 * @text Duration
 * @desc Duration in frames for offset change.
 * @default 60
 *
 * @arg EasingType:str
 * @text Camera Easing
 * @type combo
 * @option Linear
 * @option InSine
 * @option OutSine
 * @option InOutSine
 * @option InQuad
 * @option OutQuad
 * @option InOutQuad
 * @option InCubic
 * @option OutCubic
 * @option InOutCubic
 * @option InQuart
 * @option OutQuart
 * @option InOutQuart
 * @option InQuint
 * @option OutQuint
 * @option InOutQuint
 * @option InExpo
 * @option OutExpo
 * @option InOutExpo
 * @option InCirc
 * @option OutCirc
 * @option InOutCirc
 * @option InBack
 * @option OutBack
 * @option InOutBack
 * @option InElastic
 * @option OutElastic
 * @option InOutElastic
 * @option InBounce
 * @option OutBounce
 * @option InOutBounce
 * @desc Select which easing type you wish to apply.
 * Requires VisuMZ_0_CoreEngine.
 * @default InOutSine
 * 
 * @arg WaitForCamera:eval
 * @text Wait For Camera?
 * @type boolean
 * @on On
 * @off Off
 * @desc Wait for camera changes to complete before performing next command?
 * @default true
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Camera_Reset
 * @text CAMERA: Reset
 * @desc Reset the battle camera settings.
 * Requires VisuMZ_3_ActSeqCamera!
 * 
 * @arg ResetFocus:eval
 * @text Reset Focus?
 * @type boolean
 * @on On
 * @off Off
 * @desc Reset the focus point?
 * @default true
 * 
 * @arg ResetOffset:eval
 * @text Reset Offset?
 * @type boolean
 * @on On
 * @off Off
 * @desc Reset the camera offset?
 * @default true
 * 
 * @arg Duration:eval
 * @text Duration
 * @desc Duration in frames for reset change.
 * @default 60
 *
 * @arg EasingType:str
 * @text Camera Easing
 * @type combo
 * @option Linear
 * @option InSine
 * @option OutSine
 * @option InOutSine
 * @option InQuad
 * @option OutQuad
 * @option InOutQuad
 * @option InCubic
 * @option OutCubic
 * @option InOutCubic
 * @option InQuart
 * @option OutQuart
 * @option InOutQuart
 * @option InQuint
 * @option OutQuint
 * @option InOutQuint
 * @option InExpo
 * @option OutExpo
 * @option InOutExpo
 * @option InCirc
 * @option OutCirc
 * @option InOutCirc
 * @option InBack
 * @option OutBack
 * @option InOutBack
 * @option InElastic
 * @option OutElastic
 * @option InOutElastic
 * @option InBounce
 * @option OutBounce
 * @option InOutBounce
 * @desc Select which easing type you wish to apply.
 * Requires VisuMZ_0_CoreEngine.
 * @default InOutSine
 * 
 * @arg WaitForCamera:eval
 * @text Wait For Camera?
 * @type boolean
 * @on On
 * @off Off
 * @desc Wait for camera changes to complete before performing next command?
 * @default true
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Camera_WaitForCamera
 * @text CAMERA: Wait For Camera
 * @desc Waits for camera to complete before performing next command.
 * Requires VisuMZ_3_ActSeqCamera!
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActionSequenceSpaceCutin
 * @text -
 * @desc -
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActionSequenceBreakCutin
 * @text Action Sequences - Cutins
 * @desc Allows you to have control over Visual Cutin Effects.
 * Requires VisuMZ_3_VisualCutinEffect!
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Cutin_AddVisualCutinEffect
 * @text CUTIN: Add Visual Cutin Effect
 * @desc Adds the Visual Cutin Effect using these desired settings.
 * Requires VisuMZ_3_VisualCutinEffect!
 * 
 * @arg Basic
 * @text Basic Settings
 * 
 * @arg type:str
 * @text Cutin Style Type
 * @parent Basic
 * @type select
 * @option -
 * @option Whole
 * @option -
 * @option Showcase
 * @option -
 * @option LeftHorzSpan
 * @option CenterHorzSpan
 * @option RightHorzSpan
 * @option -
 * @option LeftHorzSlash
 * @option RightHorzSlash
 * @option -
 * @option LeftVertSlash
 * @option RightVertSlash
 * @option -
 * @option LeftMajor
 * @option RightMajor
 * @option -
 * @option LeftMinor
 * @option CenterMinor
 * @option RightMinor
 * @option -
 * @option LeftDiamond
 * @option CenterDiamond
 * @option RightDiamond
 * @option -
 * @option LeftGemstone
 * @option CenterGemstone
 * @option RightGemstone
 * @option -
 * @option TopLeftQuad
 * @option TopRightQuad
 * @option BottomLeftQuad
 * @option BottomRightQuad
 * @option -
 * @option TopLeftCorner
 * @option TopRightCorner
 * @option BottomLeftCorner
 * @option BottomRightCorner
 * @option -
 * @option Row1stThird
 * @option Row2ndThird
 * @option Row3rdThird
 * @option -
 * @option Row1stFourth
 * @option Row2ndFourth
 * @option Row3rdFourth
 * @option Row4thFourth
 * @option -
 * @option Row1stFifth
 * @option Row2ndFifth
 * @option Row3rdFifth
 * @option Row4thFifth
 * @option Row5thFifth
 * @option -
 * @option Col1stThird
 * @option Col2ndThird
 * @option Col3rdThird
 * @option -
 * @option Col1stFourth
 * @option Col2ndFourth
 * @option Col3rdFourth
 * @option Col4thFourth
 * @option -
 * @option Col1stFifth
 * @option Col2ndFifth
 * @option Col3rdFifth
 * @option Col4thFifth
 * @option Col5thFifth
 * @option -
 * @option SixPack1
 * @option SixPack2
 * @option SixPack3
 * @option SixPack4
 * @option SixPack5
 * @option SixPack6
 * @option -
 * @option EightPack1
 * @option EightPack2
 * @option EightPack3
 * @option EightPack4
 * @option EightPack5
 * @option EightPack6
 * @option EightPack7
 * @option EightPack8
 * @option -
 * @option TwelvePack1
 * @option TwelvePack2
 * @option TwelvePack3
 * @option TwelvePack4
 * @option TwelvePack5
 * @option TwelvePack6
 * @option TwelvePack7
 * @option TwelvePack8
 * @option TwelvePack9
 * @option TwelvePack10
 * @option TwelvePack11
 * @option TwelvePack12
 * @option -
 * @desc What Visual Cutin Effect style type do you wish to use?
 * Only one of each cutin-style type can be present.
 * @default CenterHorzSpan
 * 
 * @arg Targets:arraystr
 * @text Portrait Target
 * @parent Basic
 * @type combo[]
 * @option user
 * @option current target
 * @option prev target
 * @option next target
 * @option all targets
 * @option focus
 * @option not focus
 * @option
 * @option special
 * @option special x
 * @option 
 * @option alive friends
 * @option alive friends not user
 * @option alive friends not target
 * @option dead friends
 * @option friend index x
 * @option 
 * @option alive opponents
 * @option alive opponents not target
 * @option dead opponents
 * @option opponent index x
 * @option 
 * @option alive actors
 * @option alive actors not user
 * @option alive actors not target
 * @option dead actors
 * @option actor index x
 * @option actor ID x
 * @option 
 * @option alive enemies
 * @option alive enemies not user
 * @option alive enemies not target
 * @option dead enemies
 * @option enemy index x
 * @option enemy ID x
 * @option 
 * @option alive battlers
 * @option alive battlers not user
 * @option alive battlers not target
 * @option dead battlers
 * @option 
 * @desc Select unit(s) to grab the Visual Cutin Effect portrait
 * data from. First unit will be used to make portrait.
 * @default ["user"]
 *
 * @arg parallaxFilename:str
 * @text Parallax Filename
 * @parent Basic
 * @type file
 * @dir img/parallaxes/
 * @require 1
 * @desc Pick a parallax to use for the Visual Cutin Effect.
 * Pick (None) to not use a parallax.
 * @default >>>ATTENTION<<<
 *
 * @arg bgColor:str
 * @text Background Color
 * @parent Basic
 * @desc Use #rrggbb for custom colors or regular numbers
 * for text colors from the Window Skin.
 * @default #888888
 *
 * @arg ExtraSettings:struct
 * @text Extra Settings
 * @type struct<VisualCutinEffect>
 * @desc Extra Plugin Command settings pertaining to this Visual Cutin Effect.
 * @default {}
 * 
 * @arg WaitForEntrance:eval
 * @text Wait For Entrance
 * @type boolean
 * @on Wait
 * @off Don't Wait
 * @desc Wait until cutin entrance is finished before performing
 * the next event command?
 * @default true
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Cutin_EndVisualCutinEffectAll
 * @text CUTIN: End Visual Cutin Effect (All)
 * @desc Ends all Visual Cutin Effects currently present.
 * Requires VisuMZ_3_VisualCutinEffect!
 * 
 * @arg WaitForExit:eval
 * @text Wait For Exit
 * @type boolean
 * @on Wait
 * @off Don't Wait
 * @desc Wait until cutin exit is finished before performing
 * the next event command?
 * @default true
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Cutin_EndVisualCutinEffectType
 * @text CUTIN: End Visual Cutin Effect (Type)
 * @desc Ends the Visual Cutin Effect with the matching type.
 * Requires VisuMZ_3_VisualCutinEffect!
 * 
 * @arg type:str
 * @text Cutin Style Type
 * @type select
 * @option -
 * @option Whole
 * @option -
 * @option Showcase
 * @option -
 * @option LeftHorzSpan
 * @option CenterHorzSpan
 * @option RightHorzSpan
 * @option -
 * @option LeftHorzSlash
 * @option RightHorzSlash
 * @option -
 * @option LeftVertSlash
 * @option RightVertSlash
 * @option -
 * @option LeftMajor
 * @option RightMajor
 * @option -
 * @option LeftMinor
 * @option CenterMinor
 * @option RightMinor
 * @option -
 * @option LeftDiamond
 * @option CenterDiamond
 * @option RightDiamond
 * @option -
 * @option LeftGemstone
 * @option CenterGemstone
 * @option RightGemstone
 * @option -
 * @option TopLeftQuad
 * @option TopRightQuad
 * @option BottomLeftQuad
 * @option BottomRightQuad
 * @option -
 * @option TopLeftCorner
 * @option TopRightCorner
 * @option BottomLeftCorner
 * @option BottomRightCorner
 * @option -
 * @option Row1stThird
 * @option Row2ndThird
 * @option Row3rdThird
 * @option -
 * @option Row1stFourth
 * @option Row2ndFourth
 * @option Row3rdFourth
 * @option Row4thFourth
 * @option -
 * @option Row1stFifth
 * @option Row2ndFifth
 * @option Row3rdFifth
 * @option Row4thFifth
 * @option Row5thFifth
 * @option -
 * @option Col1stThird
 * @option Col2ndThird
 * @option Col3rdThird
 * @option -
 * @option Col1stFourth
 * @option Col2ndFourth
 * @option Col3rdFourth
 * @option Col4thFourth
 * @option -
 * @option Col1stFifth
 * @option Col2ndFifth
 * @option Col3rdFifth
 * @option Col4thFifth
 * @option Col5thFifth
 * @option -
 * @option SixPack1
 * @option SixPack2
 * @option SixPack3
 * @option SixPack4
 * @option SixPack5
 * @option SixPack6
 * @option -
 * @option EightPack1
 * @option EightPack2
 * @option EightPack3
 * @option EightPack4
 * @option EightPack5
 * @option EightPack6
 * @option EightPack7
 * @option EightPack8
 * @option -
 * @option TwelvePack1
 * @option TwelvePack2
 * @option TwelvePack3
 * @option TwelvePack4
 * @option TwelvePack5
 * @option TwelvePack6
 * @option TwelvePack7
 * @option TwelvePack8
 * @option TwelvePack9
 * @option TwelvePack10
 * @option TwelvePack11
 * @option TwelvePack12
 * @option -
 * @desc What Visual Cutin Effect style type do you wish to end?
 * @default CenterHorzSpan
 * 
 * @arg WaitForExit:eval
 * @text Wait For Exit
 * @type boolean
 * @on Wait
 * @off Don't Wait
 * @desc Wait until cutin exit is finished before performing
 * the next event command?
 * @default true
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Cutin_WaitForEntrance
 * @text CUTIN: Wait for Cutin Entrance
 * @desc Wait until all cutin entrances are finished before performing the next event command. Requires VisuMZ_3_VisualCutinEffect!
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Cutin_WaitForExit
 * @text CUTIN: Wait for Cutin Exit
 * @desc Wait until all cutin exits are finished before performing the next event command. Requires VisuMZ_3_VisualCutinEffect!
 *
 * @ --------------------------------------------------------------------------
 *
 *
 * @command ActionSequenceSpaceDragonbones
 * @text -
 * @desc -
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActionSequenceBreaDragonbones
 * @text Action Sequences - Dragonbones
 * @desc These Action Sequences are Dragonbones-related.
 * Requires VisuMZ_2_DragonbonesUnion!
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_DB_DragonbonesMotionAni
 * @text DB: Dragonbones Animation
 * @desc Causes the unit(s) to play a Dragonbones motion animation.
 * Requires VisuMZ_2_DragonbonesUnion!
 * 
 * @arg Targets:arraystr
 * @text Targets
 * @type combo[]
 * @option user
 * @option current target
 * @option prev target
 * @option next target
 * @option all targets
 * @option focus
 * @option not focus
 * @option
 * @option special
 * @option special x
 * @option 
 * @option alive friends
 * @option alive friends not user
 * @option alive friends not target
 * @option dead friends
 * @option friend index x
 * @option 
 * @option alive opponents
 * @option alive opponents not target
 * @option dead opponents
 * @option opponent index x
 * @option 
 * @option alive actors
 * @option alive actors not user
 * @option alive actors not target
 * @option dead actors
 * @option actor index x
 * @option actor ID x
 * @option 
 * @option alive enemies
 * @option alive enemies not user
 * @option alive enemies not target
 * @option dead enemies
 * @option enemy index x
 * @option enemy ID x
 * @option 
 * @option alive battlers
 * @option alive battlers not user
 * @option alive battlers not target
 * @option dead battlers
 * @option 
 * @desc Select which unit(s) to perform a motion animation.
 * @default ["user"]
 *
 * @arg MotionAni:str
 * @text Motion Animation
 * @desc What is the name of the Dragonbones motion animation you wish to play?
 * @default attack
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_DB_DragonbonesTimeScale
 * @text DB: Dragonbones Time Scale
 * @desc Causes the unit(s) to change their Dragonbones time scale.
 * Requires VisuMZ_2_DragonbonesUnion!
 * 
 * @arg Targets:arraystr
 * @text Targets
 * @type combo[]
 * @option user
 * @option current target
 * @option prev target
 * @option next target
 * @option all targets
 * @option focus
 * @option not focus
 * @option
 * @option special
 * @option special x
 * @option 
 * @option alive friends
 * @option alive friends not user
 * @option alive friends not target
 * @option dead friends
 * @option friend index x
 * @option 
 * @option alive opponents
 * @option alive opponents not target
 * @option dead opponents
 * @option opponent index x
 * @option 
 * @option alive actors
 * @option alive actors not user
 * @option alive actors not target
 * @option dead actors
 * @option actor index x
 * @option actor ID x
 * @option 
 * @option alive enemies
 * @option alive enemies not user
 * @option alive enemies not target
 * @option dead enemies
 * @option enemy index x
 * @option enemy ID x
 * @option 
 * @option alive battlers
 * @option alive battlers not user
 * @option alive battlers not target
 * @option dead battlers
 * @option 
 * @desc Select which unit(s) to perform a motion animation.
 * @default ["user"]
 *
 * @arg TimeScale:num
 * @text Time Scale
 * @desc Change the value of the Dragonbones time scale to this.
 * @default 1.0
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActionSequenceSpaceElements
 * @text -
 * @desc -
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActionSequenceBreakElements
 * @text Action Sequences - Elements
 * @desc These Action Sequences are related to elements.
 * Requires VisuMZ_1_ElementStatusCore!
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Element_AddElements
 * @text ELE: Add Elements
 * @desc Adds element(s) to be used when calculating damage.
 * Requires VisuMZ_1_ElementStatusCore!
 *
 * @arg Elements:arraynum
 * @text Elements
 * @type number[]
 * @min 1
 * @max 99
 * @desc Select which element ID to add onto the action.
 * Insert multiple element ID's to add multiple at once.
 * @default ["1"]
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Element_Clear
 * @text ELE: Clear Element Changes
 * @desc Clears all element changes made through Action Sequences.
 * Requires VisuMZ_1_ElementStatusCore!
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Element_ForceElements
 * @text ELE: Force Elements
 * @desc Forces only specific element(s) when calculating damage.
 * Requires VisuMZ_1_ElementStatusCore!
 *
 * @arg Elements:arraynum
 * @text Elements
 * @type number[]
 * @min 1
 * @max 99
 * @desc Select which element ID to force in the action.
 * Insert multiple element ID's to force multiple at once.
 * @default ["1"]
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Element_NullElements
 * @text ELE: Null Element
 * @desc Forces no element to be used when calculating damage.
 * Requires VisuMZ_1_ElementStatusCore!
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActionSequenceSpaceGrid
 * @text -
 * @desc -
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActionSequenceBreakGrid
 * @text Action Sequences - Grid
 * @desc These Action Sequences are Battle Grid System-related.
 * Requires VisuMZ_2_BattleGridSystem!
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Grid_ActionAnimationAtNode
 * @text GRID: Action Animation at Node
 * @desc Plays action animation at target node.
 * Requires VisuMZ_2_BattleGridSystem!
 *
 * @arg UseActionSelectNode:eval
 * @text Action-Selected Node?
 * @type boolean
 * @on Action-Selected
 * @off Prioritize Custom
 * @desc Use Action-Selected Node Coordinates if possible?
 * Requires "Empty" or "Any" for <Target: x Grid Node>
 * @default true
 *
 * @arg Unit:str
 * @text Unit
 * @parent UseActionSelectNode:eval
 * @type select
 * @option Actor
 * @option Enemy
 * @option Friend
 * @option Opponent
 * @desc Which unit's Node do you want to play an animation on?
 * @default Enemy
 *
 * @arg Rank:num
 * @text Rank
 * @parent UseActionSelectNode:eval
 * @type number
 * @min 1
 * @max 10
 * @desc Input the number representing the Rank of the Node
 * you want to play an animation on.
 * @default 1
 *
 * @arg Flank:num
 * @text Flank
 * @parent UseActionSelectNode:eval
 * @type number
 * @min 1
 * @max 10
 * @desc Input the number representing the Flank of the Node
 * you want to play an animation on.
 * @default 1
 *
 * @arg OffsetX:num
 * @text Offset X
 * @desc Offsets the animation x position.
 * Negative: left. Positive: right.
 * @default +0
 *
 * @arg OffsetY:num
 * @text Offset Y
 * @desc Offsets the animation y position.
 * Negative: up. Positive: down.
 * @default +0
 * 
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Grid_AddPassiveStatesToNode
 * @text GRID: Add Passive State(s) to Node
 * @desc Adds Passive State(s) at target node.
 * Requires VisuMZ_2_BattleGridSystem!
 *
 * @arg StateIDs:arraynum
 * @text State ID(s)
 * @type state[]
 * @desc Select which State ID(s) to add as a Passive State.
 * @default []
 *
 * @arg UseActionSelectNode:eval
 * @text Action-Selected Node?
 * @type boolean
 * @on Action-Selected
 * @off Prioritize Custom
 * @desc Use Action-Selected Node Coordinates if possible?
 * Requires "Empty" or "Any" for <Target: x Grid Node>
 * @default true
 *
 * @arg Unit:str
 * @text Unit
 * @parent UseActionSelectNode:eval
 * @type select
 * @option Actor
 * @option Enemy
 * @option Friend
 * @option Opponent
 * @desc Which unit do you want to add the Passive State Node
 * effect for?
 * @default Actor
 *
 * @arg Rank:eval
 * @text Rank
 * @parent UseActionSelectNode:eval
 * @desc Input the number representing the Rank of the Node
 * you want to add a Passive State(s) to.
 * @default 1
 *
 * @arg Flank:eval
 * @text Flank
 * @parent UseActionSelectNode:eval
 * @desc Input the number representing the Flank of the Node
 * you want to add a Passive State(s) to.
 * @default 1
 * 
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Grid_AddTriggerToNode
 * @text GRID: Add Trigger to Node
 * @desc Adds Trigger to target node. Target node cannot have battler.
 * Requires VisuMZ_2_BattleGridSystem!
 *
 * @arg SkillID:num
 * @text Skill ID
 * @type skill
 * @desc Select which Skill ID(s) to add as the trigger.
 * @default 1
 *
 * @arg UseActionSelectNode:eval
 * @text Action-Selected Node?
 * @type boolean
 * @on Action-Selected
 * @off Prioritize Custom
 * @desc Use Action-Selected Node Coordinates if possible?
 * Requires "Empty" or "Any" for <Target: x Grid Node>
 * @default true
 *
 * @arg Unit:str
 * @text Unit
 * @parent UseActionSelectNode:eval
 * @type select
 * @option Actor
 * @option Enemy
 * @option Friend
 * @option Opponent
 * @desc Which unit do you want to add the Trigger Node
 * effect for?
 * @default Actor
 *
 * @arg Rank:eval
 * @text Rank
 * @parent UseActionSelectNode:eval
 * @desc Input the number representing the Rank of the Node
 * you want to add a Trigger to.
 * @default 1
 *
 * @arg Flank:eval
 * @text Flank
 * @parent UseActionSelectNode:eval
 * @desc Input the number representing the Flank of the Node
 * you want to add a Trigger to.
 * @default 1
 * 
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Grid_AddTriggerToNodeJS
 * @text GRID: Add Trigger to Node JS
 * @desc Adds Trigger to target node. Target node cannot have battler.
 * Requires VisuMZ_2_BattleGridSystem!
 *
 * @arg SkillID:eval
 * @text JS: Skill ID
 * @desc Use JavaScript to determine what skill ID to add to this node.
 * @default 1
 *
 * @arg UseActionSelectNode:eval
 * @text Action-Selected Node?
 * @type boolean
 * @on Action-Selected
 * @off Prioritize Custom
 * @desc Use Action-Selected Node Coordinates if possible?
 * Requires "Empty" or "Any" for <Target: x Grid Node>
 * @default true
 *
 * @arg Unit:str
 * @text Unit
 * @parent UseActionSelectNode:eval
 * @type select
 * @option Actor
 * @option Enemy
 * @option Friend
 * @option Opponent
 * @desc Which unit do you want to add the Trigger Node
 * effect for?
 * @default Actor
 *
 * @arg Rank:eval
 * @text Rank
 * @parent UseActionSelectNode:eval
 * @desc Input the number representing the Rank of the Node
 * you want to add a Trigger to.
 * @default 1
 *
 * @arg Flank:eval
 * @text Flank
 * @parent UseActionSelectNode:eval
 * @desc Input the number representing the Flank of the Node
 * you want to add a Trigger to.
 * @default 1
 * 
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Grid_AnimationIDAtNode
 * @text GRID: Animation ID at Node
 * @desc Plays specific animation ID at target node.
 * Requires VisuMZ_2_BattleGridSystem!
 *
 * @arg AnimationID:num
 * @text Animation ID
 * @type animation
 * @desc Play this animation at target node.
 * @default 1
 *
 * @arg Mirror:eval
 * @text Mirror?
 * @parent AnimationID:num
 * @type boolean
 * @on Mirror Animation
 * @off Don't Mirror
 * @desc Mirror this animation?
 * @default false
 *
 * @arg Mute:eval
 * @text Mute?
 * @parent AnimationID:num
 * @type boolean
 * @on Mute Animation
 * @off Don't Mute
 * @desc Mute this animation?
 * @default false
 *
 * @arg UseActionSelectNode:eval
 * @text Action-Selected Node?
 * @type boolean
 * @on Action-Selected
 * @off Prioritize Custom
 * @desc Use Action-Selected Node Coordinates if possible?
 * Requires "Empty" or "Any" for <Target: x Grid Node>
 * @default true
 *
 * @arg Unit:str
 * @text Unit
 * @parent UseActionSelectNode:eval
 * @type select
 * @option Actor
 * @option Enemy
 * @option Friend
 * @option Opponent
 * @desc Which unit's Node do you want to play an animation on?
 * @default Enemy
 *
 * @arg Rank:num
 * @text Rank
 * @parent UseActionSelectNode:eval
 * @type number
 * @min 1
 * @max 10
 * @desc Input the number representing the Rank of the Node
 * you want to play an animation on.
 * @default 1
 *
 * @arg Flank:num
 * @text Flank
 * @parent UseActionSelectNode:eval
 * @type number
 * @min 1
 * @max 10
 * @desc Input the number representing the Flank of the Node
 * you want to play an animation on.
 * @default 1
 *
 * @arg OffsetX:num
 * @text Offset X
 * @desc Offsets the animation x position.
 * Negative: left. Positive: right.
 * @default +0
 *
 * @arg OffsetY:num
 * @text Offset Y
 * @desc Offsets the animation y position.
 * Negative: up. Positive: down.
 * @default +0
 * 
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Grid_AnimationJsAtNode
 * @text GRID: Animation JS at Node
 * @desc Uses JS to calculate which animation to play at target node.
 * Requires VisuMZ_2_BattleGridSystem!
 * 
 * @arg AnimationID:eval
 * @text JS: Animation ID
 * @desc Calculate which animation to play on unit(s).
 * Uses JavaScript to determine animation ID.
 * @default 1
 *
 * @arg Mirror:eval
 * @text Mirror?
 * @parent AnimationID:eval
 * @type boolean
 * @on Mirror Animation
 * @off Don't Mirror
 * @desc Mirror this animation?
 * @default false
 *
 * @arg Mute:eval
 * @text Mute?
 * @parent AnimationID:eval
 * @type boolean
 * @on Mute Animation
 * @off Don't Mute
 * @desc Mute this animation?
 * @default false
 *
 * @arg UseActionSelectNode:eval
 * @text Action-Selected Node?
 * @type boolean
 * @on Action-Selected
 * @off Prioritize Custom
 * @desc Use Action-Selected Node Coordinates if possible?
 * Requires "Empty" or "Any" for <Target: x Grid Node>
 * @default true
 *
 * @arg Unit:str
 * @text Unit
 * @parent UseActionSelectNode:eval
 * @type select
 * @option Actor
 * @option Enemy
 * @option Friend
 * @option Opponent
 * @desc Which unit's Node do you want to play an animation on?
 * @default Enemy
 *
 * @arg Rank:num
 * @text Rank
 * @parent UseActionSelectNode:eval
 * @type number
 * @min 1
 * @max 10
 * @desc Input the number representing the Rank of the Node
 * you want to play an animation on.
 * @default 1
 *
 * @arg Flank:num
 * @text Flank
 * @parent UseActionSelectNode:eval
 * @type number
 * @min 1
 * @max 10
 * @desc Input the number representing the Flank of the Node
 * you want to play an animation on.
 * @default 1
 *
 * @arg OffsetX:num
 * @text Offset X
 * @desc Offsets the animation x position.
 * Negative: left. Positive: right.
 * @default +0
 *
 * @arg OffsetY:num
 * @text Offset Y
 * @desc Offsets the animation y position.
 * Negative: up. Positive: down.
 * @default +0
 * 
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Grid_AnimationTypeAtNode
 * @text GRID: Animation Type at Node
 * @desc Plays certain animation type at target node.
 * Requires VisuMZ_2_BattleGridSystem!
 *
 * @arg Type:str
 * @text Animation Type
 * @type select
 * @option Attack
 * @option Guard
 * @option Item
 * @option Skill
 * @desc What is the animation type you would like to play?
 * @default Attack
 * 
 * @arg Slot:eval
 * @text Slot (Attack Type)
 * @parent Type:str
 * @desc Which weapon slot to get this data from?
 * Main-hand weapon is weapon slot 1.
 * @default 1
 * 
 * @arg ItemID:num
 * @text Item ID (Item Type)
 * @parent Type:str
 * @type item
 * @desc Which item ID will the animation come from?
 * @default 7
 * 
 * @arg SkillID:num
 * @text Skill ID (Skill Type)
 * @parent Type:str
 * @type skill
 * @desc Which skill ID will the animation come from?
 * @default 99
 *
 * @arg UseActionSelectNode:eval
 * @text Action-Selected Node?
 * @type boolean
 * @on Action-Selected
 * @off Prioritize Custom
 * @desc Use Action-Selected Node Coordinates if possible?
 * Requires "Empty" or "Any" for <Target: x Grid Node>
 * @default true
 *
 * @arg Unit:str
 * @text Unit
 * @parent UseActionSelectNode:eval
 * @type select
 * @option Actor
 * @option Enemy
 * @option Friend
 * @option Opponent
 * @desc Which unit's Node do you want to play an animation on?
 * @default Enemy
 *
 * @arg Rank:num
 * @text Rank
 * @parent UseActionSelectNode:eval
 * @type number
 * @min 1
 * @max 10
 * @desc Input the number representing the Rank of the Node
 * you want to play an animation on.
 * @default 1
 *
 * @arg Flank:num
 * @text Flank
 * @parent UseActionSelectNode:eval
 * @type number
 * @min 1
 * @max 10
 * @desc Input the number representing the Flank of the Node
 * you want to play an animation on.
 * @default 1
 *
 * @arg OffsetX:num
 * @text Offset X
 * @desc Offsets the animation x position.
 * Negative: left. Positive: right.
 * @default +0
 *
 * @arg OffsetY:num
 * @text Offset Y
 * @desc Offsets the animation y position.
 * Negative: up. Positive: down.
 * @default +0
 * 
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Grid_MoveTargetsInDirection
 * @text GRID: Move Target(s) In Direction
 * @desc Moves target(s) in a specific direction to other Nodes.
 * Requires VisuMZ_2_BattleGridSystem!
 * 
 * @arg Targets:arraystr
 * @text Targets
 * @type combo[]
 * @option user
 * @option current target
 * @option prev target
 * @option next target
 * @option all targets
 * @option focus
 * @option not focus
 * @option
 * @option special
 * @option special x
 * @option 
 * @option alive friends
 * @option alive friends not user
 * @option alive friends not target
 * @option dead friends
 * @option friend index x
 * @option 
 * @option alive opponents
 * @option alive opponents not target
 * @option dead opponents
 * @option opponent index x
 * @option 
 * @option alive actors
 * @option alive actors not user
 * @option alive actors not target
 * @option dead actors
 * @option actor index x
 * @option actor ID x
 * @option 
 * @option alive enemies
 * @option alive enemies not user
 * @option alive enemies not target
 * @option dead enemies
 * @option enemy index x
 * @option enemy ID x
 * @option 
 * @option alive battlers
 * @option alive battlers not user
 * @option alive battlers not target
 * @option dead battlers
 * @option 
 * @desc Select unit(s) to move.
 * @default ["all targets"]
 * 
 * @arg MoveType:str
 * @text Movement Type
 * @type select
 * @option -
 * @option Exact
 * @option -
 * @option Mid
 * @option -
 * @option Switch
 * @option Switch Mid
 * @option -
 * @option Crash
 * @option Crash Mid
 * @option -
 * @desc Select the Movement type rulings.
 * See VisuMZ_2_BattleGridSystem help file for details.
 * @default Mid
 * 
 * @arg Direction:str
 * @text Direction
 * @parent MoveType:str
 * @type select
 * @option -
 * @option Upward
 * @option Downward
 * @option -
 * @option Up-Forward
 * @option Forward
 * @option Down-Forward
 * @option -
 * @option Up-Backward
 * @option Backward
 * @option Down-Backward
 * @option -
 * @option Up-Leftward
 * @option Leftward
 * @option Down-Leftward
 * @option -
 * @option Up-Rightward
 * @option Rightward
 * @option Down-Rightward
 * @option -
 * @desc Select the movement direction.
 * @default Backward
 *
 * @arg Distance:eval
 * @text Distance
 * @parent MoveType:str
 * @desc The number of nodes to be moved.
 * You may use JavaScript code.
 * @default 1
 *
 * @arg Duration:eval
 * @text Duration
 * @desc Input the number representing the frames used to move.
 * @default 12
 *
 * @arg SilentMove:eval
 * @text Silent Change?
 * @type boolean
 * @on Silent
 * @off Visual
 * @desc Silent: Discreet changes shown. More apparent later.
 * Visual: Instant changes shown.
 * @default false
 * 
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Grid_PullToTargetNode
 * @text GRID: Pull To Target Node
 * @desc Pulls battlers towards target node.
 * Requires VisuMZ_2_BattleGridSystem!
 *
 * @arg UseActionSelectNode:eval
 * @text Action-Selected Node?
 * @type boolean
 * @on Action-Selected
 * @off Prioritize Custom
 * @desc Use Action-Selected Node Coordinates if possible?
 * Requires "Empty" or "Any" for <Target: x Grid Node>
 * @default true
 *
 * @arg Unit:str
 * @text Unit
 * @parent UseActionSelectNode:eval
 * @type select
 * @option Actor
 * @option Enemy
 * @option Friend
 * @option Opponent
 * @desc Which unit do you want to pull on?
 * @default Actor
 *
 * @arg Rank:eval
 * @text Rank
 * @parent UseActionSelectNode:eval
 * @desc Input the number representing the Rank of the Node
 * you want to pull to.
 * @default 1
 *
 * @arg Flank:eval
 * @text Flank
 * @parent UseActionSelectNode:eval
 * @desc Input the number representing the Flank of the Node
 * you want to pull to.
 * @default 1
 *
 * @arg Strength:eval
 * @text Strength
 * @desc Input the strength level of the pull.
 * @default 1
 *
 * @arg Duration:eval
 * @text Duration
 * @desc Input the number representing the frames used to move.
 * @default 12
 * 
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Grid_PushFromTargetNode
 * @text GRID: Push From Target Node
 * @desc Pushes battlers away from target node.
 * Requires VisuMZ_2_BattleGridSystem!
 *
 * @arg UseActionSelectNode:eval
 * @text Action-Selected Node?
 * @type boolean
 * @on Action-Selected
 * @off Prioritize Custom
 * @desc Use Action-Selected Node Coordinates if possible?
 * Requires "Empty" or "Any" for <Target: x Grid Node>
 * @default true
 *
 * @arg Unit:str
 * @text Unit
 * @parent UseActionSelectNode:eval
 * @type select
 * @option Actor
 * @option Enemy
 * @option Friend
 * @option Opponent
 * @desc Which unit do you want to push from?
 * @default Actor
 *
 * @arg Rank:eval
 * @text Rank
 * @parent UseActionSelectNode:eval
 * @desc Input the number representing the Rank of the Node
 * you want to push from.
 * @default 1
 *
 * @arg Flank:eval
 * @text Flank
 * @parent UseActionSelectNode:eval
 * @desc Input the number representing the Flank of the Node
 * you want to push from.
 * @default 1
 *
 * @arg Strength:eval
 * @text Strength
 * @desc Input the strength level of the push.
 * @default 1
 *
 * @arg Duration:eval
 * @text Duration
 * @desc Input the number representing the frames used to move.
 * @default 12
 * 
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Grid_ClearPassiveStatesFromNode
 * @text GRID: Remove All Passive States from Node
 * @desc Removes all all Passive State effects at target node.
 * Requires VisuMZ_2_BattleGridSystem!
 *
 * @arg UseActionSelectNode:eval
 * @text Action-Selected Node?
 * @type boolean
 * @on Action-Selected
 * @off Prioritize Custom
 * @desc Use Action-Selected Node Coordinates if possible?
 * Requires "Empty" or "Any" for <Target: x Grid Node>
 * @default true
 *
 * @arg Unit:str
 * @text Unit
 * @parent UseActionSelectNode:eval
 * @type select
 * @option Actor
 * @option Enemy
 * @option Friend
 * @option Opponent
 * @desc Which unit do you want to clear the Node for?
 * @default Actor
 *
 * @arg Rank:eval
 * @text Rank
 * @parent UseActionSelectNode:eval
 * @desc Input the number representing the Rank of the Node
 * you want to clear Passive States from.
 * @default 1
 *
 * @arg Flank:eval
 * @text Flank
 * @parent UseActionSelectNode:eval
 * @desc Input the number representing the Flank of the Node
 * you want to clear Passive States from.
 * @default 1
 * 
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Grid_RemovePassiveStatesFromNode
 * @text GRID: Remove Passive State(s) from Node
 * @desc Remove Passive State(s) at target node.
 * Requires VisuMZ_2_BattleGridSystem!
 *
 * @arg StateIDs:arraynum
 * @text State ID(s)
 * @type state[]
 * @desc Select which State ID(s) to remove as a Passive State.
 * @default []
 *
 * @arg UseActionSelectNode:eval
 * @text Action-Selected Node?
 * @type boolean
 * @on Action-Selected
 * @off Prioritize Custom
 * @desc Use Action-Selected Node Coordinates if possible?
 * Requires "Empty" or "Any" for <Target: x Grid Node>
 * @default true
 *
 * @arg Unit:str
 * @text Unit
 * @parent UseActionSelectNode:eval
 * @type select
 * @option Actor
 * @option Enemy
 * @option Friend
 * @option Opponent
 * @desc Which unit do you want to remove the Passive State Node
 * effect for?
 * @default Actor
 *
 * @arg Rank:eval
 * @text Rank
 * @parent UseActionSelectNode:eval
 * @desc Input the number representing the Rank of the Node
 * you want to remove a Passive State(s) from.
 * @default 1
 *
 * @arg Flank:eval
 * @text Flank
 * @parent UseActionSelectNode:eval
 * @desc Input the number representing the Flank of the Node
 * you want to remove a Passive State(s) from.
 * @default 1
 * 
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Grid_RemoveTriggerFromNode
 * @text GRID: Remove Trigger from Node
 * @desc Removes Trigger from target node.
 * Requires VisuMZ_2_BattleGridSystem!
 *
 * @arg UseActionSelectNode:eval
 * @text Action-Selected Node?
 * @type boolean
 * @on Action-Selected
 * @off Prioritize Custom
 * @desc Use Action-Selected Node Coordinates if possible?
 * Requires "Empty" or "Any" for <Target: x Grid Node>
 * @default true
 *
 * @arg Unit:str
 * @text Unit
 * @parent UseActionSelectNode:eval
 * @type select
 * @option Actor
 * @option Enemy
 * @option Friend
 * @option Opponent
 * @desc Which unit do you want to clear Triggers for?
 * @default Actor
 *
 * @arg Rank:eval
 * @text Rank
 * @parent UseActionSelectNode:eval
 * @desc Input the number representing the Rank of the Node
 * you want to clear Triggers from.
 * @default 1
 *
 * @arg Flank:eval
 * @text Flank
 * @parent UseActionSelectNode:eval
 * @desc Input the number representing the Flank of the Node
 * you want to clear Triggers from.
 * @default 1
 * 
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Grid_TeleportToNode
 * @text GRID: Teleport To Node
 * @desc Teleports user/random opponent to target node.
 * Requires VisuMZ_2_BattleGridSystem!
 *
 * @arg UseActionSelectNode:eval
 * @text Action-Selected Node?
 * @type boolean
 * @on Action-Selected
 * @off Prioritize Custom
 * @desc Use Action-Selected Node Coordinates if possible?
 * Requires "Empty" or "Any" for <Target: x Grid Node>
 * @default true
 *
 * @arg Unit:str
 * @text Unit
 * @parent UseActionSelectNode:eval
 * @type select
 * @option Actor
 * @option Enemy
 * @option Friend
 * @option Opponent
 * @desc Which unit do you want to teleport to?
 * @default Actor
 *
 * @arg Rank:eval
 * @text Rank
 * @parent UseActionSelectNode:eval
 * @desc Input the number representing the Rank of the Node
 * you want to teleport to.
 * @default 1
 *
 * @arg Flank:eval
 * @text Flank
 * @parent UseActionSelectNode:eval
 * @desc Input the number representing the Flank of the Node
 * you want to teleport.
 * @default 1
 * 
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Grid_TraverseToNode
 * @text GRID: Traverse To Node
 * @desc Traverses user/random opponent to target node.
 * Requires VisuMZ_2_BattleGridSystem!
 *
 * @arg UseActionSelectNode:eval
 * @text Action-Selected Node?
 * @type boolean
 * @on Action-Selected
 * @off Prioritize Custom
 * @desc Use Action-Selected Node Coordinates if possible?
 * Requires "Empty" or "Any" for <Target: x Grid Node>
 * @default true
 *
 * @arg Unit:str
 * @text Unit
 * @parent UseActionSelectNode:eval
 * @type select
 * @option Actor
 * @option Enemy
 * @option Friend
 * @option Opponent
 * @desc Which unit do you want to traverse to?
 * @default Actor
 *
 * @arg Rank:eval
 * @text Rank
 * @parent UseActionSelectNode:eval
 * @desc Input the number representing the Rank of the Node
 * you want to traverse to.
 * @default 1
 *
 * @arg Flank:eval
 * @text Flank
 * @parent UseActionSelectNode:eval
 * @desc Input the number representing the Flank of the Node
 * you want to traverse.
 * @default 1
 *
 * @arg Duration:eval
 * @text Duration
 * @desc Input the number representing the frames used to move.
 * @default 12
 * 
 * @ --------------------------------------------------------------------------
 *
 * @command ActionSequenceSpaceHorror
 * @text -
 * @desc -
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActionSequenceBreakHorror
 * @text Action Sequences - Horror Effects
 * @desc These Action Sequences are Horror Effects-related.
 * Requires VisuMZ_2_HorrorEffects!
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Horror_Clear
 * @text HORROR: Clear All Filters
 * @desc Clear all Horror Effects filters on the target battler(s).
 * 
 * @arg Targets:arraystr
 * @text Targets
 * @type combo[]
 * @option user
 * @option current target
 * @option prev target
 * @option next target
 * @option all targets
 * @option focus
 * @option not focus
 * @option
 * @option special
 * @option special x
 * @option 
 * @option alive friends
 * @option alive friends not user
 * @option alive friends not target
 * @option dead friends
 * @option friend index x
 * @option 
 * @option alive opponents
 * @option alive opponents not target
 * @option dead opponents
 * @option opponent index x
 * @option 
 * @option alive actors
 * @option alive actors not user
 * @option alive actors not target
 * @option dead actors
 * @option actor index x
 * @option actor ID x
 * @option 
 * @option alive enemies
 * @option alive enemies not user
 * @option alive enemies not target
 * @option dead enemies
 * @option enemy index x
 * @option enemy ID x
 * @option 
 * @option alive battlers
 * @option alive battlers not user
 * @option alive battlers not target
 * @option dead battlers
 * @option 
 * @desc Select unit(s) to remove Horror Effects for.
 * @default ["user"]
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Horror_GlitchCreate
 * @text HORROR: Glitch Create
 * @desc Creates the glitch effect on the target battler(s).
 * 
 * @arg Targets:arraystr
 * @text Targets
 * @type combo[]
 * @option user
 * @option current target
 * @option prev target
 * @option next target
 * @option all targets
 * @option focus
 * @option not focus
 * @option
 * @option special
 * @option special x
 * @option 
 * @option alive friends
 * @option alive friends not user
 * @option alive friends not target
 * @option dead friends
 * @option friend index x
 * @option 
 * @option alive opponents
 * @option alive opponents not target
 * @option dead opponents
 * @option opponent index x
 * @option 
 * @option alive actors
 * @option alive actors not user
 * @option alive actors not target
 * @option dead actors
 * @option actor index x
 * @option actor ID x
 * @option 
 * @option alive enemies
 * @option alive enemies not user
 * @option alive enemies not target
 * @option dead enemies
 * @option enemy index x
 * @option enemy ID x
 * @option 
 * @option alive battlers
 * @option alive battlers not user
 * @option alive battlers not target
 * @option dead battlers
 * @option 
 * @desc Select unit(s) to create the Horror Effect for.
 * @default ["user"]
 *
 * @arg slices:num
 * @text Glitch Slices
 * @parent FilterGlitch
 * @type number
 * @min 1
 * @desc Glitch slices to be used with the target.
 * @default 10
 *
 * @arg offset:num
 * @text Glitch Offset
 * @parent FilterGlitch
 * @type number
 * @min 1
 * @desc Default offset value.
 * @default 100
 *
 * @arg animated:eval
 * @text Glitch Animated?
 * @parent FilterGlitch
 * @type boolean
 * @on Animate
 * @off Static
 * @desc Animate the glitch effect?
 * @default true
 *
 * @arg aniFrequency:num
 * @text Glitch Frequency
 * @parent FilterGlitch
 * @type number
 * @min 1
 * @desc If animated, how frequent to make the glitch effect?
 * Lower = often     Higher = rarer
 * @default 300
 *
 * @arg aniStrength:num
 * @text Glitch Strength
 * @parent FilterGlitch
 * @type number
 * @min 1
 * @desc If animated, how strong is the glitch effect?
 * Lower = weaker     Higher = stronger
 * @default 30
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Horror_GlitchRemove
 * @text HORROR: Glitch Remove
 * @desc Removes the glitch effect on the target battler(s).
 * 
 * @arg Targets:arraystr
 * @text Targets
 * @type combo[]
 * @option user
 * @option current target
 * @option prev target
 * @option next target
 * @option all targets
 * @option focus
 * @option not focus
 * @option
 * @option special
 * @option special x
 * @option 
 * @option alive friends
 * @option alive friends not user
 * @option alive friends not target
 * @option dead friends
 * @option friend index x
 * @option 
 * @option alive opponents
 * @option alive opponents not target
 * @option dead opponents
 * @option opponent index x
 * @option 
 * @option alive actors
 * @option alive actors not user
 * @option alive actors not target
 * @option dead actors
 * @option actor index x
 * @option actor ID x
 * @option 
 * @option alive enemies
 * @option alive enemies not user
 * @option alive enemies not target
 * @option dead enemies
 * @option enemy index x
 * @option enemy ID x
 * @option 
 * @option alive battlers
 * @option alive battlers not user
 * @option alive battlers not target
 * @option dead battlers
 * @option 
 * @desc Select unit(s) to remove the Horror Effect for.
 * @default ["user"]
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Horror_NoiseCreate
 * @text HORROR: Noise Create
 * @desc Creates the noise effect on the target battler(s).
 * 
 * @arg Targets:arraystr
 * @text Targets
 * @type combo[]
 * @option user
 * @option current target
 * @option prev target
 * @option next target
 * @option all targets
 * @option focus
 * @option not focus
 * @option
 * @option special
 * @option special x
 * @option 
 * @option alive friends
 * @option alive friends not user
 * @option alive friends not target
 * @option dead friends
 * @option friend index x
 * @option 
 * @option alive opponents
 * @option alive opponents not target
 * @option dead opponents
 * @option opponent index x
 * @option 
 * @option alive actors
 * @option alive actors not user
 * @option alive actors not target
 * @option dead actors
 * @option actor index x
 * @option actor ID x
 * @option 
 * @option alive enemies
 * @option alive enemies not user
 * @option alive enemies not target
 * @option dead enemies
 * @option enemy index x
 * @option enemy ID x
 * @option 
 * @option alive battlers
 * @option alive battlers not user
 * @option alive battlers not target
 * @option dead battlers
 * @option 
 * @desc Select unit(s) to create the Horror Effect for.
 * @default ["user"]
 *
 * @arg noise:num
 * @text Noise Rate
 * @parent FilterNoise
 * @desc Noise rate to be used with the target.
 * @default 0.3
 *
 * @arg animated:eval
 * @text Noise Animated
 * @parent FilterNoise
 * @type boolean
 * @on Animate
 * @off Static
 * @desc Animate the noise for the target?
 * @default true
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Horror_NoiseRemove
 * @text HORROR: Noise Remove
 * @desc Removes the noise effect on the target battler(s).
 * 
 * @arg Targets:arraystr
 * @text Targets
 * @type combo[]
 * @option user
 * @option current target
 * @option prev target
 * @option next target
 * @option all targets
 * @option focus
 * @option not focus
 * @option
 * @option special
 * @option special x
 * @option 
 * @option alive friends
 * @option alive friends not user
 * @option alive friends not target
 * @option dead friends
 * @option friend index x
 * @option 
 * @option alive opponents
 * @option alive opponents not target
 * @option dead opponents
 * @option opponent index x
 * @option 
 * @option alive actors
 * @option alive actors not user
 * @option alive actors not target
 * @option dead actors
 * @option actor index x
 * @option actor ID x
 * @option 
 * @option alive enemies
 * @option alive enemies not user
 * @option alive enemies not target
 * @option dead enemies
 * @option enemy index x
 * @option enemy ID x
 * @option 
 * @option alive battlers
 * @option alive battlers not user
 * @option alive battlers not target
 * @option dead battlers
 * @option 
 * @desc Select unit(s) to remove the Horror Effect for.
 * @default ["user"]
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Horror_TVCreate
 * @text HORROR: TV Create
 * @desc Creates the TV effect on the target battler(s).
 * 
 * @arg Targets:arraystr
 * @text Targets
 * @type combo[]
 * @option user
 * @option current target
 * @option prev target
 * @option next target
 * @option all targets
 * @option focus
 * @option not focus
 * @option
 * @option special
 * @option special x
 * @option 
 * @option alive friends
 * @option alive friends not user
 * @option alive friends not target
 * @option dead friends
 * @option friend index x
 * @option 
 * @option alive opponents
 * @option alive opponents not target
 * @option dead opponents
 * @option opponent index x
 * @option 
 * @option alive actors
 * @option alive actors not user
 * @option alive actors not target
 * @option dead actors
 * @option actor index x
 * @option actor ID x
 * @option 
 * @option alive enemies
 * @option alive enemies not user
 * @option alive enemies not target
 * @option dead enemies
 * @option enemy index x
 * @option enemy ID x
 * @option 
 * @option alive battlers
 * @option alive battlers not user
 * @option alive battlers not target
 * @option dead battlers
 * @option 
 * @desc Select unit(s) to create the Horror Effect for.
 * @default ["user"]
 *
 * @arg lineWidth:num
 * @text TV Line Thickness
 * @parent FilterTV
 * @type number
 * @min 1
 * @desc Default TV line thickness
 * Lower = thinner     Higher = thicker
 * @default 5
 *
 * @arg vignetting:num
 * @text TV Corner Size
 * @parent FilterTV
 * @desc Default TV line corner size
 * Lower = smaller     Higher = bigger
 * @default 0.3
 *
 * @arg animated:eval
 * @text TV Animated
 * @parent FilterTV
 * @type boolean
 * @on Animate
 * @off Static
 * @desc Animate the TV?
 * @default true
 *
 * @arg aniSpeed:num
 * @text TV Speed
 * @parent FilterTV
 * @desc Speed used to animate the TV if animated
 * Lower = slower     Higher = faster
 * @default 0.25
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Horror_TVRemove
 * @text HORROR: TV Remove
 * @desc Removes the TV effect on the target battler(s).
 * 
 * @arg Targets:arraystr
 * @text Targets
 * @type combo[]
 * @option user
 * @option current target
 * @option prev target
 * @option next target
 * @option all targets
 * @option focus
 * @option not focus
 * @option
 * @option special
 * @option special x
 * @option 
 * @option alive friends
 * @option alive friends not user
 * @option alive friends not target
 * @option dead friends
 * @option friend index x
 * @option 
 * @option alive opponents
 * @option alive opponents not target
 * @option dead opponents
 * @option opponent index x
 * @option 
 * @option alive actors
 * @option alive actors not user
 * @option alive actors not target
 * @option dead actors
 * @option actor index x
 * @option actor ID x
 * @option 
 * @option alive enemies
 * @option alive enemies not user
 * @option alive enemies not target
 * @option dead enemies
 * @option enemy index x
 * @option enemy ID x
 * @option 
 * @option alive battlers
 * @option alive battlers not user
 * @option alive battlers not target
 * @option dead battlers
 * @option 
 * @desc Select unit(s) to remove the Horror Effect for.
 * @default ["user"]
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActionSequenceSpaceImpact
 * @text -
 * @desc -
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActionSequenceBreakImpact
 * @text Action Sequences - Impact
 * @desc These Action Sequences are related to creating impact.
 * Requires VisuMZ_3_ActSeqImpact!
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Impact_BlueRedInvert
 * @text IMPACT: Bizarro Inversion
 * @desc Swaps blue/red colors on the battlefield.
 * Requires VisuMZ_3_ActSeqImpact!
 *
 * @arg Enable:eval
 * @text Bizarro?
 * @type boolean
 * @on Enable / Bizarro
 * @off Disable / Normal
 * @desc Enable Bizarro Inversion effect?
 * @default true
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Impact_ColorBreak
 * @text IMPACT: Color Break
 * @desc Breaks the colors on the screen before reassembling.
 * Requires VisuMZ_3_ActSeqImpact!
 * 
 * @arg Intensity:eval
 * @text Intensity
 * @desc What is the intensity of the color break effect?
 * @default 60
 * 
 * @arg Duration:eval
 * @text Duration
 * @desc What is the duration of the color break effect?
 * @default 60
 *
 * @arg EasingType:str
 * @text Easing Type
 * @type combo
 * @option Linear
 * @option InSine
 * @option OutSine
 * @option InOutSine
 * @option InQuad
 * @option OutQuad
 * @option InOutQuad
 * @option InCubic
 * @option OutCubic
 * @option InOutCubic
 * @option InQuart
 * @option OutQuart
 * @option InOutQuart
 * @option InQuint
 * @option OutQuint
 * @option InOutQuint
 * @option InExpo
 * @option OutExpo
 * @option InOutExpo
 * @option InCirc
 * @option OutCirc
 * @option InOutCirc
 * @option InBack
 * @option OutBack
 * @option InOutBack
 * @option InElastic
 * @option OutElastic
 * @option InOutElastic
 * @option InBounce
 * @option OutBounce
 * @option InOutBounce
 * @desc Select which easing type you wish to apply.
 * @default OutBack
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Impact_Desaturate
 * @text IMPACT: Desaturation
 * @desc Desaturates all colors on the battlefield.
 * Requires VisuMZ_3_ActSeqImpact! Created by Manu Gaming!
 *
 * @arg Enable:eval
 * @text Desaturate?
 * @type boolean
 * @on Enable / Desaturate
 * @off Disable / Normal
 * @desc Enable Desaturation effect?
 * @default true
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Impact_MotionBlurScreen
 * @text IMPACT: Motion Blur Screen
 * @desc Creates a motion blur on the whole screen.
 * Requires VisuMZ_3_ActSeqImpact!
 *
 * @arg Angle:eval
 * @text Angle
 * @desc Determine what angle to make the motion blur at.
 * @default Math.randomInt(360)
 *
 * @arg Rate:eval
 * @text Intensity Rate
 * @desc This determines intensity rate of the motion blur.
 * Use a number between 0 and 1.
 * @default 0.1
 *
 * @arg Duration:num
 * @text Duration
 * @type number
 * @min 1
 * @desc How many frames should the motion blur last?
 * What do you want to be its duration?
 * @default 30
 *
 * @arg EasingType:str
 * @text Easing Type
 * @type combo
 * @option Linear
 * @option InSine
 * @option OutSine
 * @option InOutSine
 * @option InQuad
 * @option OutQuad
 * @option InOutQuad
 * @option InCubic
 * @option OutCubic
 * @option InOutCubic
 * @option InQuart
 * @option OutQuart
 * @option InOutQuart
 * @option InQuint
 * @option OutQuint
 * @option InOutQuint
 * @option InExpo
 * @option OutExpo
 * @option InOutExpo
 * @option InCirc
 * @option OutCirc
 * @option InOutCirc
 * @option InBack
 * @option OutBack
 * @option InOutBack
 * @option InElastic
 * @option OutElastic
 * @option InOutElastic
 * @option InBounce
 * @option OutBounce
 * @option InOutBounce
 * @desc Select which easing type you wish to apply.
 * @default InOutSine
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Impact_MotionBlurTarget
 * @text IMPACT: Motion Blur Target(s)
 * @desc Creates a motion blur on selected target(s).
 * Requires VisuMZ_3_ActSeqImpact!
 * 
 * @arg Targets:arraystr
 * @text Targets
 * @type combo[]
 * @option user
 * @option current target
 * @option prev target
 * @option next target
 * @option all targets
 * @option focus
 * @option not focus
 * @option
 * @option special
 * @option special x
 * @option 
 * @option alive friends
 * @option alive friends not user
 * @option alive friends not target
 * @option dead friends
 * @option friend index x
 * @option 
 * @option alive opponents
 * @option alive opponents not target
 * @option dead opponents
 * @option opponent index x
 * @option 
 * @option alive actors
 * @option alive actors not user
 * @option alive actors not target
 * @option dead actors
 * @option actor index x
 * @option actor ID x
 * @option 
 * @option alive enemies
 * @option alive enemies not user
 * @option alive enemies not target
 * @option dead enemies
 * @option enemy index x
 * @option enemy ID x
 * @option 
 * @option alive battlers
 * @option alive battlers not user
 * @option alive battlers not target
 * @option dead battlers
 * @option 
 * @desc Select unit(s) to create motion blur effects for.
 * @default ["user"]
 *
 * @arg Angle:eval
 * @text Angle
 * @desc Determine what angle to make the motion blur at.
 * @default Math.randomInt(360)
 *
 * @arg Rate:eval
 * @text Intensity Rate
 * @desc This determines intensity rate of the motion blur.
 * Use a number between 0 and 1.
 * @default 0.5
 *
 * @arg Duration:num
 * @text Duration
 * @type number
 * @min 1
 * @desc How many frames should the motion blur last?
 * What do you want to be its duration?
 * @default 30
 *
 * @arg EasingType:str
 * @text Easing Type
 * @type combo
 * @option Linear
 * @option InSine
 * @option OutSine
 * @option InOutSine
 * @option InQuad
 * @option OutQuad
 * @option InOutQuad
 * @option InCubic
 * @option OutCubic
 * @option InOutCubic
 * @option InQuart
 * @option OutQuart
 * @option InOutQuart
 * @option InQuint
 * @option OutQuint
 * @option InOutQuint
 * @option InExpo
 * @option OutExpo
 * @option InOutExpo
 * @option InCirc
 * @option OutCirc
 * @option InOutCirc
 * @option InBack
 * @option OutBack
 * @option InOutBack
 * @option InElastic
 * @option OutElastic
 * @option InOutElastic
 * @option InBounce
 * @option OutBounce
 * @option InOutBounce
 * @desc Select which easing type you wish to apply.
 * @default InOutSine
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Impact_MotionTrailCreate
 * @text IMPACT: Motion Trail Create
 * @desc Creates a motion trail effect for the target(s).
 * Requires VisuMZ_3_ActSeqImpact!
 * 
 * @arg Targets:arraystr
 * @text Targets
 * @type combo[]
 * @option user
 * @option current target
 * @option prev target
 * @option next target
 * @option all targets
 * @option focus
 * @option not focus
 * @option
 * @option special
 * @option special x
 * @option 
 * @option alive friends
 * @option alive friends not user
 * @option alive friends not target
 * @option dead friends
 * @option friend index x
 * @option 
 * @option alive opponents
 * @option alive opponents not target
 * @option dead opponents
 * @option opponent index x
 * @option 
 * @option alive actors
 * @option alive actors not user
 * @option alive actors not target
 * @option dead actors
 * @option actor index x
 * @option actor ID x
 * @option 
 * @option alive enemies
 * @option alive enemies not user
 * @option alive enemies not target
 * @option dead enemies
 * @option enemy index x
 * @option enemy ID x
 * @option 
 * @option alive battlers
 * @option alive battlers not user
 * @option alive battlers not target
 * @option dead battlers
 * @option 
 * @desc Select unit(s) to create motion trail effects for.
 * @default ["user"]
 *
 * @arg delay:num
 * @text Delay
 * @type number
 * @min 1
 * @desc How many frames to delay by when creating a motion trail?
 * The higher the delay, the less after images there are.
 * @default 1
 *
 * @arg duration:num
 * @text Duration
 * @type number
 * @min 1
 * @desc How many frames should the motion trail last?
 * What do you want to be its duration?
 * @default 30
 *
 * @arg hue:num
 * @text Hue
 * @type number
 * @min 0
 * @max 360
 * @desc What do you want to be the hue for the motion trail?
 * @default 0
 *
 * @arg opacityStart:num
 * @text Starting Opacity
 * @type number
 * @min 0
 * @max 255
 * @desc What starting opacity value do you want for the motion
 * trail? Opacity values decrease over time.
 * @default 200
 *
 * @arg tone:eval
 * @text Tone
 * @desc What tone do you want for the motion trail?
 * Format: [Red, Green, Blue, Gray]
 * @default [0, 0, 0, 0]
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Impact_MotionTrailRemove
 * @text IMPACT: Motion Trail Remove
 * @desc Removes the motion trail effect from the target(s).
 * Requires VisuMZ_3_ActSeqImpact!
 * 
 * @arg Targets:arraystr
 * @text Targets
 * @type combo[]
 * @option user
 * @option current target
 * @option prev target
 * @option next target
 * @option all targets
 * @option focus
 * @option not focus
 * @option
 * @option special
 * @option special x
 * @option 
 * @option alive friends
 * @option alive friends not user
 * @option alive friends not target
 * @option dead friends
 * @option friend index x
 * @option 
 * @option alive opponents
 * @option alive opponents not target
 * @option dead opponents
 * @option opponent index x
 * @option 
 * @option alive actors
 * @option alive actors not user
 * @option alive actors not target
 * @option dead actors
 * @option actor index x
 * @option actor ID x
 * @option 
 * @option alive enemies
 * @option alive enemies not user
 * @option alive enemies not target
 * @option dead enemies
 * @option enemy index x
 * @option enemy ID x
 * @option 
 * @option alive battlers
 * @option alive battlers not user
 * @option alive battlers not target
 * @option dead battlers
 * @option 
 * @desc Select unit(s) to clear motion trail effects for.
 * @default ["user"]
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Impact_Negative
 * @text IMPACT: Negative Inversion
 * @desc Inverts all the colors on the battlefield.
 * Requires VisuMZ_3_ActSeqImpact! Created by Manu Gaming!
 *
 * @arg Enable:eval
 * @text Negative?
 * @type boolean
 * @on Enable / Negative
 * @off Disable / Normal
 * @desc Enable negative inversion effect?
 * @default true
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Impact_Oversaturate
 * @text IMPACT: Oversaturation
 * @desc Oversaturates colors on the battlefield.
 * Requires VisuMZ_3_ActSeqImpact!
 *
 * @arg Enable:eval
 * @text Oversaturate?
 * @type boolean
 * @on Enable / Oversaturate
 * @off Disable / Normal
 * @desc Enable Oversaturation effect?
 * @default true
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Impact_ShockwavePoint
 * @text IMPACT: Shockwave at Point
 * @desc Creates a shockwave at the designated coordinates.
 * Requires VisuMZ_3_ActSeqImpact!
 * 
 * @arg Coordinates
 * 
 * @arg X:eval
 * @text Point: X
 * @parent Coordinates
 * @desc What x coordinate do you want to create a shockwave at?
 * You can use JavaScript code.
 * @default Graphics.width / 2
 * 
 * @arg Y:eval
 * @text Point: Y
 * @parent Coordinates
 * @desc What y coordinate do you want to create a shockwave at?
 * You can use JavaScript code.
 * @default (Graphics.height - 200) / 2
 * 
 * @arg Amp:eval
 * @text Amplitude
 * @desc What is the aplitude of the shockwave effect?
 * @default 30
 * 
 * @arg Wave:eval
 * @text Wavelength
 * @desc What is the wavelength of the shockwave effect?
 * @default 160
 * 
 * @arg Duration:eval
 * @text Duration
 * @desc What is the duration of the shockwave?
 * @default 60
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Impact_ShockwaveEachTargets
 * @text IMPACT: Shockwave from Each Target(s)
 * @desc Creates a shockwave at each of the target(s) location(s).
 * Requires VisuMZ_3_ActSeqImpact!
 * 
 * @arg Targets:arraystr
 * @text Targets
 * @type combo[]
 * @option user
 * @option current target
 * @option prev target
 * @option next target
 * @option all targets
 * @option focus
 * @option not focus
 * @option
 * @option special
 * @option special x
 * @option 
 * @option alive friends
 * @option alive friends not user
 * @option alive friends not target
 * @option dead friends
 * @option friend index x
 * @option 
 * @option alive opponents
 * @option alive opponents not target
 * @option dead opponents
 * @option opponent index x
 * @option 
 * @option alive actors
 * @option alive actors not user
 * @option alive actors not target
 * @option dead actors
 * @option actor index x
 * @option actor ID x
 * @option 
 * @option alive enemies
 * @option alive enemies not user
 * @option alive enemies not target
 * @option dead enemies
 * @option enemy index x
 * @option enemy ID x
 * @option 
 * @option alive battlers
 * @option alive battlers not user
 * @option alive battlers not target
 * @option dead battlers
 * @option 
 * @desc Select unit(s) to start a shockwave from.
 * @default ["all targets"]
 * 
 * @arg TargetLocation:str
 * @text Target Location
 * @parent Targets2:arraystr
 * @type combo
 * @option front head
 * @option front center
 * @option front base
 * @option middle head
 * @option middle center
 * @option middle base
 * @option back head
 * @option back center
 * @option back base
 * @desc Select which part target group to start a shockwave from.
 * @default middle center
 * 
 * @arg OffsetX:eval
 * @text Offset X
 * @parent TargetLocation:str
 * @desc How much to offset the shockwave X point by.
 * Negative: left. Positive: right.
 * @default +0
 * 
 * @arg OffsetY:eval
 * @text Offset Y
 * @parent TargetLocation:str
 * @desc How much to offset the shockwave Y point by.
 * Negative: up. Positive: down.
 * @default +0
 * 
 * @arg Amp:eval
 * @text Amplitude
 * @desc What is the aplitude of the shockwave effect?
 * @default 30
 * 
 * @arg Wave:eval
 * @text Wavelength
 * @desc What is the wavelength of the shockwave effect?
 * @default 160
 * 
 * @arg Duration:eval
 * @text Duration
 * @desc What is the duration of the shockwave?
 * @default 60
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Impact_ShockwaveCenterTargets
 * @text IMPACT: Shockwave from Target(s) Center
 * @desc Creates a shockwave from the center of the target(s).
 * Requires VisuMZ_3_ActSeqImpact!
 * 
 * @arg Targets:arraystr
 * @text Targets
 * @type combo[]
 * @option user
 * @option current target
 * @option prev target
 * @option next target
 * @option all targets
 * @option focus
 * @option not focus
 * @option
 * @option special
 * @option special x
 * @option 
 * @option alive friends
 * @option alive friends not user
 * @option alive friends not target
 * @option dead friends
 * @option friend index x
 * @option 
 * @option alive opponents
 * @option alive opponents not target
 * @option dead opponents
 * @option opponent index x
 * @option 
 * @option alive actors
 * @option alive actors not user
 * @option alive actors not target
 * @option dead actors
 * @option actor index x
 * @option actor ID x
 * @option 
 * @option alive enemies
 * @option alive enemies not user
 * @option alive enemies not target
 * @option dead enemies
 * @option enemy index x
 * @option enemy ID x
 * @option 
 * @option alive battlers
 * @option alive battlers not user
 * @option alive battlers not target
 * @option dead battlers
 * @option 
 * @desc Select unit(s) to start a shockwave from.
 * @default ["all targets"]
 * 
 * @arg TargetLocation:str
 * @text Target Location
 * @parent Targets2:arraystr
 * @type combo
 * @option front head
 * @option front center
 * @option front base
 * @option middle head
 * @option middle center
 * @option middle base
 * @option back head
 * @option back center
 * @option back base
 * @desc Select which part target group to start a shockwave from.
 * @default middle center
 * 
 * @arg OffsetX:eval
 * @text Offset X
 * @parent TargetLocation:str
 * @desc How much to offset the shockwave X point by.
 * Negative: left. Positive: right.
 * @default +0
 * 
 * @arg OffsetY:eval
 * @text Offset Y
 * @parent TargetLocation:str
 * @desc How much to offset the shockwave Y point by.
 * Negative: up. Positive: down.
 * @default +0
 * 
 * @arg Amp:eval
 * @text Amplitude
 * @desc What is the aplitude of the shockwave effect?
 * @default 30
 * 
 * @arg Wave:eval
 * @text Wavelength
 * @desc What is the wavelength of the shockwave effect?
 * @default 160
 * 
 * @arg Duration:eval
 * @text Duration
 * @desc What is the duration of the shockwave?
 * @default 60
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Impact_TimeScale
 * @text IMPACT: Time Scale
 * @desc Adjust time to go faster or slower!
 * Requires VisuMZ_3_ActSeqImpact! Created by Manu Gaming!
 * 
 * @arg Scale:eval
 * @text Scale
 * @desc Adjusts how fast/slow time goes.
 * 1.00 is normal. Lower is slower. Higher is faster.
 * @default 1.00
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Impact_TimeStop
 * @text IMPACT: Time Stop
 * @desc Stops time for a set amount of milliseconds.
 * Requires VisuMZ_3_ActSeqImpact! Created by Manu Gaming!
 * 
 * @arg ms:eval
 * @text Milliseconds
 * @desc How many milliseconds should time stop for?
 * 1000 milliseconds = 1 second.
 * @default 1000
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Impact_ZoomBlurPoint
 * @text IMPACT: Zoom Blur at Point
 * @desc Creates a zoom blur at the designated coordinates.
 * Requires VisuMZ_3_ActSeqImpact!
 * 
 * @arg Coordinates
 * 
 * @arg X:eval
 * @text Point: X
 * @parent Coordinates
 * @desc What x coordinate do you want to focus the zoom at?
 * You can use JavaScript code.
 * @default Graphics.width / 2
 * 
 * @arg Y:eval
 * @text Point: Y
 * @parent Coordinates
 * @desc What y coordinate do you want to focus the zoom at?
 * You can use JavaScript code.
 * @default (Graphics.height - 200) / 2
 * 
 * @arg Strength:eval
 * @text Zoom Strength
 * @desc What is the strength of the zoom effect?
 * Use a number between 0 and 1.
 * @default 0.5
 * 
 * @arg Radius:eval
 * @text Visible Radius
 * @desc How much of a radius should be visible from the center?
 * @default 0
 * 
 * @arg Duration:eval
 * @text Duration
 * @desc What is the duration of the zoom blur?
 * @default 60
 *
 * @arg EasingType:str
 * @text Easing Type
 * @type combo
 * @option Linear
 * @option InSine
 * @option OutSine
 * @option InOutSine
 * @option InQuad
 * @option OutQuad
 * @option InOutQuad
 * @option InCubic
 * @option OutCubic
 * @option InOutCubic
 * @option InQuart
 * @option OutQuart
 * @option InOutQuart
 * @option InQuint
 * @option OutQuint
 * @option InOutQuint
 * @option InExpo
 * @option OutExpo
 * @option InOutExpo
 * @option InCirc
 * @option OutCirc
 * @option InOutCirc
 * @option InBack
 * @option OutBack
 * @option InOutBack
 * @option InElastic
 * @option OutElastic
 * @option InOutElastic
 * @option InBounce
 * @option OutBounce
 * @option InOutBounce
 * @desc Select which easing type you wish to apply.
 * @default OutSine
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Impact_ZoomBlurTargetCenter
 * @text IMPACT: Zoom Blur at Target(s) Center
 * @desc Creates a zoom blur at the center of targets.
 * Requires VisuMZ_3_ActSeqImpact!
 * 
 * @arg Targets:arraystr
 * @text Targets
 * @type combo[]
 * @option user
 * @option current target
 * @option prev target
 * @option next target
 * @option all targets
 * @option focus
 * @option not focus
 * @option
 * @option special
 * @option special x
 * @option 
 * @option alive friends
 * @option alive friends not user
 * @option alive friends not target
 * @option dead friends
 * @option friend index x
 * @option 
 * @option alive opponents
 * @option alive opponents not target
 * @option dead opponents
 * @option opponent index x
 * @option 
 * @option alive actors
 * @option alive actors not user
 * @option alive actors not target
 * @option dead actors
 * @option actor index x
 * @option actor ID x
 * @option 
 * @option alive enemies
 * @option alive enemies not user
 * @option alive enemies not target
 * @option dead enemies
 * @option enemy index x
 * @option enemy ID x
 * @option 
 * @option alive battlers
 * @option alive battlers not user
 * @option alive battlers not target
 * @option dead battlers
 * @option 
 * @desc Select unit(s) to start a zoom blur from.
 * @default ["user"]
 * 
 * @arg TargetLocation:str
 * @text Target Location
 * @parent Targets2:arraystr
 * @type combo
 * @option front head
 * @option front center
 * @option front base
 * @option middle head
 * @option middle center
 * @option middle base
 * @option back head
 * @option back center
 * @option back base
 * @desc Select which part target group to start a zoom blur from.
 * @default middle center
 * 
 * @arg OffsetX:eval
 * @text Offset X
 * @parent TargetLocation:str
 * @desc How much to offset the zoom blur X point by.
 * Negative: left. Positive: right.
 * @default +0
 * 
 * @arg OffsetY:eval
 * @text Offset Y
 * @parent TargetLocation:str
 * @desc How much to offset the zoom blur Y point by.
 * Negative: up. Positive: down.
 * @default +0
 * 
 * @arg Strength:eval
 * @text Zoom Strength
 * @desc What is the strength of the zoom effect?
 * Use a number between 0 and 1.
 * @default 0.5
 * 
 * @arg Radius:eval
 * @text Visible Radius
 * @desc How much of a radius should be visible from the center?
 * @default 0
 * 
 * @arg Duration:eval
 * @text Duration
 * @desc What is the duration of the zoom blur?
 * @default 60
 *
 * @arg EasingType:str
 * @text Easing Type
 * @type combo
 * @option Linear
 * @option InSine
 * @option OutSine
 * @option InOutSine
 * @option InQuad
 * @option OutQuad
 * @option InOutQuad
 * @option InCubic
 * @option OutCubic
 * @option InOutCubic
 * @option InQuart
 * @option OutQuart
 * @option InOutQuart
 * @option InQuint
 * @option OutQuint
 * @option InOutQuint
 * @option InExpo
 * @option OutExpo
 * @option InOutExpo
 * @option InCirc
 * @option OutCirc
 * @option InOutCirc
 * @option InBack
 * @option OutBack
 * @option InOutBack
 * @option InElastic
 * @option OutElastic
 * @option InOutElastic
 * @option InBounce
 * @option OutBounce
 * @option InOutBounce
 * @desc Select which easing type you wish to apply.
 * @default OutSine
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActionSequenceSpaceInject
 * @text -
 * @desc -
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActionSequenceBreakInject
 * @text Action Sequences - Inject
 * @desc These Action Sequences are related to injected animations.
 * Requires VisuMZ_3_ActSeqImpact!
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Inject_AnimationStart
 * @text INJECT: Animation Begin
 * @desc Injects and plays a whole spritesheet animation.
 * Requires VisuMZ_3_ActSeqImpact!
 * 
 * @arg Targets:arraystr
 * @text Targets
 * @type combo[]
 * @option user
 * @option current target
 * @option prev target
 * @option next target
 * @option all targets
 * @option focus
 * @option not focus
 * @option
 * @option special
 * @option special x
 * @option 
 * @option alive friends
 * @option alive friends not user
 * @option alive friends not target
 * @option dead friends
 * @option friend index x
 * @option 
 * @option alive opponents
 * @option alive opponents not target
 * @option dead opponents
 * @option opponent index x
 * @option 
 * @option alive actors
 * @option alive actors not user
 * @option alive actors not target
 * @option dead actors
 * @option actor index x
 * @option actor ID x
 * @option 
 * @option alive enemies
 * @option alive enemies not user
 * @option alive enemies not target
 * @option dead enemies
 * @option enemy index x
 * @option enemy ID x
 * @option 
 * @option alive battlers
 * @option alive battlers not user
 * @option alive battlers not target
 * @option dead battlers
 * @option 
 * @desc Select unit(s) to inject the animation on.
 * @default ["user"]
 * 
 * @arg Filename:str
 * @text Filename
 * @type file
 * @dir img/sv_actors/
 * @desc Select the animation spritesheet file.
 * Located in the /img/sv_actors/ folder.
 * @default Untitled
 *
 * @arg horzCells:num
 * @text Horizontal Cells
 * @parent Filename:str
 * @type number
 * @min 1
 * @desc How many horizontal cells (or columns) are there?
 * @default 1
 *
 * @arg vertCells:num
 * @text Vertical Cells
 * @parent Filename:str
 * @type number
 * @min 1
 * @desc How many vertical cells (or rows) are there?
 * @default 1
 *
 * @arg frameDelay:num
 * @text Frame Delay
 * @parent Filename:str
 * @type number
 * @min 1
 * @desc How many frames are played inbetween cells?
 * @default 1
 *
 * @arg smooth:eval
 * @text Smooth Bitmap?
 * @parent Filename:str
 * @type boolean
 * @on Smooth
 * @off Pixelated
 * @desc Smooth the spritesheet graphic?
 * @default false
 * 
 * @arg Offset
 *
 * @arg offsetX:eval
 * @text Offset X
 * @parent Offset
 * @desc Offsets the X position of the injected animation.
 * Negative: left. Positive: right.
 * @default +0
 *
 * @arg offsetY:eval
 * @text Offset Y
 * @parent Offset
 * @desc Offsets the Y position of the injected animation.
 * Negative: up. Positive: down.
 * @default +0
 * 
 * 
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Inject_AnimationEnd
 * @text INJECT: Animation End
 * @desc Stops and ends any injected animations on target(s).
 * Requires VisuMZ_3_ActSeqImpact!
 * 
 * @arg Targets:arraystr
 * @text Targets
 * @type combo[]
 * @option user
 * @option current target
 * @option prev target
 * @option next target
 * @option all targets
 * @option focus
 * @option not focus
 * @option
 * @option special
 * @option special x
 * @option 
 * @option alive friends
 * @option alive friends not user
 * @option alive friends not target
 * @option dead friends
 * @option friend index x
 * @option 
 * @option alive opponents
 * @option alive opponents not target
 * @option dead opponents
 * @option opponent index x
 * @option 
 * @option alive actors
 * @option alive actors not user
 * @option alive actors not target
 * @option dead actors
 * @option actor index x
 * @option actor ID x
 * @option 
 * @option alive enemies
 * @option alive enemies not user
 * @option alive enemies not target
 * @option dead enemies
 * @option enemy index x
 * @option enemy ID x
 * @option 
 * @option alive battlers
 * @option alive battlers not user
 * @option alive battlers not target
 * @option dead battlers
 * @option 
 * @desc Select unit(s) to stop injected animation(s).
 * @default ["user"]
 * 
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Inject_AnimationPauseResume
 * @text INJECT: Animation Pause/Resume
 * @desc Pauses/resumes any injected animations on target(s).
 * Requires VisuMZ_3_ActSeqImpact!
 * 
 * @arg Targets:arraystr
 * @text Targets
 * @type combo[]
 * @option user
 * @option current target
 * @option prev target
 * @option next target
 * @option all targets
 * @option focus
 * @option not focus
 * @option
 * @option special
 * @option special x
 * @option 
 * @option alive friends
 * @option alive friends not user
 * @option alive friends not target
 * @option dead friends
 * @option friend index x
 * @option 
 * @option alive opponents
 * @option alive opponents not target
 * @option dead opponents
 * @option opponent index x
 * @option 
 * @option alive actors
 * @option alive actors not user
 * @option alive actors not target
 * @option dead actors
 * @option actor index x
 * @option actor ID x
 * @option 
 * @option alive enemies
 * @option alive enemies not user
 * @option alive enemies not target
 * @option dead enemies
 * @option enemy index x
 * @option enemy ID x
 * @option 
 * @option alive battlers
 * @option alive battlers not user
 * @option alive battlers not target
 * @option dead battlers
 * @option 
 * @desc Select unit(s) to pause injected animation(s).
 * @default ["user"]
 *
 * @arg pause:eval
 * @text Pause?
 * @parent Filename:str
 * @type boolean
 * @on Pause
 * @off Resume
 * @desc Pause the injected animation?
 * @default true
 * 
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Inject_WaitForInjectAni
 * @text INJECT: Wait For Injected Animation
 * @desc Waits for injected animations to complete before performing
 * next command. Requires VisuMZ_3_ActSeqImpact!
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActionSequenceSpaceMechanics
 * @text -
 * @desc -
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActionSequenceBreakMechanics
 * @text Action Sequences - Mechanics
 * @desc These Action Sequences are related to various mechanics
 * related to the battle system.
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Mechanics_ActionEffect
 * @text MECH: Action Effect
 * @desc Causes the unit(s) to take damage/healing from action and
 * incurs any changes made such as buffs and states.
 * 
 * @arg Targets:arraystr
 * @text Targets
 * @type combo[]
 * @option user
 * @option current target
 * @option prev target
 * @option next target
 * @option all targets
 * @option focus
 * @option not focus
 * @option
 * @option special
 * @option special x
 * @option 
 * @option alive friends
 * @option alive friends not user
 * @option alive friends not target
 * @option dead friends
 * @option friend index x
 * @option 
 * @option alive opponents
 * @option alive opponents not target
 * @option dead opponents
 * @option opponent index x
 * @option 
 * @option alive actors
 * @option alive actors not user
 * @option alive actors not target
 * @option dead actors
 * @option actor index x
 * @option actor ID x
 * @option 
 * @option alive enemies
 * @option alive enemies not user
 * @option alive enemies not target
 * @option dead enemies
 * @option enemy index x
 * @option enemy ID x
 * @option 
 * @option alive battlers
 * @option alive battlers not user
 * @option alive battlers not target
 * @option dead battlers
 * @option 
 * @desc Select unit(s) to receive the current action's effects.
 * @default ["all targets"]
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Mechanics_ActiveChainInputDisable
 * @text MECH: Active Chain Input Disable
 * @desc Disables input for Active Chain Skills at this time.
 * Requires VisuMZ_3_ActiveChainSkills!
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Mechanics_AddBuffDebuff
 * @text MECH: Add Buff/Debuff
 * @desc Adds buff(s)/debuff(s) to unit(s). 
 * Determine which parameters are affected and their durations.
 * 
 * @arg Targets:arraystr
 * @text Targets
 * @type combo[]
 * @option user
 * @option current target
 * @option prev target
 * @option next target
 * @option all targets
 * @option focus
 * @option not focus
 * @option
 * @option special
 * @option special x
 * @option 
 * @option alive friends
 * @option alive friends not user
 * @option alive friends not target
 * @option dead friends
 * @option friend index x
 * @option 
 * @option alive opponents
 * @option alive opponents not target
 * @option dead opponents
 * @option opponent index x
 * @option 
 * @option alive actors
 * @option alive actors not user
 * @option alive actors not target
 * @option dead actors
 * @option actor index x
 * @option actor ID x
 * @option 
 * @option alive enemies
 * @option alive enemies not user
 * @option alive enemies not target
 * @option dead enemies
 * @option enemy index x
 * @option enemy ID x
 * @option 
 * @option alive battlers
 * @option alive battlers not user
 * @option alive battlers not target
 * @option dead battlers
 * @option 
 * @desc Select unit(s) to receive the buff(s) and/or debuff(s).
 * @default ["user"]
 * 
 * @arg Buffs:arraystr
 * @text Buff Parameters
 * @type combo[]
 * @option MaxHP
 * @option MaxMP
 * @option ATK
 * @option DEF
 * @option MAT
 * @option MDF
 * @option AGI
 * @option LUK
 * @desc Select which parameter(s) to buff.
 * Insert a parameter multiple times to raise its stacks.
 * @default ["ATK"]
 *
 * @arg Debuffs:arraystr
 * @text Debuff Parameters
 * @type combo[]
 * @option MaxHP
 * @option MaxMP
 * @option ATK
 * @option DEF
 * @option MAT
 * @option MDF
 * @option AGI
 * @option LUK
 * @desc Select which parameter(s) to debuff.
 * Insert a parameter multiple times to raise its stacks.
 * @default ["DEF"]
 * 
 * @arg Turns:eval
 * @text Turns
 * @desc Number of turns to set the parameter(s) buffs to.
 * You may use JavaScript code.
 * @default 5
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Mechanics_AddState
 * @text MECH: Add State
 * @desc Adds state(s) to unit(s).
 * 
 * @arg Targets:arraystr
 * @text Targets
 * @type combo[]
 * @option user
 * @option current target
 * @option prev target
 * @option next target
 * @option all targets
 * @option focus
 * @option not focus
 * @option
 * @option special
 * @option special x
 * @option 
 * @option alive friends
 * @option alive friends not user
 * @option alive friends not target
 * @option dead friends
 * @option friend index x
 * @option 
 * @option alive opponents
 * @option alive opponents not target
 * @option dead opponents
 * @option opponent index x
 * @option 
 * @option alive actors
 * @option alive actors not user
 * @option alive actors not target
 * @option dead actors
 * @option actor index x
 * @option actor ID x
 * @option 
 * @option alive enemies
 * @option alive enemies not user
 * @option alive enemies not target
 * @option dead enemies
 * @option enemy index x
 * @option enemy ID x
 * @option 
 * @option alive battlers
 * @option alive battlers not user
 * @option alive battlers not target
 * @option dead battlers
 * @option 
 * @desc Select unit(s) to receive the buff(s).
 * @default ["user"]
 * 
 * @arg States:arraynum
 * @text States
 * @type state[]
 * @desc Select which state ID(s) to add to unit(s).
 * Insert multiple state ID's to add multiple at once.
 * @default ["4"]
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Mechanics_AnalyzeWeakness
 * @text MECH: Analyze Weakness
 * @desc Reveal elemental weakness(es) from target(s).
 * Requires VisuMZ_3_WeaknessDisplay!
 * 
 * @arg Targets:arraystr
 * @text Targets
 * @type combo[]
 * @option user
 * @option current target
 * @option prev target
 * @option next target
 * @option all targets
 * @option focus
 * @option not focus
 * @option
 * @option special
 * @option special x
 * @option 
 * @option alive friends
 * @option alive friends not user
 * @option alive friends not target
 * @option dead friends
 * @option friend index x
 * @option 
 * @option alive opponents
 * @option alive opponents not target
 * @option dead opponents
 * @option opponent index x
 * @option 
 * @option alive actors
 * @option alive actors not user
 * @option alive actors not target
 * @option dead actors
 * @option actor index x
 * @option actor ID x
 * @option 
 * @option alive enemies
 * @option alive enemies not user
 * @option alive enemies not target
 * @option dead enemies
 * @option enemy index x
 * @option enemy ID x
 * @option 
 * @option alive battlers
 * @option alive battlers not user
 * @option alive battlers not target
 * @option dead battlers
 * @option 
 * @desc Select unit(s) to reveal elemental weaknesses for.
 * @default ["all targets"]
 * 
 * @arg Reveal:eval
 * @text Reveal
 * @desc How many elemental weaknesses do you wish to reveal?
 * You may use JavaScript code.
 * @default 1
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Mechanics_ArmorPenetration
 * @text MECH: Armor Penetration
 * @desc Adds an extra layer of defensive penetration/reduction.
 * You may use JavaScript code for any of these.
 *
 * @arg ArmorPenetration
 * @text Armor/Magic Penetration
 * 
 * @arg ArPenRate:eval
 * @text Rate
 * @parent ArmorPenetration
 * @desc Penetrates an extra multiplier of armor by this value.
 * @default 0.00
 * 
 * @arg ArPenFlat:eval
 * @text Flat
 * @parent ArmorPenetration
 * @desc Penetrates a flat amount of armor by this value.
 * @default 0
 *
 * @arg ArmorReduction
 * @text Armor/Magic Reduction
 * 
 * @arg ArRedRate:eval
 * @text Rate
 * @parent ArmorReduction
 * @desc Reduces an extra multiplier of armor by this value.
 * @default 0.00
 * 
 * @arg ArRedFlat:eval
 * @text Flat
 * @parent ArmorReduction
 * @desc Reduces a flat amount of armor by this value.
 * @default 0
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Mechanics_AtbGauge
 * @text MECH: ATB Gauge
 * @desc Alters the ATB/TPB Gauges.
 * Requires VisuMZ_2_BattleSystemATB!
 * 
 * @arg Targets:arraystr
 * @text Targets
 * @type combo[]
 * @option user
 * @option current target
 * @option prev target
 * @option next target
 * @option all targets
 * @option focus
 * @option not focus
 * @option
 * @option special
 * @option special x
 * @option 
 * @option alive friends
 * @option alive friends not user
 * @option alive friends not target
 * @option dead friends
 * @option friend index x
 * @option 
 * @option alive opponents
 * @option alive opponents not target
 * @option dead opponents
 * @option opponent index x
 * @option 
 * @option alive actors
 * @option alive actors not user
 * @option alive actors not target
 * @option dead actors
 * @option actor index x
 * @option actor ID x
 * @option 
 * @option alive enemies
 * @option alive enemies not user
 * @option alive enemies not target
 * @option dead enemies
 * @option enemy index x
 * @option enemy ID x
 * @option 
 * @option alive battlers
 * @option alive battlers not user
 * @option alive battlers not target
 * @option dead battlers
 * @option 
 * @desc Select unit(s) to alter the ATB/TPB Gauges for.
 * @default ["all targets"]
 *
 * @arg Charging
 * 
 * @arg ChargeRate:eval
 * @text Charge Rate
 * @parent Charging
 * @desc Changes made to the ATB Gauge if it is currently charging.
 * @default -0.00
 * 
 * @arg Casting
 * 
 * @arg CastRate:eval
 * @text Cast Rate
 * @parent Casting
 * @desc Changes made to the ATB Gauge if it is currently casting.
 * @default -0.00
 * 
 * @arg Interrupt:eval
 * @text Interrupt?
 * @parent Casting
 * @type boolean
 * @on Interrupt
 * @off Don't Interrupt
 * @desc Interrupt the ATB Gauge if it is currently casting?
 * @default false
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Mechanics_BoostPointsChange
 * @text MECH: Boost Points Change
 * @desc Changes Boost Points for target(s).
 * Requires VisuMZ_3_BoostAction!
 * 
 * @arg Targets:arraystr
 * @text Targets
 * @type combo[]
 * @option user
 * @option current target
 * @option prev target
 * @option next target
 * @option all targets
 * @option focus
 * @option not focus
 * @option
 * @option special
 * @option special x
 * @option 
 * @option alive friends
 * @option alive friends not user
 * @option alive friends not target
 * @option dead friends
 * @option friend index x
 * @option 
 * @option alive opponents
 * @option alive opponents not target
 * @option dead opponents
 * @option opponent index x
 * @option 
 * @option alive actors
 * @option alive actors not user
 * @option alive actors not target
 * @option dead actors
 * @option actor index x
 * @option actor ID x
 * @option 
 * @option alive enemies
 * @option alive enemies not user
 * @option alive enemies not target
 * @option dead enemies
 * @option enemy index x
 * @option enemy ID x
 * @option 
 * @option alive battlers
 * @option alive battlers not user
 * @option alive battlers not target
 * @option dead battlers
 * @option 
 * @desc Select unit(s) to alter the Boost Points for.
 * @default ["user"]
 * 
 * @arg BoostPoints:eval
 * @text Alter Boost Points By
 * @desc Alters the unit(s) Boost Points.
 * Positive for gaining points. Negative for losing points.
 * @default +1
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Mechanics_BoostPointsStoreData
 * @text MECH: Boost Store Data
 * @desc Stores the number of Boosts used this action inside a variable.
 * Requires VisuMZ_3_BoostAction!
 * 
 * @arg VariableID:num
 * @text Variable ID
 * @type variable
 * @desc Which variable do you want to store the data inside?
 * @default 1
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Mechanics_BreakShieldChange
 * @text MECH: Break Shield Change
 * @desc Changes Break Shields for target(s) if not Break Stunned.
 * Requires VisuMZ_4_BreakShields!
 * 
 * @arg Targets:arraystr
 * @text Targets
 * @type combo[]
 * @option user
 * @option current target
 * @option prev target
 * @option next target
 * @option all targets
 * @option focus
 * @option not focus
 * @option
 * @option special
 * @option special x
 * @option 
 * @option alive friends
 * @option alive friends not user
 * @option alive friends not target
 * @option dead friends
 * @option friend index x
 * @option 
 * @option alive opponents
 * @option alive opponents not target
 * @option dead opponents
 * @option opponent index x
 * @option 
 * @option alive actors
 * @option alive actors not user
 * @option alive actors not target
 * @option dead actors
 * @option actor index x
 * @option actor ID x
 * @option 
 * @option alive enemies
 * @option alive enemies not user
 * @option alive enemies not target
 * @option dead enemies
 * @option enemy index x
 * @option enemy ID x
 * @option 
 * @option alive battlers
 * @option alive battlers not user
 * @option alive battlers not target
 * @option dead battlers
 * @option 
 * @desc Select unit(s) to alter the Break Shields for.
 * @default ["all targets"]
 * 
 * @arg BreakShields:eval
 * @text Alter Break Shields By
 * @desc Alters the unit(s) Break Shields.
 * Positive for gaining shields. Negative for losing shields.
 * @default -1
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Mechanics_BreakShieldReset
 * @text MECH: Break Shield Reset
 * @desc Resets Break Shields for target(s) if not Break Stunned.
 * Requires VisuMZ_4_BreakShields!
 * 
 * @arg Targets:arraystr
 * @text Targets
 * @type combo[]
 * @option user
 * @option current target
 * @option prev target
 * @option next target
 * @option all targets
 * @option focus
 * @option not focus
 * @option
 * @option special
 * @option special x
 * @option 
 * @option alive friends
 * @option alive friends not user
 * @option alive friends not target
 * @option dead friends
 * @option friend index x
 * @option 
 * @option alive opponents
 * @option alive opponents not target
 * @option dead opponents
 * @option opponent index x
 * @option 
 * @option alive actors
 * @option alive actors not user
 * @option alive actors not target
 * @option dead actors
 * @option actor index x
 * @option actor ID x
 * @option 
 * @option alive enemies
 * @option alive enemies not user
 * @option alive enemies not target
 * @option dead enemies
 * @option enemy index x
 * @option enemy ID x
 * @option 
 * @option alive battlers
 * @option alive battlers not user
 * @option alive battlers not target
 * @option dead battlers
 * @option 
 * @desc Select unit(s) to reset the Break Shields for.
 * @default ["all targets"]
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Mechanics_BtbGain
 * @text MECH: BTB Brave Points
 * @desc Alters the target(s) Brave Points to an exact value.
 * Requires VisuMZ_2_BattleSystemBTB!
 * 
 * @arg Targets:arraystr
 * @text Targets
 * @type combo[]
 * @option user
 * @option current target
 * @option prev target
 * @option next target
 * @option all targets
 * @option focus
 * @option not focus
 * @option
 * @option special
 * @option special x
 * @option 
 * @option alive friends
 * @option alive friends not user
 * @option alive friends not target
 * @option dead friends
 * @option friend index x
 * @option 
 * @option alive opponents
 * @option alive opponents not target
 * @option dead opponents
 * @option opponent index x
 * @option 
 * @option alive actors
 * @option alive actors not user
 * @option alive actors not target
 * @option dead actors
 * @option actor index x
 * @option actor ID x
 * @option 
 * @option alive enemies
 * @option alive enemies not user
 * @option alive enemies not target
 * @option dead enemies
 * @option enemy index x
 * @option enemy ID x
 * @option 
 * @option alive battlers
 * @option alive battlers not user
 * @option alive battlers not target
 * @option dead battlers
 * @option 
 * @desc Select unit(s) to alter the ATB/TPB Gauges for.
 * @default ["all targets"]
 * 
 * @arg BravePoints:eval
 * @text Alter Brave Points By
 * @desc Alters the target(s) Brave Points.
 * Positive for gaining BP. Negative for losing BP.
 * @default +1
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Mechanics_Collapse
 * @text MECH: Collapse
 * @desc Causes the unit(s) to perform its collapse animation
 * if the unit(s) has died.
 * 
 * @arg Targets:arraystr
 * @text Targets
 * @type combo[]
 * @option user
 * @option current target
 * @option prev target
 * @option next target
 * @option all targets
 * @option focus
 * @option not focus
 * @option
 * @option special
 * @option special x
 * @option 
 * @option alive friends
 * @option alive friends not user
 * @option alive friends not target
 * @option dead friends
 * @option friend index x
 * @option 
 * @option alive opponents
 * @option alive opponents not target
 * @option dead opponents
 * @option opponent index x
 * @option 
 * @option alive actors
 * @option alive actors not user
 * @option alive actors not target
 * @option dead actors
 * @option actor index x
 * @option actor ID x
 * @option 
 * @option alive enemies
 * @option alive enemies not user
 * @option alive enemies not target
 * @option dead enemies
 * @option enemy index x
 * @option enemy ID x
 * @option 
 * @option alive battlers
 * @option alive battlers not user
 * @option alive battlers not target
 * @option dead battlers
 * @option 
 * @desc Select unit(s) to process a death collapse.
 * @default ["all targets"]
 * 
 * @arg ForceDeath:eval
 * @text Force Death
 * @type boolean
 * @on On
 * @off Off
 * @desc Force death even if the unit has not reached 0 HP?
 * This will remove immortality.
 * @default false
 * 
 * @arg WaitForEffect:eval
 * @text Wait For Effect?
 * @type boolean
 * @on On
 * @off Off
 * @desc Wait for the collapse effect to complete before performing next command?
 * @default true
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Mechanics_CtbOrder
 * @text MECH: CTB Order
 * @desc Alters the CTB Turn Order.
 * Requires VisuMZ_2_BattleSystemCTB!
 * 
 * @arg Targets:arraystr
 * @text Targets
 * @type combo[]
 * @option user
 * @option current target
 * @option prev target
 * @option next target
 * @option all targets
 * @option focus
 * @option not focus
 * @option
 * @option special
 * @option special x
 * @option 
 * @option alive friends
 * @option alive friends not user
 * @option alive friends not target
 * @option dead friends
 * @option friend index x
 * @option 
 * @option alive opponents
 * @option alive opponents not target
 * @option dead opponents
 * @option opponent index x
 * @option 
 * @option alive actors
 * @option alive actors not user
 * @option alive actors not target
 * @option dead actors
 * @option actor index x
 * @option actor ID x
 * @option 
 * @option alive enemies
 * @option alive enemies not user
 * @option alive enemies not target
 * @option dead enemies
 * @option enemy index x
 * @option enemy ID x
 * @option 
 * @option alive battlers
 * @option alive battlers not user
 * @option alive battlers not target
 * @option dead battlers
 * @option 
 * @desc Select unit(s) to alter the CTB Turn Order for.
 * @default ["all targets"]
 *
 * @arg ChangeOrderBy:eval
 * @text Change Order By
 * @parent Charging
 * @desc Changes turn order for target(s) by this amount.
 * Positive increases wait. Negative decreases wait.
 * @default +1
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Mechanics_CtbSpeed
 * @text MECH: CTB Speed
 * @desc Alters the CTB Speed.
 * Requires VisuMZ_2_BattleSystemCTB!
 * 
 * @arg Targets:arraystr
 * @text Targets
 * @type combo[]
 * @option user
 * @option current target
 * @option prev target
 * @option next target
 * @option all targets
 * @option focus
 * @option not focus
 * @option
 * @option special
 * @option special x
 * @option 
 * @option alive friends
 * @option alive friends not user
 * @option alive friends not target
 * @option dead friends
 * @option friend index x
 * @option 
 * @option alive opponents
 * @option alive opponents not target
 * @option dead opponents
 * @option opponent index x
 * @option 
 * @option alive actors
 * @option alive actors not user
 * @option alive actors not target
 * @option dead actors
 * @option actor index x
 * @option actor ID x
 * @option 
 * @option alive enemies
 * @option alive enemies not user
 * @option alive enemies not target
 * @option dead enemies
 * @option enemy index x
 * @option enemy ID x
 * @option 
 * @option alive battlers
 * @option alive battlers not user
 * @option alive battlers not target
 * @option dead battlers
 * @option 
 * @desc Select unit(s) to alter the CTB Speed for.
 * @default ["all targets"]
 *
 * @arg ChargeRate:eval
 * @text Charge Rate
 * @parent Charging
 * @desc Changes made to the CTB Speed if it is currently charging.
 * @default -0.00
 * 
 * @arg CastRate:eval
 * @text Cast Rate
 * @parent Casting
 * @desc Changes made to the CTB Speed if it is currently casting.
 * @default -0.00
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Mechanics_CustomDmgFormula
 * @text MECH: Custom Damage Formula
 * @desc Changes the current action's damage formula to custom.
 * This will assume the MANUAL damage style.
 * 
 * @arg Formula:str
 * @text Formula
 * @desc Changes the current action's damage formula to custom.
 * Use 'default' to revert the damage formula.
 * @default default
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Mechanics_DamagePopup
 * @text MECH: Damage Popup
 * @desc Causes the unit(s) to display the current state of
 * damage received or healed.
 * 
 * @arg Targets:arraystr
 * @text Targets
 * @type combo[]
 * @option user
 * @option current target
 * @option prev target
 * @option next target
 * @option all targets
 * @option focus
 * @option not focus
 * @option
 * @option special
 * @option special x
 * @option 
 * @option alive friends
 * @option alive friends not user
 * @option alive friends not target
 * @option dead friends
 * @option friend index x
 * @option 
 * @option alive opponents
 * @option alive opponents not target
 * @option dead opponents
 * @option opponent index x
 * @option 
 * @option alive actors
 * @option alive actors not user
 * @option alive actors not target
 * @option dead actors
 * @option actor index x
 * @option actor ID x
 * @option 
 * @option alive enemies
 * @option alive enemies not user
 * @option alive enemies not target
 * @option dead enemies
 * @option enemy index x
 * @option enemy ID x
 * @option 
 * @option alive battlers
 * @option alive battlers not user
 * @option alive battlers not target
 * @option dead battlers
 * @option 
 * @desc Select unit(s) to prompt a damage popup.
 * @default ["all targets"]
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Mechanics_DeathBreak
 * @text MECH: Dead Label Jump
 * @desc If the active battler is dead, jump to a specific label in the common event.
 * 
 * @arg JumpToLabel:str
 * @text Jump To Label
 * @desc If the active battler is dead, jump to this specific label in the common event.
 * @default Untitled
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Mechanics_EmulateAttackEffect
 * @text MECH: Emulate Attack Effect
 * @desc Emulate an "Action Effect" but using a the user's
 * attack skill instead of the current action.
 * 
 * @arg Users:arraystr
 * @text User(s)
 * @type combo[]
 * @option user
 * @option current target
 * @option prev target
 * @option next target
 * @option all targets
 * @option focus
 * @option not focus
 * @option
 * @option special
 * @option special x
 * @option 
 * @option alive friends
 * @option alive friends not user
 * @option alive friends not target
 * @option dead friends
 * @option friend index x
 * @option 
 * @option alive opponents
 * @option alive opponents not target
 * @option dead opponents
 * @option opponent index x
 * @option 
 * @option alive actors
 * @option alive actors not user
 * @option alive actors not target
 * @option dead actors
 * @option actor index x
 * @option actor ID x
 * @option 
 * @option alive enemies
 * @option alive enemies not user
 * @option alive enemies not target
 * @option dead enemies
 * @option enemy index x
 * @option enemy ID x
 * @option 
 * @option alive battlers
 * @option alive battlers not user
 * @option alive battlers not target
 * @option dead battlers
 * @option 
 * @desc Select unit(s) to perform the action's effects.
 * @default ["user"]
 * 
 * @arg Targets:arraystr
 * @text Targets
 * @type combo[]
 * @option user
 * @option current target
 * @option prev target
 * @option next target
 * @option all targets
 * @option focus
 * @option not focus
 * @option
 * @option special
 * @option special x
 * @option 
 * @option alive friends
 * @option alive friends not user
 * @option alive friends not target
 * @option dead friends
 * @option friend index x
 * @option 
 * @option alive opponents
 * @option alive opponents not target
 * @option dead opponents
 * @option opponent index x
 * @option 
 * @option alive actors
 * @option alive actors not user
 * @option alive actors not target
 * @option dead actors
 * @option actor index x
 * @option actor ID x
 * @option 
 * @option alive enemies
 * @option alive enemies not user
 * @option alive enemies not target
 * @option dead enemies
 * @option enemy index x
 * @option enemy ID x
 * @option 
 * @option alive battlers
 * @option alive battlers not user
 * @option alive battlers not target
 * @option dead battlers
 * @option 
 * @desc Select unit(s) to receive the current action's effects.
 * @default ["all targets"]
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Mechanics_EmulateGuardEffect
 * @text MECH: Emulate Guard Effect
 * @desc Emulate an "Action Effect" but using a the user's
 * guard skill instead of the current action.
 * 
 * @arg Users:arraystr
 * @text User(s)
 * @type combo[]
 * @option user
 * @option current target
 * @option prev target
 * @option next target
 * @option all targets
 * @option focus
 * @option not focus
 * @option
 * @option special
 * @option special x
 * @option 
 * @option alive friends
 * @option alive friends not user
 * @option alive friends not target
 * @option dead friends
 * @option friend index x
 * @option 
 * @option alive opponents
 * @option alive opponents not target
 * @option dead opponents
 * @option opponent index x
 * @option 
 * @option alive actors
 * @option alive actors not user
 * @option alive actors not target
 * @option dead actors
 * @option actor index x
 * @option actor ID x
 * @option 
 * @option alive enemies
 * @option alive enemies not user
 * @option alive enemies not target
 * @option dead enemies
 * @option enemy index x
 * @option enemy ID x
 * @option 
 * @option alive battlers
 * @option alive battlers not user
 * @option alive battlers not target
 * @option dead battlers
 * @option 
 * @desc Select unit(s) to perform the action's effects.
 * @default ["user"]
 * 
 * @arg Targets:arraystr
 * @text Targets
 * @type combo[]
 * @option user
 * @option current target
 * @option prev target
 * @option next target
 * @option all targets
 * @option focus
 * @option not focus
 * @option
 * @option special
 * @option special x
 * @option 
 * @option alive friends
 * @option alive friends not user
 * @option alive friends not target
 * @option dead friends
 * @option friend index x
 * @option 
 * @option alive opponents
 * @option alive opponents not target
 * @option dead opponents
 * @option opponent index x
 * @option 
 * @option alive actors
 * @option alive actors not user
 * @option alive actors not target
 * @option dead actors
 * @option actor index x
 * @option actor ID x
 * @option 
 * @option alive enemies
 * @option alive enemies not user
 * @option alive enemies not target
 * @option dead enemies
 * @option enemy index x
 * @option enemy ID x
 * @option 
 * @option alive battlers
 * @option alive battlers not user
 * @option alive battlers not target
 * @option dead battlers
 * @option 
 * @desc Select unit(s) to receive the current action's effects.
 * @default ["all targets"]
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Mechanics_EmulateItemEffect
 * @text MECH: Emulate Item Effect
 * @desc Emulate an "Action Effect" but using a specific item
 * instead of the current action.
 * 
 * @arg ItemID:eval
 * @text Item ID
 * @type item
 * @desc Which item ID will be emulated?
 * @default 7
 * 
 * @arg Users:arraystr
 * @text User(s)
 * @type combo[]
 * @option user
 * @option current target
 * @option prev target
 * @option next target
 * @option all targets
 * @option focus
 * @option not focus
 * @option
 * @option special
 * @option special x
 * @option 
 * @option alive friends
 * @option alive friends not user
 * @option alive friends not target
 * @option dead friends
 * @option friend index x
 * @option 
 * @option alive opponents
 * @option alive opponents not target
 * @option dead opponents
 * @option opponent index x
 * @option 
 * @option alive actors
 * @option alive actors not user
 * @option alive actors not target
 * @option dead actors
 * @option actor index x
 * @option actor ID x
 * @option 
 * @option alive enemies
 * @option alive enemies not user
 * @option alive enemies not target
 * @option dead enemies
 * @option enemy index x
 * @option enemy ID x
 * @option 
 * @option alive battlers
 * @option alive battlers not user
 * @option alive battlers not target
 * @option dead battlers
 * @option 
 * @desc Select unit(s) to perform the action's effects.
 * @default ["user"]
 * 
 * @arg Targets:arraystr
 * @text Targets
 * @type combo[]
 * @option user
 * @option current target
 * @option prev target
 * @option next target
 * @option all targets
 * @option focus
 * @option not focus
 * @option
 * @option special
 * @option special x
 * @option 
 * @option alive friends
 * @option alive friends not user
 * @option alive friends not target
 * @option dead friends
 * @option friend index x
 * @option 
 * @option alive opponents
 * @option alive opponents not target
 * @option dead opponents
 * @option opponent index x
 * @option 
 * @option alive actors
 * @option alive actors not user
 * @option alive actors not target
 * @option dead actors
 * @option actor index x
 * @option actor ID x
 * @option 
 * @option alive enemies
 * @option alive enemies not user
 * @option alive enemies not target
 * @option dead enemies
 * @option enemy index x
 * @option enemy ID x
 * @option 
 * @option alive battlers
 * @option alive battlers not user
 * @option alive battlers not target
 * @option dead battlers
 * @option 
 * @desc Select unit(s) to receive the current action's effects.
 * @default ["all targets"]
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Mechanics_EmulateSkillCost
 * @text MECH: Emulate Skill Cost
 * @desc Pick a skill for target(s) to emulate paying the cost of.
 * Includes cooldowns and limited uses.
 * 
 * @arg SkillID:eval
 * @text Skill ID
 * @type skill
 * @desc Which skill ID will have its cost paid for?
 * Use 0 for current action's skill.
 * @default 0
 * 
 * @arg Users:arraystr
 * @text User(s)
 * @type combo[]
 * @option user
 * @option current target
 * @option prev target
 * @option next target
 * @option all targets
 * @option focus
 * @option not focus
 * @option
 * @option special
 * @option special x
 * @option 
 * @option alive friends
 * @option alive friends not user
 * @option alive friends not target
 * @option dead friends
 * @option friend index x
 * @option 
 * @option alive opponents
 * @option alive opponents not target
 * @option dead opponents
 * @option opponent index x
 * @option 
 * @option alive actors
 * @option alive actors not user
 * @option alive actors not target
 * @option dead actors
 * @option actor index x
 * @option actor ID x
 * @option 
 * @option alive enemies
 * @option alive enemies not user
 * @option alive enemies not target
 * @option dead enemies
 * @option enemy index x
 * @option enemy ID x
 * @option 
 * @option alive battlers
 * @option alive battlers not user
 * @option alive battlers not target
 * @option dead battlers
 * @option 
 * @desc Select unit(s) to perform the action's effects.
 * @default ["user"]
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Mechanics_EmulateSkillEffect
 * @text MECH: Emulate Skill Effect
 * @desc Emulate an "Action Effect" but using a specific skill
 * instead of the current action.
 * 
 * @arg SkillID:eval
 * @text Skill ID
 * @type skill
 * @desc Which skill ID will be emulated?
 * @default 99
 * 
 * @arg Users:arraystr
 * @text User(s)
 * @type combo[]
 * @option user
 * @option current target
 * @option prev target
 * @option next target
 * @option all targets
 * @option focus
 * @option not focus
 * @option
 * @option special
 * @option special x
 * @option 
 * @option alive friends
 * @option alive friends not user
 * @option alive friends not target
 * @option dead friends
 * @option friend index x
 * @option 
 * @option alive opponents
 * @option alive opponents not target
 * @option dead opponents
 * @option opponent index x
 * @option 
 * @option alive actors
 * @option alive actors not user
 * @option alive actors not target
 * @option dead actors
 * @option actor index x
 * @option actor ID x
 * @option 
 * @option alive enemies
 * @option alive enemies not user
 * @option alive enemies not target
 * @option dead enemies
 * @option enemy index x
 * @option enemy ID x
 * @option 
 * @option alive battlers
 * @option alive battlers not user
 * @option alive battlers not target
 * @option dead battlers
 * @option 
 * @desc Select unit(s) to perform the action's effects.
 * @default ["user"]
 * 
 * @arg Targets:arraystr
 * @text Targets
 * @type combo[]
 * @option user
 * @option current target
 * @option prev target
 * @option next target
 * @option all targets
 * @option focus
 * @option not focus
 * @option
 * @option special
 * @option special x
 * @option 
 * @option alive friends
 * @option alive friends not user
 * @option alive friends not target
 * @option dead friends
 * @option friend index x
 * @option 
 * @option alive opponents
 * @option alive opponents not target
 * @option dead opponents
 * @option opponent index x
 * @option 
 * @option alive actors
 * @option alive actors not user
 * @option alive actors not target
 * @option dead actors
 * @option actor index x
 * @option actor ID x
 * @option 
 * @option alive enemies
 * @option alive enemies not user
 * @option alive enemies not target
 * @option dead enemies
 * @option enemy index x
 * @option enemy ID x
 * @option 
 * @option alive battlers
 * @option alive battlers not user
 * @option alive battlers not target
 * @option dead battlers
 * @option 
 * @desc Select unit(s) to receive the current action's effects.
 * @default ["all targets"]
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Mechanics_EnemyEscape
 * @text MECH: Enemy Escape
 * @desc Causes the enemy unit(s) to escape.
 * 
 * @arg Targets:arraystr
 * @text Targets
 * @type combo[]
 * @option user
 * @option current target
 * @option prev target
 * @option next target
 * @option all targets
 * @option focus
 * @option not focus
 * @option
 * @option special
 * @option special x
 * @option 
 * @option alive friends
 * @option alive friends not user
 * @option alive friends not target
 * @option dead friends
 * @option friend index x
 * @option 
 * @option alive opponents
 * @option alive opponents not target
 * @option dead opponents
 * @option opponent index x
 * @option 
 * @option alive enemies
 * @option alive enemies not user
 * @option alive enemies not target
 * @option dead enemies
 * @option enemy index x
 * @option enemy ID x
 * @option 
 * @option alive battlers
 * @option alive battlers not user
 * @option alive battlers not target
 * @option dead battlers
 * @option 
 * @desc Select unit(s) to escape.
 * @default ["user"]
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Mechanics_EtbAction
 * @text MECH: ETB Energy Count
 * @desc Alters the subject team's available Energy Count.
 * Requires VisuMZ_2_BattleSystemETB!
 * 
 * @arg ActionCount:eval
 * @text Energy Count
 * @desc Alters the subject team's available Energy Count.
 * Positive for gaining energy. Negative for losing energy.
 * @default +1
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Mechanics_FtbAction
 * @text MECH: FTB Action Count
 * @desc Alters the subject team's available Action Count.
 * Requires VisuMZ_2_BattleSystemFTB!
 * 
 * @arg ActionCount:eval
 * @text Action Count
 * @desc Alters the subject team's available Action Count.
 * Positive for gaining actions. Negative for losing actions.
 * @default +1
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Mechanics_HpMpTp
 * @text MECH: HP, MP, TP
 * @desc Alters the HP, MP, and TP values for unit(s).
 * Positive values for healing. Negative values for damage.
 * 
 * @arg Targets:arraystr
 * @text Targets
 * @type combo[]
 * @option user
 * @option current target
 * @option prev target
 * @option next target
 * @option all targets
 * @option focus
 * @option not focus
 * @option
 * @option special
 * @option special x
 * @option 
 * @option alive friends
 * @option alive friends not user
 * @option alive friends not target
 * @option dead friends
 * @option friend index x
 * @option 
 * @option alive opponents
 * @option alive opponents not target
 * @option dead opponents
 * @option opponent index x
 * @option 
 * @option alive actors
 * @option alive actors not user
 * @option alive actors not target
 * @option dead actors
 * @option actor index x
 * @option actor ID x
 * @option 
 * @option alive enemies
 * @option alive enemies not user
 * @option alive enemies not target
 * @option dead enemies
 * @option enemy index x
 * @option enemy ID x
 * @option 
 * @option alive battlers
 * @option alive battlers not user
 * @option alive battlers not target
 * @option dead battlers
 * @option 
 * @desc Select unit(s) to receive the current action's effects.
 * @default ["user"]
 *
 * @arg HP
 * 
 * @arg HP_Rate:eval
 * @text HP Rate
 * @parent HP
 * @desc Changes made to HP based on rate.
 * Positive values for healing. Negative values for damage.
 * @default +0.00
 * 
 * @arg HP_Flat:eval
 * @text HP Flat
 * @parent HP
 * @desc Flat changes made to HP.
 * Positive values for healing. Negative values for damage.
 * @default +0
 * 
 * @arg MP
 * 
 * @arg MP_Rate:eval
 * @text MP Rate
 * @parent MP
 * @desc Changes made to MP based on rate.
 * Positive values for healing. Negative values for damage.
 * @default +0.00
 * 
 * @arg MP_Flat:eval
 * @text MP Flat
 * @parent MP
 * @desc Flat changes made to MP.
 * Positive values for healing. Negative values for damage.
 * @default +0
 *
 * @arg TP
 * 
 * @arg TP_Rate:eval
 * @text TP Rate
 * @parent TP
 * @desc Changes made to TP based on rate.
 * Positive values for healing. Negative values for damage.
 * @default +0.00
 * 
 * @arg TP_Flat:eval
 * @text TP Flat
 * @parent TP
 * @desc Flat changes made to TP.
 * Positive values for healing. Negative values for damage.
 * @default +0
 * 
 * @arg ShowPopup:eval
 * @text Damage Popup?
 * @type boolean
 * @on On
 * @off Off
 * @desc Display a damage popup after?
 * @default true
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Mechanics_Immortal
 * @text MECH: Immortal
 * @desc Changes the immortal flag of targets. If immortal flag is
 * removed and a unit would die, collapse that unit.
 * 
 * @arg Targets:arraystr
 * @text Targets
 * @type combo[]
 * @option user
 * @option current target
 * @option prev target
 * @option next target
 * @option all targets
 * @option focus
 * @option not focus
 * @option
 * @option special
 * @option special x
 * @option 
 * @option alive friends
 * @option alive friends not user
 * @option alive friends not target
 * @option dead friends
 * @option friend index x
 * @option 
 * @option alive opponents
 * @option alive opponents not target
 * @option dead opponents
 * @option opponent index x
 * @option 
 * @option alive actors
 * @option alive actors not user
 * @option alive actors not target
 * @option dead actors
 * @option actor index x
 * @option actor ID x
 * @option 
 * @option alive enemies
 * @option alive enemies not user
 * @option alive enemies not target
 * @option dead enemies
 * @option enemy index x
 * @option enemy ID x
 * @option 
 * @option alive battlers
 * @option alive battlers not user
 * @option alive battlers not target
 * @option dead battlers
 * @option 
 * @desc Alter the immortal flag of these groups. If immortal flag
 * is removed and a unit would die, collapse that unit.
 * @default ["user","all targets"]
 * 
 * @arg Immortal:eval
 * @text Immortal
 * @type boolean
 * @on On
 * @off Off
 * @desc Turn immortal flag for unit(s) on/off?
 * @default false
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Mechanics_Multipliers
 * @text MECH: Multipliers
 * @desc Changes the multipliers for the current action.
 * You may use JavaScript code for any of these.
 *
 * @arg CriticalHit
 * @text Critical Hit%
 * 
 * @arg CriticalHitRate:eval
 * @text Rate
 * @parent CriticalHit
 * @desc Affects chance to land a critical hit by this multiplier.
 * @default 1.00
 * 
 * @arg CriticalHitFlat:eval
 * @text Flat
 * @parent CriticalHit
 * @desc Affects chance to land a critical hit by this flat bonus.
 * @default +0.00
 *
 * @arg CriticalDmg
 * @text Critical Damage
 * 
 * @arg CriticalDmgRate:eval
 * @text Rate
 * @parent CriticalDmg
 * @desc Affects critical damage by this multiplier.
 * @default 1.00
 * 
 * @arg CriticalDmgFlat:eval
 * @text Flat
 * @parent CriticalDmg
 * @desc Affects critical damage by this flat bonus.
 * @default +0.00
 *
 * @arg Damage
 * @text Damage/Healing
 * 
 * @arg DamageRate:eval
 * @text Rate
 * @parent Damage
 * @desc Sets the damage/healing multiplier for current action.
 * @default 1.00
 * 
 * @arg DamageFlat:eval
 * @text Flat
 * @parent Damage
 * @desc Sets the damage/healing bonus for current action.
 * @default +0.00
 *
 * @arg HitRate
 * @text Hit Rate
 * 
 * @arg HitRate:eval
 * @text Rate
 * @parent HitRate
 * @desc Affects chance to connect attack by this multiplier.
 * @default 1.00
 * 
 * @arg HitFlat:eval
 * @text Flat
 * @parent HitRate
 * @desc Affects chance to connect attack by this flat bonus.
 * @default +0.00
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Mechanics_OnceParallel
 * @text MECH: Once Parallel
 * @desc Plays a Common Event parallel to the battle event once
 * without repeating itself when done.
 *
 * @arg CommonEventID:num
 * @text Common Event ID
 * @type common_event
 * @desc The ID of the parallel Common Event to play.
 * Does NOT repeat itself when finished.
 * @default 1
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Mechanics_OtbOrder
 * @text MECH: OTB Order
 * @desc Alters the OTB Turn Order. Best used with single targets.
 * Requires VisuMZ_2_BattleSystemOTB!
 * 
 * @arg Targets:arraystr
 * @text Targets
 * @type combo[]
 * @option user
 * @option current target
 * @option prev target
 * @option next target
 * @option all targets
 * @option focus
 * @option not focus
 * @option
 * @option special
 * @option special x
 * @option 
 * @option alive friends
 * @option alive friends not user
 * @option alive friends not target
 * @option dead friends
 * @option friend index x
 * @option 
 * @option alive opponents
 * @option alive opponents not target
 * @option dead opponents
 * @option opponent index x
 * @option 
 * @option alive actors
 * @option alive actors not user
 * @option alive actors not target
 * @option dead actors
 * @option actor index x
 * @option actor ID x
 * @option 
 * @option alive enemies
 * @option alive enemies not user
 * @option alive enemies not target
 * @option dead enemies
 * @option enemy index x
 * @option enemy ID x
 * @option 
 * @option alive battlers
 * @option alive battlers not user
 * @option alive battlers not target
 * @option dead battlers
 * @option 
 * @desc Select unit(s) to alter the OTB Turn Order for.
 * @default ["all targets"]
 *
 * @arg CurrentTurn:eval
 * @text Current Turn By
 * @parent Charging
 * @desc Changes turn order for target(s) by this amount.
 * Positive increases wait. Negative decreases wait.
 * @default +0
 *
 * @arg NextTurn:eval
 * @text Next Turn By
 * @parent Charging
 * @desc Changes turn order for target(s) by this amount.
 * Positive increases wait. Negative decreases wait.
 * @default +1
 *
 * @arg FollowTurn:eval
 * @text Follow Turn By
 * @parent Charging
 * @desc Changes turn order for target(s) by this amount.
 * Positive increases wait. Negative decreases wait.
 * @default +0
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Mechanics_PtbAlterCost
 * @text MECH: PTB Alter Cost
 * @desc Alters the action's cost settings.
 * Requires VisuMZ_2_BattleSystemPTB!
 *
 * @arg Override:eval
 * @text Override?
 * @type boolean
 * @on Override Permanent
 * @off Require Temporary
 * @desc Overrides any 'permanent' settings for Changeability?
 * @default false
 *
 * @arg alterChange:str
 * @text Alter Changeability
 * @type select
 * @option Unchanged - Cost type is unchanged after this effect
 * @value unchanged
 * @option Permanent - Cost type can no longer be changed after
 * @value permanent
 * @option Temporary - Cost type can still be changed after
 * @value temporary
 * @desc Allow the cost type and value to be changeable?
 * @default unchanged
 *
 * @arg alterType:str
 * @text Alter Cost Type
 * @type select
 * @option Unchanged - No changes are made
 * @value unchanged
 * @option Consume - Removes half, otherwise consumes full
 * @value consume
 * @option Convert - Converts full => half, otherwise consumes half
 * @value convert
 * @option Compress - Consumes half, otherwise converts full => half
 * @value compress
 * @desc Change the cost type to this scenario.
 * Use 'Unchanged' for no changes.
 * @default convert
 *
 * @arg alterCost:eval
 * @text Alter Cost Value
 * @desc What is the default action cost for this scenario?
 * @default +0
 *
 * @arg alterPriority:eval
 * @text Priority
 * @desc What is this scenario's priority? Scenario outcomes with
 * equal or lower priorities cannot override types and costs.
 * @default 50
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Mechanics_PtbConvert
 * @text MECH: PTB Conversion
 * @desc Converts full actions into half actions.
 * Requires VisuMZ_2_BattleSystemPTB!
 * 
 * @arg ConvertCount:eval
 * @text Conversion Count
 * @desc Converts full actions into half actions.
 * If not enough, consume half actions.
 * @default 1
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Mechanics_PtbFullHalfAction
 * @text MECH: PTB Full/Half Action(s)
 * @desc Alters the subject team's available Full/Half Actions.
 * Requires VisuMZ_2_BattleSystemPTB!
 * 
 * @arg FullActions:eval
 * @text Full Actions
 * @desc Alters the subject team's available Full Actions.
 * Positive for gaining. Negative for losing.
 * @default +0
 * 
 * @arg HalfActions:eval
 * @text Half Actions
 * @desc Alters the subject team's available Half Actions.
 * Positive for gaining. Negative for losing.
 * @default +0
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Mechanics_RemoveBuffDebuff
 * @text MECH: Remove Buff/Debuff
 * @desc Removes buff(s)/debuff(s) from unit(s). 
 * Determine which parameters are removed.
 * 
 * @arg Targets:arraystr
 * @text Targets
 * @type combo[]
 * @option user
 * @option current target
 * @option prev target
 * @option next target
 * @option all targets
 * @option focus
 * @option not focus
 * @option
 * @option special
 * @option special x
 * @option 
 * @option alive friends
 * @option alive friends not user
 * @option alive friends not target
 * @option dead friends
 * @option friend index x
 * @option 
 * @option alive opponents
 * @option alive opponents not target
 * @option dead opponents
 * @option opponent index x
 * @option 
 * @option alive actors
 * @option alive actors not user
 * @option alive actors not target
 * @option dead actors
 * @option actor index x
 * @option actor ID x
 * @option 
 * @option alive enemies
 * @option alive enemies not user
 * @option alive enemies not target
 * @option dead enemies
 * @option enemy index x
 * @option enemy ID x
 * @option 
 * @option alive battlers
 * @option alive battlers not user
 * @option alive battlers not target
 * @option dead battlers
 * @option 
 * @desc Select unit(s) to have the buff(s) and/or debuff(s) removed.
 * @default ["user"]
 * 
 * @arg Buffs:arraystr
 * @text Buff Parameters
 * @type combo[]
 * @option MaxHP
 * @option MaxMP
 * @option ATK
 * @option DEF
 * @option MAT
 * @option MDF
 * @option AGI
 * @option LUK
 * @desc Select which buffed parameter(s) to remove.
 * @default ["MaxHP","MaxMP","ATK","DEF","MAT","MDF","AGI","LUK"]
 *
 * @arg Debuffs:arraystr
 * @text Debuff Parameters
 * @type combo[]
 * @option MaxHP
 * @option MaxMP
 * @option ATK
 * @option DEF
 * @option MAT
 * @option MDF
 * @option AGI
 * @option LUK
 * @desc Select which debuffed parameter(s) to remove.
 * @default ["MaxHP","MaxMP","ATK","DEF","MAT","MDF","AGI","LUK"]
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Mechanics_RemoveState
 * @text MECH: Remove State
 * @desc Remove state(s) from unit(s).
 * 
 * @arg Targets:arraystr
 * @text Targets
 * @type combo[]
 * @option user
 * @option current target
 * @option prev target
 * @option next target
 * @option all targets
 * @option focus
 * @option not focus
 * @option
 * @option special
 * @option special x
 * @option 
 * @option alive friends
 * @option alive friends not user
 * @option alive friends not target
 * @option dead friends
 * @option friend index x
 * @option 
 * @option alive opponents
 * @option alive opponents not target
 * @option dead opponents
 * @option opponent index x
 * @option 
 * @option alive actors
 * @option alive actors not user
 * @option alive actors not target
 * @option dead actors
 * @option actor index x
 * @option actor ID x
 * @option 
 * @option alive enemies
 * @option alive enemies not user
 * @option alive enemies not target
 * @option dead enemies
 * @option enemy index x
 * @option enemy ID x
 * @option 
 * @option alive battlers
 * @option alive battlers not user
 * @option alive battlers not target
 * @option dead battlers
 * @option 
 * @desc Select unit(s) to have states removed from.
 * @default ["user"]
 * 
 * @arg States:arraynum
 * @text States
 * @type state[]
 * @desc Select which state ID(s) to remove from unit(s).
 * Insert multiple state ID's to remove multiple at once.
 * @default ["4"]
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Mechanics_StateTurnsChangeBy
 * @text MECH: State Turns Change By
 * @desc Changes target(s) state turns by an amount.
 * Requires VisuMZ_1_SkillsStatesCore!
 * 
 * @arg Targets:arraystr
 * @text Targets
 * @type combo[]
 * @option user
 * @option current target
 * @option prev target
 * @option next target
 * @option all targets
 * @option focus
 * @option not focus
 * @option
 * @option special
 * @option special x
 * @option 
 * @option alive friends
 * @option alive friends not user
 * @option alive friends not target
 * @option dead friends
 * @option friend index x
 * @option 
 * @option alive opponents
 * @option alive opponents not target
 * @option dead opponents
 * @option opponent index x
 * @option 
 * @option alive actors
 * @option alive actors not user
 * @option alive actors not target
 * @option dead actors
 * @option actor index x
 * @option actor ID x
 * @option 
 * @option alive enemies
 * @option alive enemies not user
 * @option alive enemies not target
 * @option dead enemies
 * @option enemy index x
 * @option enemy ID x
 * @option 
 * @option alive battlers
 * @option alive battlers not user
 * @option alive battlers not target
 * @option dead battlers
 * @option 
 * @desc Select unit(s) to affect state turns for.
 * @default ["all targets"]
 *
 * @arg StateID:num
 * @text State ID
 * @type state
 * @desc What is the ID of the state you wish to change turns for?
 * Only works on states that can have turns.
 * @default 5
 *
 * @arg Turns:eval
 * @text Change Turns By
 * @desc How many turns should the state be changed to?
 * You may use JavaScript code.
 * @default +1
 *
 * @arg AutoAddState:eval
 * @text Auto-Add State?
 * @type boolean
 * @on Auto-Add
 * @off Don't Add
 * @desc Automatically adds state if actor(s) does not have it applied?
 * @default true
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Mechanics_StateTurnsChangeTo
 * @text MECH: State Turns Change To
 * @desc Changes target(s) state turns to a specific value.
 * Requires VisuMZ_1_SkillsStatesCore!
 * 
 * @arg Targets:arraystr
 * @text Targets
 * @type combo[]
 * @option user
 * @option current target
 * @option prev target
 * @option next target
 * @option all targets
 * @option focus
 * @option not focus
 * @option
 * @option special
 * @option special x
 * @option 
 * @option alive friends
 * @option alive friends not user
 * @option alive friends not target
 * @option dead friends
 * @option friend index x
 * @option 
 * @option alive opponents
 * @option alive opponents not target
 * @option dead opponents
 * @option opponent index x
 * @option 
 * @option alive actors
 * @option alive actors not user
 * @option alive actors not target
 * @option dead actors
 * @option actor index x
 * @option actor ID x
 * @option 
 * @option alive enemies
 * @option alive enemies not user
 * @option alive enemies not target
 * @option dead enemies
 * @option enemy index x
 * @option enemy ID x
 * @option 
 * @option alive battlers
 * @option alive battlers not user
 * @option alive battlers not target
 * @option dead battlers
 * @option 
 * @desc Select unit(s) to affect state turns for.
 * @default ["all targets"]
 *
 * @arg StateID:num
 * @text State ID
 * @type state
 * @desc What is the ID of the state you wish to change turns for?
 * Only works on states that can have turns.
 * @default 5
 *
 * @arg Turns:eval
 * @text Change Turns To
 * @desc How many turns should the state be changed to?
 * You may use JavaScript code.
 * @default 10
 *
 * @arg AutoAddState:eval
 * @text Auto-Add State?
 * @type boolean
 * @on Auto-Add
 * @off Don't Add
 * @desc Automatically adds state if target(s) does not have it applied?
 * @default true
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Mechanics_StbExploit
 * @text MECH: STB Exploit Effect
 * @desc Utilize the STB Exploitation mechanics!
 * Requires VisuMZ_2_BattleSystemSTB!
 * 
 * @arg Exploited:eval
 * @text Target(s) Exploited?
 * @type boolean
 * @on Exploit
 * @off Don't
 * @desc Exploit the below targets?
 * @default true
 * 
 * @arg Targets:arraystr
 * @text Targets
 * @type combo[]
 * @option user
 * @option current target
 * @option prev target
 * @option next target
 * @option all targets
 * @option focus
 * @option not focus
 * @option
 * @option special
 * @option special x
 * @option 
 * @option alive friends
 * @option alive friends not user
 * @option alive friends not target
 * @option dead friends
 * @option friend index x
 * @option 
 * @option alive opponents
 * @option alive opponents not target
 * @option dead opponents
 * @option opponent index x
 * @option 
 * @option alive actors
 * @option alive actors not user
 * @option alive actors not target
 * @option dead actors
 * @option actor index x
 * @option actor ID x
 * @option 
 * @option alive enemies
 * @option alive enemies not user
 * @option alive enemies not target
 * @option dead enemies
 * @option enemy index x
 * @option enemy ID x
 * @option 
 * @option alive battlers
 * @option alive battlers not user
 * @option alive battlers not target
 * @option dead battlers
 * @option 
 * @desc Select unit(s) to become exploited.
 * @default ["all targets"]
 * 
 * @arg ForceExploited:eval
 * @text Force Exploitation
 * @type boolean
 * @on Force
 * @off Don't
 * @desc Force the exploited status?
 * @default false
 * 
 * @arg Exploiter:eval
 * @text User Exploiter?
 * @type boolean
 * @on Exploit
 * @off Don't
 * @desc Allow the user to become the exploiter?
 * @default true
 * 
 * @arg ForceExploited:eval
 * @text Force Exploitation
 * @type boolean
 * @on Force
 * @off Don't
 * @desc Force the exploiter status?
 * @default false
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Mechanics_StbExtraAction
 * @text MECH: STB Extra Action
 * @desc Adds an extra action for the currently active battler.
 * Requires VisuMZ_2_BattleSystemSTB!
 * 
 * @arg Actions:eval
 * @text Extra Actions
 * @parent Charging
 * @desc How many extra actions should the active battler gain?
 * You may use JavaScript code.
 * @default 1
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Mechanics_StbRemoveExcessActions
 * @text MECH: STB Remove Excess Actions
 * @desc Removes excess actions from the active battler.
 * Requires VisuMZ_2_BattleSystemSTB!
 * 
 * @arg Actions:eval
 * @text Remove Actions
 * @parent Charging
 * @desc How many actions to remove from the active battler?
 * You may use JavaScript code.
 * @default 99
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Mechanics_SwapWeapon
 * @text MECH: Swap Weapon
 * @desc Causes the unit(s) to swap their weapon for another.
 * Requires VisuMZ_2_WeaponSwapSystem!
 * 
 * @arg Targets:arraystr
 * @text Targets
 * @type combo[]
 * @option user
 * @option current target
 * @option prev target
 * @option next target
 * @option all targets
 * @option focus
 * @option not focus
 * @option
 * @option special
 * @option special x
 * @option 
 * @option alive friends
 * @option alive friends not user
 * @option alive friends not target
 * @option dead friends
 * @option friend index x
 * @option 
 * @option alive opponents
 * @option alive opponents not target
 * @option dead opponents
 * @option opponent index x
 * @option 
 * @option alive actors
 * @option alive actors not user
 * @option alive actors not target
 * @option dead actors
 * @option actor index x
 * @option actor ID x
 * @option 
 * @option alive enemies
 * @option alive enemies not user
 * @option alive enemies not target
 * @option dead enemies
 * @option enemy index x
 * @option enemy ID x
 * @option 
 * @option alive battlers
 * @option alive battlers not user
 * @option alive battlers not target
 * @option dead battlers
 * @option 
 * @desc Select unit(s) to swap weapons for.
 * @default ["user"]
 * 
 * @arg WeaponTypeID:eval
 * @text Weapon Type ID
 * @desc Which weapon type to swap to?
 * This is NOT the weapon's ID. It's the weapon TYPE.
 * @default 1
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Mechanics_TextPopup
 * @text MECH: Text Popup
 * @desc Causes the unit(s) to display a text popup.
 * 
 * @arg Targets:arraystr
 * @text Targets
 * @type combo[]
 * @option user
 * @option current target
 * @option prev target
 * @option next target
 * @option all targets
 * @option focus
 * @option not focus
 * @option
 * @option special
 * @option special x
 * @option 
 * @option alive friends
 * @option alive friends not user
 * @option alive friends not target
 * @option dead friends
 * @option friend index x
 * @option 
 * @option alive opponents
 * @option alive opponents not target
 * @option dead opponents
 * @option opponent index x
 * @option 
 * @option alive actors
 * @option alive actors not user
 * @option alive actors not target
 * @option dead actors
 * @option actor index x
 * @option actor ID x
 * @option 
 * @option alive enemies
 * @option alive enemies not user
 * @option alive enemies not target
 * @option dead enemies
 * @option enemy index x
 * @option enemy ID x
 * @option 
 * @option alive battlers
 * @option alive battlers not user
 * @option alive battlers not target
 * @option dead battlers
 * @option 
 * @desc Select unit(s) to prompt a text popup.
 * @default ["target"]
 * 
 * @arg Text:str
 * @text Text
 * @desc What text do you wish to display?
 * @default Text
 * 
 * @arg TextColor:str
 * @text Text Color
 * @parent Text:str
 * @desc Use #rrggbb for custom colors or regular numbers
 * for text colors from the Window Skin.
 * @default #ffffff
 *
 * @arg FlashColor:eval
 * @text Flash Color
 * @parent Popups
 * @desc Adjust the popup's flash color.
 * Format: [red, green, blue, alpha]
 * @default [255, 0, 0, 160]
 * 
 * @arg FlashDuration:num
 * @text Flash Duration
 * @parent FlashColor:eval
 * @type number
 * @desc What is the frame duration of the flash effect?
 * @default 60
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Mechanics_VariablePopup
 * @text MECH: Variable Popup
 * @desc Causes the unit(s) to display a popup using the data
 * stored inside a variable.
 * 
 * @arg Targets:arraystr
 * @text Targets
 * @type combo[]
 * @option user
 * @option current target
 * @option prev target
 * @option next target
 * @option all targets
 * @option focus
 * @option not focus
 * @option
 * @option special
 * @option special x
 * @option 
 * @option alive friends
 * @option alive friends not user
 * @option alive friends not target
 * @option dead friends
 * @option friend index x
 * @option 
 * @option alive opponents
 * @option alive opponents not target
 * @option dead opponents
 * @option opponent index x
 * @option 
 * @option alive actors
 * @option alive actors not user
 * @option alive actors not target
 * @option dead actors
 * @option actor index x
 * @option actor ID x
 * @option 
 * @option alive enemies
 * @option alive enemies not user
 * @option alive enemies not target
 * @option dead enemies
 * @option enemy index x
 * @option enemy ID x
 * @option 
 * @option alive battlers
 * @option alive battlers not user
 * @option alive battlers not target
 * @option dead battlers
 * @option 
 * @desc Select unit(s) to prompt a text popup.
 * @default ["target"]
 * 
 * @arg Variable:num
 * @text Variable ID
 * @type variable
 * @desc Get data from which variable to display as a popup?
 * @default 1
 * 
 * @arg DigitGrouping:eval
 * @text Digit Grouping
 * @parent Variable:num
 * @type boolean
 * @on Group Digits
 * @off Don't Group
 * @desc Use digit grouping to separate numbers?
 * Requires VisuMZ_0_CoreEngine!
 * @default true
 * 
 * @arg TextColor:str
 * @text Text Color
 * @parent Variable:num
 * @desc Use #rrggbb for custom colors or regular numbers
 * for text colors from the Window Skin.
 * @default #ffffff
 *
 * @arg FlashColor:eval
 * @text Flash Color
 * @parent Popups
 * @desc Adjust the popup's flash color.
 * Format: [red, green, blue, alpha]
 * @default [0, 0, 0, 0]
 * 
 * @arg FlashDuration:num
 * @text Flash Duration
 * @parent FlashColor:eval
 * @type number
 * @desc What is the frame duration of the flash effect?
 * @default 60
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Mechanics_WaitForEffect
 * @text MECH: Wait For Effect
 * @desc Waits for the effects to complete before performing next command.
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActionSequenceSpaceMotion
 * @text -
 * @desc -
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActionSequenceBreakMotion
 * @text Action Sequences - Motion
 * @desc These Action Sequences allow you the ability to control
 * the motions of sideview sprites.
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Motion_ClearFreezeFrame
 * @text MOTION: Clear Freeze Frame
 * @desc Clears any freeze frames from the unit(s).
 * 
 * @arg Targets:arraystr
 * @text Targets
 * @type combo[]
 * @option user
 * @option current target
 * @option prev target
 * @option next target
 * @option all targets
 * @option focus
 * @option not focus
 * @option
 * @option special
 * @option special x
 * @option 
 * @option alive friends
 * @option alive friends not user
 * @option alive friends not target
 * @option dead friends
 * @option friend index x
 * @option 
 * @option alive opponents
 * @option alive opponents not target
 * @option dead opponents
 * @option opponent index x
 * @option 
 * @option alive actors
 * @option alive actors not user
 * @option alive actors not target
 * @option dead actors
 * @option actor index x
 * @option actor ID x
 * @option 
 * @option alive enemies
 * @option alive enemies not user
 * @option alive enemies not target
 * @option dead enemies
 * @option enemy index x
 * @option enemy ID x
 * @option 
 * @option alive battlers
 * @option alive battlers not user
 * @option alive battlers not target
 * @option dead battlers
 * @option 
 * @desc Select which unit(s) to clear freeze frames for.
 * @default ["user"]
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Motion_FreezeMotionFrame
 * @text MOTION: Freeze Motion Frame
 * @desc Forces a freeze frame instantly at the selected motion.
 * Automatically clears with a new motion.
 * 
 * @arg Targets:arraystr
 * @text Targets
 * @type combo[]
 * @option user
 * @option current target
 * @option prev target
 * @option next target
 * @option all targets
 * @option focus
 * @option not focus
 * @option
 * @option special
 * @option special x
 * @option 
 * @option alive friends
 * @option alive friends not user
 * @option alive friends not target
 * @option dead friends
 * @option friend index x
 * @option 
 * @option alive opponents
 * @option alive opponents not target
 * @option dead opponents
 * @option opponent index x
 * @option 
 * @option alive actors
 * @option alive actors not user
 * @option alive actors not target
 * @option dead actors
 * @option actor index x
 * @option actor ID x
 * @option 
 * @option alive enemies
 * @option alive enemies not user
 * @option alive enemies not target
 * @option dead enemies
 * @option enemy index x
 * @option enemy ID x
 * @option 
 * @option alive battlers
 * @option alive battlers not user
 * @option alive battlers not target
 * @option dead battlers
 * @option 
 * @desc Select which unit(s) to freeze motions for.
 * @default ["user"]
 *
 * @arg MotionType:str
 * @text Motion Type
 * @type combo
 * @option walk
 * @option wait
 * @option chant
 * @option guard
 * @option damage
 * @option evade
 * @option attack
 * @option thrust
 * @option swing
 * @option missile
 * @option skill
 * @option spell
 * @option item
 * @option escape
 * @option victory
 * @option dying
 * @option abnormal
 * @option sleep
 * @option dead
 * @desc Freeze this motion for the unit(s).
 * @default attack
 * 
 * @arg Frame:num
 * @text Frame Index
 * @desc Which frame do you want to freeze the motion on?
 * Frame index values start at 0.
 * @default 2
 *
 * @arg ShowWeapon:eval
 * @text Show Weapon?
 * @type combo
 * @type boolean
 * @on Show
 * @off Hide
 * @desc If using 'attack', 'thrust', 'swing', or 'missile',
 * display the weapon sprite?
 * @default true
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Motion_MotionType
 * @text MOTION: Motion Type
 * @desc Causes the unit(s) to play the selected motion.
 * 
 * @arg Targets:arraystr
 * @text Targets
 * @type combo[]
 * @option user
 * @option current target
 * @option prev target
 * @option next target
 * @option all targets
 * @option focus
 * @option not focus
 * @option
 * @option special
 * @option special x
 * @option 
 * @option alive friends
 * @option alive friends not user
 * @option alive friends not target
 * @option dead friends
 * @option friend index x
 * @option 
 * @option alive opponents
 * @option alive opponents not target
 * @option dead opponents
 * @option opponent index x
 * @option 
 * @option alive actors
 * @option alive actors not user
 * @option alive actors not target
 * @option dead actors
 * @option actor index x
 * @option actor ID x
 * @option 
 * @option alive enemies
 * @option alive enemies not user
 * @option alive enemies not target
 * @option dead enemies
 * @option enemy index x
 * @option enemy ID x
 * @option 
 * @option alive battlers
 * @option alive battlers not user
 * @option alive battlers not target
 * @option dead battlers
 * @option 
 * @desc Select which unit(s) to perform a motion.
 * @default ["user"]
 *
 * @arg MotionType:str
 * @text Motion Type
 * @type combo
 * @option walk
 * @option wait
 * @option chant
 * @option guard
 * @option damage
 * @option evade
 * @option attack
 * @option thrust
 * @option swing
 * @option missile
 * @option skill
 * @option spell
 * @option item
 * @option escape
 * @option victory
 * @option dying
 * @option abnormal
 * @option sleep
 * @option dead
 * @desc Play this motion for the unit(s).
 * @default attack
 *
 * @arg ShowWeapon:eval
 * @text Show Weapon?
 * @type combo
 * @type boolean
 * @on Show
 * @off Hide
 * @desc If using 'attack', 'thrust', 'swing', or 'missile',
 * display the weapon sprite?
 * @default true
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Motion_PerformAction
 * @text MOTION: Perform Action
 * @desc Causes the unit(s) to play the proper motion based
 * on the current action.
 * 
 * @arg Targets:arraystr
 * @text Targets
 * @type combo[]
 * @option user
 * @option current target
 * @option prev target
 * @option next target
 * @option all targets
 * @option focus
 * @option not focus
 * @option
 * @option special
 * @option special x
 * @option 
 * @option alive friends
 * @option alive friends not user
 * @option alive friends not target
 * @option dead friends
 * @option friend index x
 * @option 
 * @option alive opponents
 * @option alive opponents not target
 * @option dead opponents
 * @option opponent index x
 * @option 
 * @option alive actors
 * @option alive actors not user
 * @option alive actors not target
 * @option dead actors
 * @option actor index x
 * @option actor ID x
 * @option 
 * @option alive enemies
 * @option alive enemies not user
 * @option alive enemies not target
 * @option dead enemies
 * @option enemy index x
 * @option enemy ID x
 * @option 
 * @option alive battlers
 * @option alive battlers not user
 * @option alive battlers not target
 * @option dead battlers
 * @option 
 * @desc Select which unit(s) to perform a motion.
 * @default ["user"]
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Motion_RefreshMotion
 * @text MOTION: Refresh Motion
 * @desc Cancels any set motions unit(s) has to do and use
 * their most natural motion at the moment.
 * 
 * @arg Targets:arraystr
 * @text Targets
 * @type combo[]
 * @option user
 * @option current target
 * @option prev target
 * @option next target
 * @option all targets
 * @option focus
 * @option not focus
 * @option
 * @option special
 * @option special x
 * @option 
 * @option alive friends
 * @option alive friends not user
 * @option alive friends not target
 * @option dead friends
 * @option friend index x
 * @option 
 * @option alive opponents
 * @option alive opponents not target
 * @option dead opponents
 * @option opponent index x
 * @option 
 * @option alive actors
 * @option alive actors not user
 * @option alive actors not target
 * @option dead actors
 * @option actor index x
 * @option actor ID x
 * @option 
 * @option alive enemies
 * @option alive enemies not user
 * @option alive enemies not target
 * @option dead enemies
 * @option enemy index x
 * @option enemy ID x
 * @option 
 * @option alive battlers
 * @option alive battlers not user
 * @option alive battlers not target
 * @option dead battlers
 * @option 
 * @desc Select which unit(s) to refresh their motion state.
 * @default ["user"]
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Motion_WaitMotionFrame
 * @text MOTION: Wait By Motion Frame
 * @desc Creates a wait equal to the number of motion frames passing.
 * Time is based on Plugin Parameters => Actors => Motion Speed.
 *
 * @arg MotionFrameWait:num
 * @text Motion Frames to Wait?
 * @type number
 * @min 1
 * @desc Each "frame" is equal to the value found in
 * Plugin Parameters => Actors => Motion Speed
 * @default 1
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActionSequenceSpaceMovement
 * @text -
 * @desc -
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActionSequenceBreakMovement
 * @text Action Sequences - Movement
 * @desc These Action Sequences allow you the ability to control
 * the sprites of actors and enemies in battle.
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Movement_BattleStep
 * @text MOVE: Battle Step
 * @desc Causes the unit(s) to move forward past their home position
 * to prepare for action.
 * 
 * @arg Targets:arraystr
 * @text Targets
 * @type combo[]
 * @option user
 * @option current target
 * @option prev target
 * @option next target
 * @option all targets
 * @option focus
 * @option not focus
 * @option
 * @option special
 * @option special x
 * @option 
 * @option alive friends
 * @option alive friends not user
 * @option alive friends not target
 * @option dead friends
 * @option friend index x
 * @option 
 * @option alive opponents
 * @option alive opponents not target
 * @option dead opponents
 * @option opponent index x
 * @option 
 * @option alive actors
 * @option alive actors not user
 * @option alive actors not target
 * @option dead actors
 * @option actor index x
 * @option actor ID x
 * @option 
 * @option alive enemies
 * @option alive enemies not user
 * @option alive enemies not target
 * @option dead enemies
 * @option enemy index x
 * @option enemy ID x
 * @option 
 * @option alive battlers
 * @option alive battlers not user
 * @option alive battlers not target
 * @option dead battlers
 * @option 
 * @desc Select which unit(s) to move.
 * @default ["user"]
 * 
 * @arg WaitForMovement:eval
 * @text Wait For Movement?
 * @type boolean
 * @on On
 * @off Off
 * @desc Wait for movement to complete before performing next command?
 * @default true
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Movement_HomeMoveBy
 * @text MOVE: Change Home By Distance
 * @desc Change unit(s)'s home position by a distance from their
 * current home position(s). Sideview-only!
 * 
 * @arg Targets:arraystr
 * @text Targets
 * @type combo[]
 * @option user
 * @option current target
 * @option prev target
 * @option next target
 * @option all targets
 * @option focus
 * @option not focus
 * @option
 * @option special
 * @option special x
 * @option 
 * @option alive friends
 * @option alive friends not user
 * @option alive friends not target
 * @option dead friends
 * @option friend index x
 * @option 
 * @option alive opponents
 * @option alive opponents not target
 * @option dead opponents
 * @option opponent index x
 * @option 
 * @option alive actors
 * @option alive actors not user
 * @option alive actors not target
 * @option dead actors
 * @option actor index x
 * @option actor ID x
 * @option 
 * @option alive enemies
 * @option alive enemies not user
 * @option alive enemies not target
 * @option dead enemies
 * @option enemy index x
 * @option enemy ID x
 * @option 
 * @option alive battlers
 * @option alive battlers not user
 * @option alive battlers not target
 * @option dead battlers
 * @option 
 * @desc Select which unit(s) to change home position(s) for.
 * @default ["user"]
 *
 * @arg DistanceAdjust:str
 * @text Distance Adjustment
 * @type select
 * @option Normal - No adjustments made
 * @value none
 * @option Horizontal - Actors adjust left, Enemies adjust right
 * @value horz
 * @option Vertical - Actors adjust Up, Enemies adjust down
 * @value vert
 * @option Both - Applies both Horizontal and Vertical
 * @value horz + vert
 * @desc Makes adjustments to distance values to determine
 * which direction to change by.
 * @default horz
 * 
 * @arg DistanceX:eval
 * @text Distance: X
 * @parent DistanceAdjust:str
 * @desc Horizontal distance to change home by.
 * You may use JavaScript code.
 * @default 48
 * 
 * @arg DistanceY:eval
 * @text Distance: Y
 * @parent DistanceAdjust:str
 * @desc Vertical distance to change home by.
 * You may use JavaScript code.
 * @default 0
 * 
 * @arg Duration:eval
 * @text Duration
 * @desc Duration in frames for total change amount.
 * @default 12
 * 
 * @arg FaceDirection:eval
 * @text Face Destination?
 * @type boolean
 * @on Turn
 * @off Don't
 * @desc Turn and face the destination?
 * @default true
 *
 * @arg EasingType:str
 * @text Movement Easing
 * @type combo
 * @option Linear
 * @option InSine
 * @option OutSine
 * @option InOutSine
 * @option InQuad
 * @option OutQuad
 * @option InOutQuad
 * @option InCubic
 * @option OutCubic
 * @option InOutCubic
 * @option InQuart
 * @option OutQuart
 * @option InOutQuart
 * @option InQuint
 * @option OutQuint
 * @option InOutQuint
 * @option InExpo
 * @option OutExpo
 * @option InOutExpo
 * @option InCirc
 * @option OutCirc
 * @option InOutCirc
 * @option InBack
 * @option OutBack
 * @option InOutBack
 * @option InElastic
 * @option OutElastic
 * @option InOutElastic
 * @option InBounce
 * @option OutBounce
 * @option InOutBounce
 * @desc Select which easing type you wish to apply.
 * Requires VisuMZ_0_CoreEngine.
 * @default Linear
 *
 * @arg MotionType:str
 * @text Movement Motion
 * @type combo
 * @option walk
 * @option wait
 * @option chant
 * @option guard
 * @option damage
 * @option evade
 * @option thrust
 * @option swing
 * @option missile
 * @option skill
 * @option spell
 * @option item
 * @option escape
 * @option victory
 * @option dying
 * @option abnormal
 * @option sleep
 * @option dead
 * @desc Play this motion for the unit(s).
 * @default walk
 * 
 * @arg WaitForMovement:eval
 * @text Wait For Movement?
 * @type boolean
 * @on On
 * @off Off
 * @desc Wait for movement to complete before performing next command?
 * @default true
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Movement_HomeMoveToJsPoint
 * @text MOVE: Change Home To JS Coordinates
 * @desc Change home position(s) to specified JS Coordinates.
 * Sideview-only! Uses JavaScript!
 * 
 * @arg Targets:arraystr
 * @text Targets
 * @type combo[]
 * @option user
 * @option current target
 * @option prev target
 * @option next target
 * @option all targets
 * @option focus
 * @option not focus
 * @option
 * @option special
 * @option special x
 * @option 
 * @option alive friends
 * @option alive friends not user
 * @option alive friends not target
 * @option dead friends
 * @option friend index x
 * @option 
 * @option alive opponents
 * @option alive opponents not target
 * @option dead opponents
 * @option opponent index x
 * @option 
 * @option alive actors
 * @option alive actors not user
 * @option alive actors not target
 * @option dead actors
 * @option actor index x
 * @option actor ID x
 * @option 
 * @option alive enemies
 * @option alive enemies not user
 * @option alive enemies not target
 * @option dead enemies
 * @option enemy index x
 * @option enemy ID x
 * @option 
 * @option alive battlers
 * @option alive battlers not user
 * @option alive battlers not target
 * @option dead battlers
 * @option 
 * @desc Select which unit(s) to change home position(s) for.
 * @default ["user"]
 *
 * @arg DestinationJS:func
 * @text JS: Coordinates
 * @type note
 * @desc Code used to determine the coordinates for the
 * target(s)'s new home position.
 * @default "// Declare Variables\nconst target = arguments[0];\nlet goalX = 0;\nlet goalY = 0;\n\n// Calculations\ngoalX = Graphics.width / 2;\ngoalY = Graphics.height / 2;\n\n// Return Data\nreturn new Point(goalX, goalY);"
 *
 * @arg OffsetAdjust:str
 * @text Offset Adjustment
 * @parent Destination:str
 * @type select
 * @option Normal - No adjustments made
 * @value none
 * @option Horizontal - Actors adjust left, Enemies adjust right
 * @value horz
 * @option Vertical - Actors adjust Up, Enemies adjust down
 * @value vert
 * @option Both - Applies both Horizontal and Vertical
 * @value horz + vert
 * @desc Makes adjustments to offset values to determine
 * which direction to adjust the destination by.
 * @default horz
 * 
 * @arg OffsetX:eval
 * @text Offset: X
 * @parent OffsetAdjust:str
 * @desc Horizontal offset to change home by.
 * You may use JavaScript code.
 * @default 0
 * 
 * @arg OffsetY:eval
 * @text Offset: Y
 * @parent OffsetAdjust:str
 * @desc Vertical offset to change home by.
 * You may use JavaScript code.
 * @default 0
 * 
 * @arg Duration:eval
 * @text Duration
 * @desc Duration in frames for total change amount.
 * @default 12
 * 
 * @arg FaceDirection:eval
 * @text Face Destination?
 * @type boolean
 * @on Turn
 * @off Don't
 * @desc Turn and face the destination?
 * @default true
 *
 * @arg EasingType:str
 * @text Movement Easing
 * @type combo
 * @option Linear
 * @option InSine
 * @option OutSine
 * @option InOutSine
 * @option InQuad
 * @option OutQuad
 * @option InOutQuad
 * @option InCubic
 * @option OutCubic
 * @option InOutCubic
 * @option InQuart
 * @option OutQuart
 * @option InOutQuart
 * @option InQuint
 * @option OutQuint
 * @option InOutQuint
 * @option InExpo
 * @option OutExpo
 * @option InOutExpo
 * @option InCirc
 * @option OutCirc
 * @option InOutCirc
 * @option InBack
 * @option OutBack
 * @option InOutBack
 * @option InElastic
 * @option OutElastic
 * @option InOutElastic
 * @option InBounce
 * @option OutBounce
 * @option InOutBounce
 * @desc Select which easing type you wish to apply.
 * Requires VisuMZ_0_CoreEngine.
 * @default Linear
 *
 * @arg MotionType:str
 * @text Movement Motion
 * @type combo
 * @option walk
 * @option wait
 * @option chant
 * @option guard
 * @option damage
 * @option evade
 * @option thrust
 * @option swing
 * @option missile
 * @option skill
 * @option spell
 * @option item
 * @option escape
 * @option victory
 * @option dying
 * @option abnormal
 * @option sleep
 * @option dead
 * @desc Play this motion for the unit(s).
 * @default walk
 * 
 * @arg WaitForMovement:eval
 * @text Wait For Movement?
 * @type boolean
 * @on On
 * @off Off
 * @desc Wait for movement to complete before performing next command?
 * @default true
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Movement_HomeMoveToPoint
 * @text MOVE: Change Home To Point
 * @desc Change home position(s) to a target point on the screen.
 * Sideview-only! Points based off Graphics.boxWidth/Height.
 * 
 * @arg Targets:arraystr
 * @text Targets
 * @type combo[]
 * @option user
 * @option current target
 * @option prev target
 * @option next target
 * @option all targets
 * @option focus
 * @option not focus
 * @option
 * @option special
 * @option special x
 * @option 
 * @option alive friends
 * @option alive friends not user
 * @option alive friends not target
 * @option dead friends
 * @option friend index x
 * @option 
 * @option alive opponents
 * @option alive opponents not target
 * @option dead opponents
 * @option opponent index x
 * @option 
 * @option alive actors
 * @option alive actors not user
 * @option alive actors not target
 * @option dead actors
 * @option actor index x
 * @option actor ID x
 * @option 
 * @option alive enemies
 * @option alive enemies not user
 * @option alive enemies not target
 * @option dead enemies
 * @option enemy index x
 * @option enemy ID x
 * @option 
 * @option alive battlers
 * @option alive battlers not user
 * @option alive battlers not target
 * @option dead battlers
 * @option 
 * @desc Select which unit(s) to change home position(s) for.
 * @default ["user"]
 * 
 * @arg Destination:str
 * @text Destination Point
 * @type combo
 * @option center
 * @option point x, y
 * @desc Select which point to face.
 * Replace 'x' and 'y' with coordinates
 * @default center
 *
 * @arg OffsetAdjust:str
 * @text Offset Adjustment
 * @parent Destination:str
 * @type select
 * @option Normal - No adjustments made
 * @value none
 * @option Horizontal - Actors adjust left, Enemies adjust right
 * @value horz
 * @option Vertical - Actors adjust Up, Enemies adjust down
 * @value vert
 * @option Both - Applies both Horizontal and Vertical
 * @value horz + vert
 * @desc Makes adjustments to offset values to determine
 * which direction to adjust the destination by.
 * @default horz
 * 
 * @arg OffsetX:eval
 * @text Offset: X
 * @parent OffsetAdjust:str
 * @desc Horizontal offset to change home by.
 * You may use JavaScript code.
 * @default 0
 * 
 * @arg OffsetY:eval
 * @text Offset: Y
 * @parent OffsetAdjust:str
 * @desc Vertical offset to change home by.
 * You may use JavaScript code.
 * @default 0
 * 
 * @arg Duration:eval
 * @text Duration
 * @desc Duration in frames for total change amount.
 * @default 12
 * 
 * @arg FaceDirection:eval
 * @text Face Destination?
 * @type boolean
 * @on Turn
 * @off Don't
 * @desc Turn and face the destination?
 * @default true
 *
 * @arg EasingType:str
 * @text Movement Easing
 * @type combo
 * @option Linear
 * @option InSine
 * @option OutSine
 * @option InOutSine
 * @option InQuad
 * @option OutQuad
 * @option InOutQuad
 * @option InCubic
 * @option OutCubic
 * @option InOutCubic
 * @option InQuart
 * @option OutQuart
 * @option InOutQuart
 * @option InQuint
 * @option OutQuint
 * @option InOutQuint
 * @option InExpo
 * @option OutExpo
 * @option InOutExpo
 * @option InCirc
 * @option OutCirc
 * @option InOutCirc
 * @option InBack
 * @option OutBack
 * @option InOutBack
 * @option InElastic
 * @option OutElastic
 * @option InOutElastic
 * @option InBounce
 * @option OutBounce
 * @option InOutBounce
 * @desc Select which easing type you wish to apply.
 * Requires VisuMZ_0_CoreEngine.
 * @default Linear
 *
 * @arg MotionType:str
 * @text Movement Motion
 * @type combo
 * @option walk
 * @option wait
 * @option chant
 * @option guard
 * @option damage
 * @option evade
 * @option thrust
 * @option swing
 * @option missile
 * @option skill
 * @option spell
 * @option item
 * @option escape
 * @option victory
 * @option dying
 * @option abnormal
 * @option sleep
 * @option dead
 * @desc Play this motion for the unit(s).
 * @default walk
 * 
 * @arg WaitForMovement:eval
 * @text Wait For Movement?
 * @type boolean
 * @on On
 * @off Off
 * @desc Wait for movement to complete before performing next command?
 * @default true
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Movement_HomeMoveToTarget
 * @text MOVE: Change Home To Target(s)
 * @desc Moves unit(s) to another unit(s) on the battle field.
 * Sideview-only!
 * 
 * @arg Targets1:arraystr
 * @text Targets (Moving)
 * @type combo[]
 * @option user
 * @option current target
 * @option prev target
 * @option next target
 * @option all targets
 * @option focus
 * @option not focus
 * @option
 * @option special
 * @option special x
 * @option 
 * @option alive friends
 * @option alive friends not user
 * @option alive friends not target
 * @option dead friends
 * @option friend index x
 * @option 
 * @option alive opponents
 * @option alive opponents not target
 * @option dead opponents
 * @option opponent index x
 * @option 
 * @option alive actors
 * @option alive actors not user
 * @option alive actors not target
 * @option dead actors
 * @option actor index x
 * @option actor ID x
 * @option 
 * @option alive enemies
 * @option alive enemies not user
 * @option alive enemies not target
 * @option dead enemies
 * @option enemy index x
 * @option enemy ID x
 * @option 
 * @option alive battlers
 * @option alive battlers not user
 * @option alive battlers not target
 * @option dead battlers
 * @option 
 * @desc Select which unit(s) to change home position(s) for.
 * @default ["user"]
 * 
 * @arg Targets2:arraystr
 * @text Targets (Destination)
 * @type combo[]
 * @option user
 * @option current target
 * @option prev target
 * @option next target
 * @option all targets
 * @option focus
 * @option not focus
 * @option
 * @option special
 * @option special x
 * @option 
 * @option alive friends
 * @option alive friends not user
 * @option alive friends not target
 * @option dead friends
 * @option friend index x
 * @option 
 * @option alive opponents
 * @option alive opponents not target
 * @option dead opponents
 * @option opponent index x
 * @option 
 * @option alive actors
 * @option alive actors not user
 * @option alive actors not target
 * @option dead actors
 * @option actor index x
 * @option actor ID x
 * @option 
 * @option alive enemies
 * @option alive enemies not user
 * @option alive enemies not target
 * @option dead enemies
 * @option enemy index x
 * @option enemy ID x
 * @option 
 * @option alive battlers
 * @option alive battlers not user
 * @option alive battlers not target
 * @option dead battlers
 * @option 
 * @desc Select which unit(s) to change home position to.
 * @default ["all targets"]
 * 
 * @arg TargetLocation:str
 * @text Target Location
 * @parent Targets2:arraystr
 * @type combo
 * @option front head
 * @option front center
 * @option front base
 * @option middle head
 * @option middle center
 * @option middle base
 * @option back head
 * @option back center
 * @option back base
 * @desc Select which part target group to change home position to.
 * @default front base
 * 
 * @arg MeleeDistance:eval
 * @text Melee Distance
 * @parent TargetLocation:str
 * @desc The melee distance away from the target location
 * in addition to the battler's width.
 * @default 24
 *
 * @arg OffsetAdjust:str
 * @text Offset Adjustment
 * @parent Targets2:arraystr
 * @type select
 * @option Normal - No adjustments made
 * @value none
 * @option Horizontal - Actors adjust left, Enemies adjust right
 * @value horz
 * @option Vertical - Actors adjust Up, Enemies adjust down
 * @value vert
 * @option Both - Applies both Horizontal and Vertical
 * @value horz + vert
 * @desc Makes adjustments to offset values to determine
 * which direction to adjust the destination by.
 * @default horz
 * 
 * @arg OffsetX:eval
 * @text Offset: X
 * @parent OffsetAdjust:str
 * @desc Horizontal offset to change home by.
 * You may use JavaScript code.
 * @default 0
 * 
 * @arg OffsetY:eval
 * @text Offset: Y
 * @parent OffsetAdjust:str
 * @desc Vertical offset to change home by.
 * You may use JavaScript code.
 * @default 0
 * 
 * @arg Duration:eval
 * @text Duration
 * @desc Duration in frames for total change amount.
 * @default 12
 * 
 * @arg FaceDirection:eval
 * @text Face Destination?
 * @type boolean
 * @on Turn
 * @off Don't
 * @desc Turn and face the destination?
 * @default true
 *
 * @arg EasingType:str
 * @text Movement Easing
 * @type combo
 * @option Linear
 * @option InSine
 * @option OutSine
 * @option InOutSine
 * @option InQuad
 * @option OutQuad
 * @option InOutQuad
 * @option InCubic
 * @option OutCubic
 * @option InOutCubic
 * @option InQuart
 * @option OutQuart
 * @option InOutQuart
 * @option InQuint
 * @option OutQuint
 * @option InOutQuint
 * @option InExpo
 * @option OutExpo
 * @option InOutExpo
 * @option InCirc
 * @option OutCirc
 * @option InOutCirc
 * @option InBack
 * @option OutBack
 * @option InOutBack
 * @option InElastic
 * @option OutElastic
 * @option InOutElastic
 * @option InBounce
 * @option OutBounce
 * @option InOutBounce
 * @desc Select which easing type you wish to apply.
 * Requires VisuMZ_0_CoreEngine.
 * @default Linear
 *
 * @arg MotionType:str
 * @text Movement Motion
 * @type combo
 * @option walk
 * @option wait
 * @option chant
 * @option guard
 * @option damage
 * @option evade
 * @option thrust
 * @option swing
 * @option missile
 * @option skill
 * @option spell
 * @option item
 * @option escape
 * @option victory
 * @option dying
 * @option abnormal
 * @option sleep
 * @option dead
 * @desc Play this motion for the unit(s).
 * @default walk
 * 
 * @arg WaitForMovement:eval
 * @text Wait For Movement?
 * @type boolean
 * @on On
 * @off Off
 * @desc Wait for movement to complete before performing next command?
 * @default true
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Movement_FaceDirection
 * @text MOVE: Face Direction
 * @desc Causes the unit(s) to face forward or backward.
 * Sideview-only!
 * 
 * @arg Targets:arraystr
 * @text Targets
 * @type combo[]
 * @option user
 * @option current target
 * @option prev target
 * @option next target
 * @option all targets
 * @option focus
 * @option not focus
 * @option
 * @option special
 * @option special x
 * @option 
 * @option alive friends
 * @option alive friends not user
 * @option alive friends not target
 * @option dead friends
 * @option friend index x
 * @option 
 * @option alive opponents
 * @option alive opponents not target
 * @option dead opponents
 * @option opponent index x
 * @option 
 * @option alive actors
 * @option alive actors not user
 * @option alive actors not target
 * @option dead actors
 * @option actor index x
 * @option actor ID x
 * @option 
 * @option alive enemies
 * @option alive enemies not user
 * @option alive enemies not target
 * @option dead enemies
 * @option enemy index x
 * @option enemy ID x
 * @option 
 * @option alive battlers
 * @option alive battlers not user
 * @option alive battlers not target
 * @option dead battlers
 * @option 
 * @desc Select which unit(s) to change direction.
 * @default ["user"]
 * 
 * @arg Direction:str
 * @text Direction
 * @type combo
 * @option forward
 * @option backward
 * @option random
 * @desc Select which direction to face.
 * @default forward
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Movement_FaceJsPoint
 * @text MOVE: Face JS Coordinates
 * @desc Causes the unit(s) to face specified JS Coordinates.
 * Sideview-only! Uses JavaScript!
 * 
 * @arg Targets:arraystr
 * @text Targets
 * @type combo[]
 * @option user
 * @option current target
 * @option prev target
 * @option next target
 * @option all targets
 * @option focus
 * @option not focus
 * @option
 * @option special
 * @option special x
 * @option 
 * @option alive friends
 * @option alive friends not user
 * @option alive friends not target
 * @option dead friends
 * @option friend index x
 * @option 
 * @option alive opponents
 * @option alive opponents not target
 * @option dead opponents
 * @option opponent index x
 * @option 
 * @option alive actors
 * @option alive actors not user
 * @option alive actors not target
 * @option dead actors
 * @option actor index x
 * @option actor ID x
 * @option 
 * @option alive enemies
 * @option alive enemies not user
 * @option alive enemies not target
 * @option dead enemies
 * @option enemy index x
 * @option enemy ID x
 * @option 
 * @option alive battlers
 * @option alive battlers not user
 * @option alive battlers not target
 * @option dead battlers
 * @option 
 * @desc Select which unit(s) to change direction.
 * @default ["user"]
 *
 * @arg PointJS:func
 * @text JS: Coordinates
 * @type note
 * @desc Code used to determine the coordinates for the
 * target(s) to face towards.
 * @default "// Declare Variables\nconst target = arguments[0];\nlet goalX = 0;\nlet goalY = 0;\n\n// Calculations\ngoalX = Graphics.width / 2;\ngoalY = Graphics.height / 2;\n\n// Return Data\nreturn new Point(goalX, goalY);"
 * 
 * @arg FaceAway:eval
 * @text Face Away From?
 * @type boolean
 * @on Turn Away
 * @off Face Directly
 * @desc Face away from the point instead?
 * @default false
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Movement_FacePoint
 * @text MOVE: Face Point
 * @desc Causes the unit(s) to face a point on the screen.
 * Sideview-only!
 * 
 * @arg Targets:arraystr
 * @text Targets
 * @type combo[]
 * @option user
 * @option current target
 * @option prev target
 * @option next target
 * @option all targets
 * @option focus
 * @option not focus
 * @option
 * @option special
 * @option special x
 * @option 
 * @option alive friends
 * @option alive friends not user
 * @option alive friends not target
 * @option dead friends
 * @option friend index x
 * @option 
 * @option alive opponents
 * @option alive opponents not target
 * @option dead opponents
 * @option opponent index x
 * @option 
 * @option alive actors
 * @option alive actors not user
 * @option alive actors not target
 * @option dead actors
 * @option actor index x
 * @option actor ID x
 * @option 
 * @option alive enemies
 * @option alive enemies not user
 * @option alive enemies not target
 * @option dead enemies
 * @option enemy index x
 * @option enemy ID x
 * @option 
 * @option alive battlers
 * @option alive battlers not user
 * @option alive battlers not target
 * @option dead battlers
 * @option 
 * @desc Select which unit(s) to change direction.
 * @default ["user"]
 * 
 * @arg Point:str
 * @text Point
 * @type combo
 * @option home
 * @option center
 * @option point x, y
 * @desc Select which point to face.
 * Replace 'x' and 'y' with coordinates
 * @default home
 * 
 * @arg FaceAway:eval
 * @text Face Away From?
 * @type boolean
 * @on Turn Away
 * @off Face Directly
 * @desc Face away from the point instead?
 * @default false
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Movement_FaceTarget
 * @text MOVE: Face Target(s)
 * @desc Causes the unit(s) to face other targets on the screen.
 * Sideview-only!
 * 
 * @arg Targets1:arraystr
 * @text Targets (facing)
 * @type combo[]
 * @option user
 * @option current target
 * @option prev target
 * @option next target
 * @option all targets
 * @option focus
 * @option not focus
 * @option
 * @option special
 * @option special x
 * @option 
 * @option alive friends
 * @option alive friends not user
 * @option alive friends not target
 * @option dead friends
 * @option friend index x
 * @option 
 * @option alive opponents
 * @option alive opponents not target
 * @option dead opponents
 * @option opponent index x
 * @option 
 * @option alive actors
 * @option alive actors not user
 * @option alive actors not target
 * @option dead actors
 * @option actor index x
 * @option actor ID x
 * @option 
 * @option alive enemies
 * @option alive enemies not user
 * @option alive enemies not target
 * @option dead enemies
 * @option enemy index x
 * @option enemy ID x
 * @option 
 * @option alive battlers
 * @option alive battlers not user
 * @option alive battlers not target
 * @option dead battlers
 * @option 
 * @desc Select which unit(s) to change direction.
 * @default ["user"]
 * 
 * @arg Targets2:arraystr
 * @text Targets (destination)
 * @type combo[]
 * @option user
 * @option current target
 * @option prev target
 * @option next target
 * @option all targets
 * @option focus
 * @option not focus
 * @option
 * @option special
 * @option special x
 * @option 
 * @option alive friends
 * @option alive friends not user
 * @option alive friends not target
 * @option dead friends
 * @option friend index x
 * @option 
 * @option alive opponents
 * @option alive opponents not target
 * @option dead opponents
 * @option opponent index x
 * @option 
 * @option alive actors
 * @option alive actors not user
 * @option alive actors not target
 * @option dead actors
 * @option actor index x
 * @option actor ID x
 * @option 
 * @option alive enemies
 * @option alive enemies not user
 * @option alive enemies not target
 * @option dead enemies
 * @option enemy index x
 * @option enemy ID x
 * @option 
 * @option alive battlers
 * @option alive battlers not user
 * @option alive battlers not target
 * @option dead battlers
 * @option 
 * @desc Select which unit(s) for the turning unit(s) to face.
 * @default ["current target"]
 * 
 * @arg FaceAway:eval
 * @text Face Away From?
 * @type boolean
 * @on Turn Away
 * @off Face Directly
 * @desc Face away from the unit(s) instead?
 * @default false
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Movement_Float
 * @text MOVE: Float
 * @desc Causes the unit(s) to float above the ground.
 * Sideview-only!
 * 
 * @arg Targets:arraystr
 * @text Targets
 * @type combo[]
 * @option user
 * @option current target
 * @option prev target
 * @option next target
 * @option all targets
 * @option focus
 * @option not focus
 * @option
 * @option special
 * @option special x
 * @option 
 * @option alive friends
 * @option alive friends not user
 * @option alive friends not target
 * @option dead friends
 * @option friend index x
 * @option 
 * @option alive opponents
 * @option alive opponents not target
 * @option dead opponents
 * @option opponent index x
 * @option 
 * @option alive actors
 * @option alive actors not user
 * @option alive actors not target
 * @option dead actors
 * @option actor index x
 * @option actor ID x
 * @option 
 * @option alive enemies
 * @option alive enemies not user
 * @option alive enemies not target
 * @option dead enemies
 * @option enemy index x
 * @option enemy ID x
 * @option 
 * @option alive battlers
 * @option alive battlers not user
 * @option alive battlers not target
 * @option dead battlers
 * @option 
 * @desc Select which unit(s) to make float.
 * @default ["user"]
 * 
 * @arg Height:eval
 * @text Desired Height
 * @desc Vertical distance to float upward.
 * You may use JavaScript code.
 * @default 100
 * 
 * @arg Duration:eval
 * @text Duration
 * @desc Duration in frames for total float amount.
 * @default 12
 *
 * @arg EasingType:str
 * @text Float Easing
 * @type combo
 * @option Linear
 * @option InSine
 * @option OutSine
 * @option InOutSine
 * @option InQuad
 * @option OutQuad
 * @option InOutQuad
 * @option InCubic
 * @option OutCubic
 * @option InOutCubic
 * @option InQuart
 * @option OutQuart
 * @option InOutQuart
 * @option InQuint
 * @option OutQuint
 * @option InOutQuint
 * @option InExpo
 * @option OutExpo
 * @option InOutExpo
 * @option InCirc
 * @option OutCirc
 * @option InOutCirc
 * @option InBack
 * @option OutBack
 * @option InOutBack
 * @option InElastic
 * @option OutElastic
 * @option InOutElastic
 * @option InBounce
 * @option OutBounce
 * @option InOutBounce
 * @desc Select which easing type you wish to apply.
 * Requires VisuMZ_0_CoreEngine.
 * @default Linear
 * 
 * @arg WaitForFloat:eval
 * @text Wait For Float?
 * @type boolean
 * @on On
 * @off Off
 * @desc Wait for floating to complete before performing next command?
 * @default true
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Movement_HomeReset
 * @text MOVE: Home Reset
 * @desc Causes the unit(s) to move back to their home position(s)
 * and face back to their original direction(s).
 * 
 * @arg Targets:arraystr
 * @text Targets
 * @type combo[]
 * @option user
 * @option current target
 * @option prev target
 * @option next target
 * @option all targets
 * @option focus
 * @option not focus
 * @option
 * @option special
 * @option special x
 * @option 
 * @option alive friends
 * @option alive friends not user
 * @option alive friends not target
 * @option dead friends
 * @option friend index x
 * @option 
 * @option alive opponents
 * @option alive opponents not target
 * @option dead opponents
 * @option opponent index x
 * @option 
 * @option alive actors
 * @option alive actors not user
 * @option alive actors not target
 * @option dead actors
 * @option actor index x
 * @option actor ID x
 * @option 
 * @option alive enemies
 * @option alive enemies not user
 * @option alive enemies not target
 * @option dead enemies
 * @option enemy index x
 * @option enemy ID x
 * @option 
 * @option alive battlers
 * @option alive battlers not user
 * @option alive battlers not target
 * @option dead battlers
 * @option 
 * @desc Select which unit(s) to move.
 * @default ["alive battlers"]
 * 
 * @arg WaitForMovement:eval
 * @text Wait For Movement?
 * @type boolean
 * @on On
 * @off Off
 * @desc Wait for movement to complete before performing next command?
 * @default true
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Movement_Jump
 * @text MOVE: Jump
 * @desc Causes the unit(s) to jump into the air.
 * Sideview-only!
 * 
 * @arg Targets:arraystr
 * @text Targets
 * @type combo[]
 * @option user
 * @option current target
 * @option prev target
 * @option next target
 * @option all targets
 * @option focus
 * @option not focus
 * @option
 * @option special
 * @option special x
 * @option 
 * @option alive friends
 * @option alive friends not user
 * @option alive friends not target
 * @option dead friends
 * @option friend index x
 * @option 
 * @option alive opponents
 * @option alive opponents not target
 * @option dead opponents
 * @option opponent index x
 * @option 
 * @option alive actors
 * @option alive actors not user
 * @option alive actors not target
 * @option dead actors
 * @option actor index x
 * @option actor ID x
 * @option 
 * @option alive enemies
 * @option alive enemies not user
 * @option alive enemies not target
 * @option dead enemies
 * @option enemy index x
 * @option enemy ID x
 * @option 
 * @option alive battlers
 * @option alive battlers not user
 * @option alive battlers not target
 * @option dead battlers
 * @option 
 * @desc Select which unit(s) to make jump.
 * @default ["user"]
 * 
 * @arg Height:eval
 * @text Desired Height
 * @desc Max jump height to go above the ground
 * You may use JavaScript code.
 * @default 100
 * 
 * @arg Duration:eval
 * @text Duration
 * @desc Duration in frames for total jump amount.
 * @default 12
 * 
 * @arg WaitForJump:eval
 * @text Wait For Jump?
 * @type boolean
 * @on On
 * @off Off
 * @desc Wait for jumping to complete before performing next command?
 * @default false
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Movement_MoveBy
 * @text MOVE: Move Distance
 * @desc Moves unit(s) by a distance from their current position(s).
 * Sideview-only!
 * 
 * @arg Targets:arraystr
 * @text Targets
 * @type combo[]
 * @option user
 * @option current target
 * @option prev target
 * @option next target
 * @option all targets
 * @option focus
 * @option not focus
 * @option
 * @option special
 * @option special x
 * @option 
 * @option alive friends
 * @option alive friends not user
 * @option alive friends not target
 * @option dead friends
 * @option friend index x
 * @option 
 * @option alive opponents
 * @option alive opponents not target
 * @option dead opponents
 * @option opponent index x
 * @option 
 * @option alive actors
 * @option alive actors not user
 * @option alive actors not target
 * @option dead actors
 * @option actor index x
 * @option actor ID x
 * @option 
 * @option alive enemies
 * @option alive enemies not user
 * @option alive enemies not target
 * @option dead enemies
 * @option enemy index x
 * @option enemy ID x
 * @option 
 * @option alive battlers
 * @option alive battlers not user
 * @option alive battlers not target
 * @option dead battlers
 * @option 
 * @desc Select which unit(s) to move.
 * @default ["user"]
 *
 * @arg DistanceAdjust:str
 * @text Distance Adjustment
 * @type select
 * @option Normal - No adjustments made
 * @value none
 * @option Horizontal - Actors adjust left, Enemies adjust right
 * @value horz
 * @option Vertical - Actors adjust Up, Enemies adjust down
 * @value vert
 * @option Both - Applies both Horizontal and Vertical
 * @value horz + vert
 * @desc Makes adjustments to distance values to determine
 * which direction to move unit(s).
 * @default horz
 * 
 * @arg DistanceX:eval
 * @text Distance: X
 * @parent DistanceAdjust:str
 * @desc Horizontal distance to move.
 * You may use JavaScript code.
 * @default 48
 * 
 * @arg DistanceY:eval
 * @text Distance: Y
 * @parent DistanceAdjust:str
 * @desc Vertical distance to move.
 * You may use JavaScript code.
 * @default 0
 * 
 * @arg Duration:eval
 * @text Duration
 * @desc Duration in frames for total movement amount.
 * @default 12
 * 
 * @arg FaceDirection:eval
 * @text Face Destination?
 * @type boolean
 * @on Turn
 * @off Don't
 * @desc Turn and face the destination?
 * @default true
 *
 * @arg EasingType:str
 * @text Movement Easing
 * @type combo
 * @option Linear
 * @option InSine
 * @option OutSine
 * @option InOutSine
 * @option InQuad
 * @option OutQuad
 * @option InOutQuad
 * @option InCubic
 * @option OutCubic
 * @option InOutCubic
 * @option InQuart
 * @option OutQuart
 * @option InOutQuart
 * @option InQuint
 * @option OutQuint
 * @option InOutQuint
 * @option InExpo
 * @option OutExpo
 * @option InOutExpo
 * @option InCirc
 * @option OutCirc
 * @option InOutCirc
 * @option InBack
 * @option OutBack
 * @option InOutBack
 * @option InElastic
 * @option OutElastic
 * @option InOutElastic
 * @option InBounce
 * @option OutBounce
 * @option InOutBounce
 * @desc Select which easing type you wish to apply.
 * Requires VisuMZ_0_CoreEngine.
 * @default Linear
 *
 * @arg MotionType:str
 * @text Movement Motion
 * @type combo
 * @option walk
 * @option wait
 * @option chant
 * @option guard
 * @option damage
 * @option evade
 * @option thrust
 * @option swing
 * @option missile
 * @option skill
 * @option spell
 * @option item
 * @option escape
 * @option victory
 * @option dying
 * @option abnormal
 * @option sleep
 * @option dead
 * @desc Play this motion for the unit(s).
 * @default walk
 * 
 * @arg WaitForMovement:eval
 * @text Wait For Movement?
 * @type boolean
 * @on On
 * @off Off
 * @desc Wait for movement to complete before performing next command?
 * @default true
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Movement_MoveToJsPoint
 * @text MOVE: Move To JS Coordinates
 * @desc Moves unit(s) to specified JS Coordinates.
 * Sideview-only! Uses JavaScript!
 * 
 * @arg Targets:arraystr
 * @text Targets
 * @type combo[]
 * @option user
 * @option current target
 * @option prev target
 * @option next target
 * @option all targets
 * @option focus
 * @option not focus
 * @option
 * @option special
 * @option special x
 * @option 
 * @option alive friends
 * @option alive friends not user
 * @option alive friends not target
 * @option dead friends
 * @option friend index x
 * @option 
 * @option alive opponents
 * @option alive opponents not target
 * @option dead opponents
 * @option opponent index x
 * @option 
 * @option alive actors
 * @option alive actors not user
 * @option alive actors not target
 * @option dead actors
 * @option actor index x
 * @option actor ID x
 * @option 
 * @option alive enemies
 * @option alive enemies not user
 * @option alive enemies not target
 * @option dead enemies
 * @option enemy index x
 * @option enemy ID x
 * @option 
 * @option alive battlers
 * @option alive battlers not user
 * @option alive battlers not target
 * @option dead battlers
 * @option 
 * @desc Select which unit(s) to move.
 * @default ["user"]
 *
 * @arg DestinationJS:func
 * @text JS: Coordinates
 * @type note
 * @desc Code used to determine the coordinates for the
 * target(s) to move to.
 * @default "// Declare Variables\nconst target = arguments[0];\nlet goalX = 0;\nlet goalY = 0;\n\n// Calculations\ngoalX = Graphics.width / 2;\ngoalY = Graphics.height / 2;\n\n// Return Data\nreturn new Point(goalX, goalY);"
 *
 * @arg OffsetAdjust:str
 * @text Offset Adjustment
 * @parent Destination:str
 * @type select
 * @option Normal - No adjustments made
 * @value none
 * @option Horizontal - Actors adjust left, Enemies adjust right
 * @value horz
 * @option Vertical - Actors adjust Up, Enemies adjust down
 * @value vert
 * @option Both - Applies both Horizontal and Vertical
 * @value horz + vert
 * @desc Makes adjustments to offset values to determine
 * which direction to adjust the destination by.
 * @default horz
 * 
 * @arg OffsetX:eval
 * @text Offset: X
 * @parent OffsetAdjust:str
 * @desc Horizontal offset to move.
 * You may use JavaScript code.
 * @default 0
 * 
 * @arg OffsetY:eval
 * @text Offset: Y
 * @parent OffsetAdjust:str
 * @desc Vertical offset to move.
 * You may use JavaScript code.
 * @default 0
 * 
 * @arg Duration:eval
 * @text Duration
 * @desc Duration in frames for total movement amount.
 * @default 12
 * 
 * @arg FaceDirection:eval
 * @text Face Destination?
 * @type boolean
 * @on Turn
 * @off Don't
 * @desc Turn and face the destination?
 * @default true
 *
 * @arg EasingType:str
 * @text Movement Easing
 * @type combo
 * @option Linear
 * @option InSine
 * @option OutSine
 * @option InOutSine
 * @option InQuad
 * @option OutQuad
 * @option InOutQuad
 * @option InCubic
 * @option OutCubic
 * @option InOutCubic
 * @option InQuart
 * @option OutQuart
 * @option InOutQuart
 * @option InQuint
 * @option OutQuint
 * @option InOutQuint
 * @option InExpo
 * @option OutExpo
 * @option InOutExpo
 * @option InCirc
 * @option OutCirc
 * @option InOutCirc
 * @option InBack
 * @option OutBack
 * @option InOutBack
 * @option InElastic
 * @option OutElastic
 * @option InOutElastic
 * @option InBounce
 * @option OutBounce
 * @option InOutBounce
 * @desc Select which easing type you wish to apply.
 * Requires VisuMZ_0_CoreEngine.
 * @default Linear
 *
 * @arg MotionType:str
 * @text Movement Motion
 * @type combo
 * @option walk
 * @option wait
 * @option chant
 * @option guard
 * @option damage
 * @option evade
 * @option thrust
 * @option swing
 * @option missile
 * @option skill
 * @option spell
 * @option item
 * @option escape
 * @option victory
 * @option dying
 * @option abnormal
 * @option sleep
 * @option dead
 * @desc Play this motion for the unit(s).
 * @default walk
 * 
 * @arg WaitForMovement:eval
 * @text Wait For Movement?
 * @type boolean
 * @on On
 * @off Off
 * @desc Wait for movement to complete before performing next command?
 * @default true
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Movement_MoveToPoint
 * @text MOVE: Move To Point
 * @desc Moves unit(s) to a designated point on the screen.
 * Sideview-only! Points based off Graphics.boxWidth/Height.
 * 
 * @arg Targets:arraystr
 * @text Targets
 * @type combo[]
 * @option user
 * @option current target
 * @option prev target
 * @option next target
 * @option all targets
 * @option focus
 * @option not focus
 * @option
 * @option special
 * @option special x
 * @option 
 * @option alive friends
 * @option alive friends not user
 * @option alive friends not target
 * @option dead friends
 * @option friend index x
 * @option 
 * @option alive opponents
 * @option alive opponents not target
 * @option dead opponents
 * @option opponent index x
 * @option 
 * @option alive actors
 * @option alive actors not user
 * @option alive actors not target
 * @option dead actors
 * @option actor index x
 * @option actor ID x
 * @option 
 * @option alive enemies
 * @option alive enemies not user
 * @option alive enemies not target
 * @option dead enemies
 * @option enemy index x
 * @option enemy ID x
 * @option 
 * @option alive battlers
 * @option alive battlers not user
 * @option alive battlers not target
 * @option dead battlers
 * @option 
 * @desc Select which unit(s) to move.
 * @default ["user"]
 * 
 * @arg Destination:str
 * @text Destination Point
 * @type combo
 * @option home
 * @option center
 * @option point x, y
 * @desc Select which point to face.
 * Replace 'x' and 'y' with coordinates
 * @default home
 *
 * @arg OffsetAdjust:str
 * @text Offset Adjustment
 * @parent Destination:str
 * @type select
 * @option Normal - No adjustments made
 * @value none
 * @option Horizontal - Actors adjust left, Enemies adjust right
 * @value horz
 * @option Vertical - Actors adjust Up, Enemies adjust down
 * @value vert
 * @option Both - Applies both Horizontal and Vertical
 * @value horz + vert
 * @desc Makes adjustments to offset values to determine
 * which direction to adjust the destination by.
 * @default horz
 * 
 * @arg OffsetX:eval
 * @text Offset: X
 * @parent OffsetAdjust:str
 * @desc Horizontal offset to move.
 * You may use JavaScript code.
 * @default 0
 * 
 * @arg OffsetY:eval
 * @text Offset: Y
 * @parent OffsetAdjust:str
 * @desc Vertical offset to move.
 * You may use JavaScript code.
 * @default 0
 * 
 * @arg Duration:eval
 * @text Duration
 * @desc Duration in frames for total movement amount.
 * @default 12
 * 
 * @arg FaceDirection:eval
 * @text Face Destination?
 * @type boolean
 * @on Turn
 * @off Don't
 * @desc Turn and face the destination?
 * @default true
 *
 * @arg EasingType:str
 * @text Movement Easing
 * @type combo
 * @option Linear
 * @option InSine
 * @option OutSine
 * @option InOutSine
 * @option InQuad
 * @option OutQuad
 * @option InOutQuad
 * @option InCubic
 * @option OutCubic
 * @option InOutCubic
 * @option InQuart
 * @option OutQuart
 * @option InOutQuart
 * @option InQuint
 * @option OutQuint
 * @option InOutQuint
 * @option InExpo
 * @option OutExpo
 * @option InOutExpo
 * @option InCirc
 * @option OutCirc
 * @option InOutCirc
 * @option InBack
 * @option OutBack
 * @option InOutBack
 * @option InElastic
 * @option OutElastic
 * @option InOutElastic
 * @option InBounce
 * @option OutBounce
 * @option InOutBounce
 * @desc Select which easing type you wish to apply.
 * Requires VisuMZ_0_CoreEngine.
 * @default Linear
 *
 * @arg MotionType:str
 * @text Movement Motion
 * @type combo
 * @option walk
 * @option wait
 * @option chant
 * @option guard
 * @option damage
 * @option evade
 * @option thrust
 * @option swing
 * @option missile
 * @option skill
 * @option spell
 * @option item
 * @option escape
 * @option victory
 * @option dying
 * @option abnormal
 * @option sleep
 * @option dead
 * @desc Play this motion for the unit(s).
 * @default walk
 * 
 * @arg WaitForMovement:eval
 * @text Wait For Movement?
 * @type boolean
 * @on On
 * @off Off
 * @desc Wait for movement to complete before performing next command?
 * @default true
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Movement_MoveToTarget
 * @text MOVE: Move To Target(s)
 * @desc Moves unit(s) to another unit(s) on the battle field.
 * Sideview-only!
 * 
 * @arg Targets1:arraystr
 * @text Targets (Moving)
 * @type combo[]
 * @option user
 * @option current target
 * @option prev target
 * @option next target
 * @option all targets
 * @option focus
 * @option not focus
 * @option
 * @option special
 * @option special x
 * @option 
 * @option alive friends
 * @option alive friends not user
 * @option alive friends not target
 * @option dead friends
 * @option friend index x
 * @option 
 * @option alive opponents
 * @option alive opponents not target
 * @option dead opponents
 * @option opponent index x
 * @option 
 * @option alive actors
 * @option alive actors not user
 * @option alive actors not target
 * @option dead actors
 * @option actor index x
 * @option actor ID x
 * @option 
 * @option alive enemies
 * @option alive enemies not user
 * @option alive enemies not target
 * @option dead enemies
 * @option enemy index x
 * @option enemy ID x
 * @option 
 * @option alive battlers
 * @option alive battlers not user
 * @option alive battlers not target
 * @option dead battlers
 * @option 
 * @desc Select which unit(s) to move.
 * @default ["user"]
 * 
 * @arg Targets2:arraystr
 * @text Targets (Destination)
 * @type combo[]
 * @option user
 * @option current target
 * @option prev target
 * @option next target
 * @option all targets
 * @option focus
 * @option not focus
 * @option
 * @option special
 * @option special x
 * @option 
 * @option alive friends
 * @option alive friends not user
 * @option alive friends not target
 * @option dead friends
 * @option friend index x
 * @option 
 * @option alive opponents
 * @option alive opponents not target
 * @option dead opponents
 * @option opponent index x
 * @option 
 * @option alive actors
 * @option alive actors not user
 * @option alive actors not target
 * @option dead actors
 * @option actor index x
 * @option actor ID x
 * @option 
 * @option alive enemies
 * @option alive enemies not user
 * @option alive enemies not target
 * @option dead enemies
 * @option enemy index x
 * @option enemy ID x
 * @option 
 * @option alive battlers
 * @option alive battlers not user
 * @option alive battlers not target
 * @option dead battlers
 * @option 
 * @desc Select which unit(s) to move to.
 * @default ["all targets"]
 * 
 * @arg TargetLocation:str
 * @text Target Location
 * @parent Targets2:arraystr
 * @type combo
 * @option front head
 * @option front center
 * @option front base
 * @option middle head
 * @option middle center
 * @option middle base
 * @option back head
 * @option back center
 * @option back base
 * @desc Select which part target group to move to.
 * @default front base
 * 
 * @arg MeleeDistance:eval
 * @text Melee Distance
 * @parent TargetLocation:str
 * @desc The melee distance away from the target location
 * in addition to the battler's width.
 * @default 24
 *
 * @arg OffsetAdjust:str
 * @text Offset Adjustment
 * @parent Targets2:arraystr
 * @type select
 * @option Normal - No adjustments made
 * @value none
 * @option Horizontal - Actors adjust left, Enemies adjust right
 * @value horz
 * @option Vertical - Actors adjust Up, Enemies adjust down
 * @value vert
 * @option Both - Applies both Horizontal and Vertical
 * @value horz + vert
 * @desc Makes adjustments to offset values to determine
 * which direction to adjust the destination by.
 * @default horz
 * 
 * @arg OffsetX:eval
 * @text Offset: X
 * @parent OffsetAdjust:str
 * @desc Horizontal offset to move.
 * You may use JavaScript code.
 * @default 0
 * 
 * @arg OffsetY:eval
 * @text Offset: Y
 * @parent OffsetAdjust:str
 * @desc Vertical offset to move.
 * You may use JavaScript code.
 * @default 0
 * 
 * @arg Duration:eval
 * @text Duration
 * @desc Duration in frames for total movement amount.
 * @default 12
 * 
 * @arg FaceDirection:eval
 * @text Face Destination?
 * @type boolean
 * @on Turn
 * @off Don't
 * @desc Turn and face the destination?
 * @default true
 *
 * @arg EasingType:str
 * @text Movement Easing
 * @type combo
 * @option Linear
 * @option InSine
 * @option OutSine
 * @option InOutSine
 * @option InQuad
 * @option OutQuad
 * @option InOutQuad
 * @option InCubic
 * @option OutCubic
 * @option InOutCubic
 * @option InQuart
 * @option OutQuart
 * @option InOutQuart
 * @option InQuint
 * @option OutQuint
 * @option InOutQuint
 * @option InExpo
 * @option OutExpo
 * @option InOutExpo
 * @option InCirc
 * @option OutCirc
 * @option InOutCirc
 * @option InBack
 * @option OutBack
 * @option InOutBack
 * @option InElastic
 * @option OutElastic
 * @option InOutElastic
 * @option InBounce
 * @option OutBounce
 * @option InOutBounce
 * @desc Select which easing type you wish to apply.
 * Requires VisuMZ_0_CoreEngine.
 * @default Linear
 *
 * @arg MotionType:str
 * @text Movement Motion
 * @type combo
 * @option walk
 * @option wait
 * @option chant
 * @option guard
 * @option damage
 * @option evade
 * @option thrust
 * @option swing
 * @option missile
 * @option skill
 * @option spell
 * @option item
 * @option escape
 * @option victory
 * @option dying
 * @option abnormal
 * @option sleep
 * @option dead
 * @desc Play this motion for the unit(s).
 * @default walk
 * 
 * @arg WaitForMovement:eval
 * @text Wait For Movement?
 * @type boolean
 * @on On
 * @off Off
 * @desc Wait for movement to complete before performing next command?
 * @default true
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Movement_Opacity
 * @text MOVE: Opacity
 * @desc Causes the unit(s) to change opacity.
 * Sideview-only!
 * 
 * @arg Targets:arraystr
 * @text Targets
 * @type combo[]
 * @option user
 * @option current target
 * @option prev target
 * @option next target
 * @option all targets
 * @option focus
 * @option not focus
 * @option
 * @option special
 * @option special x
 * @option 
 * @option alive friends
 * @option alive friends not user
 * @option alive friends not target
 * @option dead friends
 * @option friend index x
 * @option 
 * @option alive opponents
 * @option alive opponents not target
 * @option dead opponents
 * @option opponent index x
 * @option 
 * @option alive actors
 * @option alive actors not user
 * @option alive actors not target
 * @option dead actors
 * @option actor index x
 * @option actor ID x
 * @option 
 * @option alive enemies
 * @option alive enemies not user
 * @option alive enemies not target
 * @option dead enemies
 * @option enemy index x
 * @option enemy ID x
 * @option 
 * @option alive battlers
 * @option alive battlers not user
 * @option alive battlers not target
 * @option dead battlers
 * @option 
 * @desc Select which unit(s) to change opacity.
 * @default ["user"]
 * 
 * @arg Opacity:eval
 * @text Desired Opacity
 * @desc Change to this opacity value.
 * You may use JavaScript code.
 * @default 255
 * 
 * @arg Duration:eval
 * @text Duration
 * @desc Duration in frames for opacity change.
 * @default 12
 *
 * @arg EasingType:str
 * @text Opacity Easing
 * @type combo
 * @option Linear
 * @option InSine
 * @option OutSine
 * @option InOutSine
 * @option InQuad
 * @option OutQuad
 * @option InOutQuad
 * @option InCubic
 * @option OutCubic
 * @option InOutCubic
 * @option InQuart
 * @option OutQuart
 * @option InOutQuart
 * @option InQuint
 * @option OutQuint
 * @option InOutQuint
 * @option InExpo
 * @option OutExpo
 * @option InOutExpo
 * @option InCirc
 * @option OutCirc
 * @option InOutCirc
 * @option InBack
 * @option OutBack
 * @option InOutBack
 * @option InElastic
 * @option OutElastic
 * @option InOutElastic
 * @option InBounce
 * @option OutBounce
 * @option InOutBounce
 * @desc Select which easing type you wish to apply.
 * Requires VisuMZ_0_CoreEngine.
 * @default Linear
 * 
 * @arg WaitForOpacity:eval
 * @text Wait For Opacity?
 * @type boolean
 * @on On
 * @off Off
 * @desc Wait for opacity changes to complete before performing next command?
 * @default true
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Movement_Scale
 * @text MOVE: Scale/Grow/Shrink
 * @desc Causes the unit(s) to scale, grow, or shrink?.
 * Sideview-only!
 * 
 * @arg Targets:arraystr
 * @text Targets
 * @type combo[]
 * @option user
 * @option current target
 * @option prev target
 * @option next target
 * @option all targets
 * @option focus
 * @option not focus
 * @option
 * @option special
 * @option special x
 * @option 
 * @option alive friends
 * @option alive friends not user
 * @option alive friends not target
 * @option dead friends
 * @option friend index x
 * @option 
 * @option alive opponents
 * @option alive opponents not target
 * @option dead opponents
 * @option opponent index x
 * @option 
 * @option alive actors
 * @option alive actors not user
 * @option alive actors not target
 * @option dead actors
 * @option actor index x
 * @option actor ID x
 * @option 
 * @option alive enemies
 * @option alive enemies not user
 * @option alive enemies not target
 * @option dead enemies
 * @option enemy index x
 * @option enemy ID x
 * @option 
 * @option alive battlers
 * @option alive battlers not user
 * @option alive battlers not target
 * @option dead battlers
 * @option 
 * @desc Select which unit(s) to change the scale of.
 * @default ["user"]
 * 
 * @arg ScaleX:eval
 * @text Scale X
 * @desc What target scale value do you want?
 * 1.0 is normal size.
 * @default 1.00
 * 
 * @arg ScaleY:eval
 * @text Scale Y
 * @desc What target scale value do you want?
 * 1.0 is normal size.
 * @default 1.00
 * 
 * @arg Duration:eval
 * @text Duration
 * @desc Duration in frames to scale for.
 * @default 12
 *
 * @arg EasingType:str
 * @text Scale Easing
 * @type combo
 * @option Linear
 * @option InSine
 * @option OutSine
 * @option InOutSine
 * @option InQuad
 * @option OutQuad
 * @option InOutQuad
 * @option InCubic
 * @option OutCubic
 * @option InOutCubic
 * @option InQuart
 * @option OutQuart
 * @option InOutQuart
 * @option InQuint
 * @option OutQuint
 * @option InOutQuint
 * @option InExpo
 * @option OutExpo
 * @option InOutExpo
 * @option InCirc
 * @option OutCirc
 * @option InOutCirc
 * @option InBack
 * @option OutBack
 * @option InOutBack
 * @option InElastic
 * @option OutElastic
 * @option InOutElastic
 * @option InBounce
 * @option OutBounce
 * @option InOutBounce
 * @desc Select which easing type you wish to apply.
 * Requires VisuMZ_0_CoreEngine.
 * @default Linear
 * 
 * @arg WaitForScale:eval
 * @text Wait For Scale?
 * @type boolean
 * @on On
 * @off Off
 * @desc Wait for scaling to complete before performing next command?
 * @default true
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Movement_Skew
 * @text MOVE: Skew/Distort
 * @desc Causes the unit(s) to skew.
 * Sideview-only!
 * 
 * @arg Targets:arraystr
 * @text Targets
 * @type combo[]
 * @option user
 * @option current target
 * @option prev target
 * @option next target
 * @option all targets
 * @option focus
 * @option not focus
 * @option
 * @option special
 * @option special x
 * @option 
 * @option alive friends
 * @option alive friends not user
 * @option alive friends not target
 * @option dead friends
 * @option friend index x
 * @option 
 * @option alive opponents
 * @option alive opponents not target
 * @option dead opponents
 * @option opponent index x
 * @option 
 * @option alive actors
 * @option alive actors not user
 * @option alive actors not target
 * @option dead actors
 * @option actor index x
 * @option actor ID x
 * @option 
 * @option alive enemies
 * @option alive enemies not user
 * @option alive enemies not target
 * @option dead enemies
 * @option enemy index x
 * @option enemy ID x
 * @option 
 * @option alive battlers
 * @option alive battlers not user
 * @option alive battlers not target
 * @option dead battlers
 * @option 
 * @desc Select which unit(s) to skew.
 * @default ["user"]
 * 
 * @arg SkewX:eval
 * @text Skew X
 * @desc X variance to skew?
 * Use small values for the best results.
 * @default 0.00
 * 
 * @arg SkewY:eval
 * @text Skew Y
 * @desc Y variance to skew?
 * Use small values for the best results.
 * @default 0.00
 * 
 * @arg Duration:eval
 * @text Duration
 * @desc Duration in frames to skew for.
 * @default 12
 *
 * @arg EasingType:str
 * @text Skew Easing
 * @type combo
 * @option Linear
 * @option InSine
 * @option OutSine
 * @option InOutSine
 * @option InQuad
 * @option OutQuad
 * @option InOutQuad
 * @option InCubic
 * @option OutCubic
 * @option InOutCubic
 * @option InQuart
 * @option OutQuart
 * @option InOutQuart
 * @option InQuint
 * @option OutQuint
 * @option InOutQuint
 * @option InExpo
 * @option OutExpo
 * @option InOutExpo
 * @option InCirc
 * @option OutCirc
 * @option InOutCirc
 * @option InBack
 * @option OutBack
 * @option InOutBack
 * @option InElastic
 * @option OutElastic
 * @option InOutElastic
 * @option InBounce
 * @option OutBounce
 * @option InOutBounce
 * @desc Select which easing type you wish to apply.
 * Requires VisuMZ_0_CoreEngine.
 * @default Linear
 * 
 * @arg WaitForSkew:eval
 * @text Wait For Skew?
 * @type boolean
 * @on On
 * @off Off
 * @desc Wait for skew to complete before performing next command?
 * @default true
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Movement_Spin
 * @text MOVE: Spin/Rotate
 * @desc Causes the unit(s) to spin.
 * Sideview-only!
 * 
 * @arg Targets:arraystr
 * @text Targets
 * @type combo[]
 * @option user
 * @option current target
 * @option prev target
 * @option next target
 * @option all targets
 * @option focus
 * @option not focus
 * @option
 * @option special
 * @option special x
 * @option 
 * @option alive friends
 * @option alive friends not user
 * @option alive friends not target
 * @option dead friends
 * @option friend index x
 * @option 
 * @option alive opponents
 * @option alive opponents not target
 * @option dead opponents
 * @option opponent index x
 * @option 
 * @option alive actors
 * @option alive actors not user
 * @option alive actors not target
 * @option dead actors
 * @option actor index x
 * @option actor ID x
 * @option 
 * @option alive enemies
 * @option alive enemies not user
 * @option alive enemies not target
 * @option dead enemies
 * @option enemy index x
 * @option enemy ID x
 * @option 
 * @option alive battlers
 * @option alive battlers not user
 * @option alive battlers not target
 * @option dead battlers
 * @option 
 * @desc Select which unit(s) to spin.
 * @default ["user"]
 * 
 * @arg Angle:eval
 * @text Angle
 * @desc How many degrees to spin?
 * @default 360
 * 
 * @arg Duration:eval
 * @text Duration
 * @desc Duration in frames to spin for.
 * @default 12
 *
 * @arg EasingType:str
 * @text Spin Easing
 * @type combo
 * @option Linear
 * @option InSine
 * @option OutSine
 * @option InOutSine
 * @option InQuad
 * @option OutQuad
 * @option InOutQuad
 * @option InCubic
 * @option OutCubic
 * @option InOutCubic
 * @option InQuart
 * @option OutQuart
 * @option InOutQuart
 * @option InQuint
 * @option OutQuint
 * @option InOutQuint
 * @option InExpo
 * @option OutExpo
 * @option InOutExpo
 * @option InCirc
 * @option OutCirc
 * @option InOutCirc
 * @option InBack
 * @option OutBack
 * @option InOutBack
 * @option InElastic
 * @option OutElastic
 * @option InOutElastic
 * @option InBounce
 * @option OutBounce
 * @option InOutBounce
 * @desc Select which easing type you wish to apply.
 * Requires VisuMZ_0_CoreEngine.
 * @default Linear
 * 
 * @arg RevertAngle:eval
 * @text Revert Angle on Finish
 * @type boolean
 * @on Revert
 * @off Don't
 * @desc Revert angle after spinning?
 * @default true
 * 
 * @arg WaitForSpin:eval
 * @text Wait For Spin?
 * @type boolean
 * @on On
 * @off Off
 * @desc Wait for spin to complete before performing next command?
 * @default true
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Movement_WaitForFloat
 * @text MOVE: Wait For Float
 * @desc Waits for floating to complete before performing next command.
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Movement_WaitForJump
 * @text MOVE: Wait For Jump
 * @desc Waits for jumping to complete before performing next command.
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Movement_WaitForMovement
 * @text MOVE: Wait For Movement
 * @desc Waits for movement to complete before performing next command.
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Movement_WaitForOpacity
 * @text MOVE: Wait For Opacity
 * @desc Waits for opacity changes to complete before performing next command.
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Movement_WaitForScale
 * @text MOVE: Wait For Scale
 * @desc Waits for scaling to complete before performing next command.
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Movement_WaitForSkew
 * @text MOVE: Wait For Skew
 * @desc Waits for skewing to complete before performing next command.
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Movement_WaitForSpin
 * @text MOVE: Wait For Spin
 * @desc Waits for spinning to complete before performing next command.
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActionSequenceSpaceProjectile
 * @text -
 * @desc -
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActionSequenceBreakProjectile
 * @text Action Sequences - Projectiles
 * @desc Create projectiles on the screen and fire them off at a target.
 * Requires VisuMZ_3_ActSeqProjectiles!
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Projectile_Animation
 * @text PROJECTILE: Animation
 * @desc Create an animation projectile and fire it at a target.
 * Requires VisuMZ_3_ActSeqProjectiles!
 * 
 * @arg Coordinates
 *
 * @arg Start:struct
 * @text Start Location
 * @parent Coordinates
 * @type struct<ProjectileStart>
 * @desc Settings to determine where the projectile(s) start from.
 * @default {"Type:str":"target","Targets:arraystr":"[\"user\"]","TargetCenter:eval":"false","PointX:eval":"Graphics.width / 2","PointY:eval":"Graphics.height / 2","OffsetX:eval":"+0","OffsetY:eval":"+0"}
 *
 * @arg Goal:struct
 * @text Goal Location
 * @parent Coordinates
 * @type struct<ProjectileGoal>
 * @desc Settings to determine where the projectile(s) start from.
 * @default {"Type:str":"target","Targets:arraystr":"[\"all targets\"]","TargetCenter:eval":"false","PointX:eval":"Graphics.width / 2","PointY:eval":"Graphics.height / 2","OffsetX:eval":"+0","OffsetY:eval":"+0"}
 * 
 * @arg Settings
 *
 * @arg AnimationID:num
 * @text Animation ID
 * @parent Settings
 * @type animation
 * @desc Determine which animation to use as a projectile.
 * @default 77
 * 
 * @arg Duration:eval
 * @text Duration
 * @parent Settings
 * @desc Duration for the projectile(s) to travel.
 * @default 20
 * 
 * @arg WaitForProjectile:eval
 * @text Wait For Projectile?
 * @parent Settings
 * @type boolean
 * @on On
 * @off Off
 * @desc Wait for projectile(s) to reach their destination before
 * going onto the next command?
 * @default true
 * 
 * @arg WaitForAnimation:eval
 * @text Wait For Animation?
 * @parent Settings
 * @type boolean
 * @on On
 * @off Off
 * @desc Wait for animation to finish before going to the next command?
 * @default false
 * 
 * @arg Extra:struct
 * @text Extra Settings
 * @type struct<ProjectileExAni>
 * @desc Add extra settings to the projectile?
 * @default {"AutoAngle:eval":"true","AngleOffset:eval":"+0","Arc:eval":"0","EasingType:str":"Linear","Spin:eval":"+0.0"}
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Projectile_Icon
 * @text PROJECTILE: Icon
 * @desc Create an icon projectile and fire it at a target.
 * Requires VisuMZ_3_ActSeqProjectiles!
 * 
 * @arg Coordinates
 *
 * @arg Start:struct
 * @text Start Location
 * @parent Coordinates
 * @type struct<ProjectileStart>
 * @desc Settings to determine where the projectile(s) start from.
 * @default {"Type:str":"target","Targets:arraystr":"[\"user\"]","TargetCenter:eval":"false","PointX:eval":"Graphics.width / 2","PointY:eval":"Graphics.height / 2","OffsetX:eval":"+0","OffsetY:eval":"+0"}
 *
 * @arg Goal:struct
 * @text Goal Location
 * @parent Coordinates
 * @type struct<ProjectileGoal>
 * @desc Settings to determine where the projectile(s) start from.
 * @default {"Type:str":"target","Targets:arraystr":"[\"all targets\"]","TargetCenter:eval":"false","PointX:eval":"Graphics.width / 2","PointY:eval":"Graphics.height / 2","OffsetX:eval":"+0","OffsetY:eval":"+0"}
 * 
 * @arg Settings
 *
 * @arg Icon:eval
 * @text Icon Index
 * @parent Settings
 * @desc Determine which icon to use as a projectile.
 * You may use JavaScript code.
 * @default 118
 * 
 * @arg Duration:eval
 * @text Duration
 * @parent Settings
 * @desc Duration for the projectile(s) to travel.
 * @default 20
 * 
 * @arg WaitForProjectile:eval
 * @text Wait For Projectile?
 * @parent Settings
 * @type boolean
 * @on On
 * @off Off
 * @desc Wait for projectile(s) to reach their destination before
 * going onto the next command?
 * @default true
 * 
 * @arg Extra:struct
 * @text Extra Settings
 * @type struct<ProjectileExtra>
 * @desc Add extra settings to the projectile?
 * @default {"AutoAngle:eval":"true","AngleOffset:eval":"+0","Arc:eval":"0","BlendMode:num":"0","EasingType:str":"Linear","Hue:eval":"0","Scale:eval":"1.0","Spin:eval":"+0.0"}
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Projectile_Picture
 * @text PROJECTILE: Picture
 * @desc Create a picture projectile and fire it at a target.
 * Requires VisuMZ_3_ActSeqProjectiles!
 * 
 * @arg Coordinates
 *
 * @arg Start:struct
 * @text Start Location
 * @parent Coordinates
 * @type struct<ProjectileStart>
 * @desc Settings to determine where the projectile(s) start from.
 * @default {"Type:str":"target","Targets:arraystr":"[\"user\"]","TargetCenter:eval":"false","PointX:eval":"Graphics.width / 2","PointY:eval":"Graphics.height / 2","OffsetX:eval":"+0","OffsetY:eval":"+0"}
 *
 * @arg Goal:struct
 * @text Goal Location
 * @parent Coordinates
 * @type struct<ProjectileGoal>
 * @desc Settings to determine where the projectile(s) start from.
 * @default {"Type:str":"target","Targets:arraystr":"[\"all targets\"]","TargetCenter:eval":"false","PointX:eval":"Graphics.width / 2","PointY:eval":"Graphics.height / 2","OffsetX:eval":"+0","OffsetY:eval":"+0"}
 * 
 * @arg Settings
 *
 * @arg Picture:str
 * @text Picture Filename
 * @parent Settings
 * @type file
 * @dir img/pictures/
 * @desc Determine which picture to use as a projectile.
 * @default Untitled
 * 
 * @arg Duration:eval
 * @text Duration
 * @parent Settings
 * @desc Duration for the projectile(s) to travel.
 * @default 20
 * 
 * @arg WaitForProjectile:eval
 * @text Wait For Projectile?
 * @parent Settings
 * @type boolean
 * @on On
 * @off Off
 * @desc Wait for projectile(s) to reach their destination before
 * going onto the next command?
 * @default true
 * 
 * @arg Extra:struct
 * @text Extra Settings
 * @type struct<ProjectileExtra>
 * @desc Add extra settings to the projectile?
 * @default {"AutoAngle:eval":"true","AngleOffset:eval":"+0","Arc:eval":"0","BlendMode:num":"0","EasingType:str":"Linear","Hue:eval":"0","Scale:eval":"1.0","Spin:eval":"+0.0"}
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActionSequenceSpaceSkew
 * @text -
 * @desc -
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActionSequenceBreakSkew
 * @text Action Sequences - Skew
 * @desc Allows you to have control over the camera skew.
 * Requires VisuMZ_3_ActSeqCamera!
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_ChangeSkew
 * @text SKEW: Change Skew
 * @desc Changes the camera skew.
 * Requires VisuMZ_3_ActSeqCamera!
 * 
 * @arg SkewX:eval
 * @text Skew X
 * @desc Change the camera skew X to this value.
 * @default 0
 * 
 * @arg SkewY:eval
 * @text Skew Y
 * @desc Change the camera skew Y to this value.
 * @default 0
 * 
 * @arg Duration:eval
 * @text Duration
 * @desc Duration in frames to change camera skew.
 * @default 60
 *
 * @arg EasingType:str
 * @text Skew Easing
 * @type combo
 * @option Linear
 * @option InSine
 * @option OutSine
 * @option InOutSine
 * @option InQuad
 * @option OutQuad
 * @option InOutQuad
 * @option InCubic
 * @option OutCubic
 * @option InOutCubic
 * @option InQuart
 * @option OutQuart
 * @option InOutQuart
 * @option InQuint
 * @option OutQuint
 * @option InOutQuint
 * @option InExpo
 * @option OutExpo
 * @option InOutExpo
 * @option InCirc
 * @option OutCirc
 * @option InOutCirc
 * @option InBack
 * @option OutBack
 * @option InOutBack
 * @option InElastic
 * @option OutElastic
 * @option InOutElastic
 * @option InBounce
 * @option OutBounce
 * @option InOutBounce
 * @desc Select which easing type you wish to apply.
 * Requires VisuMZ_0_CoreEngine.
 * @default InOutSine
 * 
 * @arg WaitForSkew:eval
 * @text Wait For Skew?
 * @type boolean
 * @on On
 * @off Off
 * @desc Wait for skew changes to complete before performing next command?
 * @default true
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Skew_Reset
 * @text SKEW: Reset Skew
 * @desc Reset any skew settings.
 * Requires VisuMZ_3_ActSeqCamera!
 * 
 * @arg Duration:eval
 * @text Duration
 * @desc Duration in frames to reset camera skew.
 * @default 60
 *
 * @arg EasingType:str
 * @text Skew Easing
 * @type combo
 * @option Linear
 * @option InSine
 * @option OutSine
 * @option InOutSine
 * @option InQuad
 * @option OutQuad
 * @option InOutQuad
 * @option InCubic
 * @option OutCubic
 * @option InOutCubic
 * @option InQuart
 * @option OutQuart
 * @option InOutQuart
 * @option InQuint
 * @option OutQuint
 * @option InOutQuint
 * @option InExpo
 * @option OutExpo
 * @option InOutExpo
 * @option InCirc
 * @option OutCirc
 * @option InOutCirc
 * @option InBack
 * @option OutBack
 * @option InOutBack
 * @option InElastic
 * @option OutElastic
 * @option InOutElastic
 * @option InBounce
 * @option OutBounce
 * @option InOutBounce
 * @desc Select which easing type you wish to apply.
 * Requires VisuMZ_0_CoreEngine.
 * @default InOutSine
 * 
 * @arg WaitForSkew:eval
 * @text Wait For Skew?
 * @type boolean
 * @on On
 * @off Off
 * @desc Wait for skew changes to complete before performing next command?
 * @default true
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Skew_WaitForSkew
 * @text SKEW: Wait For Skew
 * @desc Waits for skew changes to complete before performing next command.
 * Requires VisuMZ_3_ActSeqCamera!
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActionSequenceSpaceTarget
 * @text -
 * @desc -
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActionSequenceBreakTarget
 * @text Action Sequences - Target
 * @desc If using a manual target by target Action Sequence,
 * these commands will give you full control over its usage.
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Target_CurrentIndex
 * @text TARGET: Current Index
 * @desc Sets the current index to this value.
 * Then decide to jump to a label (optional).
 * 
 * @arg Index:eval
 * @text Set Index To
 * @desc Sets current targeting index to this value.
 * 0 is the starting index of a target group.
 * @default 0
 * 
 * @arg JumpToLabel:str
 * @text Jump To Label
 * @desc If a target is found after the index change,
 * jump to this label in the Common Event.
 * @default Untitled
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Target_NextTarget
 * @text TARGET: Next Target
 * @desc Moves index forward by 1 to select a new current target.
 * Then decide to jump to a label (optional).
 * 
 * @arg JumpToLabel:str
 * @text Jump To Label
 * @desc If a target is found after the index change,
 * jump to this label in the Common Event.
 * @default Untitled
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Target_PrevTarget
 * @text TARGET: Previous Target
 * @desc Moves index backward by 1 to select a new current target.
 * Then decide to jump to a label (optional).
 * 
 * @arg JumpToLabel:str
 * @text Jump To Label
 * @desc If a target is found after the index change,
 * jump to this label in the Common Event.
 * @default Untitled
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Target_RandTarget
 * @text TARGET: Random Target
 * @desc Sets index randomly to determine new currernt target.
 * Then decide to jump to a label (optional).
 * 
 * @arg ForceRandom:eval
 * @text Force Random?
 * @type boolean
 * @on On
 * @off Off
 * @desc Index cannot be its previous index amount after random.
 * @default false
 * 
 * @arg JumpToLabel:str
 * @text Jump To Label
 * @desc If a target is found after the index change,
 * jump to this label in the Common Event.
 * @default Untitled
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActionSequenceSpaceVoice
 * @text -
 * @desc -
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActionSequenceBreakVoice
 * @text Action Sequences - Voice
 * @desc Allows you to play battle voices.
 * Requires VisuMZ_3_BattleVoices!
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_BattleVoice_PlayCommonLine
 * @text VOICE: Play Common Line
 * @desc Plays a common voice line from target battler(s).
 * Requires VisuMZ_3_BattleVoices!
 * 
 * @arg Targets:arraystr
 * @text Speaker Target(s)
 * @type combo[]
 * @option user
 * @option current target
 * @option prev target
 * @option next target
 * @option all targets
 * @option focus
 * @option not focus
 * @option
 * @option special
 * @option special x
 * @option 
 * @option alive friends
 * @option alive friends not user
 * @option alive friends not target
 * @option dead friends
 * @option friend index x
 * @option 
 * @option alive opponents
 * @option alive opponents not target
 * @option dead opponents
 * @option opponent index x
 * @option 
 * @option alive actors
 * @option alive actors not user
 * @option alive actors not target
 * @option dead actors
 * @option actor index x
 * @option actor ID x
 * @option 
 * @option alive enemies
 * @option alive enemies not user
 * @option alive enemies not target
 * @option dead enemies
 * @option enemy index x
 * @option enemy ID x
 * @option 
 * @option alive battlers
 * @option alive battlers not user
 * @option alive battlers not target
 * @option dead battlers
 * @option 
 * @desc Select unit(s) to play voice lines from.
 * @default ["user"]
 *
 * @arg VoiceLine:str
 * @text Voice Line
 * @type select
 * @option -
 * @value -
 * @option ---Battle Phase---
 * @value -
 * @option On Battle Start
 * @value BattleStart
 * @option On Battle Input
 * @value BattleInput
 * @option On Battle Victory
 * @value BattleVictory
 * @option Victory => Level Up
 * @value BattleVictoryLevelUp
 * @option Escape => Success
 * @value BattleEscapeSuccess
 * @option Escape => Failure
 * @value BattleEscapeFailure
 * @option -
 * @value -
 * @option ---On Action Start---
 * @value -
 * @option Basic Action => Regular Attack
 * @value ActionStartBasicAttack
 * @option Basic Action => Regular Guard
 * @value ActionStartBasicGuard
 * @option Skill Usage For Allies => Certain Hit
 * @value ActionStartSkillAllyCertainHit
 * @option Skill Usage For Allies => Physical
 * @value ActionStartSkillAllyPhysical
 * @option Skill Usage For Allies => Magical
 * @value ActionStartSkillAllyMagical
 * @option Skill Usage For Enemies => Certain Hit
 * @value ActionStartSkillEnemyCertainHit
 * @option Skill Usage For Enemies => Physical
 * @value ActionStartSkillEnemyPhysical
 * @option Skill Usage For Enemies => Magical
 * @value ActionStartSkillEnemyMagical
 * @option Item Usage For Allies
 * @value ActionStartItemAlly
 * @option Item Usage For Enemies
 * @value ActionStartItemEnemy
 * @option -
 * @value -
 * @option ---Perform Action---
 * @value -
 * @option Basic Action => Attack Motion
 * @value PerformActionBasicAttack
 * @option Basic Action => Critical Action
 * @value PerformActionCritical
 * @option Basic Action => Defeat Opponent
 * @value PerformActionDefeatFoe
 * @option Basic Action => Missed Action
 * @value PerformActionMiss
 * @option Skill Usage => Certain Hit
 * @value PerformActionSkillCertainHit
 * @option Skill Usage => Physical
 * @value PerformActionSkillPhysical
 * @option Skill Usage => Magical
 * @value PerformActionSkillMagical
 * @option -
 * @value -
 * @option ---On HP Change---
 * @value -
 * @option Life State => On Death
 * @value HpChangeDeath
 * @option Life State => On Revive
 * @value HpChangeRevive
 * @option On Damage => Damage <= 0%
 * @value HpChangeDamageNone
 * @option On Damage => Damage < 25%
 * @value HpChangeDamageLight
 * @option On Damage => Damage < 50%
 * @value HpChangeDamageMedium
 * @option On Damage => Damage >= 50%
 * @value HpChangeDamageHeavy
 * @option On Damage => Guarding Damage
 * @value HpChangeDamageGuard
 * @option On Recovery => Recovery < 25%
 * @value HpChangeRecoverLight
 * @option On Recovery => Recovery < 50%
 * @value HpChangeRecoverMedium
 * @option On Recovery => Recovery >= 50%
 * @value HpChangeRecoverHeavy
 * @option -
 * @value -
 * @option ---On Action Result---
 * @value -
 * @option On Miss/Evasion
 * @value ActionResultEvasion
 * @option On Magic Evasion
 * @value ActionResultMagicEvasion
 * @option On Counter
 * @value ActionResultCounter
 * @option On Reflection
 * @value ActionResultReflection
 * @option On Substitute
 * @value ActionResultSubstitute
 * @option -
 * @value -
 * @option ---Buff/Debuff Related---
 * @value -
 * @option On Buff Apply
 * @value BuffAdd
 * @option On Buff Remove
 * @value BuffRemove
 * @option On Debuff Apply
 * @value DebuffAdd
 * @option On Debuff Remove
 * @value DebuffRemove
 * @option -
 * @value -
 * @option ---State Related---
 * @value -
 * @option Positive States => On State Apply
 * @value StatePositiveAdd
 * @option Positive States => text On State Remove
 * @value StatePositiveRemove
 * @option Negative States => On State Apply
 * @value StateNegativeAdd
 * @option Negative States => On State Remove
 * @value StateNegativeRemove
 * @option Neutral States => On State Apply
 * @value StateNeutralAdd
 * @option Neutral States => On State Remove
 * @value StateNeutralRemove
 * @option -
 * @value -
 * @option ---Miscellaneous---
 * @value -
 * @option Voice Preview
 * @value CharaCreatePreview
 * @option -
 * @value -
 * @desc What voice line do you wish to play?
 * @default ActionStartBasicAttack
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_BattleVoice_PlaySpecialLine
 * @text VOICE: Play Special Line
 * @desc Plays a special voice line from target battler(s).
 * Requires VisuMZ_3_BattleVoices!
 * 
 * @arg Targets:arraystr
 * @text Speaker Target(s)
 * @type combo[]
 * @option user
 * @option current target
 * @option prev target
 * @option next target
 * @option all targets
 * @option focus
 * @option not focus
 * @option
 * @option special
 * @option special x
 * @option 
 * @option alive friends
 * @option alive friends not user
 * @option alive friends not target
 * @option dead friends
 * @option friend index x
 * @option 
 * @option alive opponents
 * @option alive opponents not target
 * @option dead opponents
 * @option opponent index x
 * @option 
 * @option alive actors
 * @option alive actors not user
 * @option alive actors not target
 * @option dead actors
 * @option actor index x
 * @option actor ID x
 * @option 
 * @option alive enemies
 * @option alive enemies not user
 * @option alive enemies not target
 * @option dead enemies
 * @option enemy index x
 * @option enemy ID x
 * @option 
 * @option alive battlers
 * @option alive battlers not user
 * @option alive battlers not target
 * @option dead battlers
 * @option 
 * @desc Select unit(s) to play voice lines from.
 * @default ["user"]
 *
 * @arg VoiceLineType:str
 * @text Voice Line Type
 * @type select
 * @option Action Name
 * @value ActionName
 * @option Chant Line
 * @value ChantLine
 * @option Item Name
 * @value ItemName
 * @option Skill Name
 * @value SkillName
 * @option Spell Name
 * @value SpellName
 * @option Unique Lines
 * @value UniqueLine
 * @desc What voice line type do you wish to play?
 * @default ActionName
 *
 * @arg Letter:str
 * @text Name / Letter
 * @type select
 * @option A
 * @option B
 * @option C
 * @option D
 * @option E
 * @option F
 * @option G
 * @option H
 * @option I
 * @option J
 * @option K
 * @option L
 * @option M
 * @option N
 * @option O
 * @option P
 * @option Q
 * @option R
 * @option S
 * @option T
 * @option U
 * @option V
 * @option W
 * @option X
 * @option Y
 * @option Z
 * @desc What voice letter/name do you want to play?
 * @default A
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActionSequenceSpaceWeapon
 * @text -
 * @desc -
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActionSequenceBreakWeapon
 * @text Action Sequences - Weapon
 * @desc Allows for finer control over Dual/Multi Wielding actors.
 * Only works for Actors.
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Weapon_ClearActiveWeapon
 * @text WEAPON: Clear Weapon Slot
 * @desc Clears the active weapon slot (making others valid again).
 * Only works for Actors.
 * 
 * @arg Targets:arraystr
 * @text Targets
 * @type combo[]
 * @option user
 * @option current target
 * @option prev target
 * @option next target
 * @option all targets
 * @option focus
 * @option not focus
 * @option
 * @option special
 * @option special x
 * @option 
 * @option alive friends
 * @option alive friends not user
 * @option alive friends not target
 * @option dead friends
 * @option friend index x
 * @option 
 * @option alive opponents
 * @option alive opponents not target
 * @option dead opponents
 * @option opponent index x
 * @option 
 * @option alive actors
 * @option alive actors not user
 * @option alive actors not target
 * @option dead actors
 * @option actor index x
 * @option actor ID x
 * @option 
 * @desc Select unit(s) to clear the active weapon slot for.
 * @default ["user"]
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Weapon_NextActiveWeapon
 * @text WEAPON: Next Weapon Slot
 * @desc Goes to next active weapon slot (making others invalid).
 * If next slot is weaponless, don't label jump.
 * 
 * @arg Targets:arraystr
 * @text Targets
 * @type combo[]
 * @option user
 * @option current target
 * @option prev target
 * @option next target
 * @option all targets
 * @option focus
 * @option not focus
 * @option
 * @option special
 * @option special x
 * @option 
 * @option alive friends
 * @option alive friends not user
 * @option alive friends not target
 * @option dead friends
 * @option friend index x
 * @option 
 * @option alive opponents
 * @option alive opponents not target
 * @option dead opponents
 * @option opponent index x
 * @option 
 * @option alive actors
 * @option alive actors not user
 * @option alive actors not target
 * @option dead actors
 * @option actor index x
 * @option actor ID x
 * @option 
 * @desc Select unit(s) to change the next active weapon slot for.
 * @default ["user"]
 * 
 * @arg JumpToLabel:str
 * @text Jump To Label
 * @desc If a weapon is found after the index change,
 * jump to this label in the Common Event.
 * @default Untitled
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Weapon_SetActiveWeapon
 * @text WEAPON: Set Weapon Slot
 * @desc Sets the active weapon slot (making others invalid).
 * Only works for Actors.
 * 
 * @arg Targets:arraystr
 * @text Targets
 * @type combo[]
 * @option user
 * @option current target
 * @option prev target
 * @option next target
 * @option all targets
 * @option focus
 * @option not focus
 * @option
 * @option special
 * @option special x
 * @option 
 * @option alive friends
 * @option alive friends not user
 * @option alive friends not target
 * @option dead friends
 * @option friend index x
 * @option 
 * @option alive opponents
 * @option alive opponents not target
 * @option dead opponents
 * @option opponent index x
 * @option 
 * @option alive actors
 * @option alive actors not user
 * @option alive actors not target
 * @option dead actors
 * @option actor index x
 * @option actor ID x
 * @option 
 * @desc Select unit(s) to change the active weapon slot for.
 * @default ["user"]
 * 
 * @arg SlotID:eval
 * @text Weapon Slot ID
 * @desc Select weapon slot to make active (making others invalid).
 * Use 0 to clear and normalize. You may use JavaScript code.
 * @default 1
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActionSequenceSpaceZoom
 * @text -
 * @desc -
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActionSequenceBreakZoom
 * @text Action Sequences - Zoom
 * @desc Allows you to have control over the screen zoom.
 * Requires VisuMZ_3_ActSeqCamera!
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Zoom_Scale
 * @text ZOOM: Change Scale
 * @desc Changes the zoom scale.
 * Requires VisuMZ_3_ActSeqCamera!
 * 
 * @arg Scale:eval
 * @text Scale
 * @desc The zoom scale to change to.
 * @default 1.0
 * 
 * @arg Duration:eval
 * @text Duration
 * @desc Duration in frames to change battle zoom.
 * @default 60
 *
 * @arg EasingType:str
 * @text Zoom Easing
 * @type combo
 * @option Linear
 * @option InSine
 * @option OutSine
 * @option InOutSine
 * @option InQuad
 * @option OutQuad
 * @option InOutQuad
 * @option InCubic
 * @option OutCubic
 * @option InOutCubic
 * @option InQuart
 * @option OutQuart
 * @option InOutQuart
 * @option InQuint
 * @option OutQuint
 * @option InOutQuint
 * @option InExpo
 * @option OutExpo
 * @option InOutExpo
 * @option InCirc
 * @option OutCirc
 * @option InOutCirc
 * @option InBack
 * @option OutBack
 * @option InOutBack
 * @option InElastic
 * @option OutElastic
 * @option InOutElastic
 * @option InBounce
 * @option OutBounce
 * @option InOutBounce
 * @desc Select which easing type you wish to apply.
 * Requires VisuMZ_0_CoreEngine.
 * @default InOutSine
 * 
 * @arg WaitForZoom:eval
 * @text Wait For Zoom?
 * @type boolean
 * @on On
 * @off Off
 * @desc Wait for zoom changes to complete before performing next command?
 * @default true
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Zoom_Reset
 * @text ZOOM: Reset Zoom
 * @desc Reset any zoom settings.
 * Requires VisuMZ_3_ActSeqCamera!
 * 
 * @arg Duration:eval
 * @text Duration
 * @desc Duration in frames to reset battle zoom.
 * @default 60
 *
 * @arg EasingType:str
 * @text Zoom Easing
 * @type combo
 * @option Linear
 * @option InSine
 * @option OutSine
 * @option InOutSine
 * @option InQuad
 * @option OutQuad
 * @option InOutQuad
 * @option InCubic
 * @option OutCubic
 * @option InOutCubic
 * @option InQuart
 * @option OutQuart
 * @option InOutQuart
 * @option InQuint
 * @option OutQuint
 * @option InOutQuint
 * @option InExpo
 * @option OutExpo
 * @option InOutExpo
 * @option InCirc
 * @option OutCirc
 * @option InOutCirc
 * @option InBack
 * @option OutBack
 * @option InOutBack
 * @option InElastic
 * @option OutElastic
 * @option InOutElastic
 * @option InBounce
 * @option OutBounce
 * @option InOutBounce
 * @desc Select which easing type you wish to apply.
 * Requires VisuMZ_0_CoreEngine.
 * @default InOutSine
 * 
 * @arg WaitForZoom:eval
 * @text Wait For Zoom?
 * @type boolean
 * @on On
 * @off Off
 * @desc Wait for zoom changes to complete before performing next command?
 * @default true
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActSeq_Zoom_WaitForZoom
 * @text ZOOM: Wait For Zoom
 * @desc Waits for zoom to complete before performing next command.
 * Requires VisuMZ_3_ActSeqCamera!
 *
 * @ --------------------------------------------------------------------------
 *
 * @command ActionSequenceSpaceEnd
 * @text -
 * @desc -
 *
 * @ --------------------------------------------------------------------------
 *
 * @ ==========================================================================
 * @ Plugin Parameters
 * @ ==========================================================================
 *
 * @param BreakHead
 * @text --------------------------
 * @default ----------------------------------
 *
 * @param BattleCore
 * @default Plugin Parameters
 *
 * @param ATTENTION
 * @default READ THE HELP FILE
 *
 * @param BreakSettings
 * @text --------------------------
 * @default ----------------------------------
 *
 * @param AutoBattle:struct
 * @text Auto Battle Settings
 * @type struct<AutoBattle>
 * @desc Settings pertaining to Auto Battle.
 * @default {"BattleDisplay":"","AutoBattleMsg:str":"Press %1 or %2 to stop Auto Battle","AutoBattleOK:str":"OK","AutoBattleCancel:str":"Cancel","AutoBattleBgType:num":"1","AutoBattleRect:func":"\"const width = Graphics.width;\\nconst height = this.calcWindowHeight(1, false);\\nconst x = 0;\\nconst y = (Graphics.height - height) / 2;\\nreturn new Rectangle(x, y, width, height);\"","Options":"","AddOption:eval":"true","AdjustRect:eval":"true","StartName:str":"Auto Battle Start","StyleName:str":"Auto Battle Style","StyleOFF:str":"Attack","StyleON:str":"Skills"}
 *
 * @param Damage:struct
 * @text Damage Settings
 * @type struct<Damage>
 * @desc Settings pertaining to damage calculations.
 * @default {"DamageStyles":"","DefaultDamageStyle:str":"Standard","DamageStyleList:arraystruct":"[\"{\\\"Name:str\\\":\\\"Standard\\\",\\\"Formula:func\\\":\\\"\\\\\\\"// Declare Constants\\\\\\\\nconst user = this.subject();\\\\\\\\nconst target = arguments[0];\\\\\\\\nconst item = this.item();\\\\\\\\nconst a = this.subject();\\\\\\\\nconst b = target;\\\\\\\\nconst v = $gameVariables._data;\\\\\\\\nconst sign = [3, 4].includes(item.damage.type) ? -1 : 1;\\\\\\\\n\\\\\\\\n// Replace Formula\\\\\\\\nlet formula = item.damage.formula;\\\\\\\\nif (SceneManager.isSceneBattle() && !this.isCertainHit()) {\\\\\\\\n    const fmt = 'Math.max(this.applyArmorModifiers(b, %1), 0)';\\\\\\\\n    formula = formula.replace(/b.def/g, fmt.format('b.def'));\\\\\\\\n    formula = formula.replace(/b.mdf/g, fmt.format('b.mdf'));\\\\\\\\n    formula = formula.replace(/b.agi/g, fmt.format('b.agi'));\\\\\\\\n    formula = formula.replace(/b.luk/g, fmt.format('b.luk'));\\\\\\\\n}\\\\\\\\n\\\\\\\\n// Calculate Damage\\\\\\\\nlet value = Math.max(eval(formula), 0);\\\\\\\\n\\\\\\\\n// Return Value\\\\\\\\nreturn (isNaN(value) ? 0 : value) * sign;\\\\\\\"\\\",\\\"ItemsEquipsCore\\\":\\\"\\\",\\\"DamageType\\\":\\\"\\\",\\\"DamageType1:str\\\":\\\"%1 Damage Multiplier\\\",\\\"DamageType2:str\\\":\\\"%1 Damage Multiplier\\\",\\\"DamageType3:str\\\":\\\"%1 Recovery Multiplier\\\",\\\"DamageType4:str\\\":\\\"%1 Recovery Multiplier\\\",\\\"DamageType5:str\\\":\\\"%1 Drain Multiplier\\\",\\\"DamageType6:str\\\":\\\"%1 Drain Multiplier\\\",\\\"DamageDisplay:func\\\":\\\"\\\\\\\"return this.getItemDamageAmountTextOriginal();\\\\\\\"\\\"}\",\"{\\\"Name:str\\\":\\\"Armor Scaling\\\",\\\"Formula:func\\\":\\\"\\\\\\\"// Declare Constants\\\\\\\\nconst user = this.subject();\\\\\\\\nconst target = arguments[0];\\\\\\\\nconst item = this.item();\\\\\\\\nconst a = this.subject();\\\\\\\\nconst b = target;\\\\\\\\nconst v = $gameVariables._data;\\\\\\\\nconst sign = [3, 4].includes(item.damage.type) ? -1 : 1;\\\\\\\\n\\\\\\\\n// Replace Formula\\\\\\\\nlet formula = item.damage.formula;\\\\\\\\nif (SceneManager.isSceneBattle() && !this.isCertainHit()) {\\\\\\\\n    const fmt = 'Math.max(this.applyArmorModifiers(b, %1), 1)';\\\\\\\\n    formula = formula.replace(/b.def/g, fmt.format('b.def'));\\\\\\\\n    formula = formula.replace(/b.mdf/g, fmt.format('b.mdf'));\\\\\\\\n    formula = formula.replace(/b.agi/g, fmt.format('b.agi'));\\\\\\\\n    formula = formula.replace(/b.luk/g, fmt.format('b.luk'));\\\\\\\\n}\\\\\\\\n\\\\\\\\n// Calculate Damage\\\\\\\\nlet value = Math.max(eval(formula), 0);\\\\\\\\n\\\\\\\\n// Apply Defender's Defense Parameter\\\\\\\\nif (this.isDamage() && !this.isCertainHit()) {\\\\\\\\n\\\\\\\\n    // Calculate Base Armor\\\\\\\\n    let armor = this.isPhysical() ? b.def : b.mdf;\\\\\\\\n    armor = this.applyArmorModifiers(target, armor);\\\\\\\\n\\\\\\\\n    // Apply Armor to Damage\\\\\\\\n    if (armor >= 0) {\\\\\\\\n        value *= 100 / (100 + armor);\\\\\\\\n    } else {\\\\\\\\n        value *= 2 - (100 / (100 - armor));\\\\\\\\n    }\\\\\\\\n}\\\\\\\\n\\\\\\\\n// Return Value\\\\\\\\nreturn (isNaN(value) ? 0 : value) * sign;\\\\\\\"\\\",\\\"ItemsEquipsCore\\\":\\\"\\\",\\\"DamageType\\\":\\\"\\\",\\\"DamageType1:str\\\":\\\"%1 Damage Multiplier\\\",\\\"DamageType2:str\\\":\\\"%1 Damage Multiplier\\\",\\\"DamageType3:str\\\":\\\"%1 Recovery Multiplier\\\",\\\"DamageType4:str\\\":\\\"%1 Recovery Multiplier\\\",\\\"DamageType5:str\\\":\\\"%1 Drain Multiplier\\\",\\\"DamageType6:str\\\":\\\"%1 Drain Multiplier\\\",\\\"DamageDisplay:func\\\":\\\"\\\\\\\"return this.getItemDamageAmountTextOriginal();\\\\\\\"\\\"}\",\"{\\\"Name:str\\\":\\\"CT\\\",\\\"Formula:func\\\":\\\"\\\\\\\"// Define Constants\\\\\\\\nconst user = this.subject();\\\\\\\\nconst target = arguments[0];\\\\\\\\nconst item = this.item();\\\\\\\\nconst a = this.subject();\\\\\\\\nconst b = target;\\\\\\\\nconst v = $gameVariables._data;\\\\\\\\nconst sign = [3, 4].includes(item.damage.type) ? -1 : 1;\\\\\\\\n\\\\\\\\n// Create Multiplier\\\\\\\\nconst multiplier = Math.max(eval(item.damage.formula), 0);\\\\\\\\n\\\\\\\\n// Declare Values\\\\\\\\nlet value = 0;\\\\\\\\nlet level = Math.max(a.level || a.luk, 1);\\\\\\\\nlet armor = this.isPhysical() ? b.def : b.mdf;\\\\\\\\narmor = Math.max(this.applyArmorModifiers(target, armor), 0);\\\\\\\\nlet attackStat = 0;\\\\\\\\nif (this.isPhysical() && (this.isDamage() || this.isDrain())) {\\\\\\\\n    attackStat = a.atk;\\\\\\\\n} else if (this.isMagical() && (this.isDamage() || this.isDrain())) {\\\\\\\\n    attackStat =  a.mat;\\\\\\\\n} else if (this.isPhysical() && this.isRecover()) {\\\\\\\\n    attackStat =  a.def;\\\\\\\\n} else if (this.isMagical() && this.isRecover()) {\\\\\\\\n    attackStat =  a.mdf;\\\\\\\\n}\\\\\\\\n\\\\\\\\n// Calculate Damage\\\\\\\\nattackStat = (attackStat * 1.75) + (level ** 2 / 45.5);\\\\\\\\nvalue = attackStat * 4;\\\\\\\\nif (this.isPhysical() && (this.isDamage() || this.isDrain())) {\\\\\\\\n    value *= Math.max(256 - armor, 0) / 256;\\\\\\\\n} else if (this.isMagical() && (this.isDamage() || this.isDrain())) {\\\\\\\\n    value *= Math.max(102.4 - armor, 0) / 128;\\\\\\\\n}\\\\\\\\nvalue *= multiplier;\\\\\\\\n\\\\\\\\n// Return Value\\\\\\\\nreturn (isNaN(value) ? 0 : value) * sign;\\\\\\\"\\\",\\\"ItemsEquipsCore\\\":\\\"\\\",\\\"DamageType\\\":\\\"\\\",\\\"DamageType1:str\\\":\\\"%1 Damage Multiplier\\\",\\\"DamageType2:str\\\":\\\"%1 Damage Multiplier\\\",\\\"DamageType3:str\\\":\\\"%1 Recovery Multiplier\\\",\\\"DamageType4:str\\\":\\\"%1 Recovery Multiplier\\\",\\\"DamageType5:str\\\":\\\"%1 Drain Multiplier\\\",\\\"DamageType6:str\\\":\\\"%1 Drain Multiplier\\\",\\\"DamageDisplay:func\\\":\\\"\\\\\\\"// Define Constants\\\\\\\\nconst item = this._item;\\\\\\\\nconst formula = item.damage.formula;\\\\\\\\nconst a = this._tempActorA;\\\\\\\\nconst b = this._tempActorB;\\\\\\\\nconst user = a;\\\\\\\\nconst target = b;\\\\\\\\n\\\\\\\\n// Return Value\\\\\\\\ntry {\\\\\\\\n    const value = Math.max(eval(formula), 0);\\\\\\\\n    return '%1%'.format(Math.round(value * 100));\\\\\\\\n} catch (e) {\\\\\\\\n    if ($gameTemp.isPlaytest()) {\\\\\\\\n        console.log('Damage Formula Error for %1'.format(this._item.name));\\\\\\\\n    }\\\\\\\\n    return '?????';\\\\\\\\n}\\\\\\\"\\\"}\",\"{\\\"Name:str\\\":\\\"D4\\\",\\\"Formula:func\\\":\\\"\\\\\\\"// Define Constants\\\\\\\\nconst user = this.subject();\\\\\\\\nconst target = arguments[0];\\\\\\\\nconst item = this.item();\\\\\\\\nconst a = this.subject();\\\\\\\\nconst b = target;\\\\\\\\nconst v = $gameVariables._data;\\\\\\\\nconst sign = [3, 4].includes(item.damage.type) ? -1 : 1;\\\\\\\\n\\\\\\\\n// Create Multiplier\\\\\\\\nconst multiplier = Math.max(eval(item.damage.formula), 0);\\\\\\\\n\\\\\\\\n// Declare Values\\\\\\\\nlet armor = this.isPhysical() ? b.def : b.mdf;\\\\\\\\narmor = this.applyArmorModifiers(target, armor);\\\\\\\\nlet stat = 0;\\\\\\\\nif (this.isPhysical() && (this.isDamage() || this.isDrain())) {\\\\\\\\n    stat = a.atk;\\\\\\\\n} else if (this.isMagical() && (this.isDamage() || this.isDrain())) {\\\\\\\\n    stat = a.mat;\\\\\\\\n} else if (this.isPhysical() && this.isRecover()) {\\\\\\\\n    stat = a.def;\\\\\\\\n    armor = 0;\\\\\\\\n} else if (this.isMagical() && this.isRecover()) {\\\\\\\\n    stat = a.mdf;\\\\\\\\n    armor = 0;\\\\\\\\n}\\\\\\\\n\\\\\\\\n// Calculate Damage \\\\\\\\nlet value = 1.5 * Math.max(2 * stat * multiplier - armor, 1) * multiplier / 5;\\\\\\\\n\\\\\\\\n// Return Value\\\\\\\\nreturn (isNaN(value) ? 0 : value) * sign;\\\\\\\"\\\",\\\"ItemsEquipsCore\\\":\\\"\\\",\\\"DamageType\\\":\\\"\\\",\\\"DamageType1:str\\\":\\\"%1 Damage Multiplier\\\",\\\"DamageType2:str\\\":\\\"%1 Damage Multiplier\\\",\\\"DamageType3:str\\\":\\\"%1 Recovery Multiplier\\\",\\\"DamageType4:str\\\":\\\"%1 Recovery Multiplier\\\",\\\"DamageType5:str\\\":\\\"%1 Drain Multiplier\\\",\\\"DamageType6:str\\\":\\\"%1 Drain Multiplier\\\",\\\"DamageDisplay:func\\\":\\\"\\\\\\\"// Define Constants\\\\\\\\nconst item = this._item;\\\\\\\\nconst formula = item.damage.formula;\\\\\\\\nconst a = this._tempActorA;\\\\\\\\nconst b = this._tempActorB;\\\\\\\\nconst user = a;\\\\\\\\nconst target = b;\\\\\\\\n\\\\\\\\n// Return Value\\\\\\\\ntry {\\\\\\\\n    const value = Math.max(eval(formula), 0);\\\\\\\\n    return '%1%'.format(Math.round(value * 100));\\\\\\\\n} catch (e) {\\\\\\\\n    if ($gameTemp.isPlaytest()) {\\\\\\\\n        console.log('Damage Formula Error for %1'.format(this._item.name));\\\\\\\\n    }\\\\\\\\n    return '?????';\\\\\\\\n}\\\\\\\"\\\"}\",\"{\\\"Name:str\\\":\\\"DQ\\\",\\\"Formula:func\\\":\\\"\\\\\\\"// Define Constants\\\\\\\\nconst user = this.subject();\\\\\\\\nconst target = arguments[0];\\\\\\\\nconst item = this.item();\\\\\\\\nconst a = this.subject();\\\\\\\\nconst b = target;\\\\\\\\nconst v = $gameVariables._data;\\\\\\\\nconst sign = [3, 4].includes(item.damage.type) ? -1 : 1;\\\\\\\\n\\\\\\\\n// Create Multiplier\\\\\\\\nlet multiplier = Math.max(eval(item.damage.formula), 0);\\\\\\\\nif (this.isCertainHit()) {\\\\\\\\n    let value = multiplier * Math.max(a.atk, a.mat);\\\\\\\\n    return (isNaN(value) ? 0 : value) * sign;\\\\\\\\n}\\\\\\\\n\\\\\\\\n// Get Primary Stats\\\\\\\\nlet armor = this.isPhysical() ? b.def : b.mdf;\\\\\\\\narmor = this.applyArmorModifiers(b, armor);\\\\\\\\nlet stat = 1;\\\\\\\\nif (this.isPhysical() && (this.isDamage() || this.isDrain())) {\\\\\\\\n    stat = a.atk;\\\\\\\\n} else if (this.isMagical() && (this.isDamage() || this.isDrain())) {\\\\\\\\n    stat = a.mat;\\\\\\\\n} else if (this.isPhysical() && this.isRecover()) {\\\\\\\\n    stat = a.def;\\\\\\\\n} else if (this.isMagical() && this.isRecover()) {\\\\\\\\n    stat = a.mdf;\\\\\\\\n}\\\\\\\\n\\\\\\\\n// Check for Recovery\\\\\\\\nif (this.isRecover()) {\\\\\\\\n    let value = stat * multiplier * sign;\\\\\\\\n    return isNaN(value) ? 0 : value;\\\\\\\\n}\\\\\\\\n\\\\\\\\n// Calculate Damage\\\\\\\\nlet value = 0;\\\\\\\\nif (stat < ((2 + armor) / 2)) {\\\\\\\\n    // Plink Damage\\\\\\\\n    let baseline = Math.max(stat - ((12 * (armor - stat + 1)) / stat), 5);\\\\\\\\n    value = baseline / 3;\\\\\\\\n} else {\\\\\\\\n    // Normal Damage\\\\\\\\n    let baseline = Math.max(stat - (armor / 2), 1);\\\\\\\\n    value = baseline / 2;\\\\\\\\n}\\\\\\\\nvalue *= multiplier;\\\\\\\\n\\\\\\\\n// Return Value\\\\\\\\nreturn isNaN(value) ? 0 : value;\\\\\\\"\\\",\\\"ItemsEquipsCore\\\":\\\"\\\",\\\"DamageType\\\":\\\"\\\",\\\"DamageType1:str\\\":\\\"%1 Damage Multiplier\\\",\\\"DamageType2:str\\\":\\\"%1 Damage Multiplier\\\",\\\"DamageType3:str\\\":\\\"%1 Recovery Multiplier\\\",\\\"DamageType4:str\\\":\\\"%1 Recovery Multiplier\\\",\\\"DamageType5:str\\\":\\\"%1 Drain Multiplier\\\",\\\"DamageType6:str\\\":\\\"%1 Drain Multiplier\\\",\\\"DamageDisplay:func\\\":\\\"\\\\\\\"// Define Constants\\\\\\\\nconst item = this._item;\\\\\\\\nconst formula = item.damage.formula;\\\\\\\\nconst a = this._tempActorA;\\\\\\\\nconst b = this._tempActorB;\\\\\\\\nconst user = a;\\\\\\\\nconst target = b;\\\\\\\\n\\\\\\\\n// Return Value\\\\\\\\ntry {\\\\\\\\n    const value = Math.max(eval(formula), 0);\\\\\\\\n    return '%1%'.format(Math.round(value * 100));\\\\\\\\n} catch (e) {\\\\\\\\n    if ($gameTemp.isPlaytest()) {\\\\\\\\n        console.log('Damage Formula Error for %1'.format(this._item.name));\\\\\\\\n    }\\\\\\\\n    return '?????';\\\\\\\\n}\\\\\\\"\\\"}\",\"{\\\"Name:str\\\":\\\"FF7\\\",\\\"Formula:func\\\":\\\"\\\\\\\"// Define Constants\\\\\\\\nconst user = this.subject();\\\\\\\\nconst target = arguments[0];\\\\\\\\nconst item = this.item();\\\\\\\\nconst a = this.subject();\\\\\\\\nconst b = target;\\\\\\\\nconst v = $gameVariables._data;\\\\\\\\nconst sign = [3, 4].includes(item.damage.type) ? -1 : 1;\\\\\\\\n\\\\\\\\n// Create Power\\\\\\\\nconst power = Math.max(eval(item.damage.formula), 0);\\\\\\\\n\\\\\\\\n// Declare base Damage\\\\\\\\nlet baseDamage = 0;\\\\\\\\nlet level = Math.max(a.level || a.luk, 1);\\\\\\\\nif (this.isPhysical() && (this.isDamage() || this.isDrain())) {\\\\\\\\n    baseDamage = a.atk + ((a.atk + level) / 32) * ((a.atk * level) / 32);\\\\\\\\n} else if (this.isMagical() && (this.isDamage() || this.isDrain())) {\\\\\\\\n    baseDamage = 6 * (a.mat + level);\\\\\\\\n} else if (this.isPhysical() && this.isRecover()) {\\\\\\\\n    baseDamage = 6 * (a.def + level);\\\\\\\\n} else if (this.isMagical() && this.isRecover()) {\\\\\\\\n    baseDamage = 6 * (a.mdf + level);\\\\\\\\n}\\\\\\\\n\\\\\\\\n// Calculate Final Damage\\\\\\\\nlet value = baseDamage;\\\\\\\\nlet armor = this.isPhysical() ? b.def : b.mdf;\\\\\\\\narmor = this.applyArmorModifiers(target, armor);\\\\\\\\nif (this.isRecover()) {\\\\\\\\n    value += 22 * power;\\\\\\\\n} else {\\\\\\\\n    value = (power * Math.max(512 - armor, 1) * baseDamage) / (16 * 512);\\\\\\\\n}\\\\\\\\n\\\\\\\\n// Return Value\\\\\\\\nreturn (isNaN(value) ? 0 : value) * sign;\\\\\\\"\\\",\\\"ItemsEquipsCore\\\":\\\"\\\",\\\"DamageType\\\":\\\"\\\",\\\"DamageType1:str\\\":\\\"%1 Damage Power\\\",\\\"DamageType2:str\\\":\\\"%1 Damage Power\\\",\\\"DamageType3:str\\\":\\\"%1 Recovery Power\\\",\\\"DamageType4:str\\\":\\\"%1 Recovery Power\\\",\\\"DamageType5:str\\\":\\\"%1 Drain Power\\\",\\\"DamageType6:str\\\":\\\"%1 Drain Power\\\",\\\"DamageDisplay:func\\\":\\\"\\\\\\\"// Define Constants\\\\\\\\nconst item = this._item;\\\\\\\\nconst formula = item.damage.formula;\\\\\\\\nconst a = this._tempActorA;\\\\\\\\nconst b = this._tempActorB;\\\\\\\\nconst user = a;\\\\\\\\nconst target = b;\\\\\\\\n\\\\\\\\n// Return Value\\\\\\\\ntry {\\\\\\\\n    return formula;\\\\\\\\n} catch (e) {\\\\\\\\n    if ($gameTemp.isPlaytest()) {\\\\\\\\n        console.log('Damage Formula Error for %1'.format(this._item.name));\\\\\\\\n    }\\\\\\\\n    return '?????';\\\\\\\\n}\\\\\\\"\\\"}\",\"{\\\"Name:str\\\":\\\"FF8\\\",\\\"Formula:func\\\":\\\"\\\\\\\"// Define Constants\\\\\\\\nconst user = this.subject();\\\\\\\\nconst target = arguments[0];\\\\\\\\nconst item = this.item();\\\\\\\\nconst a = this.subject();\\\\\\\\nconst b = target;\\\\\\\\nconst v = $gameVariables._data;\\\\\\\\nconst sign = [3, 4].includes(item.damage.type) ? -1 : 1;\\\\\\\\n\\\\\\\\n// Create Power\\\\\\\\nconst power = Math.max(eval(item.damage.formula), 0);\\\\\\\\n\\\\\\\\n// Declare Damage\\\\\\\\nlet Value = 0;\\\\\\\\nlet level = Math.max(a.level || a.luk, 1);\\\\\\\\nlet armor = this.isPhysical() ? b.def : b.mdf;\\\\\\\\narmor = this.applyArmorModifiers(target, armor);\\\\\\\\nif (this.isPhysical() && (this.isDamage() || this.isDrain())) {\\\\\\\\n    value = a.atk ** 2 / 16 + a.atk;\\\\\\\\n    value *= Math.max(265 - armor, 1) / 256;\\\\\\\\n    value *= power / 16;\\\\\\\\n} else if (this.isMagical() && (this.isDamage() || this.isDrain())) {\\\\\\\\n    value = a.mat + power;\\\\\\\\n    value *= Math.max(265 - armor, 1) / 4;\\\\\\\\n    value *= power / 256;\\\\\\\\n} else if (this.isPhysical() && this.isRecover()) {\\\\\\\\n    value = (power + a.def) * power / 2;\\\\\\\\n} else if (this.isMagical() && this.isRecover()) {\\\\\\\\n    value = (power + a.mdf) * power / 2;\\\\\\\\n}\\\\\\\\n\\\\\\\\n// Return Value\\\\\\\\nreturn (isNaN(value) ? 0 : value) * sign;\\\\\\\"\\\",\\\"ItemsEquipsCore\\\":\\\"\\\",\\\"DamageType\\\":\\\"\\\",\\\"DamageType1:str\\\":\\\"%1 Damage Power\\\",\\\"DamageType2:str\\\":\\\"%1 Damage Power\\\",\\\"DamageType3:str\\\":\\\"%1 Recovery Power\\\",\\\"DamageType4:str\\\":\\\"%1 Recovery Power\\\",\\\"DamageType5:str\\\":\\\"%1 Drain Power\\\",\\\"DamageType6:str\\\":\\\"%1 Drain Power\\\",\\\"DamageDisplay:func\\\":\\\"\\\\\\\"// Define Constants\\\\\\\\nconst item = this._item;\\\\\\\\nconst formula = item.damage.formula;\\\\\\\\nconst a = this._tempActorA;\\\\\\\\nconst b = this._tempActorB;\\\\\\\\nconst user = a;\\\\\\\\nconst target = b;\\\\\\\\n\\\\\\\\n// Return Value\\\\\\\\ntry {\\\\\\\\n    return formula;\\\\\\\\n} catch (e) {\\\\\\\\n    if ($gameTemp.isPlaytest()) {\\\\\\\\n        console.log('Damage Formula Error for %1'.format(this._item.name));\\\\\\\\n    }\\\\\\\\n    return '?????';\\\\\\\\n}\\\\\\\"\\\"}\",\"{\\\"Name:str\\\":\\\"FF9\\\",\\\"Formula:func\\\":\\\"\\\\\\\"// Define Constants\\\\\\\\nconst user = this.subject();\\\\\\\\nconst target = arguments[0];\\\\\\\\nconst item = this.item();\\\\\\\\nconst a = this.subject();\\\\\\\\nconst b = target;\\\\\\\\nconst v = $gameVariables._data;\\\\\\\\nconst sign = [3, 4].includes(item.damage.type) ? -1 : 1;\\\\\\\\n\\\\\\\\n// Create Damage Constant\\\\\\\\nconst power = Math.max(eval(item.damage.formula), 0);\\\\\\\\nif (this.isCertainHit()) {\\\\\\\\n    return (isNaN(power) ? 0 : power) * sign;\\\\\\\\n}\\\\\\\\n\\\\\\\\n// Declare Main Stats\\\\\\\\nlet armor = this.isPhysical() ? b.def : b.mdf;\\\\\\\\narmor = this.applyArmorModifiers(b, armor);\\\\\\\\nlet stat = 1;\\\\\\\\nif (this.isPhysical() && (this.isDamage() || this.isDrain())) {\\\\\\\\n    stat = a.atk;\\\\\\\\n} else if (this.isMagical() && (this.isDamage() || this.isDrain())) {\\\\\\\\n    stat = a.mat;\\\\\\\\n} else if (this.isPhysical() && this.isRecover()) {\\\\\\\\n    stat = a.def;\\\\\\\\n} else if (this.isMagical() && this.isRecover()) {\\\\\\\\n    stat = a.mdf;\\\\\\\\n}\\\\\\\\n\\\\\\\\n// Declare Base Damage\\\\\\\\nlet baseDamage = power;\\\\\\\\nif (this.isPhysical()) {\\\\\\\\n    baseDamage += stat;\\\\\\\\n}\\\\\\\\nif (this.isDamage() || this.isDrain()) {\\\\\\\\n    baseDamage -= armor;\\\\\\\\n    baseDamage = Math.max(1, baseDamage);\\\\\\\\n}\\\\\\\\n\\\\\\\\n// Declare Bonus Damage\\\\\\\\nlet bonusDamage = stat + (((a.level || a.luk) + stat) / 8);\\\\\\\\n\\\\\\\\n// Declare Final Damage\\\\\\\\nlet value = baseDamage * bonusDamage * sign;\\\\\\\\n\\\\\\\\n// Return Value\\\\\\\\nreturn isNaN(value) ? 0 : value;\\\\\\\"\\\",\\\"ItemsEquipsCore\\\":\\\"\\\",\\\"DamageType\\\":\\\"\\\",\\\"DamageType1:str\\\":\\\"%1 Damage Power\\\",\\\"DamageType2:str\\\":\\\"%1 Damage Power\\\",\\\"DamageType3:str\\\":\\\"%1 Recovery Power\\\",\\\"DamageType4:str\\\":\\\"%1 Recovery Power\\\",\\\"DamageType5:str\\\":\\\"%1 Drain Power\\\",\\\"DamageType6:str\\\":\\\"%1 Drain Power\\\",\\\"DamageDisplay:func\\\":\\\"\\\\\\\"// Define Constants\\\\\\\\nconst item = this._item;\\\\\\\\nconst formula = item.damage.formula;\\\\\\\\nconst a = this._tempActorA;\\\\\\\\nconst b = this._tempActorB;\\\\\\\\nconst user = a;\\\\\\\\nconst target = b;\\\\\\\\n\\\\\\\\n// Return Value\\\\\\\\ntry {\\\\\\\\n    return formula;\\\\\\\\n} catch (e) {\\\\\\\\n    if ($gameTemp.isPlaytest()) {\\\\\\\\n        console.log('Damage Formula Error for %1'.format(this._item.name));\\\\\\\\n    }\\\\\\\\n    return '?????';\\\\\\\\n}\\\\\\\"\\\"}\",\"{\\\"Name:str\\\":\\\"FF10\\\",\\\"Formula:func\\\":\\\"\\\\\\\"// Define Constants\\\\\\\\nconst user = this.subject();\\\\\\\\nconst target = arguments[0];\\\\\\\\nconst item = this.item();\\\\\\\\nconst a = this.subject();\\\\\\\\nconst b = target;\\\\\\\\nconst v = $gameVariables._data;\\\\\\\\nconst sign = [3, 4].includes(item.damage.type) ? -1 : 1;\\\\\\\\n\\\\\\\\n// Create Damage Constant\\\\\\\\nconst power = Math.max(eval(item.damage.formula), 0);\\\\\\\\nif (this.isCertainHit()) {\\\\\\\\n    return (isNaN(power) ? 0 : power) * sign;\\\\\\\\n}\\\\\\\\n\\\\\\\\n// Create Damage Offense Value\\\\\\\\nlet value = power;\\\\\\\\n\\\\\\\\nif (this.isPhysical() && (this.isDamage() || this.isDrain())) {\\\\\\\\n    value = (((a.atk ** 3) / 32) + 32) * power / 16;\\\\\\\\n} else if (this.isMagical() && (this.isDamage() || this.isDrain())) {\\\\\\\\n    value = power * ((a.mat ** 2 / 6) + power) / 4;\\\\\\\\n} else if (this.isPhysical() && this.isRecover()) {\\\\\\\\n    value = power * ((a.def + power) / 2);\\\\\\\\n} else if (this.isMagical() && this.isRecover()) {\\\\\\\\n    value = power * ((a.mdf + power) / 2);\\\\\\\\n}\\\\\\\\n\\\\\\\\n// Apply Damage Defense Value\\\\\\\\nif (this.isDamage() || this.isDrain()) {\\\\\\\\n    let armor = this.isPhysical() ? b.def : b.mdf;\\\\\\\\n    armor = this.applyArmorModifiers(b, armor);\\\\\\\\n    armor = Math.max(armor, 1);\\\\\\\\n    value *= ((((armor - 280.4) ** 2) / 110) / 16) / 730;\\\\\\\\n    value *= (730 - (armor * 51 - (armor ** 2) / 11) / 10) / 730;\\\\\\\\n} else if (this.isRecover()) {\\\\\\\\n    value *= -1;\\\\\\\\n}\\\\\\\\n\\\\\\\\n// Return Value\\\\\\\\nreturn isNaN(value) ? 0 : value;\\\\\\\"\\\",\\\"ItemsEquipsCore\\\":\\\"\\\",\\\"DamageType\\\":\\\"\\\",\\\"DamageType1:str\\\":\\\"%1 Damage Power\\\",\\\"DamageType2:str\\\":\\\"%1 Damage Power\\\",\\\"DamageType3:str\\\":\\\"%1 Recovery Power\\\",\\\"DamageType4:str\\\":\\\"%1 Recovery Power\\\",\\\"DamageType5:str\\\":\\\"%1 Drain Power\\\",\\\"DamageType6:str\\\":\\\"%1 Drain Power\\\",\\\"DamageDisplay:func\\\":\\\"\\\\\\\"// Define Constants\\\\\\\\nconst item = this._item;\\\\\\\\nconst formula = item.damage.formula;\\\\\\\\nconst a = this._tempActorA;\\\\\\\\nconst b = this._tempActorB;\\\\\\\\nconst user = a;\\\\\\\\nconst target = b;\\\\\\\\n\\\\\\\\n// Return Value\\\\\\\\ntry {\\\\\\\\n    return formula;\\\\\\\\n} catch (e) {\\\\\\\\n    if ($gameTemp.isPlaytest()) {\\\\\\\\n        console.log('Damage Formula Error for %1'.format(this._item.name));\\\\\\\\n    }\\\\\\\\n    return '?????';\\\\\\\\n}\\\\\\\"\\\"}\",\"{\\\"Name:str\\\":\\\"MK\\\",\\\"Formula:func\\\":\\\"\\\\\\\"// Define Constants\\\\\\\\nconst user = this.subject();\\\\\\\\nconst target = arguments[0];\\\\\\\\nconst item = this.item();\\\\\\\\nconst a = this.subject();\\\\\\\\nconst b = target;\\\\\\\\nconst v = $gameVariables._data;\\\\\\\\nconst sign = [3, 4].includes(item.damage.type) ? -1 : 1;\\\\\\\\n\\\\\\\\n// Create Multiplier\\\\\\\\nconst multiplier = Math.max(eval(item.damage.formula), 0);\\\\\\\\n\\\\\\\\n// Declare Values\\\\\\\\nlet armor = this.isPhysical() ? b.def : b.mdf;\\\\\\\\narmor = this.applyArmorModifiers(target, armor);\\\\\\\\nconst denominator = Math.max(200 + armor, 1);\\\\\\\\n\\\\\\\\n// Calculate Damage \\\\\\\\nlet value = 0;\\\\\\\\nif (this.isPhysical() && (this.isDamage() || this.isDrain())) {\\\\\\\\n    value = 200 * a.atk / denominator;\\\\\\\\n} else if (this.isMagical() && (this.isDamage() || this.isDrain())) {\\\\\\\\n    value = 200 * a.mat / denominator;\\\\\\\\n} else if (this.isPhysical() && this.isRecover()) {\\\\\\\\n    value = 200 * a.def / 200;\\\\\\\\n} else if (this.isMagical() && this.isRecover()) {\\\\\\\\n    value = 200 * a.mdf / 200;\\\\\\\\n}\\\\\\\\nvalue *= multiplier;\\\\\\\\n\\\\\\\\n// Return Value\\\\\\\\nreturn (isNaN(value) ? 0 : value) * sign;\\\\\\\"\\\",\\\"ItemsEquipsCore\\\":\\\"\\\",\\\"DamageType\\\":\\\"\\\",\\\"DamageType1:str\\\":\\\"%1 Damage Multiplier\\\",\\\"DamageType2:str\\\":\\\"%1 Damage Multiplier\\\",\\\"DamageType3:str\\\":\\\"%1 Recovery Multiplier\\\",\\\"DamageType4:str\\\":\\\"%1 Recovery Multiplier\\\",\\\"DamageType5:str\\\":\\\"%1 Drain Multiplier\\\",\\\"DamageType6:str\\\":\\\"%1 Drain Multiplier\\\",\\\"DamageDisplay:func\\\":\\\"\\\\\\\"// Define Constants\\\\\\\\nconst item = this._item;\\\\\\\\nconst formula = item.damage.formula;\\\\\\\\nconst a = this._tempActorA;\\\\\\\\nconst b = this._tempActorB;\\\\\\\\nconst user = a;\\\\\\\\nconst target = b;\\\\\\\\n\\\\\\\\n// Return Value\\\\\\\\ntry {\\\\\\\\n    const value = Math.max(eval(formula), 0);\\\\\\\\n    return '%1%'.format(Math.round(value * 100));\\\\\\\\n} catch (e) {\\\\\\\\n    if ($gameTemp.isPlaytest()) {\\\\\\\\n        console.log('Damage Formula Error for %1'.format(this._item.name));\\\\\\\\n    }\\\\\\\\n    return '?????';\\\\\\\\n}\\\\\\\"\\\"}\",\"{\\\"Name:str\\\":\\\"MOBA\\\",\\\"Formula:func\\\":\\\"\\\\\\\"// Define Constants\\\\\\\\nconst user = this.subject();\\\\\\\\nconst target = arguments[0];\\\\\\\\nconst item = this.item();\\\\\\\\nconst a = this.subject();\\\\\\\\nconst b = target;\\\\\\\\nconst v = $gameVariables._data;\\\\\\\\nconst sign = [3, 4].includes(item.damage.type) ? -1 : 1;\\\\\\\\n\\\\\\\\n// Create Damage Value\\\\\\\\nlet value = Math.max(eval(item.damage.formula), 0) * sign;\\\\\\\\n\\\\\\\\n// Apply Attacker's Offense Parameter\\\\\\\\nif (this.isPhysical() && (this.isDamage() || this.isDrain())) {\\\\\\\\n    value *= a.atk;\\\\\\\\n} else if (this.isMagical() && (this.isDamage() || this.isDrain())) {\\\\\\\\n    value *= a.mat;\\\\\\\\n} else if (this.isPhysical() && this.isRecover()) {\\\\\\\\n    value *= a.def;\\\\\\\\n} else if (this.isMagical() && this.isRecover()) {\\\\\\\\n    value *= a.mdf;\\\\\\\\n}\\\\\\\\n\\\\\\\\n// Apply Defender's Defense Parameter\\\\\\\\nif (this.isDamage() && !this.isCertainHit()) {\\\\\\\\n\\\\\\\\n    // Calculate Base Armor\\\\\\\\n    let armor = this.isPhysical() ? b.def : b.mdf;\\\\\\\\n    armor = this.applyArmorModifiers(target, armor);\\\\\\\\n\\\\\\\\n    // Apply Armor to Damage\\\\\\\\n    if (armor >= 0) {\\\\\\\\n        value *= 100 / (100 + armor);\\\\\\\\n    } else {\\\\\\\\n        value *= 2 - (100 / (100 - armor));\\\\\\\\n    }\\\\\\\\n}\\\\\\\\n\\\\\\\\n// Return Value\\\\\\\\nreturn isNaN(value) ? 0 : value;\\\\\\\"\\\",\\\"ItemsEquipsCore\\\":\\\"\\\",\\\"DamageType\\\":\\\"\\\",\\\"DamageType1:str\\\":\\\"%1 Damage Multiplier\\\",\\\"DamageType2:str\\\":\\\"%1 Damage Multiplier\\\",\\\"DamageType3:str\\\":\\\"%1 Recovery Multiplier\\\",\\\"DamageType4:str\\\":\\\"%1 Recovery Multiplier\\\",\\\"DamageType5:str\\\":\\\"%1 Drain Multiplier\\\",\\\"DamageType6:str\\\":\\\"%1 Drain Multiplier\\\",\\\"DamageDisplay:func\\\":\\\"\\\\\\\"// Define Constants\\\\\\\\nconst item = this._item;\\\\\\\\nconst formula = item.damage.formula;\\\\\\\\nconst a = this._tempActorA;\\\\\\\\nconst b = this._tempActorB;\\\\\\\\nconst user = a;\\\\\\\\nconst target = b;\\\\\\\\n\\\\\\\\n// Return Value\\\\\\\\ntry {\\\\\\\\n    const value = Math.max(eval(formula), 0);\\\\\\\\n    return '%1%'.format(Math.round(value * 100));\\\\\\\\n} catch (e) {\\\\\\\\n    if ($gameTemp.isPlaytest()) {\\\\\\\\n        console.log('Damage Formula Error for %1'.format(this._item.name));\\\\\\\\n    }\\\\\\\\n    return '?????';\\\\\\\\n}\\\\\\\"\\\"}\",\"{\\\"Name:str\\\":\\\"PKMN\\\",\\\"Formula:func\\\":\\\"\\\\\\\"// Define Constants\\\\\\\\nconst user = this.subject();\\\\\\\\nconst target = arguments[0];\\\\\\\\nconst item = this.item();\\\\\\\\nconst a = this.subject();\\\\\\\\nconst b = target;\\\\\\\\nconst v = $gameVariables._data;\\\\\\\\nconst sign = [3, 4].includes(item.damage.type) ? -1 : 1;\\\\\\\\n\\\\\\\\n// Create Power\\\\\\\\nconst power = Math.max(eval(item.damage.formula), 0);\\\\\\\\n\\\\\\\\n// Declare Values\\\\\\\\nlet value = 0;\\\\\\\\nlet level = Math.max(a.level || a.luk, 1);\\\\\\\\nlet armor = this.isPhysical() ? b.def : b.mdf;\\\\\\\\narmor = Math.max(this.applyArmorModifiers(target, armor), 0);\\\\\\\\nlet attackStat = 0;\\\\\\\\nif (this.isPhysical() && (this.isDamage() || this.isDrain())) {\\\\\\\\n    attackStat = a.atk;\\\\\\\\n} else if (this.isMagical() && (this.isDamage() || this.isDrain())) {\\\\\\\\n    attackStat =  a.mat;\\\\\\\\n} else if (this.isPhysical() && this.isRecover()) {\\\\\\\\n    attackStat =  a.def;\\\\\\\\n} else if (this.isMagical() && this.isRecover()) {\\\\\\\\n    attackStat =  a.mdf;\\\\\\\\n}\\\\\\\\n\\\\\\\\n// Calculate Damage\\\\\\\\nvalue = (((((2 * level) / 5) + 2) * power * (attackStat / armor)) / 50) + 2;\\\\\\\\n\\\\\\\\n// Return Value\\\\\\\\nreturn (isNaN(value) ? 0 : value) * sign;\\\\\\\"\\\",\\\"ItemsEquipsCore\\\":\\\"\\\",\\\"DamageType\\\":\\\"\\\",\\\"DamageType1:str\\\":\\\"%1 Damage Power\\\",\\\"DamageType2:str\\\":\\\"%1 Damage Power\\\",\\\"DamageType3:str\\\":\\\"%1 Recovery Power\\\",\\\"DamageType4:str\\\":\\\"%1 Recovery Power\\\",\\\"DamageType5:str\\\":\\\"%1 Drain Power\\\",\\\"DamageType6:str\\\":\\\"%1 Drain Power\\\",\\\"DamageDisplay:func\\\":\\\"\\\\\\\"// Define Constants\\\\\\\\nconst item = this._item;\\\\\\\\nconst formula = item.damage.formula;\\\\\\\\nconst a = this._tempActorA;\\\\\\\\nconst b = this._tempActorB;\\\\\\\\nconst user = a;\\\\\\\\nconst target = b;\\\\\\\\n\\\\\\\\n// Return Value\\\\\\\\ntry {\\\\\\\\n    return formula;\\\\\\\\n} catch (e) {\\\\\\\\n    if ($gameTemp.isPlaytest()) {\\\\\\\\n        console.log('Damage Formula Error for %1'.format(this._item.name));\\\\\\\\n    }\\\\\\\\n    return '?????';\\\\\\\\n}\\\\\\\"\\\"}\"]","Cap":"","EnableDamageCap:eval":"false","DefaultHardCap:num":"9999","EnableSoftCap:eval":"false","DefaultSoftCap:num":"0.80","DefaultSoftScaler:num":"0.1275","Popups":"","PopupDuration:num":"128","NewPopupBottom:eval":"true","PopupPosition:str":"base","PopupOffsetX:num":"0","PopupOffsetY:num":"0","PopupShiftX:num":"8","PopupShiftY:num":"-28","hpDamageFmt:str":"-%1","hpHealingFmt:str":"+%1","mpDamageFmt:str":"-%1 %2","mpHealingFmt:str":"+%1 %2","CriticalColor:eval":"[255, 0, 0, 160]","CriticalDuration:num":"128","Formulas":"","OverallFormulaJS:func":"\"// Declare Constants\\nconst target = arguments[0];\\nconst critical = arguments[1];\\nconst item = this.item();\\n\\n// Get Base Damage\\nconst baseValue = this.evalDamageFormula(target);\\n\\n// Calculate Element Modifiers\\nlet value = baseValue * this.calcElementRate(target);\\n\\n// Calculate Physical and Magical Modifiers\\nif (this.isPhysical()) {\\n    value *= target.pdr;\\n}\\nif (this.isMagical()) {\\n    value *= target.mdr;\\n}\\n\\n// Apply Healing Modifiers\\nif (baseValue < 0) {\\n    value *= target.rec;\\n}\\n\\n// Apply Critical Modifiers\\nif (critical) {\\n    value = this.applyCritical(value);\\n}\\n\\n// Apply Variance and Guard Modifiers\\nvalue = this.applyVariance(value, item.damage.variance);\\nvalue = this.applyGuard(value, target);\\n\\n// Finalize Damage\\nvalue = Math.round(value);\\nreturn value;\"","VarianceFormulaJS:func":"\"// Declare Constants\\nconst damage = arguments[0];\\nconst variance = arguments[1];\\n\\n// Calculate Variance\\nconst amp = Math.floor(Math.max((Math.abs(damage) * variance) / 100, 0));\\nconst v = Math.randomInt(amp + 1) + Math.randomInt(amp + 1) - amp;\\n\\n// Return Damage\\nreturn damage >= 0 ? damage + v : damage - v;\"","GuardFormulaJS:func":"\"// Declare Constants\\nconst damage = arguments[0];\\nconst target = arguments[1];\\n\\n// Return Damage Early\\nconst note = this.item().note;\\nif (note.match(/<UNBLOCKABLE>/i)) return damage;\\nif (!target.isGuard()) return damage;\\nif (damage < 0) return damage;\\n\\n// Declare Guard Rate\\nlet guardRate = 0.5;\\nguardRate /= target.grd;\\n\\n// Return Damage\\nreturn damage * guardRate;\"","Critical":"","CriticalHitRateJS:func":"\"// Declare Constants\\nconst user = this.subject();\\nconst target = arguments[0];\\n\\n// Create Base Critical Rate\\nlet rate = this.subject().cri * (1 - target.cev);\\n\\n// Apply Notetags\\nconst note = this.item().note;\\nif (note.match(/<ALWAYS CRITICAL>/i)) {\\n    return 1;\\n}\\nif (note.match(/<SET CRITICAL RATE:[ ](\\\\d+)([%])>/i)) {\\n    return Number(RegExp.$1) / 100;\\n}\\nif (note.match(/<MODIFY CRITICAL RATE:[ ](\\\\d+)([%])>/i)) {\\n    rate *= Number(RegExp.$1) / 100;\\n}\\nif (note.match(/<MODIFY CRITICAL RATE:[ ]([\\\\+\\\\-]\\\\d+)([%])>/i)) {\\n    rate += Number(RegExp.$1) / 100;\\n}\\nif (note.match(/<JS CRITICAL RATE>\\\\s*([\\\\s\\\\S]*)\\\\s*<\\\\/JS CRITICAL RATE>/i)) {\\n    const code = String(RegExp.$1);\\n    try {\\n        eval(code);\\n    } catch (e) {\\n        if ($gameTemp.isPlaytest()) console.log(e);\\n    }\\n}\\n\\n// Apply LUK Buffs/Debuffs\\nconst lukStack = this.subject().buff(7);\\nrate *= 2 ** lukStack;\\n\\n// Return Rate\\nreturn rate;\"","CriticalHitMultiplier:func":"\"// Declare Constants\\nconst user = this.subject();\\nlet damage = arguments[0];\\nlet multiplier = 2.0;\\nlet bonusDamage = this.subject().luk * this.subject().cri;\\nif (this.isHpRecover() || this.isMpRecover()) {\\n    bonusDamage *= -1;\\n}\\n\\n// Apply Notetags\\nconst note = this.item().note;\\nif (note.match(/<MODIFY CRITICAL MULTIPLIER:[ ](\\\\d+)([%])>/i)) {\\n    multiplier = Number(RegExp.$1) / 100;\\n}\\nif (note.match(/<MODIFY CRITICAL MULTIPLIER:[ ]([\\\\+\\\\-]\\\\d+)([%])>/i)) {\\n    multiplier += Number(RegExp.$1) / 100;\\n}\\nif (note.match(/<MODIFY CRITICAL BONUS DAMAGE:[ ](\\\\d+)([%])>/i)) {\\n    bonusDamage *= Number(RegExp.$1) / 100;\\n}\\nif (note.match(/<MODIFY CRITICAL BONUS DAMAGE:[ ]([\\\\+\\\\-]\\\\d+)([%])>/i)) {\\n    bonusDamage += bonusDamage * (RegExp.$1) / 100;\\n}\\nif (note.match(/<JS CRITICAL DAMAGE>\\\\s*([\\\\s\\\\S]*)\\\\s*<\\\\/JS CRITICAL DAMAGE>/i)) {\\n    const code = String(RegExp.$1);\\n    try {\\n        eval(code);\\n    } catch (e) {\\n        if ($gameTemp.isPlaytest()) console.log(e);\\n    }\\n}\\n\\n// Return Damage\\nreturn damage * multiplier + bonusDamage;\""}
 *
 * @param Mechanics:struct
 * @text Mechanics Settings
 * @type struct<Mechanics>
 * @desc Settings pertaining to various game mechanics.
 * @default {"ActionSpeed":"","AllowRandomSpeed:eval":"false","CalcActionSpeedJS:func":"\"// Declare Constants\\nconst agi = this.subject().agi;\\n\\n// Create Speed\\nlet speed = agi;\\nif (this.allowRandomSpeed()) {\\n    speed += Math.randomInt(Math.floor(5 + agi / 4));\\n}\\nif (this.item()) {\\n    speed += this.item().speed;\\n}\\nif (this.isAttack()) {\\n    speed += this.subject().attackSpeed();\\n}\\n\\n// Return Speed\\nreturn speed;\"","BaseTroop":"","BaseTroopIDs:arraynum":"[\"1\"]","CommonEvents":"","BattleStartEvent:num":"0","BattleEndEvent:num":"0","VictoryEvent:num":"0","DefeatEvent:num":"0","EscapeSuccessEvent:num":"0","EscapeFailEvent:num":"0","Escape":"","CalcEscapeRatioJS:func":"\"// Calculate Escape Ratio\\nlet ratio = 0.5;\\nratio *= $gameParty.agility();\\nratio /= $gameTroop.agility();\\n\\n// Return Ratio\\nreturn ratio;\"","CalcEscapeRaiseJS:func":"\"// Calculate Escape Ratio\\nlet value = 0.1;\\nvalue += $gameParty.aliveMembers().length;\\n\\n// Return Value\\nreturn value;\"","BattleJS":"","PreStartBattleJS:func":"\"// Declare Constants\\nconst user = this;\\nconst target = user;\\nconst a = user;\\nconst b = user;\\n\\n// Perform Actions\\n\"","PostStartBattleJS:func":"\"// Declare Constants\\nconst user = this;\\nconst target = user;\\nconst a = user;\\nconst b = user;\\n\\n// Perform Actions\\n\"","BattleVictoryJS:func":"\"// Declare Constants\\nconst user = this;\\nconst target = user;\\nconst a = user;\\nconst b = user;\\n\\n// Perform Actions\\n\"","EscapeSuccessJS:func":"\"// Declare Constants\\nconst user = this;\\nconst target = user;\\nconst a = user;\\nconst b = user;\\n\\n// Perform Actions\\n\"","EscapeFailureJS:func":"\"// Declare Constants\\nconst user = this;\\nconst target = user;\\nconst a = user;\\nconst b = user;\\n\\n// Perform Actions\\n\"","BattleDefeatJS:func":"\"// Declare Constants\\nconst user = this;\\nconst target = user;\\nconst a = user;\\nconst b = user;\\n\\n// Perform Actions\\n\"","PreEndBattleJS:func":"\"// Declare Constants\\nconst user = this;\\nconst target = user;\\nconst a = user;\\nconst b = user;\\n\\n// Perform Actions\\n\"","PostEndBattleJS:func":"\"// Declare Constants\\nconst user = this;\\nconst target = user;\\nconst a = user;\\nconst b = user;\\n\\n// Perform Actions\\n\"","TurnJS":"","PreStartTurnJS:func":"\"// Declare Constants\\nconst user = this;\\nconst target = user;\\nconst a = user;\\nconst b = user;\\n\\n// Perform Actions\\n\"","PostStartTurnJS:func":"\"// Declare Constants\\nconst user = this;\\nconst target = user;\\nconst a = user;\\nconst b = user;\\n\\n// Perform Actions\\n\"","PreEndTurnJS:func":"\"// Declare Constants\\nconst user = this;\\nconst target = user;\\nconst a = user;\\nconst b = user;\\n\\n// Perform Actions\\n\"","PostEndTurnJS:func":"\"// Declare Constants\\nconst user = this;\\nconst target = user;\\nconst a = user;\\nconst b = user;\\n\\n// Perform Actions\\n\"","PreRegenerateJS:func":"\"// Declare Constants\\nconst user = this;\\nconst target = user;\\nconst a = user;\\nconst b = user;\\n\\n// Perform Actions\\n\"","PostRegenerateJS:func":"\"// Declare Constants\\nconst user = this;\\nconst target = user;\\nconst a = user;\\nconst b = user;\\n\\n// Perform Actions\\n\"","ActionJS":"","PreStartActionJS:func":"\"// Declare Constants\\nconst value = arguments[0];\\nconst user = this.subject();\\nconst target = user;\\nconst a = user;\\nconst b = user;\\nconst action = this;\\nconst item = this.item();\\nconst skill = this.item();\\n\\n// Perform Actions\\n\"","PostStartActionJS:func":"\"// Declare Constants\\nconst value = arguments[0];\\nconst user = this.subject();\\nconst target = user;\\nconst a = user;\\nconst b = user;\\nconst action = this;\\nconst item = this.item();\\nconst skill = this.item();\\n\\n// Perform Actions\\n\"","PreApplyJS:func":"\"// Declare Constants\\nconst value = arguments[0];\\nconst target = arguments[1];\\nconst user = this.subject();\\nconst a = user;\\nconst b = target;\\nconst action = this;\\nconst item = this.item();\\nconst skill = this.item();\\n\\n// Perform Actions\\n\\n// Return Value\\nreturn value;\"","PreDamageJS:func":"\"// Declare Constants\\nconst value = arguments[0];\\nconst target = arguments[1];\\nconst user = this.subject();\\nconst a = user;\\nconst b = target;\\nconst action = this;\\nconst item = this.item();\\nconst skill = this.item();\\n\\n// Perform Actions\\n\\n// Return Value\\nreturn value;\"","PostDamageJS:func":"\"// Declare Constants\\nconst value = arguments[0];\\nconst target = arguments[1];\\nconst user = this.subject();\\nconst a = user;\\nconst b = target;\\nconst action = this;\\nconst item = this.item();\\nconst skill = this.item();\\n\\n// Perform Actions\\n\\n// Return Value\\nreturn value;\"","PostApplyJS:func":"\"// Declare Constants\\nconst value = arguments[0];\\nconst target = arguments[1];\\nconst user = this.subject();\\nconst a = user;\\nconst b = target;\\nconst action = this;\\nconst item = this.item();\\nconst skill = this.item();\\n\\n// Perform Actions\\n\\n// Return Value\\nreturn value;\"","PreEndActionJS:func":"\"// Declare Constants\\nconst value = arguments[0];\\nconst user = this.subject();\\nconst target = user;\\nconst a = user;\\nconst b = user;\\nconst action = this;\\nconst item = this.item();\\nconst skill = this.item();\\n\\n// Perform Actions\\n\"","PostEndActionJS:func":"\"// Declare Constants\\nconst value = arguments[0];\\nconst user = this.subject();\\nconst target = user;\\nconst a = user;\\nconst b = user;\\nconst action = this;\\nconst item = this.item();\\nconst skill = this.item();\\n\\n// Perform Actions\\n\""}
 *
 * @param CmdWindows
 * @text --------------------------
 * @default ----------------------------------
 *
 * @param BattleLayout:struct
 * @text Battle Layout Settings
 * @type struct<BattleLayout>
 * @desc Settings that adjust how the battle layout appears.
 * @default {"Style:str":"default","ListStyle":"","ShowFacesListStyle:eval":"true","CommandWidth:num":"192","XPStyle":"","XPActorCommandLines:num":"4","XPActorDefaultHeight:num":"64","XPSpriteYLocation:str":"name","PotraitStyle":"","ShowPortraits:eval":"true","PortraitScale:num":"0.5","BorderStyle":"","SkillItemBorderCols:num":"1","ShowPortraitsBorderStyle:eval":"true","PortraitScaleBorderStyle:num":"1.25","SkillItemWindows":"","SkillItemMiddleLayout:eval":"false","SkillItemStandardCols:num":"2"}
 *
 * @param BattleLog:struct
 * @text Battle Log Settings
 * @type struct<BattleLog>
 * @desc Settings that adjust how Window_BattleLog behaves.
 * @default {"General":"","BackColor:str":"#000000","MaxLines:num":"10","MessageWait:num":"16","TextAlign:str":"center","BattleLogRectJS:func":"\"const wx = 0;\\nconst wy = 0;\\nconst ww = Graphics.boxWidth;\\nconst wh = this.calcWindowHeight(10, false);\\nreturn new Rectangle(wx, wy, ww, wh);\"","StartTurn":"","StartTurnShow:eval":"true","StartTurnMsg:str":"Turn %1","StartTurnWait:num":"40","DisplayAction":"","ActionCenteredName:eval":"true","ActionSkillMsg1:eval":"false","ActionSkillMsg2:eval":"true","ActionItemMsg:eval":"false","ActionChanges":"","ShowCounter:eval":"true","ShowReflect:eval":"true","ShowSubstitute:eval":"true","ActionResults":"","ShowFailure:eval":"false","ShowCritical:eval":"false","ShowMissEvasion:eval":"false","ShowHpDmg:eval":"false","ShowMpDmg:eval":"false","ShowTpDmg:eval":"false","DisplayStates":"","ShowAddedState:eval":"false","ShowRemovedState:eval":"false","ShowCurrentState:eval":"false","ShowAddedBuff:eval":"false","ShowAddedDebuff:eval":"false","ShowRemovedBuff:eval":"false"}
 *
 * @param BattlebackScale:struct
 * @text Battleback Scaling
 * @type struct<Battleback>
 * @desc Settings that adjust how battlebacks scale.
 * @default {"DefaultStyle:str":"MZ","jsOneForOne:func":"\"// Adjust Size\\nthis.width = Graphics.width;\\nthis.height = Graphics.height;\\n\\n// Adjust Scale\\nconst scale = 1.0;\\nthis.scale.x = scale;\\nthis.scale.y = scale;\\n\\n// Adjust Coordinates\\nthis.x = 0;\\nthis.y = 0;\"","jsScaleToFit:func":"\"// Adjust Size\\nthis.width = Graphics.width;\\nthis.height = Graphics.height;\\n\\n// Adjust Scale\\nconst ratioX = this.width / this.bitmap.width;\\nconst ratioY = this.height / this.bitmap.height;\\nconst scale = Math.max(ratioX, ratioY);\\nthis.scale.x = scale;\\nthis.scale.y = scale;\\n\\n// Adjust Coordinates\\nthis.x = (Graphics.width - this.width) / 2;\\nthis.y = Graphics.height - this.height;\"","jsScaleDown:func":"\"// Adjust Size\\nthis.width = Graphics.width;\\nthis.height = Graphics.height;\\n\\n// Adjust Scale\\nconst ratioX = Math.min(1, this.width / this.bitmap.width);\\nconst ratioY = Math.min(1, this.height / this.bitmap.height);\\nconst scale = Math.max(ratioX, ratioY);\\nthis.scale.x = scale;\\nthis.scale.y = scale;\\n\\n// Adjust Coordinates\\nthis.x = (Graphics.width - this.width) / 2;\\nthis.y = Graphics.height - this.height;\"","jsScale Up:func":"\"// Adjust Size\\nthis.width = Graphics.width;\\nthis.height = Graphics.height;\\n\\n// Adjust Scale\\nconst ratioX = Math.max(1, this.width / this.bitmap.width);\\nconst ratioY = Math.max(1, this.height / this.bitmap.height);\\nconst scale = Math.max(ratioX, ratioY);\\nthis.scale.x = scale;\\nthis.scale.y = scale;\\n\\n// Adjust Coordinates\\nthis.x = (Graphics.width - this.width) / 2;\\nthis.y = Graphics.height - this.height;\""}
 *
 * @param PartyCmd:struct
 * @text Party Command Window
 * @type struct<PartyCmd>
 * @desc Settings that alter the Party Command Window in battle.
 * @default {"Cmd":"","CmdStyle:str":"auto","CmdTextAlign:str":"left","CmdIconFight:num":"76","CommandAddAutoBattle:eval":"true","CmdIconAutoBattle:num":"78","CmdTextAutoBattle:str":"Auto","CommandAddOptions:eval":"true","CmdIconOptions:num":"83","ActiveTpbOptionsMessage:str":"Options Menu queued after action is complete.","CmdIconEscape:num":"82","Access":"","SkipPartyCmd:eval":"true","DisablePartyCmd:eval":"false","HelpWindow":"","HelpFight:str":"Select actions to fight.","HelpAutoBattle:str":"Sets party to Auto Battle mode.","HelpOptions:str":"Opens up the Options Menu.","HelpEscape:str":"Attempt to escape the battle."}
 *
 * @param ActorCmd:struct
 * @text Actor Command Window
 * @type struct<ActorCmd>
 * @desc Settings that alter the Actor Command Window in battle.
 * @default {"Cmd":"","CmdStyle:str":"auto","CmdTextAlign:str":"left","CmdIconItem:num":"176","IconStypeNorm:num":"78","IconStypeMagic:num":"79","BattleCmd":"","BattleCmdList:arraystr":"[\"attack\",\"skills\",\"guard\",\"item\",\"escape\"]","HelpWindow":"","HelpSkillType:str":"Opens up a list of skills under the \\C[16]%1\\C[0] category.","HelpItem:str":"Opens up a list of items that you can use.","HelpEscape:str":"Attempt to escape the battle.","HelpAutoBattle:str":"Automatically choose an action suitable for combat."}
 * 
 * @param MultiTarget:struct
 * @text Multi-Target Windows
 * @type struct<MultiTarget>
 * @desc Settings that alter the Multi-Target Windows in battle.
 * @default {"Properties":"","WindowWidth:num":"280","BgType:num":"2","ShowButton:eval":"true","Vocab":"","AllActorsText:str":"All Allies","AllEnemiesText:str":"All Enemies","Offsets":"","ActorOffsets":"","ActorOffsetX:num":"+0","ActorOffsetY:num":"+0","EnemyOffsets":"","EnemyOffsetX:num":"+0","EnemyOffsetY:num":"+0"}
 * 
 * @param ComboWindow:struct
 * @text Damage Combo Window
 * @type struct<ComboWindow>
 * @desc Settings that alter the damage/healing combo window displayed in battle.
 * @default {"General":"","Enable:eval":"true","Appearance":"","CustomFontFace:str":"Arial","TextAlign:str":"left","ComboWindow_DrawJS:func":"\"// Declare Coordinates\\nlet x = 0;\\nlet y = 0;\\n\\n// Hit Text\\nconst hitText = this.hitText();\\nconst hitTextSize = this.textSizeEx(hitText);\\nif (this.textAlignment() === 'right') {\\n    x = this.innerWidth - this.itemPadding() - hitTextSize.width;\\n} else if (this.textAlignment() === 'center') {\\n    x = Math.floor((this.innerWidth - hitTextSize.width) / 2);\\n} else {\\n    x = this.itemPadding();\\n}\\nthis.drawTextEx(hitText, x, y);\\n\\n// New Line\\ny += Math.ceil(this.lineHeight() * 2/3);\\n\\n// Damage Text\\nconst dmgText = this.damageText();\\nconst dmgTextSize = this.textSizeEx(dmgText);\\nif (this.textAlignment() === 'right') {\\n    x = this.innerWidth - this.itemPadding() - dmgTextSize.width;\\n} else if (this.textAlignment() === 'center') {\\n    x = Math.floor((this.innerWidth - dmgTextSize.width) / 2);\\n} else {\\n    x = this.itemPadding();\\n}\\nthis.drawTextEx(dmgText, x, y);\"","Vocab":"","hitsDmgFmt:str":"\\C[6]%1\\} \\C[4]Hit Combo\\C[0]\\{","hitsHealFmt:str":"\\C[6]%1\\} \\C[4]Heal Combo\\C[0]\\{","totalDmgFmt:str":"\\}\\C[21]Total Damage: \\{\\C[0]%1","totalHealFmt:str":"\\}\\C[21]Total Healing: \\{\\C[24]+%1\\C[0]","Position":"","fadeShiftX:num":"-2","fadeShiftY:num":"+0","PosOffsetX:num":"+0","PosOffsetY:num":"+0","ComboWindow_RectJS:func":"\"const ww = Math.ceil(Graphics.width / 4);\\nconst wh = this.calcWindowHeight(2, true);\\nconst wx = 0 + this.comboWindowOffsetX();\\nconst wy = Math.round(Graphics.boxHeight * 1 / 3) + this.comboWindowOffsetY();\\nreturn new Rectangle(wx, wy, ww, wh);\"","Update":"","updateDuration:num":"20","minimumStayDuration:num":"40","minimumHits:num":"1","opacitySpeed:num":"16"}
 *
 * @param VisualBreak
 * @text --------------------------
 * @default ----------------------------------
 *
 * @param Actor:struct
 * @text Actor Battler Settings
 * @type struct<Actor>
 * @desc Settings that alter various properties for actors.
 * @default {"Flinch":"","FlinchDistanceX:num":"12","FlinchDistanceY:num":"0","FlinchDuration:num":"6","SvBattlers":"","AnchorX:num":"0.5","AnchorY:num":"1.0","ChantStyle:eval":"true","OffsetX:num":"0","OffsetY:num":"0","MotionSpeed:num":"12","PrioritySortActive:eval":"true","PrioritySortActors:eval":"false","Shadow:eval":"true","SmoothImage:eval":"true","HomePosJS:func":"\"// Declare Constants\\nconst sprite = this;\\nconst actor = this._actor;\\nconst index = arguments[0];\\n\\n// Make Calculations\\nlet x = Math.round((Graphics.width / 2) + 192)\\nx -= Math.floor((Graphics.width - Graphics.boxWidth) / 2);\\nx += index * 32;\\nlet y = (Graphics.height - 200) - ($gameParty.maxBattleMembers() * 48);\\ny -= Math.floor((Graphics.height - Graphics.boxHeight) / 2);\\ny += index * 48;\\n\\n// Home Position Offsets\\nconst offsetNote = /<SIDEVIEW HOME OFFSET:[ ]([\\\\+\\\\-]\\\\d+),[ ]([\\\\+\\\\-]\\\\d+)>/i;\\nconst xOffsets = actor.traitObjects().map((obj) => (obj && obj.note.match(offsetNote) ? Number(RegExp.$1) : 0));\\nconst yOffsets = actor.traitObjects().map((obj) => (obj && obj.note.match(offsetNote) ? Number(RegExp.$2) : 0));\\nx = xOffsets.reduce((r, offset) => r + offset, x);\\ny = yOffsets.reduce((r, offset) => r + offset, y);\\n\\n// Set Home Position\\nthis.setHome(x, y);\""}
 *
 * @param Enemy:struct
 * @text Enemy Battler Settings
 * @type struct<Enemy>
 * @desc Settings that alter various properties for enemies.
 * @default {"Visual":"","AttackAnimation:num":"1","EmergeText:eval":"false","OffsetX:num":"0","OffsetY:num":"0","SmoothImage:eval":"true","SelectWindow":"","FrontViewSelect:eval":"false","SideviewSelect:eval":"true","NameFontSize:num":"22","SvBattlers":"","AllowCollapse:eval":"false","AnchorX:num":"0.5","AnchorY:num":"1.0","MotionIdle:str":"walk","Shadow:eval":"true","Width:num":"64","Height:num":"64","WtypeId:num":"0"}
 *
 * @param HpGauge:struct
 * @text HP Gauge Settings
 * @type struct<HpGauge>
 * @desc Settings that adjust the visual HP Gauge displayed in battle.
 * @default {"Display":"","ShowActorGauge:eval":"false","ShowEnemyGauge:eval":"true","RequiresDefeat:eval":"false","BTestBypass:eval":"true","Settings":"","AnchorX:num":"0.5","AnchorY:num":"1.0","Scale:num":"0.5","OffsetX:num":"0","OffsetY:num":"-3","Options":"","AddHpGaugeOption:eval":"true","AdjustRect:eval":"true","Name:str":"Show HP Gauge"}
 *
 * @param ActionSequence:struct
 * @text Action Sequence Settings
 * @type struct<ActionSequence>
 * @desc Settings that adjust how certain Action Sequences work.
 * @default {"AutoSequences":"","AutoMeleeSolo:eval":"true","AutoMeleeAoE:eval":"true","CastAnimations":"","CastCertain:num":"120","CastPhysical:num":"52","CastMagical:num":"51","CounterReflection":"","CounterPlayback:eval":"true","ReflectAnimation:num":"53","ReflectPlayback:eval":"true","Stepping":"","MeleeDistance:num":"24","StepDistanceX:num":"48","StepDistanceY:num":"0","StepDuration:num":"12"}
 *
 * @param BreakEnd1
 * @text --------------------------
 * @default ----------------------------------
 *
 * @param End Of
 * @default Plugin Parameters
 *
 * @param BreakEnd2
 * @text --------------------------
 * @default ----------------------------------
 *
 */
/* ----------------------------------------------------------------------------
 * Auto Battle Settings
 * ----------------------------------------------------------------------------
 */
/*~struct~AutoBattle:
 *
 * @param BattleDisplay
 * @text Battle Display
 *
 * @param AutoBattleMsg:str
 * @text Message
 * @parent BattleDisplay
 * @desc Message that's displayed when Auto Battle is on.
 * Text codes allowed. %1 - OK button, %2 - Cancel button
 * @default Press %1 or %2 to stop Auto Battle
 *
 * @param AutoBattleOK:str
 * @text OK Button
 * @parent BattleDisplay
 * @desc Text used to represent the OK button.
 * If VisuMZ_0_CoreEngine is present, ignore this.
 * @default OK
 *
 * @param AutoBattleCancel:str
 * @text Cancel Button
 * @parent BattleDisplay
 * @desc Text used to represent the Cancel button.
 * If VisuMZ_0_CoreEngine is present, ignore this.
 * @default Cancel
 *
 * @param AutoBattleBgType:num
 * @text Background Type
 * @parent BattleDisplay
 * @type select
 * @option 0 - Window
 * @value 0
 * @option 1 - Dim
 * @value 1
 * @option 2 - Transparent
 * @value 2
 * @desc Select background type for Auto Battle window.
 * @default 1
 *
 * @param AutoBattleRect:func
 * @text JS: X, Y, W, H
 * @parent BattleDisplay
 * @type note
 * @desc Code used to determine the dimensions for this window.
 * @default "const width = Graphics.width;\nconst height = this.calcWindowHeight(1, false);\nconst x = 0;\nconst y = (Graphics.height - height) / 2;\nreturn new Rectangle(x, y, width, height);"
 *
 * @param Options
 *
 * @param AddOption:eval
 * @text Add Option?
 * @parent Options
 * @type boolean
 * @on Add
 * @off Don't Add
 * @desc Add the Auto Battle options to the Options menu?
 * @default true
 *
 * @param AdjustRect:eval
 * @text Adjust Window Height
 * @parent Options
 * @type boolean
 * @on Adjust
 * @off Don't
 * @desc Automatically adjust the options window height?
 * @default true
 *
 * @param StartName:str
 * @text Startup Name
 * @parent Options
 * @desc Command name of the option.
 * @default Auto Battle Start
 *
 * @param StyleName:str
 * @text Style Name
 * @parent Options
 * @desc Command name of the option.
 * @default Auto Battle Style
 *
 * @param StyleOFF:str
 * @text OFF
 * @parent StyleName:str
 * @desc Text displayed when Auto Battle Style is OFF.
 * @default Attack
 *
 * @param StyleON:str
 * @text ON
 * @parent StyleName:str
 * @desc Text displayed when Auto Battle Style is ON.
 * @default Skills
 *
 */
/* ----------------------------------------------------------------------------
 * Damage Settings
 * ----------------------------------------------------------------------------
 */
/*~struct~Damage:
 *
 * @param DamageStyles
 * @text Damage Styles
 *
 * @param DefaultDamageStyle:str
 * @text Default Style
 * @parent DamageStyles
 * @desc Which Damage Style do you want to set as default?
 * Use 'Manual' to not use any styles at all.
 * @default Standard
 *
 * @param DamageStyleList:arraystruct
 * @text Style List
 * @parent DamageStyles
 * @type struct<DamageStyle>[]
 * @desc A list of the damage styles available.
 * These are used to calculate base damage.
 * @default ["{\"Name:str\":\"Standard\",\"Formula:func\":\"\\\"// Declare Constants\\\\nconst user = this.subject();\\\\nconst target = arguments[0];\\\\nconst item = this.item();\\\\nconst a = this.subject();\\\\nconst b = target;\\\\nconst v = $gameVariables._data;\\\\nconst sign = [3, 4].includes(item.damage.type) ? -1 : 1;\\\\n\\\\n// Replace Formula\\\\nlet formula = item.damage.formula;\\\\nif (SceneManager.isSceneBattle() && !this.isCertainHit()) {\\\\n    const fmt = 'Math.max(this.applyArmorModifiers(b, %1), 0)';\\\\n    formula = formula.replace(/b.def/g, fmt.format('b.def'));\\\\n    formula = formula.replace(/b.mdf/g, fmt.format('b.mdf'));\\\\n    formula = formula.replace(/b.agi/g, fmt.format('b.agi'));\\\\n    formula = formula.replace(/b.luk/g, fmt.format('b.luk'));\\\\n}\\\\n\\\\n// Calculate Damage\\\\nlet value = Math.max(eval(formula), 0);\\\\n\\\\n// Return Value\\\\nreturn (isNaN(value) ? 0 : value) * sign;\\\"\",\"ItemsEquipsCore\":\"\",\"DamageType\":\"\",\"DamageType1:str\":\"%1 Damage Multiplier\",\"DamageType2:str\":\"%1 Damage Multiplier\",\"DamageType3:str\":\"%1 Recovery Multiplier\",\"DamageType4:str\":\"%1 Recovery Multiplier\",\"DamageType5:str\":\"%1 Drain Multiplier\",\"DamageType6:str\":\"%1 Drain Multiplier\",\"DamageDisplay:func\":\"\\\"return this.getItemDamageAmountTextOriginal();\\\"\"}","{\"Name:str\":\"Armor Scaling\",\"Formula:func\":\"\\\"// Declare Constants\\\\nconst user = this.subject();\\\\nconst target = arguments[0];\\\\nconst item = this.item();\\\\nconst a = this.subject();\\\\nconst b = target;\\\\nconst v = $gameVariables._data;\\\\nconst sign = [3, 4].includes(item.damage.type) ? -1 : 1;\\\\n\\\\n// Replace Formula\\\\nlet formula = item.damage.formula;\\\\nif (SceneManager.isSceneBattle() && !this.isCertainHit()) {\\\\n    const fmt = 'Math.max(this.applyArmorModifiers(b, %1), 1)';\\\\n    formula = formula.replace(/b.def/g, fmt.format('b.def'));\\\\n    formula = formula.replace(/b.mdf/g, fmt.format('b.mdf'));\\\\n    formula = formula.replace(/b.agi/g, fmt.format('b.agi'));\\\\n    formula = formula.replace(/b.luk/g, fmt.format('b.luk'));\\\\n}\\\\n\\\\n// Calculate Damage\\\\nlet value = Math.max(eval(formula), 0);\\\\n\\\\n// Apply Defender's Defense Parameter\\\\nif (this.isDamage() && !this.isCertainHit()) {\\\\n\\\\n    // Calculate Base Armor\\\\n    let armor = this.isPhysical() ? b.def : b.mdf;\\\\n    armor = this.applyArmorModifiers(target, armor);\\\\n\\\\n    // Apply Armor to Damage\\\\n    if (armor >= 0) {\\\\n        value *= 100 / (100 + armor);\\\\n    } else {\\\\n        value *= 2 - (100 / (100 - armor));\\\\n    }\\\\n}\\\\n\\\\n// Return Value\\\\nreturn (isNaN(value) ? 0 : value) * sign;\\\"\",\"ItemsEquipsCore\":\"\",\"DamageType\":\"\",\"DamageType1:str\":\"%1 Damage Multiplier\",\"DamageType2:str\":\"%1 Damage Multiplier\",\"DamageType3:str\":\"%1 Recovery Multiplier\",\"DamageType4:str\":\"%1 Recovery Multiplier\",\"DamageType5:str\":\"%1 Drain Multiplier\",\"DamageType6:str\":\"%1 Drain Multiplier\",\"DamageDisplay:func\":\"\\\"return this.getItemDamageAmountTextOriginal();\\\"\"}","{\"Name:str\":\"CT\",\"Formula:func\":\"\\\"// Define Constants\\\\nconst user = this.subject();\\\\nconst target = arguments[0];\\\\nconst item = this.item();\\\\nconst a = this.subject();\\\\nconst b = target;\\\\nconst v = $gameVariables._data;\\\\nconst sign = [3, 4].includes(item.damage.type) ? -1 : 1;\\\\n\\\\n// Create Multiplier\\\\nconst multiplier = Math.max(eval(item.damage.formula), 0);\\\\n\\\\n// Declare Values\\\\nlet value = 0;\\\\nlet level = Math.max(a.level || a.luk, 1);\\\\nlet armor = this.isPhysical() ? b.def : b.mdf;\\\\narmor = Math.max(this.applyArmorModifiers(target, armor), 0);\\\\nlet attackStat = 0;\\\\nif (this.isPhysical() && (this.isDamage() || this.isDrain())) {\\\\n    attackStat = a.atk;\\\\n} else if (this.isMagical() && (this.isDamage() || this.isDrain())) {\\\\n    attackStat =  a.mat;\\\\n} else if (this.isPhysical() && this.isRecover()) {\\\\n    attackStat =  a.def;\\\\n} else if (this.isMagical() && this.isRecover()) {\\\\n    attackStat =  a.mdf;\\\\n}\\\\n\\\\n// Calculate Damage\\\\nattackStat = (attackStat * 1.75) + (level ** 2 / 45.5);\\\\nvalue = attackStat * 4;\\\\nif (this.isPhysical() && (this.isDamage() || this.isDrain())) {\\\\n    value *= Math.max(256 - armor, 0) / 256;\\\\n} else if (this.isMagical() && (this.isDamage() || this.isDrain())) {\\\\n    value *= Math.max(102.4 - armor, 0) / 128;\\\\n}\\\\nvalue *= multiplier;\\\\n\\\\n// Return Value\\\\nreturn (isNaN(value) ? 0 : value) * sign;\\\"\",\"ItemsEquipsCore\":\"\",\"DamageType\":\"\",\"DamageType1:str\":\"%1 Damage Multiplier\",\"DamageType2:str\":\"%1 Damage Multiplier\",\"DamageType3:str\":\"%1 Recovery Multiplier\",\"DamageType4:str\":\"%1 Recovery Multiplier\",\"DamageType5:str\":\"%1 Drain Multiplier\",\"DamageType6:str\":\"%1 Drain Multiplier\",\"DamageDisplay:func\":\"\\\"// Define Constants\\\\nconst item = this._item;\\\\nconst formula = item.damage.formula;\\\\nconst a = this._tempActorA;\\\\nconst b = this._tempActorB;\\\\nconst user = a;\\\\nconst target = b;\\\\n\\\\n// Return Value\\\\ntry {\\\\n    const value = Math.max(eval(formula), 0);\\\\n    return '%1%'.format(Math.round(value * 100));\\\\n} catch (e) {\\\\n    if ($gameTemp.isPlaytest()) {\\\\n        console.log('Damage Formula Error for %1'.format(this._item.name));\\\\n    }\\\\n    return '?????';\\\\n}\\\"\"}","{\"Name:str\":\"D4\",\"Formula:func\":\"\\\"// Define Constants\\\\nconst user = this.subject();\\\\nconst target = arguments[0];\\\\nconst item = this.item();\\\\nconst a = this.subject();\\\\nconst b = target;\\\\nconst v = $gameVariables._data;\\\\nconst sign = [3, 4].includes(item.damage.type) ? -1 : 1;\\\\n\\\\n// Create Multiplier\\\\nconst multiplier = Math.max(eval(item.damage.formula), 0);\\\\n\\\\n// Declare Values\\\\nlet armor = this.isPhysical() ? b.def : b.mdf;\\\\narmor = this.applyArmorModifiers(target, armor);\\\\nlet stat = 0;\\\\nif (this.isPhysical() && (this.isDamage() || this.isDrain())) {\\\\n    stat = a.atk;\\\\n} else if (this.isMagical() && (this.isDamage() || this.isDrain())) {\\\\n    stat = a.mat;\\\\n} else if (this.isPhysical() && this.isRecover()) {\\\\n    stat = a.def;\\\\n    armor = 0;\\\\n} else if (this.isMagical() && this.isRecover()) {\\\\n    stat = a.mdf;\\\\n    armor = 0;\\\\n}\\\\n\\\\n// Calculate Damage \\\\nlet value = 1.5 * Math.max(2 * stat * multiplier - armor, 1) * multiplier / 5;\\\\n\\\\n// Return Value\\\\nreturn (isNaN(value) ? 0 : value) * sign;\\\"\",\"ItemsEquipsCore\":\"\",\"DamageType\":\"\",\"DamageType1:str\":\"%1 Damage Multiplier\",\"DamageType2:str\":\"%1 Damage Multiplier\",\"DamageType3:str\":\"%1 Recovery Multiplier\",\"DamageType4:str\":\"%1 Recovery Multiplier\",\"DamageType5:str\":\"%1 Drain Multiplier\",\"DamageType6:str\":\"%1 Drain Multiplier\",\"DamageDisplay:func\":\"\\\"// Define Constants\\\\nconst item = this._item;\\\\nconst formula = item.damage.formula;\\\\nconst a = this._tempActorA;\\\\nconst b = this._tempActorB;\\\\nconst user = a;\\\\nconst target = b;\\\\n\\\\n// Return Value\\\\ntry {\\\\n    const value = Math.max(eval(formula), 0);\\\\n    return '%1%'.format(Math.round(value * 100));\\\\n} catch (e) {\\\\n    if ($gameTemp.isPlaytest()) {\\\\n        console.log('Damage Formula Error for %1'.format(this._item.name));\\\\n    }\\\\n    return '?????';\\\\n}\\\"\"}","{\"Name:str\":\"DQ\",\"Formula:func\":\"\\\"// Define Constants\\\\nconst user = this.subject();\\\\nconst target = arguments[0];\\\\nconst item = this.item();\\\\nconst a = this.subject();\\\\nconst b = target;\\\\nconst v = $gameVariables._data;\\\\nconst sign = [3, 4].includes(item.damage.type) ? -1 : 1;\\\\n\\\\n// Create Multiplier\\\\nlet multiplier = Math.max(eval(item.damage.formula), 0);\\\\nif (this.isCertainHit()) {\\\\n    let value = multiplier * Math.max(a.atk, a.mat);\\\\n    return (isNaN(value) ? 0 : value) * sign;\\\\n}\\\\n\\\\n// Get Primary Stats\\\\nlet armor = this.isPhysical() ? b.def : b.mdf;\\\\narmor = this.applyArmorModifiers(b, armor);\\\\nlet stat = 1;\\\\nif (this.isPhysical() && (this.isDamage() || this.isDrain())) {\\\\n    stat = a.atk;\\\\n} else if (this.isMagical() && (this.isDamage() || this.isDrain())) {\\\\n    stat = a.mat;\\\\n} else if (this.isPhysical() && this.isRecover()) {\\\\n    stat = a.def;\\\\n} else if (this.isMagical() && this.isRecover()) {\\\\n    stat = a.mdf;\\\\n}\\\\n\\\\n// Check for Recovery\\\\nif (this.isRecover()) {\\\\n    let value = stat * multiplier * sign;\\\\n    return isNaN(value) ? 0 : value;\\\\n}\\\\n\\\\n// Calculate Damage\\\\nlet value = 0;\\\\nif (stat < ((2 + armor) / 2)) {\\\\n    // Plink Damage\\\\n    let baseline = Math.max(stat - ((12 * (armor - stat + 1)) / stat), 5);\\\\n    value = baseline / 3;\\\\n} else {\\\\n    // Normal Damage\\\\n    let baseline = Math.max(stat - (armor / 2), 1);\\\\n    value = baseline / 2;\\\\n}\\\\nvalue *= multiplier;\\\\n\\\\n// Return Value\\\\nreturn isNaN(value) ? 0 : value;\\\"\",\"ItemsEquipsCore\":\"\",\"DamageType\":\"\",\"DamageType1:str\":\"%1 Damage Multiplier\",\"DamageType2:str\":\"%1 Damage Multiplier\",\"DamageType3:str\":\"%1 Recovery Multiplier\",\"DamageType4:str\":\"%1 Recovery Multiplier\",\"DamageType5:str\":\"%1 Drain Multiplier\",\"DamageType6:str\":\"%1 Drain Multiplier\",\"DamageDisplay:func\":\"\\\"// Define Constants\\\\nconst item = this._item;\\\\nconst formula = item.damage.formula;\\\\nconst a = this._tempActorA;\\\\nconst b = this._tempActorB;\\\\nconst user = a;\\\\nconst target = b;\\\\n\\\\n// Return Value\\\\ntry {\\\\n    const value = Math.max(eval(formula), 0);\\\\n    return '%1%'.format(Math.round(value * 100));\\\\n} catch (e) {\\\\n    if ($gameTemp.isPlaytest()) {\\\\n        console.log('Damage Formula Error for %1'.format(this._item.name));\\\\n    }\\\\n    return '?????';\\\\n}\\\"\"}","{\"Name:str\":\"FF7\",\"Formula:func\":\"\\\"// Define Constants\\\\nconst user = this.subject();\\\\nconst target = arguments[0];\\\\nconst item = this.item();\\\\nconst a = this.subject();\\\\nconst b = target;\\\\nconst v = $gameVariables._data;\\\\nconst sign = [3, 4].includes(item.damage.type) ? -1 : 1;\\\\n\\\\n// Create Power\\\\nconst power = Math.max(eval(item.damage.formula), 0);\\\\n\\\\n// Declare base Damage\\\\nlet baseDamage = 0;\\\\nlet level = Math.max(a.level || a.luk, 1);\\\\nif (this.isPhysical() && (this.isDamage() || this.isDrain())) {\\\\n    baseDamage = a.atk + ((a.atk + level) / 32) * ((a.atk * level) / 32);\\\\n} else if (this.isMagical() && (this.isDamage() || this.isDrain())) {\\\\n    baseDamage = 6 * (a.mat + level);\\\\n} else if (this.isPhysical() && this.isRecover()) {\\\\n    baseDamage = 6 * (a.def + level);\\\\n} else if (this.isMagical() && this.isRecover()) {\\\\n    baseDamage = 6 * (a.mdf + level);\\\\n}\\\\n\\\\n// Calculate Final Damage\\\\nlet value = baseDamage;\\\\nlet armor = this.isPhysical() ? b.def : b.mdf;\\\\narmor = this.applyArmorModifiers(target, armor);\\\\nif (this.isRecover()) {\\\\n    value += 22 * power;\\\\n} else {\\\\n    value = (power * Math.max(512 - armor, 1) * baseDamage) / (16 * 512);\\\\n}\\\\n\\\\n// Return Value\\\\nreturn (isNaN(value) ? 0 : value) * sign;\\\"\",\"ItemsEquipsCore\":\"\",\"DamageType\":\"\",\"DamageType1:str\":\"%1 Damage Power\",\"DamageType2:str\":\"%1 Damage Power\",\"DamageType3:str\":\"%1 Recovery Power\",\"DamageType4:str\":\"%1 Recovery Power\",\"DamageType5:str\":\"%1 Drain Power\",\"DamageType6:str\":\"%1 Drain Power\",\"DamageDisplay:func\":\"\\\"// Define Constants\\\\nconst item = this._item;\\\\nconst formula = item.damage.formula;\\\\nconst a = this._tempActorA;\\\\nconst b = this._tempActorB;\\\\nconst user = a;\\\\nconst target = b;\\\\n\\\\n// Return Value\\\\ntry {\\\\n    return formula;\\\\n} catch (e) {\\\\n    if ($gameTemp.isPlaytest()) {\\\\n        console.log('Damage Formula Error for %1'.format(this._item.name));\\\\n    }\\\\n    return '?????';\\\\n}\\\"\"}","{\"Name:str\":\"FF8\",\"Formula:func\":\"\\\"// Define Constants\\\\nconst user = this.subject();\\\\nconst target = arguments[0];\\\\nconst item = this.item();\\\\nconst a = this.subject();\\\\nconst b = target;\\\\nconst v = $gameVariables._data;\\\\nconst sign = [3, 4].includes(item.damage.type) ? -1 : 1;\\\\n\\\\n// Create Power\\\\nconst power = Math.max(eval(item.damage.formula), 0);\\\\n\\\\n// Declare Damage\\\\nlet Value = 0;\\\\nlet level = Math.max(a.level || a.luk, 1);\\\\nlet armor = this.isPhysical() ? b.def : b.mdf;\\\\narmor = this.applyArmorModifiers(target, armor);\\\\nif (this.isPhysical() && (this.isDamage() || this.isDrain())) {\\\\n    value = a.atk ** 2 / 16 + a.atk;\\\\n    value *= Math.max(265 - armor, 1) / 256;\\\\n    value *= power / 16;\\\\n} else if (this.isMagical() && (this.isDamage() || this.isDrain())) {\\\\n    value = a.mat + power;\\\\n    value *= Math.max(265 - armor, 1) / 4;\\\\n    value *= power / 256;\\\\n} else if (this.isPhysical() && this.isRecover()) {\\\\n    value = (power + a.def) * power / 2;\\\\n} else if (this.isMagical() && this.isRecover()) {\\\\n    value = (power + a.mdf) * power / 2;\\\\n}\\\\n\\\\n// Return Value\\\\nreturn (isNaN(value) ? 0 : value) * sign;\\\"\",\"ItemsEquipsCore\":\"\",\"DamageType\":\"\",\"DamageType1:str\":\"%1 Damage Power\",\"DamageType2:str\":\"%1 Damage Power\",\"DamageType3:str\":\"%1 Recovery Power\",\"DamageType4:str\":\"%1 Recovery Power\",\"DamageType5:str\":\"%1 Drain Power\",\"DamageType6:str\":\"%1 Drain Power\",\"DamageDisplay:func\":\"\\\"// Define Constants\\\\nconst item = this._item;\\\\nconst formula = item.damage.formula;\\\\nconst a = this._tempActorA;\\\\nconst b = this._tempActorB;\\\\nconst user = a;\\\\nconst target = b;\\\\n\\\\n// Return Value\\\\ntry {\\\\n    return formula;\\\\n} catch (e) {\\\\n    if ($gameTemp.isPlaytest()) {\\\\n        console.log('Damage Formula Error for %1'.format(this._item.name));\\\\n    }\\\\n    return '?????';\\\\n}\\\"\"}","{\"Name:str\":\"FF9\",\"Formula:func\":\"\\\"// Define Constants\\\\nconst user = this.subject();\\\\nconst target = arguments[0];\\\\nconst item = this.item();\\\\nconst a = this.subject();\\\\nconst b = target;\\\\nconst v = $gameVariables._data;\\\\nconst sign = [3, 4].includes(item.damage.type) ? -1 : 1;\\\\n\\\\n// Create Damage Constant\\\\nconst power = Math.max(eval(item.damage.formula), 0);\\\\nif (this.isCertainHit()) {\\\\n    return (isNaN(power) ? 0 : power) * sign;\\\\n}\\\\n\\\\n// Declare Main Stats\\\\nlet armor = this.isPhysical() ? b.def : b.mdf;\\\\narmor = this.applyArmorModifiers(b, armor);\\\\nlet stat = 1;\\\\nif (this.isPhysical() && (this.isDamage() || this.isDrain())) {\\\\n    stat = a.atk;\\\\n} else if (this.isMagical() && (this.isDamage() || this.isDrain())) {\\\\n    stat = a.mat;\\\\n} else if (this.isPhysical() && this.isRecover()) {\\\\n    stat = a.def;\\\\n} else if (this.isMagical() && this.isRecover()) {\\\\n    stat = a.mdf;\\\\n}\\\\n\\\\n// Declare Base Damage\\\\nlet baseDamage = power;\\\\nif (this.isPhysical()) {\\\\n    baseDamage += stat;\\\\n}\\\\nif (this.isDamage() || this.isDrain()) {\\\\n    baseDamage -= armor;\\\\n    baseDamage = Math.max(1, baseDamage);\\\\n}\\\\n\\\\n// Declare Bonus Damage\\\\nlet bonusDamage = stat + (((a.level || a.luk) + stat) / 8);\\\\n\\\\n// Declare Final Damage\\\\nlet value = baseDamage * bonusDamage * sign;\\\\n\\\\n// Return Value\\\\nreturn isNaN(value) ? 0 : value;\\\"\",\"ItemsEquipsCore\":\"\",\"DamageType\":\"\",\"DamageType1:str\":\"%1 Damage Power\",\"DamageType2:str\":\"%1 Damage Power\",\"DamageType3:str\":\"%1 Recovery Power\",\"DamageType4:str\":\"%1 Recovery Power\",\"DamageType5:str\":\"%1 Drain Power\",\"DamageType6:str\":\"%1 Drain Power\",\"DamageDisplay:func\":\"\\\"// Define Constants\\\\nconst item = this._item;\\\\nconst formula = item.damage.formula;\\\\nconst a = this._tempActorA;\\\\nconst b = this._tempActorB;\\\\nconst user = a;\\\\nconst target = b;\\\\n\\\\n// Return Value\\\\ntry {\\\\n    return formula;\\\\n} catch (e) {\\\\n    if ($gameTemp.isPlaytest()) {\\\\n        console.log('Damage Formula Error for %1'.format(this._item.name));\\\\n    }\\\\n    return '?????';\\\\n}\\\"\"}","{\"Name:str\":\"FF10\",\"Formula:func\":\"\\\"// Define Constants\\\\nconst user = this.subject();\\\\nconst target = arguments[0];\\\\nconst item = this.item();\\\\nconst a = this.subject();\\\\nconst b = target;\\\\nconst v = $gameVariables._data;\\\\nconst sign = [3, 4].includes(item.damage.type) ? -1 : 1;\\\\n\\\\n// Create Damage Constant\\\\nconst power = Math.max(eval(item.damage.formula), 0);\\\\nif (this.isCertainHit()) {\\\\n    return (isNaN(power) ? 0 : power) * sign;\\\\n}\\\\n\\\\n// Create Damage Offense Value\\\\nlet value = power;\\\\n\\\\nif (this.isPhysical() && (this.isDamage() || this.isDrain())) {\\\\n    value = (((a.atk ** 3) / 32) + 32) * power / 16;\\\\n} else if (this.isMagical() && (this.isDamage() || this.isDrain())) {\\\\n    value = power * ((a.mat ** 2 / 6) + power) / 4;\\\\n} else if (this.isPhysical() && this.isRecover()) {\\\\n    value = power * ((a.def + power) / 2);\\\\n} else if (this.isMagical() && this.isRecover()) {\\\\n    value = power * ((a.mdf + power) / 2);\\\\n}\\\\n\\\\n// Apply Damage Defense Value\\\\nif (this.isDamage() || this.isDrain()) {\\\\n    let armor = this.isPhysical() ? b.def : b.mdf;\\\\n    armor = this.applyArmorModifiers(b, armor);\\\\n    armor = Math.max(armor, 1);\\\\n    value *= ((((armor - 280.4) ** 2) / 110) / 16) / 730;\\\\n    value *= (730 - (armor * 51 - (armor ** 2) / 11) / 10) / 730;\\\\n} else if (this.isRecover()) {\\\\n    value *= -1;\\\\n}\\\\n\\\\n// Return Value\\\\nreturn isNaN(value) ? 0 : value;\\\"\",\"ItemsEquipsCore\":\"\",\"DamageType\":\"\",\"DamageType1:str\":\"%1 Damage Power\",\"DamageType2:str\":\"%1 Damage Power\",\"DamageType3:str\":\"%1 Recovery Power\",\"DamageType4:str\":\"%1 Recovery Power\",\"DamageType5:str\":\"%1 Drain Power\",\"DamageType6:str\":\"%1 Drain Power\",\"DamageDisplay:func\":\"\\\"// Define Constants\\\\nconst item = this._item;\\\\nconst formula = item.damage.formula;\\\\nconst a = this._tempActorA;\\\\nconst b = this._tempActorB;\\\\nconst user = a;\\\\nconst target = b;\\\\n\\\\n// Return Value\\\\ntry {\\\\n    return formula;\\\\n} catch (e) {\\\\n    if ($gameTemp.isPlaytest()) {\\\\n        console.log('Damage Formula Error for %1'.format(this._item.name));\\\\n    }\\\\n    return '?????';\\\\n}\\\"\"}","{\"Name:str\":\"MK\",\"Formula:func\":\"\\\"// Define Constants\\\\nconst user = this.subject();\\\\nconst target = arguments[0];\\\\nconst item = this.item();\\\\nconst a = this.subject();\\\\nconst b = target;\\\\nconst v = $gameVariables._data;\\\\nconst sign = [3, 4].includes(item.damage.type) ? -1 : 1;\\\\n\\\\n// Create Multiplier\\\\nconst multiplier = Math.max(eval(item.damage.formula), 0);\\\\n\\\\n// Declare Values\\\\nlet armor = this.isPhysical() ? b.def : b.mdf;\\\\narmor = this.applyArmorModifiers(target, armor);\\\\nconst denominator = Math.max(200 + armor, 1);\\\\n\\\\n// Calculate Damage \\\\nlet value = 0;\\\\nif (this.isPhysical() && (this.isDamage() || this.isDrain())) {\\\\n    value = 200 * a.atk / denominator;\\\\n} else if (this.isMagical() && (this.isDamage() || this.isDrain())) {\\\\n    value = 200 * a.mat / denominator;\\\\n} else if (this.isPhysical() && this.isRecover()) {\\\\n    value = 200 * a.def / 200;\\\\n} else if (this.isMagical() && this.isRecover()) {\\\\n    value = 200 * a.mdf / 200;\\\\n}\\\\nvalue *= multiplier;\\\\n\\\\n// Return Value\\\\nreturn (isNaN(value) ? 0 : value) * sign;\\\"\",\"ItemsEquipsCore\":\"\",\"DamageType\":\"\",\"DamageType1:str\":\"%1 Damage Multiplier\",\"DamageType2:str\":\"%1 Damage Multiplier\",\"DamageType3:str\":\"%1 Recovery Multiplier\",\"DamageType4:str\":\"%1 Recovery Multiplier\",\"DamageType5:str\":\"%1 Drain Multiplier\",\"DamageType6:str\":\"%1 Drain Multiplier\",\"DamageDisplay:func\":\"\\\"// Define Constants\\\\nconst item = this._item;\\\\nconst formula = item.damage.formula;\\\\nconst a = this._tempActorA;\\\\nconst b = this._tempActorB;\\\\nconst user = a;\\\\nconst target = b;\\\\n\\\\n// Return Value\\\\ntry {\\\\n    const value = Math.max(eval(formula), 0);\\\\n    return '%1%'.format(Math.round(value * 100));\\\\n} catch (e) {\\\\n    if ($gameTemp.isPlaytest()) {\\\\n        console.log('Damage Formula Error for %1'.format(this._item.name));\\\\n    }\\\\n    return '?????';\\\\n}\\\"\"}","{\"Name:str\":\"MOBA\",\"Formula:func\":\"\\\"// Define Constants\\\\nconst user = this.subject();\\\\nconst target = arguments[0];\\\\nconst item = this.item();\\\\nconst a = this.subject();\\\\nconst b = target;\\\\nconst v = $gameVariables._data;\\\\nconst sign = [3, 4].includes(item.damage.type) ? -1 : 1;\\\\n\\\\n// Create Damage Value\\\\nlet value = Math.max(eval(item.damage.formula), 0) * sign;\\\\n\\\\n// Apply Attacker's Offense Parameter\\\\nif (this.isPhysical() && (this.isDamage() || this.isDrain())) {\\\\n    value *= a.atk;\\\\n} else if (this.isMagical() && (this.isDamage() || this.isDrain())) {\\\\n    value *= a.mat;\\\\n} else if (this.isPhysical() && this.isRecover()) {\\\\n    value *= a.def;\\\\n} else if (this.isMagical() && this.isRecover()) {\\\\n    value *= a.mdf;\\\\n}\\\\n\\\\n// Apply Defender's Defense Parameter\\\\nif (this.isDamage() && !this.isCertainHit()) {\\\\n\\\\n    // Calculate Base Armor\\\\n    let armor = this.isPhysical() ? b.def : b.mdf;\\\\n    armor = this.applyArmorModifiers(target, armor);\\\\n\\\\n    // Apply Armor to Damage\\\\n    if (armor >= 0) {\\\\n        value *= 100 / (100 + armor);\\\\n    } else {\\\\n        value *= 2 - (100 / (100 - armor));\\\\n    }\\\\n}\\\\n\\\\n// Return Value\\\\nreturn isNaN(value) ? 0 : value;\\\"\",\"ItemsEquipsCore\":\"\",\"DamageType\":\"\",\"DamageType1:str\":\"%1 Damage Multiplier\",\"DamageType2:str\":\"%1 Damage Multiplier\",\"DamageType3:str\":\"%1 Recovery Multiplier\",\"DamageType4:str\":\"%1 Recovery Multiplier\",\"DamageType5:str\":\"%1 Drain Multiplier\",\"DamageType6:str\":\"%1 Drain Multiplier\",\"DamageDisplay:func\":\"\\\"// Define Constants\\\\nconst item = this._item;\\\\nconst formula = item.damage.formula;\\\\nconst a = this._tempActorA;\\\\nconst b = this._tempActorB;\\\\nconst user = a;\\\\nconst target = b;\\\\n\\\\n// Return Value\\\\ntry {\\\\n    const value = Math.max(eval(formula), 0);\\\\n    return '%1%'.format(Math.round(value * 100));\\\\n} catch (e) {\\\\n    if ($gameTemp.isPlaytest()) {\\\\n        console.log('Damage Formula Error for %1'.format(this._item.name));\\\\n    }\\\\n    return '?????';\\\\n}\\\"\"}","{\"Name:str\":\"PKMN\",\"Formula:func\":\"\\\"// Define Constants\\\\nconst user = this.subject();\\\\nconst target = arguments[0];\\\\nconst item = this.item();\\\\nconst a = this.subject();\\\\nconst b = target;\\\\nconst v = $gameVariables._data;\\\\nconst sign = [3, 4].includes(item.damage.type) ? -1 : 1;\\\\n\\\\n// Create Power\\\\nconst power = Math.max(eval(item.damage.formula), 0);\\\\n\\\\n// Declare Values\\\\nlet value = 0;\\\\nlet level = Math.max(a.level || a.luk, 1);\\\\nlet armor = this.isPhysical() ? b.def : b.mdf;\\\\narmor = Math.max(this.applyArmorModifiers(target, armor), 0);\\\\nlet attackStat = 0;\\\\nif (this.isPhysical() && (this.isDamage() || this.isDrain())) {\\\\n    attackStat = a.atk;\\\\n} else if (this.isMagical() && (this.isDamage() || this.isDrain())) {\\\\n    attackStat =  a.mat;\\\\n} else if (this.isPhysical() && this.isRecover()) {\\\\n    attackStat =  a.def;\\\\n} else if (this.isMagical() && this.isRecover()) {\\\\n    attackStat =  a.mdf;\\\\n}\\\\n\\\\n// Calculate Damage\\\\nvalue = (((((2 * level) / 5) + 2) * power * (attackStat / armor)) / 50) + 2;\\\\n\\\\n// Return Value\\\\nreturn (isNaN(value) ? 0 : value) * sign;\\\"\",\"ItemsEquipsCore\":\"\",\"DamageType\":\"\",\"DamageType1:str\":\"%1 Damage Power\",\"DamageType2:str\":\"%1 Damage Power\",\"DamageType3:str\":\"%1 Recovery Power\",\"DamageType4:str\":\"%1 Recovery Power\",\"DamageType5:str\":\"%1 Drain Power\",\"DamageType6:str\":\"%1 Drain Power\",\"DamageDisplay:func\":\"\\\"// Define Constants\\\\nconst item = this._item;\\\\nconst formula = item.damage.formula;\\\\nconst a = this._tempActorA;\\\\nconst b = this._tempActorB;\\\\nconst user = a;\\\\nconst target = b;\\\\n\\\\n// Return Value\\\\ntry {\\\\n    return formula;\\\\n} catch (e) {\\\\n    if ($gameTemp.isPlaytest()) {\\\\n        console.log('Damage Formula Error for %1'.format(this._item.name));\\\\n    }\\\\n    return '?????';\\\\n}\\\"\"}"]
 *
 * @param Cap
 * @text Damage Cap
 *
 * @param EnableDamageCap:eval
 * @text Enable Damage Cap?
 * @parent Cap
 * @type boolean
 * @on Enable
 * @off Disable
 * @desc Put a maximum hard damage cap on how far damage can go?
 * This can be broken through the usage of notetags.
 * @default false
 *
 * @param DefaultHardCap:num
 * @text Default Hard Cap
 * @parent EnableDamageCap:eval
 * @type number
 * @min 1
 * @desc The default hard damage cap used before applying damage.
 * @default 9999
 *
 * @param EnableSoftCap:eval
 * @text Enable Soft Cap?
 * @parent Cap
 * @type boolean
 * @on Enable
 * @off Disable
 * @desc Soft caps ease in the damage values leading up to the 
 * hard damage cap. Requires hard Damage Cap enabled.
 * @default false
 *
 * @param DefaultSoftCap:num
 * @text Base Soft Cap Rate
 * @parent EnableSoftCap:eval
 * @desc The default soft damage cap used before applying damage.
 * @default 0.80
 *
 * @param DefaultSoftScaler:num
 * @text Soft Scale Constant
 * @parent EnableSoftCap:eval
 * @desc The default soft damage cap used before applying damage.
 * @default 0.1275
 *
 * @param Popups
 *
 * @param PopupDuration:num
 * @text Popup Duration
 * @parent Popups
 * @type number
 * @min 1
 * @desc Adjusts how many frames a popup stays visible.
 * @default 128
 *
 * @param NewPopupBottom:eval
 * @text Newest Popups Bottom
 * @parent Popups
 * @type boolean
 * @on Bottom
 * @off Top
 * @desc Puts the newest popups at the bottom.
 * @default true
 *
 * @param PopupPosition:str
 * @text Appear Position
 * @parent Popups
 * @type select
 * @option Head - At the top of the battler.
 * @value head
 * @option Center - At the center of the battler.
 * @value center
 * @option Base - At the foot of the battler.
 * @value base
 * @desc Selects where you want popups to appear relative to the battler.
 * @default base
 *
 * @param EndBattlePopups:eval
 * @text End Battle Show?
 * @parent Popups
 * @type boolean
 * @on Show
 * @off Hide
 * @desc Show or hide popups upon victory or escape?
 * Used to hide battle-state removal popups.
 * @default true
 *
 * @param PopupOffsetX:num
 * @text Offset X
 * @parent Popups
 * @desc Sets how much to offset the sprites by horizontally.
 * Negative values go left. Positive values go right.
 * @default 0
 *
 * @param PopupOffsetY:num
 * @text Offset Y
 * @parent Popups
 * @desc Sets how much to offset the sprites by vertically.
 * Negative values go up. Positive values go down.
 * @default 0
 *
 * @param PopupShiftX:num
 * @text Shift X
 * @parent Popups
 * @desc Sets how much to shift the sprites by horizontally.
 * Negative values go left. Positive values go right.
 * @default 8
 *
 * @param PopupShiftY:num
 * @text Shift Y
 * @parent Popups
 * @desc Sets how much to shift the sprites by vertically.
 * Negative values go up. Positive values go down.
 * @default -28
 *
 * @param hpDamageFmt:str
 * @text HP Damage Format
 * @parent Popups
 * @desc Determines HP damage format for popup.
 * %1 - Value, %2 - HP Text
 * @default -%1
 *
 * @param hpHealingFmt:str
 * @text HP Healing Format
 * @parent Popups
 * @desc Determines HP healing format for popup.
 * %1 - Value, %2 - HP Text
 * @default +%1
 *
 * @param mpDamageFmt:str
 * @text MP Damage Format
 * @parent Popups
 * @desc Determines MP damage format for popup.
 * %1 - Value, %2 - MP Text
 * @default -%1 %2
 *
 * @param mpHealingFmt:str
 * @text MP Healing Format
 * @parent Popups
 * @desc Determines MP healing format for popup.
 * %1 - Value, %2 - MP Text
 * @default +%1 %2
 *
 * @param CriticalColor:eval
 * @text Critical Flash Color
 * @parent Popups
 * @desc Adjust the popup's flash color.
 * Format: [red, green, blue, alpha]
 * @default [255, 0, 0, 160]
 *
 * @param CriticalDuration:num
 * @text Critical Duration
 * @parent Popups
 * @type number
 * @min 1
 * @desc Adjusts how many frames a the flash lasts.
 * @default 128
 *
 * @param Formulas
 *
 * @param OverallFormulaJS:func
 * @text JS: Overall Formula
 * @parent Formulas
 * @type note
 * @desc The overall formula used when calculating damage.
 * @default "// Declare Constants\nconst target = arguments[0];\nconst critical = arguments[1];\nconst item = this.item();\n\n// Get Base Damage\nconst baseValue = this.evalDamageFormula(target);\n\n// Calculate Element Modifiers\nlet value = baseValue * this.calcElementRate(target);\n\n// Calculate Physical and Magical Modifiers\nif (this.isPhysical()) {\n    value *= target.pdr;\n}\nif (this.isMagical()) {\n    value *= target.mdr;\n}\n\n// Apply Healing Modifiers\nif (baseValue < 0) {\n    value *= target.rec;\n}\n\n// Apply Critical Modifiers\nif (critical) {\n    value = this.applyCritical(value);\n}\n\n// Apply Variance and Guard Modifiers\nvalue = this.applyVariance(value, item.damage.variance);\nvalue = this.applyGuard(value, target);\n\n// Finalize Damage\nvalue = Math.round(value);\nreturn value;"
 *
 * @param VarianceFormulaJS:func
 * @text JS: Variance Formula
 * @parent Formulas
 * @type note
 * @desc The formula used when damage variance.
 * @default "// Declare Constants\nconst damage = arguments[0];\nconst variance = arguments[1];\n\n// Calculate Variance\nconst amp = Math.floor(Math.max((Math.abs(damage) * variance) / 100, 0));\nconst v = Math.randomInt(amp + 1) + Math.randomInt(amp + 1) - amp;\n\n// Return Damage\nreturn damage >= 0 ? damage + v : damage - v;"
 *
 * @param GuardFormulaJS:func
 * @text JS: Guard Formula
 * @parent Formulas
 * @type note
 * @desc The formula used when damage is guarded.
 * @default "// Declare Constants\nconst damage = arguments[0];\nconst target = arguments[1];\n\n// Return Damage Early\nconst note = this.item().note;\nif (note.match(/<UNBLOCKABLE>/i)) return damage;\nif (!target.isGuard()) return damage;\nif (damage < 0) return damage;\n\n// Declare Guard Rate\nlet guardRate = 0.5;\nguardRate /= target.grd;\n\n// Return Damage\nreturn damage * guardRate;"
 *
 * @param Critical
 * @text Critical Hits
 *
 * @param CriticalHitRateJS:func
 * @text JS: Rate Formula
 * @parent Critical
 * @type note
 * @desc The formula used to calculate Critical Hit Rates.
 * @default "// Declare Constants\nconst user = this.subject();\nconst target = arguments[0];\n\n// Create Base Critical Rate\nlet rate = this.subject().cri * (1 - target.cev);\n\n// Apply Notetags\nconst note = this.item().note;\nif (note.match(/<ALWAYS CRITICAL>/i)) {\n    return 1;\n}\nif (note.match(/<SET CRITICAL RATE:[ ](\\d+)([%])>/i)) {\n    return Number(RegExp.$1) / 100;\n}\nif (note.match(/<MODIFY CRITICAL RATE:[ ](\\d+)([%])>/i)) {\n    rate *= Number(RegExp.$1) / 100;\n}\nif (note.match(/<MODIFY CRITICAL RATE:[ ]([\\+\\-]\\d+)([%])>/i)) {\n    rate += Number(RegExp.$1) / 100;\n}\nif (note.match(/<JS CRITICAL RATE>\\s*([\\s\\S]*)\\s*<\\/JS CRITICAL RATE>/i)) {\n    const code = String(RegExp.$1);\n    try {\n        eval(code);\n    } catch (e) {\n        if ($gameTemp.isPlaytest()) console.log(e);\n    }\n}\n\n// Apply LUK Buffs/Debuffs\nconst lukStack = this.subject().buff(7);\nrate *= 2 ** lukStack;\n\n// Return Rate\nreturn rate;"
 *
 * @param CriticalHitMultiplier:func
 * @text JS: Damage Formula
 * @parent Critical
 * @type note
 * @desc The formula used to calculate Critical Hit Damage modification.
 * @default "// Declare Constants\nconst user = this.subject();\nlet damage = arguments[0];\nlet multiplier = 2.0;\nlet bonusDamage = this.subject().luk * this.subject().cri;\n\n// Apply Notetags\nconst note = this.item().note;\nif (note.match(/<MODIFY CRITICAL MULTIPLIER:[ ](\\d+)([%])>/i)) {\n    multiplier = Number(RegExp.$1) / 100;\n}\nif (note.match(/<MODIFY CRITICAL MULTIPLIER:[ ]([\\+\\-]\\d+)([%])>/i)) {\n    multiplier += Number(RegExp.$1) / 100;\n}\nif (note.match(/<MODIFY CRITICAL BONUS DAMAGE:[ ](\\d+)([%])>/i)) {\n    bonusDamage *= Number(RegExp.$1) / 100;\n}\nif (note.match(/<MODIFY CRITICAL BONUS DAMAGE:[ ]([\\+\\-]\\d+)([%])>/i)) {\n    bonusDamage += bonusDamage * (RegExp.$1) / 100;\n}\nif (note.match(/<JS CRITICAL DAMAGE>\\s*([\\s\\S]*)\\s*<\\/JS CRITICAL DAMAGE>/i)) {\n    const code = String(RegExp.$1);\n    try {\n        eval(code);\n    } catch (e) {\n        if ($gameTemp.isPlaytest()) console.log(e);\n    }\n}\n\n// Return Damage\nreturn damage * multiplier + bonusDamage;"
 *
 */
/* ----------------------------------------------------------------------------
 * Damage Formula Style
 * ----------------------------------------------------------------------------
 */
/*~struct~DamageStyle:
 *
 * @param Name:str
 * @text Name
 * @desc Name of this Damage Style.
 * Used for notetags and such.
 * @default Untitled
 *
 * @param Formula:func
 * @text JS: Formula
 * @parent Name:str
 * @type note
 * @desc The base formula for this Damage Style.
 * @default "// Define Constants\nconst item = this.item();\nconst a = this.subject();\nconst b = target;\nconst sign = [3, 4].includes(item.damage.type) ? -1 : 1;\n\n// Create Damage Value\nlet value = Math.max(eval(item.damage.formula), 0) * sign;\n\n// Return Value\nreturn isNaN(value) ? 0 : value;"
 *
 * @param ItemsEquipsCore
 * @text Items & Equips Core
 *
 * @param DamageType
 * @text Damage Label
 * @parent ItemsEquipsCore
 *
 * @param DamageType1:str
 * @text HP Damage
 * @parent DamageType
 * @desc Vocabulary used for this data entry.
 * @default %1 Damage Multiplier
 *
 * @param DamageType2:str
 * @text MP Damage
 * @parent DamageType
 * @desc Vocabulary used for this data entry.
 * @default %1 Damage Multiplier
 *
 * @param DamageType3:str
 * @text HP Recovery
 * @parent DamageType
 * @desc Vocabulary used for this data entry.
 * @default %1 Recovery Multiplier
 *
 * @param DamageType4:str
 * @text MP Recovery
 * @parent DamageType
 * @desc Vocabulary used for this data entry.
 * @default %1 Recovery Multiplier
 *
 * @param DamageType5:str
 * @text HP Drain
 * @parent DamageType
 * @desc Vocabulary used for this data entry.
 * @default %1 Drain Multiplier
 *
 * @param DamageType6:str
 * @text MP Drain
 * @parent DamageType
 * @desc Vocabulary used for this data entry.
 * @default %1 Drain Multiplier
 *
 * @param DamageDisplay:func
 * @text JS: Damage Display
 * @parent ItemsEquipsCore
 * @type note
 * @desc Code used the data displayed for this category.
 * @default "// Define Constants\nconst item = this._item;\nconst formula = item.damage.formula;\nconst a = this._tempActorA;\nconst b = this._tempActorB;\nconst user = a;\nconst target = b;\n\n// Return Value\ntry {\n    const value = Math.max(eval(formula), 0);\n    return '%1%'.format(Math.round(value * 100));\n} catch (e) {\n    if ($gameTemp.isPlaytest()) {\n        console.log('Damage Formula Error for %1'.format(this._item.name));\n    }\n    return '?????';\n}"
 *
 */
/* ----------------------------------------------------------------------------
 * Mechanics Settings
 * ----------------------------------------------------------------------------
 */
/*~struct~Mechanics:
 *
 * @param ActionSpeed
 * @text Action Speed
 *
 * @param AllowRandomSpeed:eval
 * @text Allow Random Speed?
 * @parent ActionSpeed
 * @type boolean
 * @on Allow
 * @off Disable
 * @desc Allow speed to be randomized base off the user's AGI?
 * @default false
 *
 * @param SyncBuffExpire:eval
 * @text Turn End Buffs Expire
 * @parent ActionSpeed
 * @type boolean
 * @on Expire
 * @off Don't Expire
 * @desc Normally, buffs expire after all actions end.
 * But here, you can have buffs expire on turn end.
 * @default false
 *
 * @param CalcActionSpeedJS:func
 * @text JS: Calculate
 * @parent ActionSpeed
 * @type note
 * @desc Code used to calculate action speed.
 * @default "// Declare Constants\nconst agi = this.subject().agi;\n\n// Create Speed\nlet speed = agi;\nif (this.allowRandomSpeed()) {\n    speed += Math.randomInt(Math.floor(5 + agi / 4));\n}\nif (this.item()) {\n    speed += this.item().speed;\n}\nif (this.isAttack()) {\n    speed += this.subject().attackSpeed();\n}\n\n// Return Speed\nreturn speed;"
 *
 * @param BaseTroop
 * @text Base Troop
 *
 * @param BaseTroopIDs:arraynum
 * @text Base Troop ID's
 * @parent BaseTroop
 * @type troop[]
 * @desc Select the Troop ID(s) to duplicate page events from for all other troops.
 * @default ["1"]
 *
 * @param CommonEvents
 * @text Common Events (on Map)
 *
 * @param BattleStartEvent:num
 * @text Pre-Battle Event
 * @parent CommonEvents
 * @type common_event
 * @desc Common Event to run before each battle on map.
 * Use to 0 to not run any Common Event at all.
 * @default 0
 *
 * @param BattleEndEvent:num
 * @text Post-Battle Event
 * @parent CommonEvents
 * @type common_event
 * @desc Queued Common Event to run after each battle on map.
 * Use to 0 to not run any Common Event at all.
 * @default 0
 *
 * @param VictoryEvent:num
 * @text Victory Event
 * @parent CommonEvents
 * @type common_event
 * @desc Queued Common Event to run upon victory on map.
 * Use to 0 to not run any Common Event at all.
 * @default 0
 *
 * @param DefeatEvent:num
 * @text Defeat Event
 * @parent CommonEvents
 * @type common_event
 * @desc Queued Common Event to run upon defeat on map.
 * Use to 0 to not run any Common Event at all.
 * @default 0
 *
 * @param EscapeSuccessEvent:num
 * @text Escape Success Event
 * @parent CommonEvents
 * @type common_event
 * @desc Queued Common Event to run upon escape success on map.
 * Use to 0 to not run any Common Event at all.
 * @default 0
 *
 * @param EscapeFailEvent:num
 * @text Escape Fail Event
 * @parent CommonEvents
 * @type common_event
 * @desc Queued Common Event to run upon escape failure on map.
 * Use to 0 to not run any Common Event at all.
 * @default 0
 *
 * @param Escape
 *
 * @param CalcEscapeRatioJS:func
 * @text JS: Calc Escape Ratio
 * @parent Escape
 * @type note
 * @desc Code used to calculate the escape success ratio.
 * @default "// Calculate Escape Ratio\nlet ratio = 0.5;\nratio *= $gameParty.agility();\nratio /= $gameTroop.agility();\n\n// Return Ratio\nreturn ratio;"
 *
 * @param CalcEscapeRaiseJS:func
 * @text JS: Calc Escape Raise
 * @parent Escape
 * @type note
 * @desc Code used to calculate how much the escape success ratio raises upon each failure.
 * @default "// Calculate Escape Ratio\nlet value = 0.1;\nvalue += $gameParty.aliveMembers().length;\n\n// Return Value\nreturn value;"
 *
 * @param Switches
 *
 * @param SwitchCritical:num
 * @text Switch: Critical
 * @parent Switches
 * @type switch
 * @desc Turns switch ON if the action performs a critical hit.
 * Switch reverts to OFF whenever an action starts.
 * @default 0
 *
 * @param SwitchMissEvade:num
 * @text Switch: Miss/Evade
 * @parent Switches
 * @type switch
 * @desc Turns switch ON if the action misses/is evaded.
 * Switch reverts to OFF whenever an action starts.
 * @default 0
 *
 * @param Variables
 *
 * @param VariableDmg:num
 * @text Variable: Damage
 * @parent Variables
 * @type variable
 * @desc Variable records target damage during action.
 * Variable reverts to 0 whenever an action starts.
 * @default 0
 *
 * @param VariableHeal:num
 * @text Variable: Healing
 * @parent Variables
 * @type variable
 * @desc Variable records target healing during action.
 * Variable reverts to 0 whenever an action starts.
 * @default 0
 *
 * @param BattleJS
 * @text JS: Battle-Related
 * 
 * @param PreStartBattleJS:func
 * @text JS: Pre-Start Battle
 * @parent BattleJS
 * @type note
 * @desc Target function: BattleManager.startBattle()
 * JavaScript code occurs before function is run.
 * @default "// Declare Constants\nconst user = this;\nconst target = user;\nconst a = user;\nconst b = user;\n\n// Perform Actions\n"
 *
 * @param PostStartBattleJS:func
 * @text JS: Post-Start Battle
 * @parent BattleJS
 * @type note
 * @desc Target function: BattleManager.startBattle()
 * JavaScript code occurs after function is run.
 * @default "// Declare Constants\nconst user = this;\nconst target = user;\nconst a = user;\nconst b = user;\n\n// Perform Actions\n"
 * 
 * @param BattleVictoryJS:func
 * @text JS: Battle Victory
 * @parent BattleJS
 * @type note
 * @desc Target function: BattleManager.processVictory()
 * JavaScript code occurs before function is run.
 * @default "// Declare Constants\nconst user = this;\nconst target = user;\nconst a = user;\nconst b = user;\n\n// Perform Actions\n"
 *
 * @param EscapeSuccessJS:func
 * @text JS: Escape Success
 * @parent BattleJS
 * @type note
 * @desc Target function: BattleManager.onEscapeSuccess()
 * JavaScript code occurs before function is run.
 * @default "// Declare Constants\nconst user = this;\nconst target = user;\nconst a = user;\nconst b = user;\n\n// Perform Actions\n"
 *
 * @param EscapeFailureJS:func
 * @text JS: Escape Failure
 * @parent BattleJS
 * @type note
 * @desc Target function: BattleManager.onEscapeFailure()
 * JavaScript code occurs before function is run.
 * @default "// Declare Constants\nconst user = this;\nconst target = user;\nconst a = user;\nconst b = user;\n\n// Perform Actions\n"
 * 
 * @param BattleDefeatJS:func
 * @text JS: Battle Defeat
 * @parent BattleJS
 * @type note
 * @desc Target function: BattleManager.processDefeat()
 * JavaScript code occurs before function is run.
 * @default "// Declare Constants\nconst user = this;\nconst target = user;\nconst a = user;\nconst b = user;\n\n// Perform Actions\n"
 * 
 * @param PreEndBattleJS:func
 * @text JS: Pre-End Battle
 * @parent BattleJS
 * @type note
 * @desc Target function: BattleManager.endBattle()
 * JavaScript code occurs before function is run.
 * @default "// Declare Constants\nconst user = this;\nconst target = user;\nconst a = user;\nconst b = user;\n\n// Perform Actions\n"
 *
 * @param PostEndBattleJS:func
 * @text JS: Post-End Battle
 * @parent BattleJS
 * @type note
 * @desc Target function: BattleManager.endBattle()
 * JavaScript code occurs after function is run.
 * @default "// Declare Constants\nconst user = this;\nconst target = user;\nconst a = user;\nconst b = user;\n\n// Perform Actions\n"
 *
 * @param TurnJS
 * @text JS: Turn-Related
 *
 * @param PreStartTurnJS:func
 * @text JS: Pre-Start Turn
 * @parent TurnJS
 * @type note
 * @desc Target function: BattleManager.startTurn()
 * JavaScript code occurs before function is run.
 * @default "// Declare Constants\nconst user = this;\nconst target = user;\nconst a = user;\nconst b = user;\n\n// Perform Actions\n"
 *
 * @param PostStartTurnJS:func
 * @text JS: Post-Start Turn
 * @parent TurnJS
 * @type note
 * @desc Target function: BattleManager.startTurn()
 * JavaScript code occurs after function is run.
 * @default "// Declare Constants\nconst user = this;\nconst target = user;\nconst a = user;\nconst b = user;\n\n// Perform Actions\n"
 *
 * @param PreEndTurnJS:func
 * @text JS: Pre-End Turn
 * @parent TurnJS
 * @type note
 * @desc Target function: Game_Battler.prototype.onTurnEnd()
 * JavaScript code occurs before function is run.
 * @default "// Declare Constants\nconst user = this;\nconst target = user;\nconst a = user;\nconst b = user;\n\n// Perform Actions\n"
 *
 * @param PostEndTurnJS:func
 * @text JS: Post-End Turn
 * @parent TurnJS
 * @type note
 * @desc Target function: Game_Battler.prototype.onTurnEnd()
 * JavaScript code occurs after function is run.
 * @default "// Declare Constants\nconst user = this;\nconst target = user;\nconst a = user;\nconst b = user;\n\n// Perform Actions\n"
 *
 * @param PreRegenerateJS:func
 * @text JS: Pre-Regenerate
 * @parent TurnJS
 * @type note
 * @desc Target function: Game_Battler.prototype.regenerateAll()
 * JavaScript code occurs before function is run.
 * @default "// Declare Constants\nconst user = this;\nconst target = user;\nconst a = user;\nconst b = user;\n\n// Perform Actions\n"
 *
 * @param PostRegenerateJS:func
 * @text JS: Post-Regenerate
 * @parent TurnJS
 * @type note
 * @desc Target function: Game_Battler.prototype.regenerateAll()
 * JavaScript code occurs after function is run.
 * @default "// Declare Constants\nconst user = this;\nconst target = user;\nconst a = user;\nconst b = user;\n\n// Perform Actions\n"
 *
 * @param ActionJS
 * @text JS: Action-Related
 *
 * @param PreStartActionJS:func
 * @text JS: Pre-Start Action
 * @parent ActionJS
 * @type note
 * @desc Target function: BattleManager.startAction()
 * JavaScript code occurs before function is run.
 * @default "// Declare Constants\nconst value = arguments[0];\nconst user = this.subject();\nconst target = user;\nconst a = user;\nconst b = user;\nconst action = this;\nconst item = this.item();\nconst skill = this.item();\n\n// Perform Actions\n"
 *
 * @param PostStartActionJS:func
 * @text JS: Post-Start Action
 * @parent ActionJS
 * @type note
 * @desc Target function: BattleManager.startAction()
 * JavaScript code occurs after function is run.
 * @default "// Declare Constants\nconst value = arguments[0];\nconst user = this.subject();\nconst target = user;\nconst a = user;\nconst b = user;\nconst action = this;\nconst item = this.item();\nconst skill = this.item();\n\n// Perform Actions\n"
 *
 * @param PreApplyJS:func
 * @text JS: Pre-Apply
 * @parent ActionJS
 * @type note
 * @desc Target function: Game_Action.prototype.apply()
 * JavaScript code occurs before function is run.
 * @default "// Declare Constants\nconst value = arguments[0];\nconst target = arguments[1];\nconst user = this.subject();\nconst a = user;\nconst b = target;\nconst action = this;\nconst item = this.item();\nconst skill = this.item();\n\n// Perform Actions\n\n// Return Value\nreturn value;"
 *
 * @param PreDamageJS:func
 * @text JS: Pre-Damage
 * @parent ActionJS
 * @type note
 * @desc Target function: Game_Action.prototype.executeDamage()
 * JavaScript code occurs before function is run.
 * @default "// Declare Constants\nconst value = arguments[0];\nconst target = arguments[1];\nconst user = this.subject();\nconst a = user;\nconst b = target;\nconst action = this;\nconst item = this.item();\nconst skill = this.item();\n\n// Perform Actions\n\n// Return Value\nreturn value;"
 *
 * @param PostDamageJS:func
 * @text JS: Post-Damage
 * @parent ActionJS
 * @type note
 * @desc Target function: Game_Action.prototype.executeDamage()
 * JavaScript code occurs after function is run.
 * @default "// Declare Constants\nconst value = arguments[0];\nconst target = arguments[1];\nconst user = this.subject();\nconst a = user;\nconst b = target;\nconst action = this;\nconst item = this.item();\nconst skill = this.item();\n\n// Perform Actions\n\n// Return Value\nreturn value;"
 *
 * @param PostApplyJS:func
 * @text JS: Post-Apply
 * @parent ActionJS
 * @type note
 * @desc Target function: Game_Action.prototype.apply()
 * JavaScript code occurs after function is run.
 * @default "// Declare Constants\nconst value = arguments[0];\nconst target = arguments[1];\nconst user = this.subject();\nconst a = user;\nconst b = target;\nconst action = this;\nconst item = this.item();\nconst skill = this.item();\n\n// Perform Actions\n\n// Return Value\nreturn value;"
 *
 * @param PreEndActionJS:func
 * @text JS: Pre-End Action
 * @parent ActionJS
 * @type note
 * @desc Target function: BattleManager.endAction()
 * JavaScript code occurs before function is run.
 * @default "// Declare Constants\nconst value = arguments[0];\nconst user = this.subject();\nconst target = user;\nconst a = user;\nconst b = user;\nconst action = this;\nconst item = this.item();\nconst skill = this.item();\n\n// Perform Actions\n"
 *
 * @param PostEndActionJS:func
 * @text JS: Post-End Action
 * @parent ActionJS
 * @type note
 * @desc Target function: BattleManager.endAction()
 * JavaScript code occurs after function is run.
 * @default "// Declare Constants\nconst value = arguments[0];\nconst user = this.subject();\nconst target = user;\nconst a = user;\nconst b = user;\nconst action = this;\nconst item = this.item();\nconst skill = this.item();\n\n// Perform Actions\n"
 *
 */
/* ----------------------------------------------------------------------------
 * Battle Layout Settings
 * ----------------------------------------------------------------------------
 */
/*~struct~BattleLayout:
 *
 * @param Style:str
 * @text Battle Layout Style
 * @type select
 * @option Default - Shows actor faces in Battle Status.
 * @value default
 * @option List - Lists actors in Battle Status.
 * @value list
 * @option XP - Shows actor battlers in a stretched Battle Status.
 * @value xp
 * @option Portrait - Shows portraits in a stretched Battle Status.
 * @value portrait
 * @option Border - Displays windows around the screen border.
 * @value border
 * @option Frontview Battle UI - Requires VisuMZ_3_FrontviewBattleUI
 * @value frontview_ui
 * @option Sideview Battle UI - Requires VisuMZ_3_SideviewBattleUI
 * @value sideview_ui
 * @desc The style used for the battle layout.
 * @default default
 *
 * @param ListStyle
 * @text List Style
 * @parent Style:str
 *
 * @param ShowFacesListStyle:eval
 * @text Show Faces
 * @parent ListStyle
 * @type boolean
 * @on Show
 * @off Hide
 * @desc Shows faces in List Style?
 * @default true
 *
 * @param CommandWidth:num
 * @text Command Window Width
 * @parent ListStyle
 * @type number
 * @min 1
 * @desc Determine the window width for the Party and Actor Command
 * Windows. Affects Default and List Battle Layout styles.
 * @default 192
 *
 * @param XPStyle
 * @text XP Style
 * @parent Style:str
 *
 * @param XPActorCommandLines:num
 * @text Command Lines
 * @parent XPStyle
 * @type number
 * @min 1
 * @desc Number of action lines in the Actor Command Window for the XP Style.
 * @default 4
 *
 * @param XPActorDefaultHeight:num
 * @text Sprite Height
 * @parent XPStyle
 * @type number
 * @min 1
 * @desc Default sprite height used when if the sprite's height has not been determined yet.
 * @default 64
 *
 * @param XPSpriteYLocation:str
 * @text Sprite Base Location
 * @parent XPStyle
 * @type select
 * @option Above Name - Sprite is located above the name.
 * @value name
 * @option Bottom - Sprite is located at the bottom of the window.
 * @value bottom
 * @option Centered - Sprite is centered in the window.
 * @value center
 * @option Top - Sprite is located at the top of the window.
 * @value top
 * @desc Determine where the sprite is located on the Battle Status Window.
 * @default name
 *
 * @param PotraitStyle
 * @text Portrait Style
 * @parent Style:str
 *
 * @param ShowPortraits:eval
 * @text Show Portraits?
 * @parent PotraitStyle
 * @type boolean
 * @on Portraits
 * @off Faces
 * @desc Requires VisuMZ_1_MainMenuCore.
 * Shows the actor's portrait instead of a face.
 * @default true
 *
 * @param PortraitScale:num
 * @text Portrait Scaling
 * @parent PotraitStyle
 * @desc If portraits are used, scale them by this much.
 * @default 0.5
 *
 * @param BorderStyle
 * @text Border Style
 * @parent Style:str
 *
 * @param SkillItemBorderCols:num
 * @text Columns
 * @parent BorderStyle
 * @type number
 * @min 1
 * @desc The total number of columns for Skill & Item Windows
 * in the battle scene.
 * @default 1
 *
 * @param ShowPortraitsBorderStyle:eval
 * @text Show Portraits?
 * @parent BorderStyle
 * @type boolean
 * @on Portraits
 * @off Faces
 * @desc Requires VisuMZ_1_MainMenuCore.
 * Shows the actor's portrait at the edge of the screen.
 * @default true
 *
 * @param PortraitScaleBorderStyle:num
 * @text Portrait Scaling
 * @parent BorderStyle
 * @desc If portraits are used, scale them by this much.
 * @default 1.0
 *
 * @param SkillItemWindows
 * @text Skill & Item Windows
 *
 * @param SkillItemMiddleLayout:eval
 * @text Middle Layout
 * @parent SkillItemWindows
 * @type boolean
 * @on Middle
 * @off Bottom
 * @desc Shows the Skill & Item Windows in mid-screen?
 * @default false
 *
 * @param SkillItemStandardCols:num
 * @text Columns
 * @parent SkillItemWindows
 * @type number
 * @min 1
 * @desc The total number of columns for Skill & Item Windows
 * in the battle scene.
 * @default 2
 *
 * @param StatusWindow
 * @text Status Window Elements
 *
 * @param StatusWindowName
 * @text Battler Name
 * @parent StatusWindow
 *
 * @param NameOffsetX:num
 * @text Offset: X
 * @parent StatusWindowName
 * @desc Offset this Battle Status Window element's X.
 * Negative goes left. Positive goes right.
 * @default +0
 *
 * @param NameOffsetY:num
 * @text Offset: Y
 * @parent StatusWindowName
 * @desc Offset this Battle Status Window element's Y.
 * Negative goes up. Positive goes down.
 * @default +0
 *
 * @param StatusWindowHpGauge
 * @text Gauge 1 (HP)
 * @parent StatusWindow
 *
 * @param HpGaugeOffsetX:num
 * @text Offset: X
 * @parent StatusWindowHpGauge
 * @desc Offset this Battle Status Window element's X.
 * Negative goes left. Positive goes right.
 * @default +0
 *
 * @param HpGaugeOffsetY:num
 * @text Offset: Y
 * @parent StatusWindowHpGauge
 * @desc Offset this Battle Status Window element's Y.
 * Negative goes up. Positive goes down.
 * @default +0
 *
 * @param StatusWindowMpGauge
 * @text Gauge 2 (MP)
 * @parent StatusWindow
 *
 * @param MpGaugeOffsetX:num
 * @text Offset: X
 * @parent StatusWindowMpGauge
 * @desc Offset this Battle Status Window element's X.
 * Negative goes left. Positive goes right.
 * @default +0
 *
 * @param MpGaugeOffsetY:num
 * @text Offset: Y
 * @parent StatusWindowMpGauge
 * @desc Offset this Battle Status Window element's Y.
 * Negative goes up. Positive goes down.
 * @default +0
 *
 * @param StatusWindowTpGauge
 * @text Gauge 3 (TP)
 * @parent StatusWindow
 *
 * @param TpGaugeOffsetX:num
 * @text Offset: X
 * @parent StatusWindowTpGauge
 * @desc Offset this Battle Status Window element's X.
 * Negative goes left. Positive goes right.
 * @default +0
 *
 * @param TpGaugeOffsetY:num
 * @text Offset: Y
 * @parent StatusWindowTpGauge
 * @desc Offset this Battle Status Window element's Y.
 * Negative goes up. Positive goes down.
 * @default +0
 *
 * @param StatusWindowStateIcon
 * @text State Icon
 * @parent StatusWindow
 *
 * @param StateIconOffsetX:num
 * @text Offset: X
 * @parent StatusWindowStateIcon
 * @desc Offset this Battle Status Window element's X.
 * Negative goes left. Positive goes right.
 * @default +0
 *
 * @param StateIconOffsetY:num
 * @text Offset: Y
 * @parent StatusWindowStateIcon
 * @desc Offset this Battle Status Window element's Y.
 * Negative goes up. Positive goes down.
 * @default +0
 *
 * @param StatusWindowTpbGauge
 * @text TPB/ATB Gauge
 * @parent StatusWindow
 *
 * @param TpbGaugeOffsetX:num
 * @text Offset: X
 * @parent StatusWindowTpbGauge
 * @desc Offset this Battle Status Window element's X.
 * Negative goes left. Positive goes right.
 * @default +0
 *
 * @param TpbGaugeOffsetY:num
 * @text Offset: Y
 * @parent StatusWindowTpbGauge
 * @desc Offset this Battle Status Window element's Y.
 * Negative goes up. Positive goes down.
 * @default +0
 *
 * @param StatusWindowSkin
 * @text Window Skin
 * @parent StatusWindow
 *
 * @param StatusWindowSkinFilename:str
 * @text Filename
 * @parent StatusWindowSkin
 * @type file
 * @dir img/system/
 * @desc Filename used for the Battle Status Window skin.
 * Leave this empty to use the default window skin.
 * @default 
 *
 * @param StatusWindowSkinHide:eval
 * @text Hide Window Skin?
 * @parent StatusWindowSkin
 * @type boolean
 * @on No Window Skin
 * @off Default Skin
 * @desc Show/Hide the window skin for the Battle Status Window?
 * @default false
 *
 * @param StatusWindowSelectBack
 * @text Selectable Background
 * @parent StatusWindow
 *
 * @param StatusWindowSelectableBackHide:eval
 * @text Hide Selectable BG?
 * @parent StatusWindowSelectBack
 * @type boolean
 * @on No Selectable BG
 * @off Default Selectable BG
 * @desc Show/Hide the selectable background box for the Battle Status Window?
 * @default false
 *
 * @param StatusWindowAttachments
 * @text Attachments
 * @parent StatusWindow
 *
 * @param StatusWindowBackAttachment
 * @text Back Attachment
 * @parent StatusWindowAttachments
 *
 * @param StatusWindowAttachmentBack:str
 * @text Filename
 * @parent StatusWindowBackAttachment
 * @type file
 * @dir img/system/
 * @desc Filename used for an image to attach to the back of the
 * Battle Status Window. Leave empty for none.
 * @default 
 *
 * @param StatusWindowAttachmentBackOffsetX:num
 * @text Offset: X
 * @parent StatusWindowBackAttachment
 * @desc Offset this Battle Status Window element's X.
 * Negative goes left. Positive goes right.
 * @default +0
 *
 * @param StatusWindowAttachmentBackOffsetY:num
 * @text Offset: Y
 * @parent StatusWindowBackAttachment
 * @desc Offset this Battle Status Window element's Y.
 * Negative goes up. Positive goes down.
 * @default +0
 *
 * @param StatusWindowFrontAttachment
 * @text Front Attachment
 * @parent StatusWindowAttachments
 *
 * @param StatusWindowAttachmentFront:str
 * @text Filename
 * @parent StatusWindowFrontAttachment
 * @type file
 * @dir img/system/
 * @desc Filename used for an image to attach to the front of the
 * Battle Status Window. Leave empty for none.
 * @default 
 *
 * @param StatusWindowAttachmentFrontOffsetX:num
 * @text Offset: X
 * @parent StatusWindowFrontAttachment
 * @desc Offset this Battle Status Window element's X.
 * Negative goes left. Positive goes right.
 * @default +0
 *
 * @param StatusWindowAttachmentFrontOffsetY:num
 * @text Offset: Y
 * @parent StatusWindowFrontAttachment
 * @desc Offset this Battle Status Window element's Y.
 * Negative goes up. Positive goes down.
 * @default +0
 *
 * @param UiElements
 * @text UI Elements
 *
 * @param AntiTintUiElements:eval
 * @text Anti-Tint UI?
 * @parent UiElements
 * @type boolean
 * @on Prevent Tint
 * @off Allow Tint
 * @desc Prevent UI Elements from being tinted?
 * @default true
 *
 */
/* ----------------------------------------------------------------------------
 * Battle Log Settings
 * ----------------------------------------------------------------------------
 */
/*~struct~BattleLog:
 *
 * @param General
 *
 * @param BackColor:str
 * @text Back Color
 * @parent General
 * @desc Use #rrggbb for a hex color.
 * @default #000000
 *
 * @param MaxLines:num
 * @text Max Lines
 * @parent General
 * @type number
 * @min 1
 * @desc Maximum number of lines to be displayed.
 * @default 10
 *
 * @param MessageWait:num
 * @text Message Wait
 * @parent General
 * @type number
 * @min 1
 * @desc Number of frames for a usual message wait.
 * @default 16
 *
 * @param TextAlign:str
 * @text Text Align
 * @parent General
 * @type combo
 * @option left
 * @option center
 * @option right
 * @desc Text alignment for the Window_BattleLog.
 * @default center
 *
 * @param BattleLogRectJS:func
 * @text JS: X, Y, W, H
 * @parent General
 * @type note
 * @desc Code used to determine the dimensions for the battle log.
 * @default "const wx = 0;\nconst wy = 0;\nconst ww = Graphics.boxWidth;\nconst wh = this.calcWindowHeight(10, false);\nreturn new Rectangle(wx, wy, ww, wh);"
 *
 * @param StartTurn
 * @text Start Turn
 *
 * @param StartTurnShow:eval
 * @text Show Start Turn?
 * @parent StartTurn
 * @type boolean
 * @on Show
 * @off Hide
 * @desc Display turn changes at the start of the turn?
 * @default false
 *
 * @param StartTurnMsg:str
 * @text Start Turn Message
 * @parent StartTurn
 * @desc Message displayed at turn start.
 * %1 - Turn Count
 * @default Turn %1
 *
 * @param StartTurnWait:num
 * @text Start Turn Wait
 * @parent StartTurn
 * @type number
 * @min 1
 * @desc Number of frames to wait after a turn started.
 * @default 40
 *
 * @param DisplayAction
 * @text Display Action
 *
 * @param ActionCenteredName:eval
 * @text Show Centered Action?
 * @parent DisplayAction
 * @type boolean
 * @on Show
 * @off Hide
 * @desc Display a centered text of the action name?
 * @default true
 *
 * @param ActionSkillMsg1:eval
 * @text Show Skill Message 1?
 * @parent DisplayAction
 * @type boolean
 * @on Show
 * @off Hide
 * @desc Display the 1st skill message?
 * @default false
 *
 * @param ActionSkillMsg2:eval
 * @text Show Skill Message 2?
 * @parent DisplayAction
 * @type boolean
 * @on Show
 * @off Hide
 * @desc Display the 2nd skill message?
 * @default true
 *
 * @param ActionItemMsg:eval
 * @text Show Item Message?
 * @parent DisplayAction
 * @type boolean
 * @on Show
 * @off Hide
 * @desc Display the item use message?
 * @default false
 *
 * @param ActionChanges
 * @text Action Changes
 *
 * @param ShowCounter:eval
 * @text Show Counter?
 * @parent ActionChanges
 * @type boolean
 * @on Show
 * @off Hide
 * @desc Display counter text?
 * @default true
 *
 * @param ShowReflect:eval
 * @text Show Reflect?
 * @parent ActionChanges
 * @type boolean
 * @on Show
 * @off Hide
 * @desc Display magic reflection text?
 * @default true
 *
 * @param ShowSubstitute:eval
 * @text Show Substitute?
 * @parent ActionChanges
 * @type boolean
 * @on Show
 * @off Hide
 * @desc Display substitute text?
 * @default true
 *
 * @param ActionResults
 * @text Action Results
 *
 * @param ShowFailure:eval
 * @text Show No Effect?
 * @parent ActionResults
 * @type boolean
 * @on Show
 * @off Hide
 * @desc Display no effect text?
 * @default false
 *
 * @param ShowCritical:eval
 * @text Show Critical?
 * @parent ActionResults
 * @type boolean
 * @on Show
 * @off Hide
 * @desc Display critical text?
 * @default false
 *
 * @param ShowMissEvasion:eval
 * @text Show Miss/Evasion?
 * @parent ActionResults
 * @type boolean
 * @on Show
 * @off Hide
 * @desc Display miss/evasion text?
 * @default false
 *
 * @param ShowHpDmg:eval
 * @text Show HP Damage?
 * @parent ActionResults
 * @type boolean
 * @on Show
 * @off Hide
 * @desc Display HP Damage text?
 * @default false
 *
 * @param ShowMpDmg:eval
 * @text Show MP Damage?
 * @parent ActionResults
 * @type boolean
 * @on Show
 * @off Hide
 * @desc Display MP Damage text?
 * @default false
 *
 * @param ShowTpDmg:eval
 * @text Show TP Damage?
 * @parent ActionResults
 * @type boolean
 * @on Show
 * @off Hide
 * @desc Display TP Damage text?
 * @default false
 *
 * @param DisplayStates
 * @text Display States
 *
 * @param ShowAddedState:eval
 * @text Show Added States?
 * @parent DisplayStates
 * @type boolean
 * @on Show
 * @off Hide
 * @desc Display added states text?
 * @default false
 *
 * @param ShowRemovedState:eval
 * @text Show Removed States?
 * @parent DisplayStates
 * @type boolean
 * @on Show
 * @off Hide
 * @desc Display removed states text?
 * @default false
 *
 * @param ShowCurrentState:eval
 * @text Show Current States?
 * @parent DisplayStates
 * @type boolean
 * @on Show
 * @off Hide
 * @desc Display the currently affected state text?
 * @default false
 *
 * @param ShowAddedBuff:eval
 * @text Show Added Buffs?
 * @parent DisplayStates
 * @type boolean
 * @on Show
 * @off Hide
 * @desc Display added buffs text?
 * @default false
 *
 * @param ShowAddedDebuff:eval
 * @text Show Added Debuffs?
 * @parent DisplayStates
 * @type boolean
 * @on Show
 * @off Hide
 * @desc Display added debuffs text?
 * @default false
 *
 * @param ShowRemovedBuff:eval
 * @text Show Removed Buffs?
 * @parent DisplayStates
 * @type boolean
 * @on Show
 * @off Hide
 * @desc Display removed de/buffs text?
 * @default false
 *
 */
/* ----------------------------------------------------------------------------
 * Battleback Settings
 * ----------------------------------------------------------------------------
 */
/*~struct~Battleback:
 *
 * @param DefaultStyle:str
 * @text Default Style
 * @type select
 * @option MZ (MZ's default style)
 * @value MZ
 * @option 1:1 (No Scaling)
 * @value 1:1
 * @option Scale To Fit (Scale to screen size)
 * @value ScaleToFit
 * @option Scale Down (Scale Downward if Larger than Screen)
 * @value ScaleDown
 * @option Scale Up (Scale Upward if Smaller than Screen)
 * @value ScaleUp
 * @desc The default scaling style used for battlebacks.
 * @default MZ
 *
 * @param jsOneForOne:func
 * @text JS: 1:1
 * @type note
 * @desc This code gives you control over the scaling for this style.
 * @default "// Adjust Size\nthis.width = Graphics.width;\nthis.height = Graphics.height;\n\n// Adjust Scale\nconst scale = 1.0;\nthis.scale.x = scale;\nthis.scale.y = scale;\n\n// Adjust Coordinates\nthis.x = 0;\nthis.y = 0;"
 *
 * @param jsScaleToFit:func
 * @text JS: Scale To Fit
 * @type note
 * @desc This code gives you control over the scaling for this style.
 * @default "// Adjust Size\nthis.width = Graphics.width;\nthis.height = Graphics.height;\n\n// Adjust Scale\nconst ratioX = this.width / this.bitmap.width;\nconst ratioY = this.height / this.bitmap.height;\nconst scale = Math.max(ratioX, ratioY);\nthis.scale.x = scale;\nthis.scale.y = scale;\n\n// Adjust Coordinates\nthis.x = (Graphics.width - this.width) / 2;\nthis.y = Graphics.height - this.height;"
 *
 * @param jsScaleDown:func
 * @text JS: Scale Down
 * @type note
 * @desc This code gives you control over the scaling for this style.
 * @default "// Adjust Size\nthis.width = Graphics.width;\nthis.height = Graphics.height;\n\n// Adjust Scale\nconst ratioX = Math.min(1, this.width / this.bitmap.width);\nconst ratioY = Math.min(1, this.height / this.bitmap.height);\nconst scale = Math.max(ratioX, ratioY);\nthis.scale.x = scale;\nthis.scale.y = scale;\n\n// Adjust Coordinates\nthis.x = (Graphics.width - this.width) / 2;\nthis.y = Graphics.height - this.height;"
 *
 * @param jsScaleUp:func
 * @text JS: Scale Up
 * @type note
 * @desc This code gives you control over the scaling for this style.
 * @default "// Adjust Size\nthis.width = Graphics.width;\nthis.height = Graphics.height;\n\n// Adjust Scale\nconst ratioX = Math.max(1, this.width / this.bitmap.width);\nconst ratioY = Math.max(1, this.height / this.bitmap.height);\nconst scale = Math.max(ratioX, ratioY);\nthis.scale.x = scale;\nthis.scale.y = scale;\n\n// Adjust Coordinates\nthis.x = (Graphics.width - this.width) / 2;\nthis.y = Graphics.height - this.height;"
 *
 */
/* ----------------------------------------------------------------------------
 * Party Command Window Settings
 * ----------------------------------------------------------------------------
 */
/*~struct~PartyCmd:
 *
 * @param Cmd
 * @text Command Window
 *
 * @param CmdStyle:str
 * @text Style
 * @parent Cmd
 * @type select
 * @option Text Only
 * @value text
 * @option Icon Only
 * @value icon
 * @option Icon + Text
 * @value iconText
 * @option Automatic
 * @value auto
 * @desc How do you wish to draw commands in the Party Command Window?
 * @default auto
 *
 * @param CmdTextAlign:str
 * @text Text Align
 * @parent Cmd
 * @type combo
 * @option left
 * @option center
 * @option right
 * @desc Text alignment for the Party Command Window.
 * @default left
 *
 * @param CmdIconFight:num
 * @text Fight Icon
 * @parent Cmd
 * @desc The icon used for the Fight command.
 * @default 76
 *
 * @param CommandAddAutoBattle:eval
 * @text Add Auto Battle?
 * @parent Cmd
 * @type boolean
 * @on Add
 * @off Don't
 * @desc Add the "Auto Battle" command to the Command Window?
 * @default true
 *
 * @param CmdIconAutoBattle:num
 * @text Auto Battle Icon
 * @parent CommandAddAutoBattle:eval
 * @desc The icon used for the Auto Battle command.
 * @default 78
 *
 * @param CmdTextAutoBattle:str
 * @text Auto Battle Text
 * @parent CommandAddAutoBattle:eval
 * @desc The text used for the Auto Battle command.
 * @default Auto
 *
 * @param CommandAddOptions:eval
 * @text Add Options?
 * @parent Cmd
 * @type boolean
 * @on Add
 * @off Don't
 * @desc Add the "Options" command to the Command Window?
 * @default true
 *
 * @param CmdIconOptions:num
 * @text Options Icon
 * @parent CommandAddOptions:eval
 * @desc The icon used for the Options command.
 * @default 83
 *
 * @param ActiveTpbOptionsMessage:str
 * @text Active TPB Message
 * @parent CommandAddOptions:eval
 * @desc Message that will be displayed when selecting options during the middle of an action.
 * @default Options Menu queued after action is complete.
 *
 * @param CmdIconEscape:num
 * @text Escape Icon
 * @parent Cmd
 * @desc The icon used for the Escape command.
 * @default 82
 *
 * @param Access
 *
 * @param SkipPartyCmd:eval
 * @text Skip Party Command
 * @parent Access
 * @type boolean
 * @on Skip
 * @off Don't
 * @desc DTB: Skip Party Command selection on turn start.
 * TPB: Skip Party Command selection at battle start.
 * @default true
 *
 * @param DisablePartyCmd:eval
 * @text Disable Party Command
 * @parent Access
 * @type boolean
 * @on Disable
 * @off Don't
 * @desc Disable the Party Command Window entirely?
 * @default false
 *
 * @param HelpWindow
 * @text Help Window
 *
 * @param HelpFight:str
 * @text Fight
 * @parent HelpWindow
 * @desc Text displayed when selecting a skill type.
 * %1 - Skill Type Name
 * @default Select actions to fight.
 *
 * @param HelpAutoBattle:str
 * @text Auto Battle
 * @parent HelpWindow
 * @desc Text displayed when selecting the Auto Battle command.
 * @default Sets party to Auto Battle mode.
 *
 * @param HelpOptions:str
 * @text Options
 * @parent HelpWindow
 * @desc Text displayed when selecting the Options command.
 * @default Opens up the Options Menu.
 *
 * @param HelpEscape:str
 * @text Escape
 * @parent HelpWindow
 * @desc Text displayed when selecting the escape command.
 * @default Attempt to escape the battle.
 *
 */
/* ----------------------------------------------------------------------------
 * Actor Command Window Settings
 * ----------------------------------------------------------------------------
 */
/*~struct~ActorCmd:
 *
 * @param Cmd
 * @text Command Window
 *
 * @param CmdStyle:str
 * @text Style
 * @parent Cmd
 * @type select
 * @option Text Only
 * @value text
 * @option Icon Only
 * @value icon
 * @option Icon + Text
 * @value iconText
 * @option Automatic
 * @value auto
 * @desc How do you wish to draw commands in the Actor Command Window?
 * @default auto
 *
 * @param CmdTextAlign:str
 * @text Text Align
 * @parent Cmd
 * @type combo
 * @option left
 * @option center
 * @option right
 * @desc Text alignment for the Actor Command Window.
 * @default left
 *
 * @param CmdIconItem:num
 * @text Item Icon
 * @parent Cmd
 * @desc The icon used for the Item command.
 * @default 176
 *
 * @param IconStypeNorm:num
 * @text Normal SType Icon
 * @parent Cmd
 * @desc Icon used for normal skill types that aren't assigned any
 * icons. Ignore if VisuMZ_1_SkillsStatesCore is installed.
 * @default 78
 *
 * @param IconStypeMagic:num
 * @text Magic SType Icon
 * @parent Cmd
 * @desc Icon used for magic skill types that aren't assigned any
 * icons. Ignore if VisuMZ_1_SkillsStatesCore is installed.
 * @default 79
 *
 * @param BattleCmd
 * @text Battle Commands
 *
 * @param BattleCmdList:arraystr
 * @text Command List
 * @parent BattleCmd
 * @type combo[]
 * @option attack
 * @option skills
 * @option guard
 * @option item
 * @option party
 * @option escape
 * @option auto battle
 * @option stypes
 * @option stype: x
 * @option stype: name
 * @option all skills
 * @option skill: x
 * @option skill: name
 * @option combat log
 * @option talk
 * @option weapon swap
 * @desc List of battle commands that appear by default
 * if the <Battle Commands> notetag isn't present.
 * @default ["attack","skills","guard","party","item"]
 *
 * @param ShowCosts:eval
 * @text Show Command Costs
 * @parent BattleCmd
 * @type boolean
 * @on Show Costs
 * @off Hide Costs
 * @desc If a battle command has a resource cost, show it?
 * @default true
 *
 * @param HelpWindow
 * @text Help Window
 *
 * @param HelpSkillType:str
 * @text Skill Types
 * @parent HelpWindow
 * @desc Text displayed when selecting a skill type.
 * %1 - Skill Type Name
 * @default Opens up a list of skills under the \C[16]%1\C[0] category.
 *
 * @param HelpItem:str
 * @text Items
 * @parent HelpWindow
 * @desc Text displayed when selecting the item command.
 * @default Opens up a list of items that you can use.
 *
 * @param HelpEscape:str
 * @text Escape
 * @parent HelpWindow
 * @desc Text displayed when selecting the escape command.
 * @default Attempt to escape the battle.
 *
 * @param HelpAutoBattle:str
 * @text Auto Battle
 * @parent HelpWindow
 * @desc Text displayed when selecting the Auto Battle command.
 * @default Automatically choose an action suitable for combat.
 *
 * @param HelpParty:str
 * @text Party
 * @parent HelpWindow
 * @desc Text displayed when selecting the Party command.
 * Requires 
 * @default Automatically choose an action suitable for combat.
 *
 */
/* ----------------------------------------------------------------------------
 * Multi-Target Window Settings
 * ----------------------------------------------------------------------------
 */
/*~struct~MultiTarget:
 *
 * @param Properties
 * 
 * @param WindowWidth:num
 * @text Window Width
 * @parent Properties
 * @type number
 * @min 1
 * @desc What is the width used for the Multi-Target Window?
 * @default 280
 *
 * @param BgType:num
 * @text Background Type
 * @parent Properties
 * @type select
 * @option 0 - Window
 * @value 0
 * @option 1 - Dim
 * @value 1
 * @option 2 - Transparent
 * @value 2
 * @desc Select background type for these windows.
 * @default 2
 *
 * @param ShowButton:eval
 * @text Show Button
 * @parent Properties
 * @type boolean
 * @on Show
 * @off Hide
 * @desc Shows the keyboard/controller button to press?
 * Requires VisuMZ_0_CoreEngine!
 * @default true
 * 
 * @param Vocab
 *
 * @param AllActorsText:str
 * @text All Actors
 * @parent Vocab
 * @desc What is the text used for the "All Actors" button?
 * @default All Allies
 *
 * @param AllEnemiesText:str
 * @text All Enemies
 * @parent Vocab
 * @desc What is the text used for the "All Enemies" button?
 * @default All Enemies
 * 
 * @param Offsets
 * 
 * @param ActorOffsets
 * @text Actor Offsets
 * @parent Offsets
 *
 * @param ActorOffsetX:num
 * @text Offset X
 * @parent ActorOffsets
 * @desc Offsets the button's x position.
 * Negative: left. Positive: right.
 * @default +0
 *
 * @param ActorOffsetY:num
 * @text Offset Y
 * @parent ActorOffsets
 * @desc Offsets the button's y position.
 * Negative: up. Positive: down.
 * @default +0
 * 
 * @param EnemyOffsets
 * @text Enemy Offsets
 * @parent Offsets
 *
 * @param EnemyOffsetX:num
 * @text Offset X
 * @parent EnemyOffsets
 * @desc Offsets the button's x position.
 * Negative: left. Positive: right.
 * @default +0
 *
 * @param EnemyOffsetY:num
 * @text Offset Y
 * @parent EnemyOffsets
 * @desc Offsets the button's y position.
 * Negative: up. Positive: down.
 * @default +0
 *
 */
/* ----------------------------------------------------------------------------
 * Combo Window Settings
 * ----------------------------------------------------------------------------
 */
/*~struct~ComboWindow:
 *
 * @param General
 * @text General Settings
 *
 * @param Enable:eval
 * @text Enable?
 * @parent General
 * @type boolean
 * @on Enable
 * @off Disable
 * @desc Add the Combo Window to show in battle?
 * @default true
 *
 * @param Appearance
 * @text Appearance Settings
 *
 * @param CustomFontFace:str
 * @text Custom Font
 * @parent Appearance
 * @desc Insert the custom font face name here.
 * Use VisuMZ_1_MessageCore to register new fonts.
 * @default Arial
 *
 * @param TextAlign:str
 * @text Text Align
 * @parent Appearance
 * @type combo
 * @option left
 * @option center
 * @option right
 * @desc Text alignment for this window?
 * @default left
 *
 * @param ComboWindow_DrawJS:func
 * @text JS: Draw Data
 * @parent Appearance
 * @type note
 * @desc Code used to draw the data in this window.
 * @default ""
 * 
 * @param Vocab
 * @text Vocabulary
 *
 * @param hitsDmgFmt:str
 * @text Damage Combo Format
 * @parent Vocab
 * @desc Text format used to display total hits for damage.
 * %1 - Total Hits
 * @default \C[6]%1\} \C[4]Hit Combo\C[0]\{
 *
 * @param hitsHealFmt:str
 * @text Healing Combo Format
 * @parent Vocab
 * @desc Text format used to display total hits for healing.
 * %1 - Total Hits
 * @default \C[6]%1\} \C[4]Heal Combo\C[0]\{
 *
 * @param totalDmgFmt:str
 * @text Damage Total Format
 * @parent Vocab
 * @desc Text format used to display total value for damage.
 * %1 - Total Damage
 * @default \}\C[21]Total Damage: \{\C[0]%1
 *
 * @param totalHealFmt:str
 * @text Healing Total Format
 * @parent Vocab
 * @desc Text format used to display total value for healing.
 * %1 - Total Healing
 * @default \}\C[21]Total Healing: \{\C[24]+%1\C[0]
 *
 * @param Position
 * @text Position Settings
 *
 * @param fadeShiftX:num
 * @text Fade Shift X
 * @parent Position
 * @desc Shifts the windows x position when fading.
 * Negative: left. Positive: right.
 * @default -2
 *
 * @param fadeShiftY:num
 * @text Fade Shift Y
 * @parent Position
 * @desc Shifts the windows y position when fading.
 * Negative: up. Positive: down.
 * @default +0
 *
 * @param PosOffsetX:num
 * @text Offset X
 * @parent Position
 * @desc Offsets the windows x position.
 * Negative: left. Positive: right.
 * @default +0
 *
 * @param PosOffsetY:num
 * @text Offset Y
 * @parent Position
 * @desc Offsets the windows y position.
 * Negative: up. Positive: down.
 * @default +0
 *
 * @param ComboWindow_RectJS:func
 * @text JS: X, Y, W, H
 * @parent Position
 * @type note
 * @desc Code used to determine the dimensions for this window.
 * @default "const ww = Math.ceil(Graphics.width / 4);\nconst wh = this.calcWindowHeight(2, true);\nconst wx = 0 + this.comboWindowOffsetX();\nconst wy = Math.round(Graphics.boxHeight * 1 / 3) + this.comboWindowOffsetY();\nreturn new Rectangle(wx, wy, ww, wh);"
 * 
 * @param Update
 * @text Updating Settings
 *
 * @param updateDuration:num
 * @text Number Roll Duration
 * @parent Update
 * @type number
 * @min 1
 * @desc Frame duration to roll damage numbers.
 * 60 frames = 1 second.
 * @default 20
 *
 * @param minimumStayDuration:num
 * @text Minimum Stay Duration
 * @parent Update
 * @type number
 * @desc Frame duration to stay visible minimum.
 * 60 frames = 1 second.
 * @default 40
 *
 * @param minimumHits:num
 * @text Minimum Hit Visible
 * @parent Update
 * @type number
 * @min 1
 * @desc Minimum hits before combo window becomes visible?
 * @default 1
 *
 * @param opacitySpeed:num
 * @text Opacity Speed
 * @parent Update
 * @type number
 * @min 1
 * @desc Opacity speed when fading in/out.
 * @default 16
 *
 */
/* ----------------------------------------------------------------------------
 * Actor Settings
 * ----------------------------------------------------------------------------
 */
/*~struct~Actor:
 *
 * @param Flinch
 *
 * @param FlinchDistanceX:num
 * @text Flinch Distance X
 * @parent Flinch
 * @desc The normal X distance when flinching.
 * @default 12
 *
 * @param FlinchDistanceY:num
 * @text Flinch Distance Y
 * @parent Flinch
 * @desc The normal Y distance when flinching.
 * @default 0
 *
 * @param FlinchDuration:num
 * @text Flinch Duration
 * @parent Flinch
 * @desc The number of frames for a flinch to complete.
 * @default 6
 *
 * @param ShakeFlinch:eval
 * @text Shake Flinch
 * @parent Flinch
 * @type boolean
 * @on Enable
 * @off Disable
 * @desc Perform a shake flinch when taking damage?
 * @default false
 *
 * @param ShakeFlinchDuration:num
 * @text Max Duration
 * @parent ShakeFlinch:eval
 * @type number
 * @min 1
 * @desc Maximum duration a shake flinch can have.
 * This is reduced relative to the amount of damage taken.
 * @default 24
 *
 * @param ShakeFlinchPower:num
 * @text Max Power
 * @parent ShakeFlinch:eval
 * @type number
 * @min 1
 * @desc The power rating of a shake flinch at full damage.
 * This is reduced relative to the amount of damage taken.
 * @default 48
 *
 * @param SvBattlers
 * @text Sideview Battlers
 * 
 * @param SvAnchor
 * @text Anchor
 * @parent SvBattlers
 *
 * @param AnchorX:num
 * @text Anchor: X
 * @parent SvAnchor
 * @desc Default X anchor for Sideview Battlers.
 * Use values between 0 and 1 to be safe.
 * @default 0.5
 *
 * @param AnchorY:num
 * @text Anchor: Y
 * @parent SvAnchor
 * @desc Default Y anchor for Sideview Battlers.
 * Use values between 0 and 1 to be safe.
 * @default 1.0
 *
 * @param ChantStyle:eval
 * @text Chant Style
 * @parent SvBattlers
 * @type boolean
 * @on Magical Hit Type
 * @off Magical Skill Type
 * @desc What determines the chant motion?
 * Hit type or skill type?
 * @default true
 *
 * @param MotionSpeed:num
 * @text Motion Speed
 * @parent SvBattlers
 * @type number
 * @min 1
 * @desc The number of frames in between each motion.
 * @default 12
 * 
 * @param SvPosition
 * @text Position
 * @parent SvBattlers
 *
 * @param OffsetX:num
 * @text Offset: X
 * @parent SvPosition
 * @desc Offsets X position where actor is positioned.
 * Negative values go left. Positive values go right.
 * @default 0
 *
 * @param OffsetY:num
 * @text Offset: Y
 * @parent SvPosition
 * @desc Offsets Y position where actor is positioned.
 * Negative values go up. Positive values go down.
 * @default 0
 *
 * @param PrioritySortActive:eval
 * @text Priority: Active
 * @parent SvBattlers
 * @type boolean
 * @on Active Actor over All Else
 * @off Active Actor is Sorted Normally
 * @desc Place the active actor on top of actor and enemy sprites.
 * @default false
 *
 * @param PrioritySortActors:eval
 * @text Priority: Actors
 * @parent SvBattlers
 * @type boolean
 * @on Actors over Enemies
 * @off Sort by Y Position
 * @desc Prioritize actors over enemies when placing sprites on top
 * of each other.
 * @default true
 *
 * @param Shadow:eval
 * @text Shadow Visible
 * @parent SvBattlers
 * @type boolean
 * @on Visible
 * @off Hidden
 * @desc Show or hide the shadow for Sideview Battlers.
 * @default true
 * 
 * @param SvStateOverlay
 * @text State Overlay
 * @parent SvBattlers
 *
 * @param StateOverlayOffsetX:num
 * @text Offset: X
 * @parent SvStateOverlay
 * @desc Offsets X position for state overlay on actor.
 * Negative values go left. Positive values go right.
 * @default 0
 *
 * @param StateOverlayOffsetY:num
 * @text Offset: Y
 * @parent SvStateOverlay
 * @desc Offsets Y position for state overlay on actor.
 * Negative values go up. Positive values go down.
 * @default 0
 *
 * @param SmoothImage:eval
 * @text Smooth Image
 * @parent SvBattlers
 * @type boolean
 * @on Smooth
 * @off Pixelated
 * @desc Smooth out the battler images or pixelate them?
 * @default false
 *
 * @param HomePosJS:func
 * @text JS: Home Position
 * @parent SvBattlers
 * @type note
 * @desc Code used to calculate the home position of actors.
 * @default "// Declare Constants\nconst sprite = this;\nconst actor = this._actor;\nconst index = arguments[0];\n\n// Make Calculations\nlet x = Math.round((Graphics.width / 2) + 192)\nx -= Math.floor((Graphics.width - Graphics.boxWidth) / 2);\nx += index * 32;\nlet y = (Graphics.height - 200) - ($gameParty.maxBattleMembers() * 48);\ny -= Math.floor((Graphics.height - Graphics.boxHeight) / 2);\ny += index * 48;\n\n// Home Position Offsets\nconst offsetNote = /<SIDEVIEW HOME OFFSET:[ ]([\\+\\-]\\d+),[ ]([\\+\\-]\\d+)>/i;\nconst xOffsets = actor.traitObjects().map((obj) => (obj && obj.note.match(offsetNote) ? Number(RegExp.$1) : 0));\nconst yOffsets = actor.traitObjects().map((obj) => (obj && obj.note.match(offsetNote) ? Number(RegExp.$2) : 0));\nx = xOffsets.reduce((r, offset) => r + offset, x);\ny = yOffsets.reduce((r, offset) => r + offset, y);\n\n// Set Home Position\nthis.setHome(x, y);"
 *
 */
/* ----------------------------------------------------------------------------
 * Enemy Settings
 * ----------------------------------------------------------------------------
 */
/*~struct~Enemy:
 *
 * @param Visual
 *
 * @param AttackAnimation:num
 * @text Attack Animation
 * @parent Visual
 * @type animation
 * @desc Default attack animation used for enemies.
 * Use <Attack Animation: x> for custom animations.
 * @default 1
 *
 * @param EmergeText:eval
 * @text Emerge Text
 * @parent Visual
 * @type boolean
 * @on Show
 * @off Hide
 * @desc Show or hide the 'Enemy emerges!' text at the start of battle.
 * @default false
 *
 * @param OffsetX:num
 * @text Offset: X
 * @parent Visual
 * @desc Offsets X position where enemy is positioned.
 * Negative values go left. Positive values go right.
 * @default 0
 *
 * @param OffsetY:num
 * @text Offset: Y
 * @parent Visual
 * @desc Offsets Y position where enemy is positioned.
 * Negative values go up. Positive values go down.
 * @default 0
 *
 * @param SmoothImage:eval
 * @text Smooth Image
 * @parent Visual
 * @type boolean
 * @on Smooth
 * @off Pixelated
 * @desc Smooth out the battler images or pixelate them?
 * @default true
 *
 * @param SelectWindow
 * @text Select Window
 *
 * @param LastSelected:eval
 * @text Any: Last Selected
 * @parent SelectWindow
 * @type boolean
 * @on Last Selected
 * @off FV/SV Priority
 * @desc Prioritize last selected enemy over front view or sideview settings?
 * @default true
 *
 * @param FrontViewSelect:eval
 * @text FV: Right Priority
 * @parent SelectWindow
 * @type boolean
 * @on Right
 * @off Normal
 * @desc If using frontview, auto select the enemy furthest right.
 * @default false
 *
 * @param SideviewSelect:eval
 * @text SV: Right Priority
 * @parent SelectWindow
 * @type boolean
 * @on Right
 * @off Normal
 * @desc If using sideview, auto select the enemy furthest right.
 * @default true
 * 
 * @param Name
 *
 * @param NameLegacy:eval
 * @text Legacy Option
 * @parent Name
 * @type boolean
 * @on Legacy Version
 * @off New Version (Sprite)
 * @desc Use the legacy version (window) or new version (sprite).
 * WARNING: Legacy version is no longer supported for bugs.
 * @default false
 *
 * @param NameFontSize:num
 * @text Font Size
 * @parent Name
 * @desc Font size used for enemy names.
 * @default 22
 * 
 * @param NamePosition
 * @text Name Position
 * @parent Name
 *
 * @param NameOffsetX:num
 * @text Offset X
 * @parent NamePosition
 * @desc Offset the enemy name's X position by this much.
 * Negative goes left. Positive goes right.
 * @default 0
 *
 * @param NameOffsetY:num
 * @text Offset Y
 * @parent NamePosition
 * @desc Offset the enemy name's Y position by this much.
 * Negative goes up. Positive goes down.
 * @default 0
 *
 * @param NameAttachStateIcon:eval
 * @text Attach States
 * @parent Name
 * @type boolean
 * @on Attach
 * @off Normal Position
 * @desc Attach the enemy's state icon to the enemy name?
 * @default false
 *
 * @param AttachStateOffsetX:num
 * @text Attach: Offset X
 * @parent NameAttachStateIcon:eval
 * @desc How much to offset the attached icon's X position by?
 * Negative goes left. Positive goes right.
 * @default +0
 *
 * @param AttachStateOffsetY:num
 * @text Attach: Offset Y
 * @parent NameAttachStateIcon:eval
 * @desc How much to offset the attached icon's Y position by?
 * Negative goes up. Positive goes down.
 * @default +0
 * 
 * @param NameVisibility
 * @text Name Visibility
 * @parent Name
 *
 * @param NameAlwaysHidden:eval
 * @text Always Hidden
 * @parent NameVisibility
 * @type boolean
 * @on Always Hidden
 * @off No Priority
 * @desc Determines if the enemy name will always be visible.
 * Highest priority.
 * @default false
 *
 * @param NameAlwaysVisible:eval
 * @text Always Visible
 * @parent NameVisibility
 * @type boolean
 * @on Always Visible
 * @off Hide when Unselected
 * @desc Determines if the enemy name will always be visible.
 * Medium priority.
 * @default false
 *
 * @param NameAsTarget:eval
 * @text As Target
 * @parent NameVisibility
 * @type boolean
 * @on Visible As Target
 * @off No Priority
 * @desc Shows enemy name when enemy is a target.
 * Medium priority.
 * @default true
 *
 * @param NameAlwaysSelectOnly:eval
 * @text By Selection?
 * @parent NameVisibility
 * @type boolean
 * @on Visible when Selected
 * @off Visible when Targeting
 * @desc Determines the conditions for enemy name visibility.
 * Lowest priority.
 * @default false
 *
 * @param NameDamageVisibility:num
 * @text Temporary Visibility
 * @parent NameVisibility
 * @type number
 * @desc Number of frames enemy's name temporarily visible after
 * taking an action effect in battle. 60 frames = 1 second.
 * @default 0
 *
 * @param SvBattlers
 * @text Sideview Battlers
 *
 * @param AllowCollapse:eval
 * @text Allow Collapse
 * @parent SvBattlers
 * @type boolean
 * @on Allow
 * @off Don't
 * @desc Causes defeated enemies with SV Battler graphics
 * to "fade away" when defeated?
 * @default false
 *
 * @param AnchorX:num
 * @text Anchor: X
 * @parent SvBattlers
 * @desc Default X anchor for Sideview Battlers.
 * Use values between 0 and 1 to be safe.
 * @default 0.5
 *
 * @param AnchorY:num
 * @text Anchor: Y
 * @parent SvBattlers
 * @desc Default Y anchor for Sideview Battlers.
 * Use values between 0 and 1 to be safe.
 * @default 1.0
 *
 * @param MotionIdle:str
 * @text Motion: Idle
 * @parent SvBattlers
 * @type combo
 * @option walk
 * @option wait
 * @option chant
 * @option guard
 * @option damage
 * @option evade
 * @option thrust
 * @option swing
 * @option missile
 * @option skill
 * @option spell
 * @option item
 * @option escape
 * @option victory
 * @option dying
 * @option abnormal
 * @option sleep
 * @option dead
 * @desc Sets default idle animation used by Sideview Battlers.
 * @default walk
 *
 * @param Shadow:eval
 * @text Shadow Visible
 * @parent SvBattlers
 * @type boolean
 * @on Visible
 * @off Hidden
 * @desc Show or hide the shadow for Sideview Battlers.
 * @default true
 *
 * @param Width:num
 * @text Size: Width
 * @parent SvBattlers
 * @type number
 * @min 1
 * @desc Default width for enemies that use Sideview Battlers.
 * @default 64
 *
 * @param Height:num
 * @text Size: Height
 * @parent SvBattlers
 * @type number
 * @min 1
 * @desc Default height for enemies that use Sideview Battlers.
 * @default 64
 *
 * @param WtypeId:num
 * @text Weapon Type
 * @parent SvBattlers
 * @type number
 * @min 0
 * @desc Sets default weapon type used by Sideview Battlers.
 * Use 0 for Bare Hands.
 * @default 0
 *
 */
/* ----------------------------------------------------------------------------
 * HP Gauge Settings
 * ----------------------------------------------------------------------------
 */
/*~struct~HpGauge:
 *
 * @param Display
 * @text Show Gauges For
 *
 * @param ShowActorGauge:eval
 * @text Actors
 * @parent Display
 * @type boolean
 * @on Show
 * @off Hide
 * @desc Show HP Gauges over the actor sprites' heads?
 * Requires SV Actors to be visible.
 * @default true
 *
 * @param ShowEnemyGauge:eval
 * @text Enemies
 * @parent Display
 * @type boolean
 * @on Show
 * @off Hide
 * @desc Show HP Gauges over the enemy sprites' heads?
 * Can be bypassed with <Hide HP Gauge> notetag.
 * @default true
 *
 * @param RequiresDefeat:eval
 * @text Requires Defeat?
 * @parent ShowEnemyGauge:eval
 * @type boolean
 * @on Require Defeat First
 * @off No Requirement
 * @desc Requires defeating the enemy once to show HP Gauge?
 * Can be bypassed with <Show HP Gauge> notetag.
 * @default true
 *
 * @param BTestBypass:eval
 * @text Battle Test Bypass?
 * @parent RequiresDefeat:eval
 * @type boolean
 * @on Bypass
 * @off Don't Bypass
 * @desc Bypass the defeat requirement in battle test?
 * @default true
 *
 * @param Settings
 *
 * @param AniDuration:num
 * @text Animation Duration
 * @parent Settings
 * @type number
 * @min 1
 * @desc How many frames should gauges animate themselves?
 * Default: 20 frames.
 * @default 20
 *
 * @param AnchorX:num
 * @text Anchor X
 * @parent Settings
 * @desc Where do you want the HP Gauge sprite's anchor X to be?
 * Use values between 0 and 1 to be safe.
 * @default 0.5
 *
 * @param AnchorY:num
 * @text Anchor Y
 * @parent Settings
 * @desc Where do you want the HP Gauge sprite's anchor Y to be?
 * Use values between 0 and 1 to be safe.
 * @default 1.0
 *
 * @param Scale:num
 * @text Scale
 * @parent Settings
 * @desc How large/small do you want the HP Gauge to be scaled?
 * @default 0.5
 *
 * @param OffsetX:num
 * @text Offset X
 * @parent Settings
 * @desc How many pixels to offset the HP Gauge's X by?
 * @default 0
 *
 * @param OffsetY:num
 * @text Offset Y
 * @parent Settings
 * @desc How many pixels to offset the HP Gauge's Y by?
 * @default -3
 *
 * @param Options
 * @text Options
 *
 * @param AddHpGaugeOption:eval
 * @text Add Option?
 * @parent Options
 * @type boolean
 * @on Add
 * @off Don't Add
 * @desc Add the 'Show HP Gauge' option to the Options menu?
 * @default true
 *
 * @param AdjustRect:eval
 * @text Adjust Window Height
 * @parent Options
 * @type boolean
 * @on Adjust
 * @off Don't
 * @desc Automatically adjust the options window height?
 * @default true
 *
 * @param Name:str
 * @text Option Name
 * @parent Options
 * @desc Command name of the option.
 * @default Show HP Gauge
 *
 */
/* ----------------------------------------------------------------------------
 * Action Sequence Settings
 * ----------------------------------------------------------------------------
 */
/*~struct~ActionSequence:
 *
 * @param AutoSequences
 * @text Automatic Sequences
 *
 * @param AutoMeleeSolo:eval
 * @text Melee Single Target
 * @parent AutoSequences
 * @type boolean
 * @on Allow
 * @off Ignore
 * @desc Allow this auto sequence for physical, single target actions?
 * @default true
 *
 * @param AutoMeleeAoE:eval
 * @text Melee Multi Target
 * @parent AutoSequences
 * @type boolean
 * @on Allow
 * @off Ignore
 * @desc Allow this auto sequence for physical, multi-target actions?
 * @default true
 *
 * @param QoL
 * @text Quality of Life
 *
 * @param AutoNotetag:eval
 * @text Auto Notetag
 * @parent QoL
 * @type boolean
 * @on Automatic
 * @off Manual
 * @desc Automatically apply the <Custom Action Sequence> notetag
 * effect to any item or skill that has a Common Event?
 * @default false
 *
 * @param CastAnimations
 * @text Cast Animations
 *
 * @param CastCertain:num
 * @text Certain Hit
 * @parent CastAnimations
 * @type animation
 * @desc Cast animation for Certain Hit skills.
 * @default 120
 *
 * @param CastPhysical:num
 * @text Physical
 * @parent CastAnimations
 * @type animation
 * @desc Cast animation for Physical skills.
 * @default 52
 *
 * @param CastMagical:num
 * @text Magical
 * @parent CastAnimations
 * @type animation
 * @desc Cast animation for Magical skills.
 * @default 51
 *
 * @param CounterReflection
 * @text Counter/Reflect
 *
 * @param CounterPlayback:eval
 * @text Counter Back
 * @parent CounterReflection
 * @type boolean
 * @on Play Back
 * @off Ignore
 * @desc Play back the attack animation used?
 * @default true
 *
 * @param ReflectAnimation:num
 * @text Reflect Animation
 * @parent CounterReflection
 * @type animation
 * @desc Animation played when an action is reflected.
 * @default 53
 *
 * @param ReflectPlayback:eval
 * @text Reflect Back
 * @parent CounterReflection
 * @type boolean
 * @on Play Back
 * @off Ignore
 * @desc Play back the attack animation used?
 * @default true
 *
 * @param Stepping
 *
 * @param MeleeDistance:num
 * @text Melee Distance
 * @parent Stepping
 * @desc Minimum distance in pixels for Movement Action Sequences.
 * @default 24
 *
 * @param StepDistanceX:num
 * @text Step Distance X
 * @parent Stepping
 * @desc The normal X distance when stepping forward.
 * @default 48
 *
 * @param StepDistanceY:num
 * @text Step Distance Y
 * @parent Stepping
 * @desc The normal Y distance when stepping forward.
 * @default 0
 *
 * @param StepDuration:num
 * @text Step Duration
 * @parent Stepping
 * @desc The number of frames for a stepping action to complete.
 * @default 12
 *
 */
/* ----------------------------------------------------------------------------
 * Projectile Start Settings
 * ----------------------------------------------------------------------------
 */
/*~struct~ProjectileStart:
 * 
 * @param Type:str
 * @text Type
 * @type select
 * @option Target - Start from battler target(s)
 * @value target
 * @option Point - Start from a point on the screen
 * @value point
 * @desc Select where the projectile should start from.
 * @default target
 * 
 * @param Targets:arraystr
 * @text Target(s)
 * @parent Type:str
 * @type combo[]
 * @option user
 * @option current target
 * @option prev target
 * @option next target
 * @option all targets
 * @option focus
 * @option not focus
 * @option
 * @option special
 * @option special x
 * @option 
 * @option alive friends
 * @option alive friends not user
 * @option alive friends not target
 * @option dead friends
 * @option friend index x
 * @option 
 * @option alive opponents
 * @option alive opponents not target
 * @option dead opponents
 * @option opponent index x
 * @option 
 * @option alive actors
 * @option alive actors not user
 * @option alive actors not target
 * @option dead actors
 * @option actor index x
 * @option actor ID x
 * @option 
 * @option alive enemies
 * @option alive enemies not user
 * @option alive enemies not target
 * @option dead enemies
 * @option enemy index x
 * @option enemy ID x
 * @option 
 * @option alive battlers
 * @option alive battlers not user
 * @option alive battlers not target
 * @option dead battlers
 * @option 
 * @desc Select which unit(s) to start the projectile from.
 * @default ["user"]
 * 
 * @param TargetCenter:eval
 * @text Centralize
 * @parent Targets:arraystr
 * @type boolean
 * @on Center Projectile
 * @off Create Each
 * @desc Create one projectile at the center of the targets?
 * Or create a projectile for each target?
 * @default false
 * 
 * @param TargetLocation:str
 * @text Target Location
 * @parent Targets:arraystr
 * @type combo
 * @option front head
 * @option front center
 * @option front base
 * @option middle head
 * @option middle center
 * @option middle base
 * @option back head
 * @option back center
 * @option back base
 * @desc Select which part of the target to send the projectile from.
 * @default middle center
 * 
 * @param PointX:eval
 * @text Point X
 * @parent Type:str
 * @desc Insert the X coordinate to start the projectile at.
 * You may use JavaScript code.
 * @default Graphics.width / 2
 * 
 * @param PointY:eval
 * @text Point Y
 * @parent Type:str
 * @desc Insert the Y coordinate to start the projectile at.
 * You may use JavaScript code.
 * @default Graphics.height / 2
 * 
 * @param OffsetX:eval
 * @text Offset X
 * @desc Insert how many pixels to offset the X coordinate by.
 * You may use JavaScript code.
 * @default +0
 * 
 * @param OffsetY:eval
 * @text Offset Y
 * @desc Insert how many pixels to offset the Y coordinate by.
 * You may use JavaScript code.
 * @default +0
 *
 */
/* ----------------------------------------------------------------------------
 * Projectile Goal Settings
 * ----------------------------------------------------------------------------
 */
/*~struct~ProjectileGoal:
 * 
 * @param Type:str
 * @text Type
 * @type select
 * @option Target - Goal is battler target(s)
 * @value target
 * @option Point - Goal is a point on the screen
 * @value point
 * @desc Select where the projectile should go to.
 * @default target
 * 
 * @param Targets:arraystr
 * @text Target(s)
 * @parent Type:str
 * @type combo[]
 * @option user
 * @option current target
 * @option prev target
 * @option next target
 * @option all targets
 * @option focus
 * @option not focus
 * @option
 * @option special
 * @option special x
 * @option 
 * @option alive friends
 * @option alive friends not user
 * @option alive friends not target
 * @option dead friends
 * @option friend index x
 * @option 
 * @option alive opponents
 * @option alive opponents not target
 * @option dead opponents
 * @option opponent index x
 * @option 
 * @option alive actors
 * @option alive actors not user
 * @option alive actors not target
 * @option dead actors
 * @option actor index x
 * @option actor ID x
 * @option 
 * @option alive enemies
 * @option alive enemies not user
 * @option alive enemies not target
 * @option dead enemies
 * @option enemy index x
 * @option enemy ID x
 * @option 
 * @option alive battlers
 * @option alive battlers not user
 * @option alive battlers not target
 * @option dead battlers
 * @option 
 * @desc Select which unit(s) for projectile to go to.
 * @default ["all targets"]
 * 
 * @param TargetCenter:eval
 * @text Centralize
 * @parent Targets:arraystr
 * @type boolean
 * @on Center Projectile
 * @off Create Each
 * @desc Set goal in the center of targets?
 * Or create a projectile to go to each target?
 * @default false
 * 
 * @param TargetLocation:str
 * @text Target Location
 * @parent Targets:arraystr
 * @type combo
 * @option front head
 * @option front center
 * @option front base
 * @option middle head
 * @option middle center
 * @option middle base
 * @option back head
 * @option back center
 * @option back base
 * @desc Select which part of the target to send the projectile at.
 * @default middle center
 * 
 * @param PointX:eval
 * @text Point X
 * @parent Type:str
 * @desc Insert the X coordinate to send the projectile to.
 * You may use JavaScript code.
 * @default Graphics.width / 2
 * 
 * @param PointY:eval
 * @text Point Y
 * @parent Type:str
 * @desc Insert the Y coordinate to send the projectile to.
 * You may use JavaScript code.
 * @default Graphics.height / 2
 * 
 * @param OffsetX:eval
 * @text Offset X
 * @desc Insert how many pixels to offset the X coordinate by.
 * You may use JavaScript code.
 * @default +0
 * 
 * @param OffsetY:eval
 * @text Offset Y
 * @desc Insert how many pixels to offset the Y coordinate by.
 * You may use JavaScript code.
 * @default +0
 *
 */
/* ----------------------------------------------------------------------------
 * Projectile Extra Animation Settings
 * ----------------------------------------------------------------------------
 */
/*~struct~ProjectileExAni:
 * 
 * @param AutoAngle:eval
 * @text Auto Angle?
 * @parent Settings
 * @type boolean
 * @on Automatically Angle
 * @off Normal
 * @desc Automatically angle the projectile to tilt the direction it's moving?
 * @default true
 * 
 * @param AngleOffset:eval
 * @text Angle Offset
 * @desc Alter the projectile's tilt by this many degrees.
 * @default +0
 * 
 * @param Arc:eval
 * @text Arc Peak
 * @parent Settings
 * @desc This is the height of the projectile's trajectory arc
 * in pixels.
 * @default 0
 *
 * @param EasingType:str
 * @text Easing
 * @parent Settings
 * @type combo
 * @option Linear
 * @option InSine
 * @option OutSine
 * @option InOutSine
 * @option InQuad
 * @option OutQuad
 * @option InOutQuad
 * @option InCubic
 * @option OutCubic
 * @option InOutCubic
 * @option InQuart
 * @option OutQuart
 * @option InOutQuart
 * @option InQuint
 * @option OutQuint
 * @option InOutQuint
 * @option InExpo
 * @option OutExpo
 * @option InOutExpo
 * @option InCirc
 * @option OutCirc
 * @option InOutCirc
 * @option InBack
 * @option OutBack
 * @option InOutBack
 * @option InElastic
 * @option OutElastic
 * @option InOutElastic
 * @option InBounce
 * @option OutBounce
 * @option InOutBounce
 * @desc Select which easing type to apply to the projectile's trajectory.
 * @default Linear
 * 
 * @param Spin:eval
 * @text Spin Speed
 * @parent Settings
 * @desc Determine how much angle the projectile spins per frame.
 * Does not work well with "Auto Angle".
 * @default +0.0
 * 
 * @param Emulate
 * @text Effect Emulation
 * 
 * @param EmulateActionEffect:eval
 * @text Action Effect?
 * @parent Emulate
 * @type boolean
 * @on Emulate
 * @off Don't Emulate
 * @desc Emulate current Action Effect when projectile reaches
 * target? Only works with start/goal targets.
 * @default false
 * 
 * @param EmulateItemEffect:eval
 * @text Item Effect ID
 * @parent Emulate
 * @type item
 * @desc Emulate an Item Effect when projectile reaches target?
 * Use 0 to not use. Only works with start/goal targets.
 * @default 0
 * 
 * @param EmulateSkillEffect:eval
 * @text Skill Effect ID
 * @parent Emulate
 * @type skill
 * @desc Emulate a Skill Effect when projectile reaches target?
 * Use 0 to not use. Only works with start/goal targets.
 * @default 0
 *
 * @param OnceParallel:num
 * @text Common Event ID
 * @parent Emulate
 * @type common_event
 * @desc Plays a Once Parallel Common Event upon reaching target.
 * Use 0 to not use. Works regardless of start/goal targets.
 * @default 0
 *
 */
/* ----------------------------------------------------------------------------
 * Projectile Extra Settings
 * ----------------------------------------------------------------------------
 */
/*~struct~ProjectileExtra:
 * 
 * @param AutoAngle:eval
 * @text Auto Angle?
 * @parent Settings
 * @type boolean
 * @on Automatically Angle
 * @off Normal
 * @desc Automatically angle the projectile to tilt the direction it's moving?
 * @default true
 * 
 * @param AngleOffset:eval
 * @text Angle Offset
 * @desc Alter the projectile's tilt by this many degrees.
 * @default +0
 * 
 * @param Arc:eval
 * @text Arc Peak
 * @parent Settings
 * @desc This is the height of the projectile's trajectory arc
 * in pixels.
 * @default 0
 *
 * @param BlendMode:num
 * @text Blend Mode
 * @type select
 * @option 0 - Normal
 * @value 0
 * @option 1 - Additive
 * @value 1
 * @option 2 - Multiply
 * @value 2
 * @option 3 - Screen
 * @value 3
 * @desc What kind of blend mode do you wish to apply to the projectile?
 * @default 0
 *
 * @param EasingType:str
 * @text Easing
 * @parent Settings
 * @type combo
 * @option Linear
 * @option InSine
 * @option OutSine
 * @option InOutSine
 * @option InQuad
 * @option OutQuad
 * @option InOutQuad
 * @option InCubic
 * @option OutCubic
 * @option InOutCubic
 * @option InQuart
 * @option OutQuart
 * @option InOutQuart
 * @option InQuint
 * @option OutQuint
 * @option InOutQuint
 * @option InExpo
 * @option OutExpo
 * @option InOutExpo
 * @option InCirc
 * @option OutCirc
 * @option InOutCirc
 * @option InBack
 * @option OutBack
 * @option InOutBack
 * @option InElastic
 * @option OutElastic
 * @option InOutElastic
 * @option InBounce
 * @option OutBounce
 * @option InOutBounce
 * @desc Select which easing type to apply to the projectile's trajectory.
 * @default Linear
 * 
 * @param Hue:eval
 * @text Hue
 * @parent Settings
 * @desc Adjust the hue of the projectile.
 * Insert a number between 0 and 360.
 * @default 0
 * 
 * @param Scale:eval
 * @text Scale
 * @parent Settings
 * @desc Adjust the size scaling of the projectile.
 * Use decimals for exact control.
 * @default 1.0
 * 
 * @param Spin:eval
 * @text Spin Speed
 * @parent Settings
 * @desc Determine how much angle the projectile spins per frame.
 * Does not work well with "Auto Angle".
 * @default +0.0
 * 
 * @param Emulate
 * @text Effect Emulation
 * 
 * @param EmulateActionEffect:eval
 * @text Action Effect?
 * @parent Emulate
 * @type boolean
 * @on Emulate
 * @off Don't Emulate
 * @desc Emulate current Action Effect when projectile reaches
 * target? Only works with start/goal targets.
 * @default false
 * 
 * @param EmulateItemEffect:eval
 * @text Item Effect ID
 * @parent Emulate
 * @type item
 * @desc Emulate an Item Effect when projectile reaches target?
 * Use 0 to not use. Only works with start/goal targets.
 * @default 0
 * 
 * @param EmulateSkillEffect:eval
 * @text Skill Effect ID
 * @parent Emulate
 * @type skill
 * @desc Emulate a Skill Effect when projectile reaches target?
 * Use 0 to not use. Only works with start/goal targets.
 * @default 0
 *
 * @param OnceParallel:num
 * @text Common Event ID
 * @parent Emulate
 * @type common_event
 * @desc Plays a Once Parallel Common Event upon reaching target.
 * Use 0 to not use. Works regardless of start/goal targets.
 * @default 0
 *
 */
/* ----------------------------------------------------------------------------
 * Visual Cutin Effect Settings
 * ----------------------------------------------------------------------------
 */
/*~struct~VisualCutinEffect:
 *
 * @param Transition
 * 
 * @param enterDuration:num
 * @text Entrance Duration
 * @parent Transition
 * @type number
 * @desc How many frames does it take to fully enter?
 * Used when a Visual Cutin Effect starts.
 * @default 12
 * 
 * @param exitDuration:num
 * @text Exit Duration
 * @parent Transition
 * @type number
 * @desc How many frames does it take to fully exit?
 * Used when a Visual Cutin Effect ends.
 * @default 12
 *
 * @param Cutin
 * @text Cutin Settings
 *
 * @param bgShow:eval
 * @text Show BG Color?
 * @parent Cutin
 * @type boolean
 * @on Show
 * @off Hide
 * @desc Add a background color for this cutin?
 * Background colors appear behind the parallax.
 * @default true
 *
 * @param outlineShow:eval
 * @text Show Outline?
 * @parent Cutin
 * @type boolean
 * @on Show
 * @off Hide
 * @desc Show the cutin outline?
 * @default true
 *
 * @param Portrait
 * @text Portrait Settings
 *
 * @param PortraitBase
 * @text Base Properties
 * @parent Portrait
 * 
 * @param portraitAnchorX:num
 * @text Anchor X
 * @parent PortraitBase
 * @desc Determines the sprite anchor X alignment.
 * 0.0: Left, 0.5: Center, 1.0: Right.
 * @default 0.5
 * 
 * @param portraitAnchorY:num
 * @text Anchor Y
 * @parent PortraitBase
 * @desc Determines the sprite anchor Y alignment.
 * 0.0: Top, 0.5: Middle, 1.0: Bottom.
 * @default 0.5
 *
 * @param portraitHue:num
 * @text Hue
 * @parent PortraitBase
 * @type number
 * @min 0
 * @max 360
 * @desc Do you wish to adjust this cutin's portrait hue?
 * @default 0
 * 
 * @param portraitOpacity:num
 * @text Opacity
 * @parent PortraitBase
 * @type number
 * @max 255
 * @desc What is the opacity level of this cutin's portrait?
 * @default 255
 * 
 * @param portraitOffsetX:num
 * @text Offset X
 * @parent PortraitBase
 * @desc Offsets the cutin portrait's X location.
 * Negative: left. Positive: right.
 * @default +0
 * 
 * @param portraitOffsetY:num
 * @text Offset Y
 * @parent PortraitBase
 * @desc Offsets the cutin portrait's Y location.
 * Negative: up. Positive: down.
 * @default +0
 *
 * @param PortraitEnter
 * @text Entrance Properties
 * @parent Portrait
 * 
 * @param portraitEnterX:num
 * @text Entrance X
 * @parent PortraitEnter
 * @desc Sets the cutin portrait's X entrance.
 * Negative: from left. Positive: from right.
 * @default +0
 * 
 * @param portraitEnterY:num
 * @text Entrance Y
 * @parent PortraitEnter
 * @desc Sets the cutin portrait's Y entrance.
 * Negative: from up. Positive: from down.
 * @default +0
 *
 * @param portraitEnterEasingType:str
 * @text Entrance Easing
 * @parent PortraitEnter
 * @type combo
 * @option Linear
 * @option InSine
 * @option OutSine
 * @option InOutSine
 * @option InQuad
 * @option OutQuad
 * @option InOutQuad
 * @option InCubic
 * @option OutCubic
 * @option InOutCubic
 * @option InQuart
 * @option OutQuart
 * @option InOutQuart
 * @option InQuint
 * @option OutQuint
 * @option InOutQuint
 * @option InExpo
 * @option OutExpo
 * @option InOutExpo
 * @option InCirc
 * @option OutCirc
 * @option InOutCirc
 * @option InBack
 * @option OutBack
 * @option InOutBack
 * @option InElastic
 * @option OutElastic
 * @option InOutElastic
 * @option InBounce
 * @option OutBounce
 * @option InOutBounce
 * @desc Select which easing type you wish to apply.
 * @default InOutSine
 *
 * @param PortraitExit
 * @text Exit Properties
 * @parent Portrait
 * 
 * @param portraitExitX:num
 * @text Exit X
 * @parent PortraitExit
 * @desc Sets the cutin portrait's X exit.
 * Negative: to left. Positive: to right.
 * @default +0
 * 
 * @param portraitExitY:num
 * @text Exit Y
 * @parent PortraitExit
 * @desc Sets the cutin portrait's Y exit.
 * Negative: to up. Positive: to down.
 * @default +0
 *
 * @param portraitExitEasingType:str
 * @text Exit Easing
 * @parent PortraitExit
 * @type combo
 * @option Linear
 * @option InSine
 * @option OutSine
 * @option InOutSine
 * @option InQuad
 * @option OutQuad
 * @option InOutQuad
 * @option InCubic
 * @option OutCubic
 * @option InOutCubic
 * @option InQuart
 * @option OutQuart
 * @option InOutQuart
 * @option InQuint
 * @option OutQuint
 * @option InOutQuint
 * @option InExpo
 * @option OutExpo
 * @option InOutExpo
 * @option InCirc
 * @option OutCirc
 * @option InOutCirc
 * @option InBack
 * @option OutBack
 * @option InOutBack
 * @option InElastic
 * @option OutElastic
 * @option InOutElastic
 * @option InBounce
 * @option OutBounce
 * @option InOutBounce
 * @desc Select which easing type you wish to apply.
 * @default InOutSine
 *
 * @param PortraitFlip
 * @text Flip Properties
 * @parent Portrait
 *
 * @param portraitFlipHorz:eval
 * @text Flip Horizontally?
 * @parent PortraitFlip
 * @type boolean
 * @on Flip
 * @off Don't Flip
 * @desc Flip the cutin portrait horizontally?
 * @default false
 *
 * @param portraitFlipVert:eval
 * @text Flip Vertically?
 * @parent PortraitFlip
 * @type boolean
 * @on Flip
 * @off Don't Flip
 * @desc Flip the cutin portrait vertically?
 * @default false
 *
 * @param PortraitScale
 * @text Scaling Properties
 * @parent Portrait
 * 
 * @param portraitForcedScale:num
 * @text Forced Scaling
 * @parent PortraitScale
 * @desc Do you want to force a scaling ratio?
 * Leave as 0 for none. Disables "Fit to Scale?".
 * @default 0.0
 *
 * @param portraitScaleToFit:eval
 * @text Fit to Scale?
 * @parent PortraitScale
 * @type boolean
 * @on Fit to Scale
 * @off Don't Scale
 * @desc Scale the cutin portrait to fit the cutin style?
 * Cannot be used with "Forced Scaling".
 * @default true
 *
 * @param portraitScaleMax:eval
 * @text Scale Max?
 * @parent portraitScaleToFit:eval
 * @type boolean
 * @on Scale Maximum
 * @off Scale Minimum
 * @desc Scale the cutin portrait to the maximum fit or
 * scale the cutin portrait to the minimum fit.
 * @default false
 *
 * @param PortraitAni
 * @text Animated Portraits
 * @parent Portrait
 *
 * @param animatedPortraitLooping:eval
 * @text Loop?
 * @parent PortraitAni
 * @type boolean
 * @on ON
 * @off OFF
 * @desc Will loop back to beginning once ended.
 * Requires VisuMZ_4_AnimatedPictures!
 * @default true
 *
 * @param animatedPortraitWaitFrames:num
 * @text Wait Frames
 * @parent PortraitAni
 * @type number
 * @min 1
 * @desc Frames to wait before moving to next cell.
 * Requires VisuMZ_4_AnimatedPictures!
 * @default 4
 *
 * @param Parallax
 * @text Parallax Settings
 *
 * @param ParallaxBase
 * @text Base Settings
 * @parent Parallax
 *
 * @param parallaxBlendMode:num
 * @text Blend Mode
 * @parent ParallaxBase
 * @type select
 * @option 0 - Normal
 * @value 0
 * @option 1 - Additive
 * @value 1
 * @option 2 - Multiply
 * @value 2
 * @option 3 - Screen
 * @value 3
 * @desc What kind of blend mode do you wish to apply to the cutin?
 * @default 0
 *
 * @param parallaxHue:num
 * @text Hue
 * @parent ParallaxBase
 * @type number
 * @min 0
 * @max 360
 * @desc Do you wish to adjust this cutin's parallax hue?
 * @default 0
 *
 * @param parallaxHueEnemyModifier:num
 * @text Enemy Modifier
 * @parent parallaxHue:num
 * @desc Adjust the hue value by this if the cutin target is an enemy.
 * @default +0
 * 
 * @param parallaxOpacity:num
 * @text Opacity
 * @parent ParallaxBase
 * @type number
 * @max 255
 * @desc What is the opacity level of this cutin's parallax?
 * @default 255
 *
 * @param ParallaxScroll
 * @text Scrolling Settings
 * @parent Parallax
 * 
 * @param parallaxOffsetX:num
 * @text Offset X
 * @parent ParallaxScroll
 * @desc Offsets the cutin parallax's X location.
 * Negative: left. Positive: right.
 * @default +0.0
 * 
 * @param parallaxOffsetY:num
 * @text Offset Y
 * @parent ParallaxScroll
 * @desc Offsets the cutin parallax's Y location.
 * Negative: up. Positive: down.
 * @default +0.0
 * 
 * @param parallaxScrollX:num
 * @text Scroll X
 * @parent ParallaxScroll
 * @desc How many pixels does the parallax scroll horizontally?
 * Negative: Scroll to right. Positive: Scroll to left.
 * @default +0.0
 *
 * @param parallaxScrollXinvertEnemy:eval
 * @text Invert for Enemy?
 * @parent parallaxScrollX:num
 * @type boolean
 * @on Invert
 * @off Don't Invert
 * @desc Invert the X scroll direction if the cutin target is an enemy?
 * @default false
 * 
 * @param parallaxScrollY:num
 * @text Scroll Y
 * @parent ParallaxScroll
 * @desc How many pixels does the parallax scroll vertically?
 * Negative: Scroll to down. Positive: Scroll to up.
 * @default +0.0
 *
 * @param parallaxScrollYinvertEnemy:eval
 * @text Invert for Enemy?
 * @parent parallaxScrollY:num
 * @type boolean
 * @on Invert
 * @off Don't Invert
 * @desc Invert the Y scroll direction if the cutin target is an enemy?
 * @default false
 *
 */
//=============================================================================

var tier = tier || 0x0;
var dependencies = [];
var pluginData = $plugins.filter(function (_0x5545a2) {
  return _0x5545a2.status && _0x5545a2.description.includes("[BattleCore]");
})[0x0];
VisuMZ.BattleCore.Settings = VisuMZ.BattleCore.Settings || {};
VisuMZ.ConvertParams = function (_0x52a385, _0x3cb515) {
  for (const _0x137efc in _0x3cb515) {
    if (_0x137efc.match(/(.*):(.*)/i)) {
      const _0x4b6cf1 = String(RegExp.$1);
      const _0x48da7 = String(RegExp.$2).toUpperCase().trim();
      let _0x7f729a;
      let _0x475709;
      let _0x2708ea;
      switch (_0x48da7) {
        case "NUM":
          _0x7f729a = _0x3cb515[_0x137efc] !== '' ? Number(_0x3cb515[_0x137efc]) : 0x0;
          break;
        case "ARRAYNUM":
          _0x475709 = _0x3cb515[_0x137efc] !== '' ? JSON.parse(_0x3cb515[_0x137efc]) : [];
          _0x7f729a = _0x475709.map(_0x1f55f6 => Number(_0x1f55f6));
          break;
        case "EVAL":
          _0x7f729a = _0x3cb515[_0x137efc] !== '' ? eval(_0x3cb515[_0x137efc]) : null;
          break;
        case "ARRAYEVAL":
          _0x475709 = _0x3cb515[_0x137efc] !== '' ? JSON.parse(_0x3cb515[_0x137efc]) : [];
          _0x7f729a = _0x475709.map(_0x506e3b => eval(_0x506e3b));
          break;
        case "JSON":
          _0x7f729a = _0x3cb515[_0x137efc] !== '' ? JSON.parse(_0x3cb515[_0x137efc]) : '';
          break;
        case "ARRAYJSON":
          _0x475709 = _0x3cb515[_0x137efc] !== '' ? JSON.parse(_0x3cb515[_0x137efc]) : [];
          _0x7f729a = _0x475709.map(_0x8b756e => JSON.parse(_0x8b756e));
          break;
        case "FUNC":
          _0x7f729a = _0x3cb515[_0x137efc] !== '' ? new Function(JSON.parse(_0x3cb515[_0x137efc])) : new Function("return 0");
          break;
        case "ARRAYFUNC":
          _0x475709 = _0x3cb515[_0x137efc] !== '' ? JSON.parse(_0x3cb515[_0x137efc]) : [];
          _0x7f729a = _0x475709.map(_0x377f89 => new Function(JSON.parse(_0x377f89)));
          break;
        case "STR":
          _0x7f729a = _0x3cb515[_0x137efc] !== '' ? String(_0x3cb515[_0x137efc]) : '';
          break;
        case "ARRAYSTR":
          _0x475709 = _0x3cb515[_0x137efc] !== '' ? JSON.parse(_0x3cb515[_0x137efc]) : [];
          _0x7f729a = _0x475709.map(_0x4fd913 => String(_0x4fd913));
          break;
        case "STRUCT":
          _0x2708ea = _0x3cb515[_0x137efc] !== '' ? JSON.parse(_0x3cb515[_0x137efc]) : {};
          _0x52a385[_0x4b6cf1] = {};
          VisuMZ.ConvertParams(_0x52a385[_0x4b6cf1], _0x2708ea);
          continue;
        case 'ARRAYSTRUCT':
          _0x475709 = _0x3cb515[_0x137efc] !== '' ? JSON.parse(_0x3cb515[_0x137efc]) : [];
          _0x7f729a = _0x475709.map(_0x417d54 => VisuMZ.ConvertParams({}, JSON.parse(_0x417d54)));
          break;
        default:
          continue;
      }
      _0x52a385[_0x4b6cf1] = _0x7f729a;
    }
  }
  return _0x52a385;
};
(_0x31359b => {
  const _0x1eb406 = _0x31359b.name;
  for (const _0x29ec3a of dependencies) {
    if (!Imported[_0x29ec3a]) {
      alert("%1 is missing a required plugin.\nPlease install %2 into the Plugin Manager.".format(_0x1eb406, _0x29ec3a));
      SceneManager.exit();
      break;
    }
  }
  const _0x160dc5 = _0x31359b.description;
  if (_0x160dc5.match(/\[Version[ ](.*?)\]/i)) {
    const _0x34d869 = Number(RegExp.$1);
    if (_0x34d869 !== VisuMZ.BattleCore.version) {
      alert("%1's version does not match plugin's. Please update it in the Plugin Manager.".format(_0x1eb406, _0x34d869));
      SceneManager.exit();
    }
  }
  if (_0x160dc5.match(/\[Tier[ ](\d+)\]/i)) {
    const _0x4b6adc = Number(RegExp.$1);
    if (_0x4b6adc < tier) {
      alert("%1 is incorrectly placed on the plugin list.\nIt is a Tier %2 plugin placed over other Tier %3 plugins.\nPlease reorder the plugin list from smallest to largest tier numbers.".format(_0x1eb406, _0x4b6adc, tier));
      SceneManager.exit();
    } else {
      tier = Math.max(_0x4b6adc, tier);
    }
  }
  VisuMZ.ConvertParams(VisuMZ.BattleCore.Settings, _0x31359b.parameters);
})(pluginData);
VisuMZ.CreateActionSequenceTargets = function (_0x3547f0) {
  let _0x4939bd = [];
  for (const _0x5a0abe of _0x3547f0) {
    _0x4939bd = _0x4939bd.concat(VisuMZ.ConvertActionSequenceTarget(_0x5a0abe));
  }
  return _0x4939bd.filter(_0x48e8f5 => _0x48e8f5);
};
VisuMZ.ConvertActionSequenceTarget = function (_0x758887) {
  const _0x2eed71 = BattleManager.allBattleMembers().filter(_0x2b1fe9 => _0x2b1fe9 && _0x2b1fe9.isAppeared());
  const _0x53eb16 = BattleManager._subject;
  const _0x5f0e2a = BattleManager._target;
  const _0x248687 = BattleManager._allTargets ? BattleManager._allTargets.slice(0x0) : _0x2eed71;
  _0x758887 = _0x758887.toLowerCase().trim();
  if (_0x758887 === 'user') {
    return [_0x53eb16];
  } else {
    if (_0x758887 === "current target") {
      return [_0x5f0e2a];
    } else {
      if (_0x758887 === "prev target") {
        if (_0x5f0e2a) {
          const _0x39701e = _0x248687.indexOf(_0x5f0e2a);
          return _0x39701e >= 0x0 ? [_0x248687[_0x39701e - 0x1] || _0x5f0e2a] : [_0x5f0e2a];
        }
      } else {
        if (_0x758887 === "text target") {
          if (_0x5f0e2a) {
            const _0x242d7c = _0x248687.indexOf(_0x5f0e2a);
            return _0x242d7c >= 0x0 ? [_0x248687[_0x242d7c + 0x1] || _0x5f0e2a] : [_0x5f0e2a];
          }
        } else {
          if (_0x758887 === "all targets") {
            return _0x248687;
          } else {
            if (_0x758887 === "focus") {
              return [_0x53eb16].concat(_0x248687);
            } else {
              if (_0x758887 === "not focus") {
                return _0x2eed71.filter(_0x22e4b0 => _0x22e4b0 !== _0x53eb16 && !_0x248687.includes(_0x22e4b0) && _0x22e4b0.notFocusValid());
              } else {
                if (_0x758887 === "special") {
                  return [VisuMZ.GetActionSequenceSpecialTarget()];
                } else {
                  if (_0x758887.match(/SPECIAL (.*)>/i)) {
                    const _0x503a19 = String(RegExp.$1).split(',').map(_0x4b5be9 => _0x4b5be9.trim());
                    return [VisuMZ.GetActionSequenceSpecialTargetWithFlags(_0x503a19)];
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  if (_0x53eb16) {
    if (_0x758887 === "alive friends") {
      return _0x53eb16.friendsUnit().aliveMembers();
    } else {
      if (_0x758887 === "alive friends not user") {
        return _0x53eb16.friendsUnit().aliveMembers().filter(_0x551a18 => _0x551a18 !== _0x53eb16);
      } else {
        if (_0x758887 === "alive friends not target") {
          return _0x53eb16.friendsUnit().aliveMembers().filter(_0x334f7b => _0x334f7b !== _0x5f0e2a);
        } else {
          if (_0x758887 === "dead friends") {
            return _0x53eb16.friendsUnit().deadMembers();
          } else {
            if (_0x758887.match(/FRIEND INDEX (\d+)/i)) {
              const _0x2d9ed7 = Number(RegExp.$1);
              return [_0x53eb16.friendsUnit().members()[_0x2d9ed7]];
            }
          }
        }
      }
    }
    if (_0x758887 === "alive opponents") {
      return _0x53eb16.opponentsUnit().aliveMembers();
    } else {
      if (_0x758887 === "alive opponents not target") {
        return _0x53eb16.opponentsUnit().aliveMembers().filter(_0x19de91 => _0x19de91 !== _0x5f0e2a);
      } else {
        if (_0x758887 === "dead opponents") {
          return _0x53eb16.opponentsUnit().deadMembers();
        } else {
          if (_0x758887.match(/OPPONENT INDEX (\d+)/i)) {
            const _0x4c5bc0 = Number(RegExp.$1);
            return [_0x53eb16.opponentsUnit().members()[_0x4c5bc0]];
          }
        }
      }
    }
  }
  if (_0x758887 === "alive actors") {
    return $gameParty.aliveMembers();
  } else {
    if (_0x758887 === "alive actors not user") {
      return $gameParty.aliveMembers().filter(_0x1291f3 => _0x1291f3 !== _0x53eb16);
    } else {
      if (_0x758887 === "alive actors not target") {
        return $gameParty.aliveMembers().filter(_0x8938e1 => _0x8938e1 !== _0x5f0e2a);
      } else {
        if (_0x758887 === "dead actors") {
          return $gameParty.deadMembers();
        } else {
          if (_0x758887.match(/ACTOR INDEX (\d+)/i)) {
            const _0x5271b6 = Number(RegExp.$1);
            return [$gameParty.members()[_0x5271b6]];
          } else {
            if (_0x758887.match(/ACTOR ID (\d+)/i)) {
              const _0x5689a5 = Number(RegExp.$1);
              return [$gameActors.actor(_0x5689a5)];
            }
          }
        }
      }
    }
  }
  if (_0x758887 === "alive enemies") {
    return $gameTroop.aliveMembers();
  } else {
    if (_0x758887 === "alive enemies not user") {
      return $gameTroop.aliveMembers().filter(_0x11de41 => _0x11de41 !== _0x53eb16);
    } else {
      if (_0x758887 === "alive enemies not target") {
        return $gameTroop.aliveMembers().filter(_0x162582 => _0x162582 !== _0x5f0e2a);
      } else {
        if (_0x758887 === "dead enemies") {
          return $gameTroop.deadMembers();
        } else {
          if (_0x758887.match(/ENEMY INDEX (\d+)/i)) {
            const _0x34c4e6 = Number(RegExp.$1);
            return [$gameTroop.members()[_0x34c4e6]];
          } else {
            if (_0x758887.match(/ENEMY ID (\d+)/i)) {
              const _0x375575 = Number(RegExp.$1);
              return $gameTroop.aliveMembers().filter(_0xfce460 => _0xfce460.enemyId() === _0x375575);
            }
          }
        }
      }
    }
  }
  if (_0x758887 === "alive battlers") {
    return _0x2eed71.filter(_0x3a862c => _0x3a862c.isAlive());
  } else {
    if (_0x758887 === "alive battlers not user") {
      return _0x2eed71.filter(_0x628192 => _0x628192.isAlive() && _0x628192 !== _0x53eb16);
    } else {
      if (_0x758887 === "alive battlers not target") {
        return _0x2eed71.filter(_0xdfd47e => _0xdfd47e.isAlive() && _0xdfd47e !== _0x5f0e2a);
      } else {
        if (_0x758887 === "dead battlers") {
          return _0x2eed71.filter(_0x5866f8 => _0x5866f8.isDead());
        }
      }
    }
  }
  return [];
};
VisuMZ.GetActionSequenceSpecialTarget = function () {
  return BattleManager._target;
};
VisuMZ.GetActionSequenceSpecialTargetWithFlags = function (_0x45169b) {
  return BattleManager._target;
};
PluginManager.registerCommand(pluginData.name, "ActSeq_Set_SetupAction", _0x330cf1 => {
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  VisuMZ.ConvertParams(_0x330cf1, _0x330cf1);
  const _0x524200 = $gameTemp.getLastPluginCommandInterpreter();
  const _0xc9caf2 = BattleManager._action;
  const _0xa1c973 = BattleManager._subject;
  const _0x48865f = BattleManager._allTargets ? BattleManager._allTargets.slice(0x0) : [];
  const _0x490b1c = BattleManager._logWindow;
  if (!_0x524200 || !_0xc9caf2 || !_0xa1c973) {
    return;
  }
  if (!_0xc9caf2.item()) {
    return;
  }
  if (_0x330cf1.DisplayAction) {
    _0x490b1c.displayAction(_0xa1c973, _0xc9caf2.item());
  }
  if (_0x330cf1.ApplyImmortal) {
    _0x490b1c.push('applyImmortal', _0xa1c973, _0x48865f, true);
  }
  if (_0x330cf1.ActionStart) {
    _0x490b1c.push('performActionStart', _0xa1c973, _0xc9caf2);
  }
  if (_0x330cf1.WaitForMovement) {
    _0x490b1c.push('waitForMovement');
  }
  if (_0x330cf1.CastAnimation) {
    _0x490b1c.push('performCastAnimation', _0xa1c973, _0xc9caf2);
  }
  if (_0x330cf1.WaitForAnimation) {
    _0x490b1c.push("waitForAnimation");
  }
  _0x524200.setWaitMode("battlelog");
});
PluginManager.registerCommand(pluginData.name, "ActSeq_Set_WholeActionSet", _0xf68a9e => {
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  VisuMZ.ConvertParams(_0xf68a9e, _0xf68a9e);
  const _0x7ccc70 = $gameTemp.getLastPluginCommandInterpreter();
  const _0x4112cf = BattleManager._action;
  const _0x129a56 = BattleManager._subject;
  const _0x1aaeaf = BattleManager._allTargets ? BattleManager._allTargets.slice(0x0) : [];
  const _0x53d0dd = BattleManager._logWindow;
  const _0x1089f1 = _0xf68a9e.DualWield ?? false;
  if (!_0x7ccc70 || !_0x4112cf || !_0x129a56) {
    return;
  }
  if (!_0x4112cf.item()) {
    return;
  }
  let _0x1ee7c8 = _0x1089f1 ? _0x53d0dd.getDualWieldTimes(_0x129a56) : 0x1;
  for (let _0xf4cd31 = 0x0; _0xf4cd31 < _0x1ee7c8; _0xf4cd31++) {
    if (_0x1089f1 && _0x129a56.isActor()) {
      _0x53d0dd.push("setActiveWeaponSet", _0x129a56, _0xf4cd31);
    }
    if (_0xf68a9e.PerformAction) {
      _0x53d0dd.push("performAction", _0x129a56, _0x4112cf);
    }
    if (_0xf68a9e.WaitCount > 0x0) {
      _0x53d0dd.push("waitCount", _0xf68a9e.WaitCount);
    }
    if (_0xf68a9e.ActionAnimation) {
      _0x53d0dd.push("showAnimation", _0x129a56, _0x1aaeaf, _0x4112cf.item().animationId);
    }
    if (_0xf68a9e.WaitForAnimation) {
      _0x53d0dd.push('waitForAnimation');
    }
    for (const _0x1a5f7e of _0x1aaeaf) {
      if (!_0x1a5f7e) {
        continue;
      }
      if (_0xf68a9e.ActionEffect) {
        _0x53d0dd.push("actionEffect", _0x129a56, _0x1a5f7e);
      }
    }
  }
  if (_0x1089f1 && _0x129a56.isActor()) {
    _0x53d0dd.push("clearActiveWeaponSet", _0x129a56);
  }
  if (_0xf68a9e.ApplyImmortal) {
    _0x53d0dd.push("applyImmortal", _0x129a56, _0x1aaeaf, false);
  }
  _0x7ccc70.setWaitMode('battlelog');
});
PluginManager.registerCommand(pluginData.name, 'ActSeq_Set_TargetActionSet', _0x1e774a => {
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  VisuMZ.ConvertParams(_0x1e774a, _0x1e774a);
  const _0x305243 = $gameTemp.getLastPluginCommandInterpreter();
  const _0x2093df = BattleManager._action;
  const _0x4259b0 = BattleManager._subject;
  const _0x3ae27a = BattleManager._allTargets ? BattleManager._allTargets.slice(0x0) : [];
  const _0x370c22 = BattleManager._logWindow;
  const _0x3b4219 = _0x1e774a.DualWield ?? false;
  if (!_0x305243 || !_0x2093df || !_0x4259b0) {
    return;
  }
  if (!_0x2093df.item()) {
    return;
  }
  let _0xd54ef = _0x3b4219 ? _0x370c22.getDualWieldTimes(_0x4259b0) : 0x1;
  for (let _0x33a6b2 = 0x0; _0x33a6b2 < _0xd54ef; _0x33a6b2++) {
    for (const _0x546ba1 of _0x3ae27a) {
      if (!_0x546ba1) {
        continue;
      }
      if (_0x3b4219 && _0x4259b0.isActor()) {
        _0x370c22.push("setActiveWeaponSet", _0x4259b0, _0x33a6b2);
      }
      if (_0x1e774a.PerformAction) {
        _0x370c22.push("performAction", _0x4259b0, _0x2093df);
      }
      if (_0x1e774a.WaitCount1 > 0x0) {
        _0x370c22.push("waitCount", _0x1e774a.WaitCount1);
      }
      if (_0x1e774a.ActionAnimation) {
        _0x370c22.push("showAnimation", _0x4259b0, [_0x546ba1], _0x2093df.item().animationId);
      }
      if (_0x1e774a.WaitCount2 > 0x0) {
        _0x370c22.push("waitCount", _0x1e774a.WaitCount2);
      }
      if (_0x1e774a.ActionEffect) {
        _0x370c22.push("actionEffect", _0x4259b0, _0x546ba1);
      }
    }
  }
  if (_0x3b4219 && _0x4259b0.isActor()) {
    _0x370c22.push("clearActiveWeaponSet", _0x4259b0);
  }
  if (_0x1e774a.ApplyImmortal) {
    _0x370c22.push("applyImmortal", _0x4259b0, _0x3ae27a, false);
  }
  _0x305243.setWaitMode("battlelog");
});
PluginManager.registerCommand(pluginData.name, "ActSeq_Set_FinishAction", _0x569580 => {
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  VisuMZ.ConvertParams(_0x569580, _0x569580);
  const _0x5d5675 = $gameTemp.getLastPluginCommandInterpreter();
  const _0x333ad1 = BattleManager._action;
  const _0x2870ab = BattleManager._subject;
  const _0x436e28 = BattleManager._allTargets ? BattleManager._allTargets.slice(0x0) : [];
  const _0x93bff6 = BattleManager._logWindow;
  if (!_0x5d5675 || !_0x333ad1 || !_0x2870ab) {
    return;
  }
  if (!_0x333ad1.item()) {
    return;
  }
  if (_0x569580.ApplyImmortal) {
    _0x93bff6.push("applyImmortal", _0x2870ab, _0x436e28, false);
  }
  if (_0x569580.WaitForNewLine) {
    _0x93bff6.push("waitForNewLine");
  }
  if (_0x569580.WaitForEffect) {
    _0x93bff6.push("waitForEffect");
  }
  if (_0x569580.ClearBattleLog) {
    _0x93bff6.push('clear');
  }
  if (_0x569580.ActionEnd) {
    _0x93bff6.push("performActionEnd", _0x2870ab);
  }
  if (_0x569580.WaitForMovement) {
    _0x93bff6.push("waitForMovement");
  }
  _0x5d5675.setWaitMode("battlelog");
});
PluginManager.registerCommand(pluginData.name, 'ActSeq_ChangeAngle', _0xb413e => {
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  if (!Imported.VisuMZ_3_ActSeqCamera) {
    return;
  }
  VisuMZ.ConvertParams(_0xb413e, _0xb413e);
  const _0xc24adf = $gameTemp.getLastPluginCommandInterpreter();
  const _0x3693aa = _0xb413e.WaitForAngle;
  if (!_0xc24adf) {
    return;
  }
  $gameScreen.setBattleAngle(_0xb413e.Angle, _0xb413e.Duration, _0xb413e.EasingType);
  if (_0x3693aa) {
    _0xc24adf.setWaitMode("battleAngle");
  }
});
PluginManager.registerCommand(pluginData.name, "ActSeq_Angle_Reset", _0x58b357 => {
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  if (!Imported.VisuMZ_3_ActSeqCamera) {
    return;
  }
  VisuMZ.ConvertParams(_0x58b357, _0x58b357);
  const _0x559446 = $gameTemp.getLastPluginCommandInterpreter();
  const _0x2b323d = _0x58b357.WaitForAngle;
  if (!_0x559446) {
    return;
  }
  $gameScreen.setBattleAngle(0x0, _0x58b357.Duration, _0x58b357.EasingType);
  if (_0x2b323d) {
    _0x559446.setWaitMode("battleAngle");
  }
});
PluginManager.registerCommand(pluginData.name, 'ActSeq_Angle_WaitForAngle', _0x1f73b3 => {
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  if (!Imported.VisuMZ_3_ActSeqCamera) {
    return;
  }
  const _0x576339 = $gameTemp.getLastPluginCommandInterpreter();
  if (!_0x576339) {
    return;
  }
  _0x576339.setWaitMode("battleAngle");
});
PluginManager.registerCommand(pluginData.name, "ActSeq_Animation_ActionAnimation", _0x2cd561 => {
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  VisuMZ.ConvertParams(_0x2cd561, _0x2cd561);
  const _0x248c9d = $gameTemp.getLastPluginCommandInterpreter();
  const _0x5e9686 = BattleManager._action;
  const _0x4c3fd3 = BattleManager._subject;
  const _0x2bba1e = VisuMZ.CreateActionSequenceTargets(_0x2cd561.Targets);
  const _0x692fe1 = _0x2cd561.Mirror;
  if (!_0x248c9d || !_0x5e9686 || !_0x4c3fd3) {
    return;
  }
  if (!_0x5e9686.item()) {
    return;
  }
  let _0x36cadd = _0x5e9686.item().animationId;
  if (_0x36cadd < 0x0) {
    _0x36cadd = _0x4c3fd3.attackAnimationId1();
  }
  $gameTemp.requestAnimation(_0x2bba1e, _0x36cadd, _0x692fe1);
  if (_0x2cd561.WaitForAnimation) {
    _0x248c9d.setWaitMode("battleAnimation");
  }
});
PluginManager.registerCommand(pluginData.name, "ActSeq_Animation_AttackAnimation", _0x47cbd6 => {
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  VisuMZ.ConvertParams(_0x47cbd6, _0x47cbd6);
  const _0x228923 = $gameTemp.getLastPluginCommandInterpreter();
  const _0x38fe07 = BattleManager._subject;
  const _0x1be2c1 = VisuMZ.CreateActionSequenceTargets(_0x47cbd6.Targets);
  const _0x5ca921 = _0x47cbd6.Mirror;
  if (!_0x228923 || !_0x38fe07) {
    return;
  }
  const _0x9f0748 = _0x38fe07.attackAnimationId1();
  $gameTemp.requestAnimation(_0x1be2c1, _0x9f0748, _0x5ca921);
  if (_0x47cbd6.WaitForAnimation) {
    _0x228923.setWaitMode("battleAnimation");
  }
});
PluginManager.registerCommand(pluginData.name, "ActSeq_Animation_AttackAnimation2", _0x3f2903 => {
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  VisuMZ.ConvertParams(_0x3f2903, _0x3f2903);
  const _0x511568 = _0x2d559f.attackAnimationIdSlot(_0x3f2903.Slot);
  if (_0x511568 <= 0x0) {
    return;
  }
  const _0x35cdfe = $gameTemp.getLastPluginCommandInterpreter();
  const _0x2d559f = BattleManager._subject;
  const _0x208de3 = VisuMZ.CreateActionSequenceTargets(_0x3f2903.Targets);
  const _0x366ebb = _0x3f2903.Mirror;
  if (!_0x35cdfe || !_0x2d559f) {
    return;
  }
  $gameTemp.requestAnimation(_0x208de3, _0x511568, _0x366ebb);
  if (_0x3f2903.WaitForAnimation) {
    _0x35cdfe.setWaitMode('battleAnimation');
  }
});
PluginManager.registerCommand(pluginData.name, "ActSeq_Animation_BalloonAnimation", _0x2bfac6 => {
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  VisuMZ.ConvertParams(_0x2bfac6, _0x2bfac6);
  const _0x6a2755 = $gameTemp.getLastPluginCommandInterpreter();
  const _0x3d835d = VisuMZ.CreateActionSequenceTargets(_0x2bfac6.Targets);
  const _0x4bd0e0 = _0x2bfac6.Balloon;
  let _0x42de04 = 0x0;
  switch (_0x4bd0e0.toUpperCase().trim()) {
    case '!':
    case 'EXCLAMATION':
      _0x42de04 = 0x1;
      break;
    case '?':
    case "QUESTION":
      _0x42de04 = 0x2;
      break;
    case "MUSIC":
    case "NOTE":
    case "MUSIC NOTE":
    case 'MUSIC-NOTE':
    case 'MUSICNOTE':
      _0x42de04 = 0x3;
      break;
    case "HEART":
    case 'LOVE':
      _0x42de04 = 0x4;
      break;
    case "ANGLE":
    case "ANGER":
      _0x42de04 = 0x5;
      break;
    case "SWEAT":
      _0x42de04 = 0x6;
      break;
    case "COBWEB":
    case 'ANNOYED':
    case "FRUSTRATION":
      _0x42de04 = 0x7;
      break;
    case "SILENCE":
    case "...":
      _0x42de04 = 0x8;
      break;
    case "LIGHT":
    case "BULB":
    case "LIGHT BULB":
    case "LIGHT-BULB":
    case "LIGHTBULB":
      _0x42de04 = 0x9;
      break;
    case 'Z':
    case 'ZZ':
    case "ZZZ":
    case 'SLEEP':
      _0x42de04 = 0xa;
      break;
    case "USER-DEFINED 1":
      _0x42de04 = 0xb;
      break;
    case "USER-DEFINED 2":
      _0x42de04 = 0xc;
      break;
    case "USER-DEFINED 3":
      _0x42de04 = 0xd;
      break;
    case "USER-DEFINED 4":
      _0x42de04 = 0xe;
      break;
    case "USER-DEFINED 5":
      _0x42de04 = 0xf;
      break;
  }
  for (const _0x4e3a6d of _0x3d835d) {
    if (!_0x4e3a6d) {
      continue;
    }
    $gameTemp.requestBattleBalloon(_0x4e3a6d, _0x42de04);
  }
  if (_0x2bfac6.WaitComplete && _0x6a2755) {
    _0x6a2755.wait(0x1);
    _0x6a2755.setWaitMode("battleBalloon");
  }
});
PluginManager.registerCommand(pluginData.name, "ActSeq_Animation_BalloonIcon", _0x503be0 => {
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  if (!Imported.VisuMZ_4_IconBalloons) {
    return;
  }
  VisuMZ.ConvertParams(_0x503be0, _0x503be0);
  const _0x3b438e = $gameTemp.getLastPluginCommandInterpreter();
  const _0x1e117b = VisuMZ.CreateActionSequenceTargets(_0x503be0.Targets);
  const _0x9e9f = _0x503be0.IconIndex;
  for (const _0x4e19de of _0x1e117b) {
    if (!_0x4e19de) {
      continue;
    }
    $gameTemp.requestBattleBalloon(_0x4e19de, [_0x9e9f]);
  }
  if (_0x503be0.WaitComplete && _0x3b438e) {
    _0x3b438e.wait(0x1);
    _0x3b438e.setWaitMode("battleBalloon");
  }
});
PluginManager.registerCommand(pluginData.name, "ActSeq_Animation_BalloonIconRange", _0x4feeb8 => {
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  if (!Imported.VisuMZ_4_IconBalloons) {
    return;
  }
  VisuMZ.ConvertParams(_0x4feeb8, _0x4feeb8);
  const _0x44e142 = $gameTemp.getLastPluginCommandInterpreter();
  const _0x55038c = VisuMZ.CreateActionSequenceTargets(_0x4feeb8.Targets);
  const _0xe1310d = Math.min(Number(_0x4feeb8.startIcon || 0x0), Number(_0x4feeb8.endIcon || 0x0));
  const _0x1b917f = Math.max(Number(_0x4feeb8.startIcon || 0x0), Number(_0x4feeb8.endIcon || 0x0));
  const _0x6160a7 = [];
  for (let _0x24dfc5 = _0xe1310d; _0x24dfc5 <= _0x1b917f; _0x24dfc5++) {
    _0x6160a7.push(_0x24dfc5);
  }
  for (const _0x2d5375 of _0x55038c) {
    if (!_0x2d5375) {
      continue;
    }
    $gameTemp.requestBattleBalloon(_0x2d5375, _0x6160a7);
  }
  if (_0x4feeb8.WaitComplete && _0x44e142) {
    _0x44e142.wait(0x1);
    _0x44e142.setWaitMode("battleBalloon");
  }
});
PluginManager.registerCommand(pluginData.name, "ActSeq_Animation_BalloonIconSpecific", _0x50736e => {
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  if (!Imported.VisuMZ_4_IconBalloons) {
    return;
  }
  VisuMZ.ConvertParams(_0x50736e, _0x50736e);
  const _0xa25264 = $gameTemp.getLastPluginCommandInterpreter();
  const _0x41805d = VisuMZ.CreateActionSequenceTargets(_0x50736e.Targets);
  const _0x2c6dd6 = _0x50736e.icons;
  for (const _0xcc5de0 of _0x41805d) {
    if (!_0xcc5de0) {
      continue;
    }
    $gameTemp.requestBattleBalloon(_0xcc5de0, _0x2c6dd6);
  }
  if (_0x50736e.WaitComplete && _0xa25264) {
    _0xa25264.wait(0x1);
    _0xa25264.setWaitMode("battleBalloon");
  }
});
PluginManager.registerCommand(pluginData.name, "ActSeq_Animation_CastAnimation", _0x2f3ff5 => {
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  VisuMZ.ConvertParams(_0x2f3ff5, _0x2f3ff5);
  const _0x4436aa = $gameTemp.getLastPluginCommandInterpreter();
  const _0x4c32ba = BattleManager._action;
  const _0x2eb8d = _0x2f3ff5.Mirror;
  const _0x5dcfaa = VisuMZ.CreateActionSequenceTargets(_0x2f3ff5.Targets);
  if (!_0x4436aa || !_0x4c32ba) {
    return;
  }
  if (!_0x4c32ba.item()) {
    return;
  }
  for (const _0x1925e7 of _0x5dcfaa) {
    if (!_0x1925e7) {
      continue;
    }
    _0x1925e7.performCastAnimation(_0x4c32ba, _0x2eb8d);
  }
  if (_0x2f3ff5.WaitForAnimation) {
    _0x4436aa.setWaitMode("battleAnimation");
  }
});
PluginManager.registerCommand(pluginData.name, "ActSeq_Animation_ChangeBattlePortrait", _0x451f02 => {
  VisuMZ.ConvertParams(_0x451f02, _0x451f02);
  const _0x58af88 = VisuMZ.CreateActionSequenceTargets(_0x451f02.Targets);
  const _0xef399b = _0x451f02.Filename;
  if (!_0xef399b) {
    return;
  }
  for (const _0x429152 of _0x58af88) {
    if (!_0x429152) {
      continue;
    }
    if (!_0x429152.isActor()) {
      continue;
    }
    _0x429152.setBattlePortrait(_0xef399b);
  }
});
PluginManager.registerCommand(pluginData.name, 'ActSeq_Animation_GuardAnimation', _0x242a53 => {
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  VisuMZ.ConvertParams(_0x242a53, _0x242a53);
  const _0x421b70 = $gameTemp.getLastPluginCommandInterpreter();
  const _0x528420 = BattleManager._subject;
  const _0x1e30ac = VisuMZ.CreateActionSequenceTargets(_0x242a53.Targets);
  const _0x1eefc3 = _0x242a53.Mirror;
  if (!_0x421b70 || !_0x528420) {
    return;
  }
  const _0x30c117 = $dataSkilles[_0x528420.guardSkillId()];
  const _0x33ea8f = _0x30c117.animationId;
  $gameTemp.requestAnimation(_0x1e30ac, _0x33ea8f, _0x1eefc3);
  if (_0x242a53.WaitForAnimation) {
    _0x421b70.setWaitMode("battleAnimation");
  }
});
PluginManager.registerCommand(pluginData.name, "ActSeq_Animation_ItemAnimation", _0x3ec7cb => {
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  VisuMZ.ConvertParams(_0x3ec7cb, _0x3ec7cb);
  const _0x1c1e4b = $gameTemp.getLastPluginCommandInterpreter();
  const _0x3f4468 = VisuMZ.CreateActionSequenceTargets(_0x3ec7cb.Targets);
  const _0x16e29f = Number(_0x3ec7cb.ItemID || 0x1);
  const _0x24b8e0 = $dataItems[_0x16e29f];
  const _0x7f0019 = _0x3ec7cb.Mirror;
  if (!_0x1c1e4b) {
    return;
  }
  if (!_0x24b8e0) {
    return;
  }
  let _0x374b1e = _0x24b8e0.animationId;
  $gameTemp.requestAnimation(_0x3f4468, _0x374b1e, _0x7f0019);
  if (_0x3ec7cb.WaitForAnimation) {
    _0x1c1e4b.setWaitMode("battleAnimation");
  }
});
PluginManager.registerCommand(pluginData.name, "ActSeq_Animation_PlayAtCoordinate", _0x59c115 => {
  if (!SceneManager._scene) {
    return;
  }
  if (!SceneManager._scene._spriteset) {
    return;
  }
  if (!Imported.VisuMZ_0_CoreEngine) {
    return;
  }
  VisuMZ.ConvertParams(_0x59c115, _0x59c115);
  const _0x5f198c = $gameTemp.getLastPluginCommandInterpreter();
  const _0x509877 = Math.round(_0x59c115.pointX);
  const _0x32a083 = Math.round(_0x59c115.pointY);
  $gameTemp.requestPointAnimation(_0x509877, _0x32a083, _0x59c115.AnimationID, _0x59c115.Mirror, _0x59c115.Mute);
  if (_0x59c115.WaitComplete && _0x5f198c) {
    SceneManager._scene._spriteset.updatePointAnimations();
    _0x5f198c.setWaitMode("battleAnimation");
  }
});
PluginManager.registerCommand(pluginData.name, "ActSeq_Animation_ShowAnimation", _0x2ce6e1 => {
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  VisuMZ.ConvertParams(_0x2ce6e1, _0x2ce6e1);
  const _0x5390c5 = $gameTemp.getLastPluginCommandInterpreter();
  const _0x3bd0f7 = VisuMZ.CreateActionSequenceTargets(_0x2ce6e1.Targets);
  const _0x239f3d = _0x2ce6e1.AnimationID;
  const _0x6124d3 = _0x2ce6e1.Mirror;
  if (!_0x5390c5) {
    return;
  }
  $gameTemp.requestAnimation(_0x3bd0f7, _0x239f3d, _0x6124d3);
  if (_0x2ce6e1.WaitForAnimation) {
    _0x5390c5.setWaitMode("battleAnimation");
  }
});
PluginManager.registerCommand(pluginData.name, 'ActSeq_Animation_ShowAnimationJS', _0x6c4c5d => {
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  VisuMZ.ConvertParams(_0x6c4c5d, _0x6c4c5d);
  const _0xbc7d72 = $gameTemp.getLastPluginCommandInterpreter();
  const _0x2ed8a5 = VisuMZ.CreateActionSequenceTargets(_0x6c4c5d.Targets);
  const _0x5a25f2 = Number(_0x6c4c5d.AnimationID) || 0x1;
  const _0x2d867d = _0x6c4c5d.Mirror;
  if (!_0xbc7d72) {
    return;
  }
  $gameTemp.requestAnimation(_0x2ed8a5, _0x5a25f2, _0x2d867d);
  if (_0x6c4c5d.WaitForAnimation) {
    _0xbc7d72.setWaitMode("battleAnimation");
  }
});
PluginManager.registerCommand(pluginData.name, 'ActSeq_Animation_SkillAnimation', _0x533a51 => {
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  VisuMZ.ConvertParams(_0x533a51, _0x533a51);
  const _0x4aea50 = $gameTemp.getLastPluginCommandInterpreter();
  const _0x514356 = VisuMZ.CreateActionSequenceTargets(_0x533a51.Targets);
  const _0x4c9d65 = Number(_0x533a51.SkillID || 0x1);
  const _0x35cd85 = $dataSkills[_0x4c9d65];
  const _0x5246bd = _0x533a51.Mirror;
  if (!_0x4aea50) {
    return;
  }
  if (!_0x35cd85) {
    return;
  }
  let _0x4afa85 = _0x35cd85.animationId;
  $gameTemp.requestAnimation(_0x514356, _0x4afa85, _0x5246bd);
  if (_0x533a51.WaitForAnimation) {
    _0x4aea50.setWaitMode("battleAnimation");
  }
});
PluginManager.registerCommand(pluginData.name, 'ActSeq_Animation_WaitForAnimation', _0x5c1cfa => {
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  const _0x4b3338 = $gameTemp.getLastPluginCommandInterpreter();
  if (!_0x4b3338) {
    return;
  }
  _0x4b3338.setWaitMode("battleAnimation");
});
PluginManager.registerCommand(pluginData.name, "ActSeq_BattleLog_AddText", _0xcfaebf => {
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  VisuMZ.ConvertParams(_0xcfaebf, _0xcfaebf);
  const _0x1ddff1 = BattleManager._logWindow;
  const _0x1cde45 = _0xcfaebf.CopyCombatLog && Imported.VisuMZ_4_CombatLog;
  _0x1ddff1.addText(_0xcfaebf.Text);
  if (_0x1cde45 && Imported.VisuMZ_4_CombatLog) {
    $gameSystem.addTextToCombatLog(_0xcfaebf.Text || '', _0xcfaebf.CombatLogIcon || 0x0);
  }
});
PluginManager.registerCommand(pluginData.name, 'ActSeq_BattleLog_Clear', _0xa34be9 => {
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  const _0x12fc12 = BattleManager._logWindow;
  _0x12fc12.clear();
});
PluginManager.registerCommand(pluginData.name, 'ActSeq_BattleLog_DisplayAction', _0x3002e6 => {
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  const _0x109228 = $gameTemp.getLastPluginCommandInterpreter();
  const _0x3be32d = BattleManager._action;
  const _0x14569b = BattleManager._subject;
  const _0x49e1da = BattleManager._logWindow;
  if (!_0x109228 || !_0x3be32d || !_0x14569b) {
    return;
  }
  if (!_0x3be32d.item()) {
    return;
  }
  _0x49e1da.displayAction(_0x14569b, _0x3be32d.item());
  _0x109228.setWaitMode("battlelog");
});
PluginManager.registerCommand(pluginData.name, "ActSeq_BattleLog_PopBaseLine", _0x36973a => {
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  const _0x3cae53 = BattleManager._logWindow;
  _0x3cae53.popBaseLine();
});
PluginManager.registerCommand(pluginData.name, 'ActSeq_BattleLog_PushBaseLine', _0x1563d5 => {
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  const _0x23b646 = BattleManager._logWindow;
  _0x23b646.pushBaseLine();
});
PluginManager.registerCommand(pluginData.name, "ActSeq_BattleLog_Refresh", _0x253df4 => {
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  const _0x4e7536 = BattleManager._logWindow;
  _0x4e7536.refresh();
});
PluginManager.registerCommand(pluginData.name, "ActSeq_BattleLog_UI", _0x3c872e => {
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  VisuMZ.ConvertParams(_0x3c872e, _0x3c872e);
  SceneManager._scene.setVisibleUI(_0x3c872e.ShowHide);
});
PluginManager.registerCommand(pluginData.name, "ActSeq_BattleLog_WaitForBattleLog", _0x10293b => {
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  const _0x32249b = $gameTemp.getLastPluginCommandInterpreter();
  _0x32249b.setWaitMode("battlelog");
});
PluginManager.registerCommand(pluginData.name, 'ActSeq_BattleLog_WaitForNewLine', _0x5f02b1 => {
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  const _0x51d4a9 = $gameTemp.getLastPluginCommandInterpreter();
  const _0x16bbd7 = BattleManager._logWindow;
  _0x16bbd7.waitForNewLine();
  _0x51d4a9.setWaitMode("battlelog");
});
PluginManager.registerCommand(pluginData.name, "ActSeq_Camera_Clamp", _0x4a2cd5 => {
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  if (!Imported.VisuMZ_3_ActSeqCamera) {
    return;
  }
  VisuMZ.ConvertParams(_0x4a2cd5, _0x4a2cd5);
  const _0x25d949 = $gameScreen.battleCameraData();
  _0x25d949.cameraClamp = _0x4a2cd5.Setting;
});
PluginManager.registerCommand(pluginData.name, "ActSeq_Camera_FocusPoint", _0x1c6d85 => {
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  if (!Imported.VisuMZ_3_ActSeqCamera) {
    return;
  }
  VisuMZ.ConvertParams(_0x1c6d85, _0x1c6d85);
  const _0x26a01b = $gameTemp.getLastPluginCommandInterpreter();
  const _0x5e5ebc = _0x1c6d85.WaitForCamera;
  $gameScreen.setBattleCameraPoint(_0x1c6d85.FocusX, _0x1c6d85.FocusY, _0x1c6d85.Duration, _0x1c6d85.EasingType);
  if (_0x5e5ebc) {
    _0x26a01b.setWaitMode("battleCamera");
  }
});
PluginManager.registerCommand(pluginData.name, "ActSeq_Camera_FocusTarget", _0x2935f0 => {
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  if (!Imported.VisuMZ_3_ActSeqCamera) {
    return;
  }
  VisuMZ.ConvertParams(_0x2935f0, _0x2935f0);
  const _0x596b4a = $gameTemp.getLastPluginCommandInterpreter();
  const _0x42decc = VisuMZ.CreateActionSequenceTargets(_0x2935f0.Targets);
  const _0x7d3901 = _0x2935f0.WaitForCamera;
  $gameScreen.setBattleCameraTargets(_0x42decc, _0x2935f0.Duration, _0x2935f0.EasingType);
  if (_0x7d3901) {
    _0x596b4a.setWaitMode('battleCamera');
  }
});
PluginManager.registerCommand(pluginData.name, 'ActSeq_Camera_Offset', _0x22107f => {
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  if (!Imported.VisuMZ_3_ActSeqCamera) {
    return;
  }
  VisuMZ.ConvertParams(_0x22107f, _0x22107f);
  const _0x5337bc = $gameTemp.getLastPluginCommandInterpreter();
  const _0x2d88f3 = _0x22107f.WaitForCamera;
  $gameScreen.setBattleCameraOffset(_0x22107f.OffsetX, _0x22107f.OffsetY, _0x22107f.Duration, _0x22107f.EasingType);
  if (_0x2d88f3) {
    _0x5337bc.setWaitMode("battleCamera");
  }
});
PluginManager.registerCommand(pluginData.name, "ActSeq_Camera_Reset", _0x2ba73f => {
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  if (!Imported.VisuMZ_3_ActSeqCamera) {
    return;
  }
  VisuMZ.ConvertParams(_0x2ba73f, _0x2ba73f);
  const _0x58ae1f = $gameTemp.getLastPluginCommandInterpreter();
  const _0x2d8b55 = _0x2ba73f.ResetFocus;
  const _0x4e6439 = _0x2ba73f.ResetOffset;
  const _0x1cdbbd = _0x2ba73f.WaitForCamera;
  if (_0x2d8b55) {
    const _0x571d72 = Math.round(Graphics.width / 0x2);
    const _0x4fce5d = Math.round(Graphics.height / 0x2);
    $gameScreen.setBattleCameraPoint(_0x571d72, _0x4fce5d, _0x2ba73f.Duration, _0x2ba73f.EasingType);
  }
  if (_0x4e6439) {
    $gameScreen.setBattleCameraOffset(0x0, 0x0, _0x2ba73f.Duration, _0x2ba73f.EasingType);
  }
  if (_0x1cdbbd) {
    _0x58ae1f.setWaitMode("battleCamera");
  }
});
PluginManager.registerCommand(pluginData.name, "ActSeq_Camera_WaitForCamera", _0x147835 => {
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  if (!Imported.VisuMZ_3_ActSeqCamera) {
    return;
  }
  const _0x5edf2d = $gameTemp.getLastPluginCommandInterpreter();
  if (!_0x5edf2d) {
    return;
  }
  _0x5edf2d.setWaitMode("battleCamera");
});
VisuMZ.BattleCore.CreateCutinSettings = function (_0x4d12f1) {
  _0x4d12f1.portraitFilename = '';
  const _0x4fb9b8 = VisuMZ.VisualCutinEffect.CreateCutinSettings(_0x4d12f1);
  const _0x4686b9 = VisuMZ.CreateActionSequenceTargets(_0x4d12f1.Targets)[0x0] || null;
  if (_0x4686b9) {
    _0x4fb9b8.portraitFilename = _0x4686b9.visualCutinPortraitFilename();
    _0x4fb9b8.portraitIndex = _0x4686b9.visualCutinPortraitIndex();
    _0x4fb9b8.portraitHue = _0x4686b9.visualCutinPortraitHue();
    _0x4fb9b8.portraitType = _0x4686b9.visualCutinPortraitType();
    if (_0x4686b9.isEnemy()) {
      if (_0x4686b9.flipVisualCutinHorz()) {
        _0x4fb9b8.portraitFlipHorz = !_0x4fb9b8.portraitFlipHorz;
      }
      if (_0x4686b9.flipVisualCutinVert()) {
        _0x4fb9b8.portraitFlipVert = !_0x4fb9b8.portraitFlipVert;
      }
      if (_0x4fb9b8.portraitType === "svActor") {
        _0x4fb9b8.portraitFlipHorz = !_0x4fb9b8.portraitFlipHorz;
      }
      if (_0x4d12f1.ExtraSettings.parallaxScrollXinvertEnemy) {
        _0x4fb9b8.parallaxScrollX *= -0x1;
      }
      if (_0x4d12f1.ExtraSettings.parallaxScrollYinvertEnemy) {
        _0x4fb9b8.parallaxScrollY *= -0x1;
      }
      _0x4fb9b8.parallaxHue += _0x4d12f1.ExtraSettings.parallaxHueEnemyModifier ?? 0x0;
    }
  }
  return _0x4fb9b8;
};
PluginManager.registerCommand(pluginData.name, 'ActSeq_Cutin_AddVisualCutinEffect', _0x395240 => {
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  if (!Imported.VisuMZ_3_VisualCutinEffect) {
    return;
  }
  VisuMZ.ConvertParams(_0x395240, _0x395240);
  const _0x106fad = VisuMZ.BattleCore.CreateCutinSettings(_0x395240);
  SceneManager._scene.startVisualCutin(_0x106fad);
  const _0x51c1d8 = $gameTemp.getLastPluginCommandInterpreter();
  if (_0x51c1d8 && _0x395240.WaitForEntrance) {
    _0x51c1d8.setWaitMode("cutinEnter");
  }
});
PluginManager.registerCommand(pluginData.name, "ActSeq_Cutin_EndVisualCutinEffectAll", _0x21ad25 => {
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  if (!Imported.VisuMZ_3_VisualCutinEffect) {
    return;
  }
  VisuMZ.ConvertParams(_0x21ad25, _0x21ad25);
  SceneManager._scene.clearAllVisualCutins();
  const _0x2abe2f = $gameTemp.getLastPluginCommandInterpreter();
  if (_0x2abe2f && _0x21ad25.WaitForExit) {
    _0x2abe2f.setWaitMode("cutinExit");
  }
});
PluginManager.registerCommand(pluginData.name, 'ActSeq_Cutin_EndVisualCutinEffectType', _0x3e5765 => {
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  if (!Imported.VisuMZ_3_VisualCutinEffect) {
    return;
  }
  VisuMZ.ConvertParams(_0x3e5765, _0x3e5765);
  const _0x293e8b = _0x3e5765.type.toLowerCase().trim();
  SceneManager._scene.endVisualCutin(_0x293e8b);
  const _0x101b31 = $gameTemp.getLastPluginCommandInterpreter();
  if (_0x101b31 && _0x3e5765.WaitForExit) {
    _0x101b31.setWaitMode("cutinExit");
  }
});
PluginManager.registerCommand(pluginData.name, "ActSeq_Cutin_WaitForEntrance", _0x3b76c0 => {
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  if (!Imported.VisuMZ_3_VisualCutinEffect) {
    return;
  }
  const _0x89448d = $gameTemp.getLastPluginCommandInterpreter();
  _0x89448d.setWaitMode("cutinEnter");
});
PluginManager.registerCommand(pluginData.name, 'ActSeq_Cutin_WaitForExit', _0x7f452e => {
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  if (!Imported.VisuMZ_3_VisualCutinEffect) {
    return;
  }
  const _0x1369b0 = $gameTemp.getLastPluginCommandInterpreter();
  _0x1369b0.setWaitMode("cutinExit");
});
PluginManager.registerCommand(pluginData.name, "ActSeq_DB_DragonbonesMotionAni", _0x129387 => {
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  if (!Imported.VisuMZ_2_DragonbonesUnion) {
    return;
  }
  VisuMZ.ConvertParams(_0x129387, _0x129387);
  const _0x72354e = VisuMZ.CreateActionSequenceTargets(_0x129387.Targets);
  const _0x402ffc = _0x129387.MotionAni.toLowerCase().trim();
  for (const _0x3a9248 of _0x72354e) {
    if (!_0x3a9248) {
      continue;
    }
    _0x3a9248.requestDragonbonesAnimation(_0x402ffc);
  }
});
PluginManager.registerCommand(pluginData.name, "ActSeq_DB_DragonbonesTimeScale", _0x4bf369 => {
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  if (!Imported.VisuMZ_2_DragonbonesUnion) {
    return;
  }
  VisuMZ.ConvertParams(_0x4bf369, _0x4bf369);
  const _0x1299d9 = VisuMZ.CreateActionSequenceTargets(_0x4bf369.Targets);
  const _0x131661 = _0x4bf369.TimeScale;
  for (const _0x44f086 of _0x1299d9) {
    if (!_0x44f086) {
      continue;
    }
    _0x44f086.dragonbonesData().timeScale = _0x131661;
  }
});
PluginManager.registerCommand(pluginData.name, "ActSeq_Element_AddElements", _0x49421d => {
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  if (!Imported.VisuMZ_1_ElementStatusCore) {
    return;
  }
  VisuMZ.ConvertParams(_0x49421d, _0x49421d);
  const _0x2a6e4a = BattleManager._action;
  const _0x3cfbbf = _0x49421d.Elements;
  if (!_0x2a6e4a) {
    return;
  }
  _0x2a6e4a._battleCoreAddedElements = _0x3cfbbf;
});
PluginManager.registerCommand(pluginData.name, "ActSeq_Element_Clear", _0x3f0571 => {
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  if (!Imported.VisuMZ_1_ElementStatusCore) {
    return;
  }
  const _0x1e35b7 = BattleManager._action;
  if (!_0x1e35b7) {
    return;
  }
  _0x1e35b7.clearElementChanges();
});
PluginManager.registerCommand(pluginData.name, 'ActSeq_Element_ForceElements', _0x4c508e => {
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  if (!Imported.VisuMZ_1_ElementStatusCore) {
    return;
  }
  VisuMZ.ConvertParams(_0x4c508e, _0x4c508e);
  const _0x1017f6 = BattleManager._action;
  const _0x5376ec = _0x4c508e.Elements;
  if (!_0x1017f6) {
    return;
  }
  _0x1017f6._battleCoreForcedElements = _0x5376ec;
});
PluginManager.registerCommand(pluginData.name, 'ActSeq_Element_NullElements', _0x596429 => {
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  if (!Imported.VisuMZ_1_ElementStatusCore) {
    return;
  }
  const _0x27ae04 = BattleManager._action;
  if (!_0x27ae04) {
    return;
  }
  _0x27ae04._battleCoreNoElement = true;
});
PluginManager.registerCommand(pluginData.name, "ActSeq_Grid_ActionAnimationAtNode", _0x530cc5 => {
  VisuMZ.BattleGridSystem.ActSeq_Grid_ActionAnimationAtNode(_0x530cc5);
});
PluginManager.registerCommand(pluginData.name, "ActSeq_Grid_AddPassiveStatesToNode", _0x31b295 => {
  VisuMZ.BattleGridSystem.ActSeq_Grid_AddPassiveStatesToNode(_0x31b295);
});
PluginManager.registerCommand(pluginData.name, "ActSeq_Grid_AddTriggerToNode", _0x49660e => {
  VisuMZ.BattleGridSystem.ActSeq_Grid_AddTriggerToNode(_0x49660e);
});
PluginManager.registerCommand(pluginData.name, "ActSeq_Grid_AddTriggerToNodeJS", _0x355c4e => {
  VisuMZ.BattleGridSystem.ActSeq_Grid_AddTriggerToNode(_0x355c4e);
});
PluginManager.registerCommand(pluginData.name, "ActSeq_Grid_AnimationIDAtNode", _0x4026a6 => {
  VisuMZ.BattleGridSystem.ActSeq_Grid_AnimationIDAtNode(_0x4026a6);
});
PluginManager.registerCommand(pluginData.name, "ActSeq_Grid_AnimationJsAtNode", _0x1f28f1 => {
  VisuMZ.BattleGridSystem.ActSeq_Grid_AnimationJsAtNode(_0x1f28f1);
});
PluginManager.registerCommand(pluginData.name, "ActSeq_Grid_AnimationTypeAtNode", _0x1dd616 => {
  VisuMZ.BattleGridSystem.ActSeq_Grid_AnimationTypeAtNode(_0x1dd616);
});
PluginManager.registerCommand(pluginData.name, 'ActSeq_Grid_ClearPassiveStatesFromNode', _0x32504b => {
  VisuMZ.BattleGridSystem.ActSeq_Grid_ClearPassiveStatesFromNode(_0x32504b);
});
PluginManager.registerCommand(pluginData.name, 'ActSeq_Grid_MoveTargetsInDirection', _0x1702ca => {
  VisuMZ.BattleGridSystem.ActSeq_Grid_MoveTargetsInDirection(_0x1702ca);
});
PluginManager.registerCommand(pluginData.name, 'ActSeq_Grid_PullToTargetNode', _0x1b7ad5 => {
  VisuMZ.BattleGridSystem.ActSeq_Grid_PullToTargetNode(_0x1b7ad5);
});
PluginManager.registerCommand(pluginData.name, 'ActSeq_Grid_PushFromTargetNode', _0x3dc5b1 => {
  VisuMZ.BattleGridSystem.ActSeq_Grid_PushFromTargetNode(_0x3dc5b1);
});
PluginManager.registerCommand(pluginData.name, 'ActSeq_Grid_RemovePassiveStatesFromNode', _0x4b8d6a => {
  VisuMZ.BattleGridSystem.ActSeq_Grid_RemovePassiveStatesFromNode(_0x4b8d6a);
});
PluginManager.registerCommand(pluginData.name, "ActSeq_Grid_RemoveTriggerFromNode", _0xc53723 => {
  VisuMZ.BattleGridSystem.ActSeq_Grid_RemoveTriggerFromNode(_0xc53723);
});
PluginManager.registerCommand(pluginData.name, "ActSeq_Grid_TeleportToNode", _0x15d720 => {
  VisuMZ.BattleGridSystem.ActSeq_Grid_TeleportToNode(_0x15d720);
});
PluginManager.registerCommand(pluginData.name, 'ActSeq_Grid_TraverseToNode', _0x37a155 => {
  VisuMZ.BattleGridSystem.ActSeq_Grid_TraverseToNode(_0x37a155);
});
PluginManager.registerCommand(pluginData.name, "ActSeq_Horror_Clear", _0x5eaf8f => {
  if (!Imported.VisuMZ_2_HorrorEffects) {
    return;
  }
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  VisuMZ.ConvertParams(_0x5eaf8f, _0x5eaf8f);
  const _0x5c603e = VisuMZ.CreateActionSequenceTargets(_0x5eaf8f.Targets);
  for (const _0x459755 of _0x5c603e) {
    if (!_0x459755) {
      continue;
    }
    _0x459755.removeHorrorEffect("noise");
    _0x459755.removeHorrorEffect("glitch");
    _0x459755.removeHorrorEffect('tv');
    _0x459755.clearHorrorEffects();
  }
  $gamePlayer.refresh();
});
PluginManager.registerCommand(pluginData.name, "ActSeq_Horror_GlitchCreate", _0x1d71f0 => {
  if (!Imported.VisuMZ_2_HorrorEffects) {
    return;
  }
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  VisuMZ.ConvertParams(_0x1d71f0, _0x1d71f0);
  const _0x1a88c5 = VisuMZ.CreateActionSequenceTargets(_0x1d71f0.Targets);
  _0x1d71f0.sliceMin = Math.ceil(_0x1d71f0.slices / 0x2);
  _0x1d71f0.sliceMax = _0x1d71f0.slices;
  _0x1d71f0.refreshRequest = true;
  for (const _0x1de92a of _0x1a88c5) {
    if (!_0x1de92a) {
      continue;
    }
    _0x1de92a.setHorrorEffectSettings("glitch", _0x1d71f0);
  }
  $gamePlayer.refresh();
});
PluginManager.registerCommand(pluginData.name, "ActSeq_Horror_GlitchRemove", _0xc367b0 => {
  if (!Imported.VisuMZ_2_HorrorEffects) {
    return;
  }
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  VisuMZ.ConvertParams(_0xc367b0, _0xc367b0);
  const _0x57a4a3 = VisuMZ.CreateActionSequenceTargets(_0xc367b0.Targets);
  for (const _0x4e354a of _0x57a4a3) {
    if (!_0x4e354a) {
      continue;
    }
    _0x4e354a.removeHorrorEffect("glitch");
  }
  $gamePlayer.refresh();
});
PluginManager.registerCommand(pluginData.name, "ActSeq_Horror_NoiseCreate", _0x43a953 => {
  if (!Imported.VisuMZ_2_HorrorEffects) {
    return;
  }
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  VisuMZ.ConvertParams(_0x43a953, _0x43a953);
  const _0x12a4a3 = VisuMZ.CreateActionSequenceTargets(_0x43a953.Targets);
  for (const _0x313eca of _0x12a4a3) {
    if (!_0x313eca) {
      continue;
    }
    _0x313eca.setHorrorEffectSettings('noise', _0x43a953);
  }
  $gamePlayer.refresh();
});
PluginManager.registerCommand(pluginData.name, "ActSeq_Horror_NoiseRemove", _0xa1788c => {
  if (!Imported.VisuMZ_2_HorrorEffects) {
    return;
  }
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  VisuMZ.ConvertParams(_0xa1788c, _0xa1788c);
  const _0x231514 = VisuMZ.CreateActionSequenceTargets(_0xa1788c.Targets);
  for (const _0x1bbcb1 of _0x231514) {
    if (!_0x1bbcb1) {
      continue;
    }
    _0x1bbcb1.removeHorrorEffect("noise");
  }
  $gamePlayer.refresh();
});
PluginManager.registerCommand(pluginData.name, "ActSeq_Horror_TVCreate", _0x4fe2f4 => {
  if (!Imported.VisuMZ_2_HorrorEffects) {
    return;
  }
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  VisuMZ.ConvertParams(_0x4fe2f4, _0x4fe2f4);
  const _0x2d4fd4 = VisuMZ.CreateActionSequenceTargets(_0x4fe2f4.Targets);
  for (const _0x4c6783 of _0x2d4fd4) {
    if (!_0x4c6783) {
      continue;
    }
    _0x4c6783.setHorrorEffectSettings('tv', _0x4fe2f4);
  }
  $gamePlayer.refresh();
});
PluginManager.registerCommand(pluginData.name, "ActSeq_Horror_TVRemove", _0x2f05d2 => {
  if (!Imported.VisuMZ_2_HorrorEffects) {
    return;
  }
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  VisuMZ.ConvertParams(_0x2f05d2, _0x2f05d2);
  const _0x19f536 = VisuMZ.CreateActionSequenceTargets(_0x2f05d2.Targets);
  for (const _0x5bc3c5 of _0x19f536) {
    if (!_0x5bc3c5) {
      continue;
    }
    _0x5bc3c5.removeHorrorEffect('tv');
  }
  $gamePlayer.refresh();
});
PluginManager.registerCommand(pluginData.name, "ActSeq_Impact_BlueRedInvert", _0x5ef361 => {
  if (!Imported.VisuMZ_3_ActSeqImpact) {
    return;
  }
  const _0x1d47da = SceneManager._scene._spriteset;
  if (!_0x1d47da) {
    return;
  }
  if (VisuMZ.ActSeqImpact.version <= 1.04) {
    alert("Action Sequence Impact needs an update!");
    SceneManager.exit();
    return;
  }
  VisuMZ.ConvertParams(_0x5ef361, _0x5ef361);
  const _0xb8737c = _0x5ef361.Enable;
  _0x1d47da.setupBlueRedInvertImpactFilter(_0xb8737c);
});
PluginManager.registerCommand(pluginData.name, "ActSeq_Impact_ColorBreak", _0x33d11b => {
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  if (!Imported.VisuMZ_3_ActSeqImpact) {
    return;
  }
  const _0x24f947 = SceneManager._scene._spriteset;
  if (!_0x24f947) {
    return;
  }
  VisuMZ.ConvertParams(_0x33d11b, _0x33d11b);
  const _0x109e49 = _0x33d11b.Intensity || 0x1;
  const _0x1f8042 = _0x33d11b.Duration || 0x1;
  const _0x22c67f = _0x33d11b.EasingType || 'Linear';
  _0x24f947.setupRgbSplitImpactFilter(_0x109e49, _0x1f8042, _0x22c67f);
});
PluginManager.registerCommand(pluginData.name, "ActSeq_Impact_Desaturate", _0x3871d3 => {
  if (!Imported.VisuMZ_3_ActSeqImpact) {
    return;
  }
  const _0x5100dc = SceneManager._scene._spriteset;
  if (!_0x5100dc) {
    return;
  }
  if (VisuMZ.ActSeqImpact.version <= 1.04) {
    alert("Action Sequence Impact needs an update!");
    SceneManager.exit();
    return;
  }
  VisuMZ.ConvertParams(_0x3871d3, _0x3871d3);
  const _0x5183ad = _0x3871d3.Enable;
  _0x5100dc.setupDesaturateImpactFilter(_0x5183ad);
});
PluginManager.registerCommand(pluginData.name, "ActSeq_Impact_MotionBlurScreen", _0x31f396 => {
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  if (!Imported.VisuMZ_3_ActSeqImpact) {
    return;
  }
  const _0x2ea8d9 = SceneManager._scene._spriteset;
  if (!_0x2ea8d9) {
    return;
  }
  VisuMZ.ConvertParams(_0x31f396, _0x31f396);
  const _0x1b931d = Number(_0x31f396.Angle) || 0x0;
  const _0xaf9cd2 = Number(_0x31f396.Rate);
  const _0x2aec8e = _0x31f396.Duration || 0x1;
  const _0x519955 = _0x31f396.EasingType || "Linear";
  _0x2ea8d9.setupMotionBlurImpactFilter(_0x1b931d, _0xaf9cd2, _0x2aec8e, _0x519955);
});
PluginManager.registerCommand(pluginData.name, "ActSeq_Impact_MotionBlurTarget", _0x522eab => {
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  if (!Imported.VisuMZ_3_ActSeqImpact) {
    return;
  }
  const _0x18ee91 = SceneManager._scene._spriteset;
  if (!_0x18ee91) {
    return;
  }
  VisuMZ.ConvertParams(_0x522eab, _0x522eab);
  const _0x58f36b = Number(_0x522eab.Angle) || 0x0;
  const _0x51ac48 = Number(_0x522eab.Rate);
  const _0x277ba9 = _0x522eab.Duration || 0x1;
  const _0x4f4a10 = _0x522eab.EasingType || "Linear";
  const _0x2f29cc = VisuMZ.CreateActionSequenceTargets(_0x522eab.Targets);
  for (const _0x228bbc of _0x2f29cc) {
    if (!_0x228bbc) {
      continue;
    }
    if (!_0x228bbc.battler()) {
      continue;
    }
    _0x228bbc.battler().setupMotionBlurImpactFilter(_0x58f36b, _0x51ac48, _0x277ba9, _0x4f4a10);
  }
});
PluginManager.registerCommand(pluginData.name, 'ActSeq_Impact_MotionTrailCreate', _0x36ad61 => {
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  if (!Imported.VisuMZ_3_ActSeqImpact) {
    return;
  }
  VisuMZ.ConvertParams(_0x36ad61, _0x36ad61);
  const _0x4921cd = {
    'delay': _0x36ad61.delay,
    'duration': _0x36ad61.duration,
    'hue': _0x36ad61.hue,
    'opacityStart': _0x36ad61.opacityStart,
    'tone': _0x36ad61.tone,
    'visible': true
  };
  const _0x2c2ff0 = VisuMZ.CreateActionSequenceTargets(_0x36ad61.Targets);
  for (const _0x23603a of _0x2c2ff0) {
    if (!_0x23603a) {
      continue;
    }
    _0x23603a.setBattlerMotionTrailData(_0x4921cd);
  }
});
PluginManager.registerCommand(pluginData.name, "ActSeq_Impact_MotionTrailRemove", _0x330518 => {
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  if (!Imported.VisuMZ_3_ActSeqImpact) {
    return;
  }
  VisuMZ.ConvertParams(_0x330518, _0x330518);
  const _0x48fbd5 = VisuMZ.CreateActionSequenceTargets(_0x330518.Targets);
  for (const _0x5ccd1b of _0x48fbd5) {
    if (!_0x5ccd1b) {
      continue;
    }
    _0x5ccd1b.clearBattlerMotionTrailData();
  }
});
PluginManager.registerCommand(pluginData.name, 'ActSeq_Impact_Negative', _0x42faf7 => {
  if (!Imported.VisuMZ_3_ActSeqImpact) {
    return;
  }
  const _0x29d2e6 = SceneManager._scene._spriteset;
  if (!_0x29d2e6) {
    return;
  }
  if (VisuMZ.ActSeqImpact.version <= 1.04) {
    alert("Action Sequence Impact needs an update!");
    SceneManager.exit();
    return;
  }
  VisuMZ.ConvertParams(_0x42faf7, _0x42faf7);
  const _0x5043ea = _0x42faf7.Enable;
  _0x29d2e6.setupNegativeImpactFilter(_0x5043ea);
});
PluginManager.registerCommand(pluginData.name, "ActSeq_Impact_Oversaturate", _0x43f05a => {
  if (!Imported.VisuMZ_3_ActSeqImpact) {
    return;
  }
  const _0x148eaa = SceneManager._scene._spriteset;
  if (!_0x148eaa) {
    return;
  }
  if (VisuMZ.ActSeqImpact.version <= 1.04) {
    alert("Action Sequence Impact needs an update!");
    SceneManager.exit();
    return;
  }
  VisuMZ.ConvertParams(_0x43f05a, _0x43f05a);
  const _0x2c4297 = _0x43f05a.Enable;
  _0x148eaa.setupOversaturateImpactFilter(_0x2c4297);
});
PluginManager.registerCommand(pluginData.name, "ActSeq_Impact_ShockwavePoint", _0x33a38a => {
  if (!Imported.VisuMZ_3_ActSeqImpact) {
    return;
  }
  const _0x4cac39 = SceneManager._scene._spriteset;
  if (!_0x4cac39) {
    return;
  }
  VisuMZ.ConvertParams(_0x33a38a, _0x33a38a);
  const _0x118ece = _0x33a38a.X || 0x0;
  const _0x3e1529 = _0x33a38a.Y || 0x0;
  const _0xa2e573 = _0x33a38a.Amp || 0x0;
  const _0x54a4a6 = _0x33a38a.Wave || 0x0;
  const _0x4656a8 = _0x33a38a.Duration || 0x1;
  _0x4cac39.setupShockwaveImpactFilter(_0x118ece, _0x3e1529, _0xa2e573, _0x54a4a6, _0x4656a8);
});
PluginManager.registerCommand(pluginData.name, "ActSeq_Impact_ShockwaveEachTargets", _0x5f1116 => {
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  if (!Imported.VisuMZ_3_ActSeqImpact) {
    return;
  }
  const _0x2a7765 = SceneManager._scene._spriteset;
  if (!_0x2a7765) {
    return;
  }
  VisuMZ.ConvertParams(_0x5f1116, _0x5f1116);
  const _0x5b7bc3 = VisuMZ.CreateActionSequenceTargets(_0x5f1116.Targets);
  const _0x4bb4e5 = _0x5f1116.TargetLocation;
  const _0x12d761 = _0x5f1116.OffsetX || 0x0;
  const _0x297323 = _0x5f1116.OffsetY || 0x0;
  const _0x50c435 = _0x5f1116.Amp || 0x0;
  const _0xd50031 = _0x5f1116.Wave || 0x0;
  const _0x4833d1 = _0x5f1116.Duration || 0x1;
  for (const _0x3574cd of _0x5b7bc3) {
    if (!_0x3574cd) {
      continue;
    }
    if (!_0x3574cd.battler()) {
      continue;
    }
    const _0x34a416 = _0x3574cd.battler();
    let _0x3dfc77 = _0x34a416._baseX;
    let _0x3e44a6 = _0x34a416._baseY;
    _0x3dfc77 += (Graphics.width - Graphics.boxWidth) / 0x2;
    _0x3e44a6 += (Graphics.height - Graphics.boxHeight) / 0x2;
    if (_0x4bb4e5.match(/front/i)) {
      _0x3dfc77 += (_0x3574cd.isEnemy() ? 0x1 : -0x1) * _0x34a416.mainSpriteWidth() / 0x2;
    } else if (_0x4bb4e5.match(/back/i)) {
      _0x3dfc77 += (_0x3574cd.isEnemy() ? -0x1 : 0x1) * _0x34a416.mainSpriteWidth() / 0x2;
    }
    if (_0x4bb4e5.match(/head/i)) {
      _0x3e44a6 -= _0x34a416.mainSpriteHeight();
    } else if (_0x4bb4e5.match(/center/i)) {
      _0x3e44a6 -= _0x34a416.mainSpriteHeight() / 0x2;
    }
    _0x3dfc77 += _0x12d761;
    _0x3e44a6 += _0x297323;
    _0x2a7765.setupShockwaveImpactFilter(_0x3dfc77, _0x3e44a6, _0x50c435, _0xd50031, _0x4833d1);
  }
});
PluginManager.registerCommand(pluginData.name, 'ActSeq_Impact_ShockwaveCenterTargets', _0x5dcb6e => {
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  if (!Imported.VisuMZ_3_ActSeqImpact) {
    return;
  }
  const _0x5eac6c = SceneManager._scene._spriteset;
  if (!_0x5eac6c) {
    return;
  }
  VisuMZ.ConvertParams(_0x5dcb6e, _0x5dcb6e);
  const _0x39bc6c = VisuMZ.CreateActionSequenceTargets(_0x5dcb6e.Targets);
  const _0x659032 = _0x5dcb6e.TargetLocation;
  const _0x44e6df = _0x5dcb6e.OffsetX || 0x0;
  const _0x2d1c1e = _0x5dcb6e.OffsetY || 0x0;
  const _0x508ba7 = _0x5dcb6e.Amp || 0x0;
  const _0x411b4b = _0x5dcb6e.Wave || 0x0;
  const _0x381fb8 = _0x5dcb6e.Duration || 0x1;
  const _0x43e456 = Math.min(..._0x39bc6c.map(_0x48f2d2 => _0x48f2d2.battler()._baseX - _0x48f2d2.battler().mainSpriteWidth() / 0x2));
  const _0x4b961f = Math.max(..._0x39bc6c.map(_0xe239db => _0xe239db.battler()._baseX + _0xe239db.battler().mainSpriteWidth() / 0x2));
  const _0x37bcd3 = Math.min(..._0x39bc6c.map(_0x352730 => _0x352730.battler()._baseY - _0x352730.battler().mainSpriteHeight()));
  const _0x5aab85 = Math.max(..._0x39bc6c.map(_0x22ede8 => _0x22ede8.battler()._baseY));
  const _0x17be5f = _0x39bc6c.filter(_0x4faf8d => _0x4faf8d.isActor()).length;
  const _0x3ce503 = _0x39bc6c.filter(_0x3cba14 => _0x3cba14.isEnemy()).length;
  let _0xa3889 = 0x0;
  let _0x5c7d15 = 0x0;
  if (_0x659032.match(/front/i)) {
    _0xa3889 = _0x17be5f >= _0x3ce503 ? _0x43e456 : _0x4b961f;
  } else {
    if (_0x659032.match(/middle/i)) {
      _0xa3889 = (_0x43e456 + _0x4b961f) / 0x2;
      melee = -0x1;
    } else if (_0x659032.match(/back/i)) {
      _0xa3889 = _0x17be5f >= _0x3ce503 ? _0x4b961f : _0x43e456;
    }
  }
  if (_0x659032.match(/head/i)) {
    _0x5c7d15 = _0x37bcd3;
  } else {
    if (_0x659032.match(/center/i)) {
      _0x5c7d15 = (_0x37bcd3 + _0x5aab85) / 0x2;
    } else if (_0x659032.match(/base/i)) {
      _0x5c7d15 = _0x5aab85;
    }
  }
  _0xa3889 += (Graphics.width - Graphics.boxWidth) / 0x2;
  _0x5c7d15 += (Graphics.height - Graphics.boxHeight) / 0x2;
  _0xa3889 += _0x44e6df;
  _0x5c7d15 += _0x2d1c1e;
  _0x5eac6c.setupShockwaveImpactFilter(_0xa3889, _0x5c7d15, _0x508ba7, _0x411b4b, _0x381fb8);
});
PluginManager.registerCommand(pluginData.name, "ActSeq_Impact_TimeScale", _0x35a17e => {
  if (!Imported.VisuMZ_3_ActSeqImpact) {
    return;
  }
  const _0x3c5402 = SceneManager._scene._spriteset;
  if (!_0x3c5402) {
    return;
  }
  if (VisuMZ.ActSeqImpact.version <= 1.04) {
    alert("Action Sequence Impact needs an update!");
    SceneManager.exit();
    return;
  }
  VisuMZ.ConvertParams(_0x35a17e, _0x35a17e);
  const _0x51e4d2 = $gameTemp.getLastPluginCommandInterpreter();
  const _0xdad2d = Math.max(0.01, _0x35a17e.Scale);
  $gameTemp.setBattleImpactTimeScale(_0xdad2d, _0x51e4d2);
});
PluginManager.registerCommand(pluginData.name, "ActSeq_Impact_TimeStop", _0x52e895 => {
  if (!Imported.VisuMZ_3_ActSeqImpact) {
    return;
  }
  const _0x29831a = SceneManager._scene._spriteset;
  if (!_0x29831a) {
    return;
  }
  if (VisuMZ.ActSeqImpact.version <= 1.04) {
    alert("Action Sequence Impact needs an update!");
    SceneManager.exit();
    return;
  }
  VisuMZ.ConvertParams(_0x52e895, _0x52e895);
  const _0x498486 = $gameTemp.getLastPluginCommandInterpreter();
  const _0x648025 = _0x52e895.ms || 0x1;
  VisuMZ.ActSeqImpact.freezeTime(_0x648025, _0x498486);
});
PluginManager.registerCommand(pluginData.name, 'ActSeq_Impact_ZoomBlurPoint', _0x191894 => {
  if (!Imported.VisuMZ_3_ActSeqImpact) {
    return;
  }
  const _0x3e72b0 = SceneManager._scene._spriteset;
  if (!_0x3e72b0) {
    return;
  }
  VisuMZ.ConvertParams(_0x191894, _0x191894);
  const _0x59ffc5 = _0x191894.X || 0x0;
  const _0x114190 = _0x191894.Y || 0x0;
  const _0x1a88be = _0x191894.Strength || 0x0;
  const _0x1a9426 = _0x191894.Radius || 0x0;
  const _0xa98099 = _0x191894.Duration || 0x1;
  const _0x549dd2 = _0x191894.EasingType || "Linear";
  _0x3e72b0.setupZoomBlurImpactFilter(_0x1a88be, _0x59ffc5, _0x114190, _0x1a9426, _0xa98099, _0x549dd2);
});
PluginManager.registerCommand(pluginData.name, "ActSeq_Impact_ZoomBlurTargetCenter", _0x4107a1 => {
  if (!Imported.VisuMZ_3_ActSeqImpact) {
    return;
  }
  const _0x19995a = SceneManager._scene._spriteset;
  if (!_0x19995a) {
    return;
  }
  VisuMZ.ConvertParams(_0x4107a1, _0x4107a1);
  const _0x32310a = VisuMZ.CreateActionSequenceTargets(_0x4107a1.Targets);
  const _0x1a4f87 = _0x4107a1.TargetLocation;
  const _0x4adec7 = _0x4107a1.OffsetX || 0x0;
  const _0x5dbe58 = _0x4107a1.OffsetY || 0x0;
  const _0x30e32a = _0x4107a1.Strength || 0x0;
  const _0x692c1a = _0x4107a1.Radius || 0x0;
  const _0x36e6e2 = _0x4107a1.Duration || 0x1;
  const _0x4694ab = _0x4107a1.EasingType || "Linear";
  const _0x36852c = Math.min(..._0x32310a.map(_0x3f9412 => _0x3f9412.battler()._baseX - _0x3f9412.battler().mainSpriteWidth() / 0x2));
  const _0x56734e = Math.max(..._0x32310a.map(_0x235b26 => _0x235b26.battler()._baseX + _0x235b26.battler().mainSpriteWidth() / 0x2));
  const _0x113f47 = Math.min(..._0x32310a.map(_0x1f4a38 => _0x1f4a38.battler()._baseY - _0x1f4a38.battler().mainSpriteHeight()));
  const _0x3f870c = Math.max(..._0x32310a.map(_0x19f45a => _0x19f45a.battler()._baseY));
  const _0x37aea6 = _0x32310a.filter(_0x2d849d => _0x2d849d.isActor()).length;
  const _0x4f6e2d = _0x32310a.filter(_0x598f22 => _0x598f22.isEnemy()).length;
  let _0x92d9d2 = 0x0;
  let _0x1bd697 = 0x0;
  if (_0x1a4f87.match(/front/i)) {
    _0x92d9d2 = _0x37aea6 >= _0x4f6e2d ? _0x36852c : _0x56734e;
  } else {
    if (_0x1a4f87.match(/middle/i)) {
      _0x92d9d2 = (_0x36852c + _0x56734e) / 0x2;
      melee = -0x1;
    } else if (_0x1a4f87.match(/back/i)) {
      _0x92d9d2 = _0x37aea6 >= _0x4f6e2d ? _0x56734e : _0x36852c;
    }
  }
  if (_0x1a4f87.match(/head/i)) {
    _0x1bd697 = _0x113f47;
  } else {
    if (_0x1a4f87.match(/center/i)) {
      _0x1bd697 = (_0x113f47 + _0x3f870c) / 0x2;
    } else if (_0x1a4f87.match(/base/i)) {
      _0x1bd697 = _0x3f870c;
    }
  }
  _0x92d9d2 += (Graphics.width - Graphics.boxWidth) / 0x2;
  _0x1bd697 += (Graphics.height - Graphics.boxHeight) / 0x2;
  _0x92d9d2 += _0x4adec7;
  _0x1bd697 += _0x5dbe58;
  _0x19995a.setupZoomBlurImpactFilter(_0x30e32a, _0x92d9d2, _0x1bd697, _0x692c1a, _0x36e6e2, _0x4694ab);
});
PluginManager.registerCommand(pluginData.name, "ActSeq_Inject_AnimationStart", _0x3bfea8 => {
  if (!Imported.VisuMZ_3_ActSeqImpact) {
    return;
  }
  const _0xc049d7 = SceneManager._scene._spriteset;
  if (!_0xc049d7) {
    return;
  }
  if (VisuMZ.ActSeqImpact.version <= 1.05) {
    alert("Action Sequence Impact needs an update!");
    SceneManager.exit();
    return;
  }
  VisuMZ.ConvertParams(_0x3bfea8, _0x3bfea8);
  const _0x18f3c2 = VisuMZ.CreateActionSequenceTargets(_0x3bfea8.Targets);
  const _0x4f8f36 = {
    'filename': _0x3bfea8.Filename,
    'horzCells': _0x3bfea8.horzCells || 0x1,
    'vertCells': _0x3bfea8.vertCells || 0x1,
    'frameDelay': _0x3bfea8.frameDelay || 0x1,
    'smooth': _0x3bfea8.smooth || false,
    'anchorX': _0x3bfea8.anchorX || 0x0,
    'anchorY': _0x3bfea8.anchorY || 0x0,
    'offsetX': _0x3bfea8.offsetX || 0x0,
    'offsetY': _0x3bfea8.offsetY || 0x0
  };
  for (const _0x338022 of _0x18f3c2) {
    if (!_0x338022) {
      continue;
    }
    if (!_0x338022.battler()) {
      continue;
    }
    _0x338022.battler().startInjectAnimation(_0x4f8f36);
  }
  const _0x5002ed = $gameTemp.getLastPluginCommandInterpreter();
  if (_0x5002ed) {
    _0x5002ed.setWaitMode('battleInjectPrep');
  }
});
PluginManager.registerCommand(pluginData.name, 'ActSeq_Inject_AnimationEnd', _0x269cff => {
  if (!Imported.VisuMZ_3_ActSeqImpact) {
    return;
  }
  const _0x2515c6 = SceneManager._scene._spriteset;
  if (!_0x2515c6) {
    return;
  }
  if (VisuMZ.ActSeqImpact.version <= 1.05) {
    alert("Action Sequence Impact needs an update!");
    SceneManager.exit();
    return;
  }
  VisuMZ.ConvertParams(_0x269cff, _0x269cff);
  const _0x5e454c = VisuMZ.CreateActionSequenceTargets(_0x269cff.Targets);
  for (const _0x32fb3f of _0x5e454c) {
    if (!_0x32fb3f) {
      continue;
    }
    if (!_0x32fb3f.battler()) {
      continue;
    }
    _0x32fb3f.battler().stopInjectAnimation();
  }
});
PluginManager.registerCommand(pluginData.name, 'ActSeq_Inject_AnimationPauseResume', _0x4cf674 => {
  if (!Imported.VisuMZ_3_ActSeqImpact) {
    return;
  }
  const _0x4093c6 = SceneManager._scene._spriteset;
  if (!_0x4093c6) {
    return;
  }
  if (VisuMZ.ActSeqImpact.version <= 1.05) {
    alert("Action Sequence Impact needs an update!");
    SceneManager.exit();
    return;
  }
  VisuMZ.ConvertParams(_0x4cf674, _0x4cf674);
  const _0xa36051 = VisuMZ.CreateActionSequenceTargets(_0x4cf674.Targets);
  const _0xa001d1 = _0x4cf674.pause;
  for (const _0x250fad of _0xa36051) {
    if (!_0x250fad) {
      continue;
    }
    if (!_0x250fad.battler()) {
      continue;
    }
    _0x250fad.battler().pauseInjectAnimation(_0xa001d1);
  }
});
PluginManager.registerCommand(pluginData.name, "ActSeq_Inject_WaitForInjectAni", _0x472fce => {
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  const _0x22c814 = $gameTemp.getLastPluginCommandInterpreter();
  if (!_0x22c814) {
    return;
  }
  _0x22c814.setWaitMode('battleInjectAni');
});
PluginManager.registerCommand(pluginData.name, 'ActSeq_Mechanics_ActionEffect', _0x510f20 => {
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  VisuMZ.ConvertParams(_0x510f20, _0x510f20);
  const _0x54e410 = $gameTemp.getLastPluginCommandInterpreter();
  const _0x376bb1 = BattleManager._action;
  const _0x305aef = BattleManager._subject;
  const _0x3ff3c0 = BattleManager._logWindow;
  if (!_0x54e410 || !_0x376bb1 || !_0x305aef) {
    return;
  }
  if (!_0x376bb1.item()) {
    return;
  }
  const _0xf5ee84 = VisuMZ.CreateActionSequenceTargets(_0x510f20.Targets);
  for (const _0x2e6e9b of _0xf5ee84) {
    if (!_0x2e6e9b) {
      continue;
    }
    _0x3ff3c0.push("actionEffect", _0x305aef, _0x2e6e9b);
  }
  _0x54e410.setWaitMode("battlelog");
});
PluginManager.registerCommand(pluginData.name, "ActSeq_Mechanics_ActiveChainInputDisable", _0x5ec79d => {
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  if (!Imported.VisuMZ_3_ActiveChainSkills) {
    return;
  }
  $gameTemp._performActionEnd = true;
});
PluginManager.registerCommand(pluginData.name, 'ActSeq_Mechanics_AddBuffDebuff', _0x573b84 => {
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  VisuMZ.ConvertParams(_0x573b84, _0x573b84);
  const _0x3650db = ["MAXHP", 'MAXMP', "ATK", 'DEF', "MAT", "MDF", "AGI", "LUK"];
  const _0x1ad274 = _0x573b84.Buffs;
  const _0x1dbf07 = _0x573b84.Debuffs;
  const _0x4b045c = _0x573b84.Turns;
  const _0x14c26f = VisuMZ.CreateActionSequenceTargets(_0x573b84.Targets);
  for (const _0x2129b6 of _0x14c26f) {
    if (!_0x2129b6) {
      continue;
    }
    for (const _0x382396 of _0x1ad274) {
      const _0x10b462 = _0x3650db.indexOf(_0x382396.toUpperCase().trim());
      if (_0x10b462 >= 0x0 && _0x10b462 <= 0x7) {
        _0x2129b6.addBuff(_0x10b462, _0x4b045c);
      }
    }
    for (const _0x5b5fec of _0x1dbf07) {
      const _0x1e7cd1 = _0x3650db.indexOf(_0x5b5fec.toUpperCase().trim());
      if (_0x1e7cd1 >= 0x0 && _0x1e7cd1 <= 0x7) {
        _0x2129b6.addDebuff(_0x1e7cd1, _0x4b045c);
      }
    }
  }
});
PluginManager.registerCommand(pluginData.name, "ActSeq_Mechanics_AddState", _0x147f4c => {
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  VisuMZ.ConvertParams(_0x147f4c, _0x147f4c);
  const _0x3dc6c4 = _0x147f4c.States;
  const _0x4d0f3f = VisuMZ.CreateActionSequenceTargets(_0x147f4c.Targets);
  for (const _0x4a48b1 of _0x4d0f3f) {
    if (!_0x4a48b1) {
      continue;
    }
    for (const _0x2b2d38 of _0x3dc6c4) {
      _0x4a48b1.addState(_0x2b2d38);
    }
  }
});
PluginManager.registerCommand(pluginData.name, 'ActSeq_Mechanics_ArmorPenetration', _0x3312cb => {
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  VisuMZ.ConvertParams(_0x3312cb, _0x3312cb);
  const _0x1caaef = BattleManager._action;
  const _0x4a6814 = {
    'arPenRate': _0x3312cb.ArPenRate,
    'arPenFlat': _0x3312cb.ArPenFlat,
    'arRedRate': _0x3312cb.ArRedRate,
    'arRedFlat': _0x3312cb.ArRedFlat
  };
  _0x1caaef._armorPenetration = _0x4a6814;
});
PluginManager.registerCommand(pluginData.name, 'ActSeq_Mechanics_AnalyzeWeakness', _0x421ebc => {
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  if (!Imported.VisuMZ_3_WeaknessDisplay) {
    return;
  }
  VisuMZ.ConvertParams(_0x421ebc, _0x421ebc);
  const _0x46b975 = VisuMZ.CreateActionSequenceTargets(_0x421ebc.Targets);
  const _0x5e7bc2 = _0x421ebc.Reveal || 0x1;
  for (const _0x78938b of _0x46b975) {
    if (!_0x78938b) {
      continue;
    }
    if (!_0x78938b.isEnemy()) {
      continue;
    }
    _0x78938b.revealNewWeaknesses(_0x5e7bc2);
  }
});
PluginManager.registerCommand(pluginData.name, "ActSeq_Mechanics_AtbGauge", _0x144850 => {
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  if (!Imported.VisuMZ_2_BattleSystemATB) {
    return;
  }
  if (!BattleManager.isATB()) {
    return;
  }
  VisuMZ.ConvertParams(_0x144850, _0x144850);
  const _0x2bc6f9 = VisuMZ.CreateActionSequenceTargets(_0x144850.Targets);
  const _0x362ac4 = _0x144850.ChargeRate;
  const _0x48204f = _0x144850.ChargeRate;
  const _0x517cc5 = _0x144850.Interrupt;
  for (const _0x5ab613 of _0x2bc6f9) {
    if (!_0x5ab613) {
      continue;
    }
    if (_0x5ab613.isAtbChargingState()) {
      _0x5ab613.changeAtbChargeTime(_0x362ac4);
    } else {
      if (_0x5ab613.isAtbCastingState()) {
        _0x5ab613.changeAtbCastTime(_0x48204f);
        if (_0x517cc5) {
          _0x5ab613.atbInterrupt();
        }
      }
    }
  }
});
PluginManager.registerCommand(pluginData.name, "ActSeq_Mechanics_BoostPointsChange", _0x425914 => {
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  if (!Imported.VisuMZ_3_BoostAction) {
    return;
  }
  VisuMZ.ConvertParams(_0x425914, _0x425914);
  const _0x9dd738 = VisuMZ.CreateActionSequenceTargets(_0x425914.Targets);
  const _0x12f371 = _0x425914.BoostPoints;
  for (const _0x1da67e of _0x9dd738) {
    if (!_0x1da67e) {
      continue;
    }
    _0x1da67e.gainStoredBoostPoints(_0x12f371);
  }
});
PluginManager.registerCommand(pluginData.name, "ActSeq_Mechanics_BoostPointsStoreData", _0x454f82 => {
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  if (!Imported.VisuMZ_3_BoostAction) {
    return;
  }
  if (!BattleManager._subject) {
    return;
  }
  VisuMZ.ConvertParams(_0x454f82, _0x454f82);
  const _0x133cba = _0x454f82.VariableID;
  $gameVariables.setValue(_0x133cba, BattleManager._subject.toUseBoostPoints());
});
PluginManager.registerCommand(pluginData.name, "ActSeq_Mechanics_BreakShieldChange", _0x4ddcfc => {
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  if (!Imported.VisuMZ_4_BreakShields) {
    return;
  }
  VisuMZ.ConvertParams(_0x4ddcfc, _0x4ddcfc);
  const _0x5072d4 = VisuMZ.CreateActionSequenceTargets(_0x4ddcfc.Targets);
  const _0x36cd7b = _0x4ddcfc.BreakShields;
  for (const _0x1e9b29 of _0x5072d4) {
    if (!_0x1e9b29) {
      continue;
    }
    if (_0x1e9b29.isBreakStunned()) {
      continue;
    }
    if (!_0x1e9b29.isAffectedByBreakShield()) {
      continue;
    }
    _0x1e9b29.alterBreakShield(_0x36cd7b);
  }
});
PluginManager.registerCommand(pluginData.name, "ActSeq_Mechanics_BreakShieldReset", _0x327add => {
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  if (!Imported.VisuMZ_4_BreakShields) {
    return;
  }
  VisuMZ.ConvertParams(_0x327add, _0x327add);
  const _0x52a76c = VisuMZ.CreateActionSequenceTargets(_0x327add.Targets);
  for (const _0x24e9ee of _0x52a76c) {
    if (!_0x24e9ee) {
      continue;
    }
    if (_0x24e9ee.isBreakStunned()) {
      continue;
    }
    if (!_0x24e9ee.isAffectedByBreakShield()) {
      continue;
    }
    _0x24e9ee.resetBreakShield();
  }
});
PluginManager.registerCommand(pluginData.name, "ActSeq_Mechanics_BtbGain", _0x40b4c4 => {
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  if (!Imported.VisuMZ_2_BattleSystemBTB) {
    return;
  }
  if (!BattleManager.isBTB()) {
    return;
  }
  VisuMZ.ConvertParams(_0x40b4c4, _0x40b4c4);
  const _0x1b9224 = VisuMZ.CreateActionSequenceTargets(_0x40b4c4.Targets);
  const _0x27d593 = _0x40b4c4.BravePoints;
  for (const _0x391a61 of _0x1b9224) {
    if (!_0x391a61) {
      continue;
    }
    _0x391a61.gainBravePoints(_0x27d593);
  }
});
PluginManager.registerCommand(pluginData.name, "ActSeq_Mechanics_Collapse", _0xbee0d8 => {
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  VisuMZ.ConvertParams(_0xbee0d8, _0xbee0d8);
  const _0x4f156b = $gameTemp.getLastPluginCommandInterpreter();
  const _0x153a43 = BattleManager._action;
  const _0x5a458c = BattleManager._subject;
  if (!_0x4f156b || !_0x153a43 || !_0x5a458c) {
    return;
  }
  if (!_0x153a43.item()) {
    return;
  }
  const _0x4eeb0c = VisuMZ.CreateActionSequenceTargets(_0xbee0d8.Targets);
  for (const _0x370e67 of _0x4eeb0c) {
    if (!_0x370e67) {
      continue;
    }
    if (_0xbee0d8.ForceDeath) {
      _0x370e67.removeImmortal();
      _0x370e67.addState(_0x370e67.deathStateId());
    }
    if (_0x370e67.isDeathStateAffected()) {
      _0x370e67.performCollapse();
    }
  }
  _0x4f156b.setWaitMode("battleEffect");
});
PluginManager.registerCommand(pluginData.name, "ActSeq_Mechanics_CtbOrder", _0x330982 => {
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  if (!Imported.VisuMZ_2_BattleSystemCTB) {
    return;
  }
  if (!BattleManager.isCTB()) {
    return;
  }
  VisuMZ.ConvertParams(_0x330982, _0x330982);
  const _0x142297 = VisuMZ.CreateActionSequenceTargets(_0x330982.Targets);
  const _0x6bc632 = _0x330982.ChangeOrderBy;
  for (const _0x4af9df of _0x142297) {
    if (!_0x4af9df) {
      continue;
    }
    _0x4af9df.changeTurnOrderByCTB(_0x6bc632);
  }
});
PluginManager.registerCommand(pluginData.name, "ActSeq_Mechanics_CtbSpeed", _0x4d88e1 => {
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  if (!Imported.VisuMZ_2_BattleSystemCTB) {
    return;
  }
  if (!BattleManager.isCTB()) {
    return;
  }
  VisuMZ.ConvertParams(_0x4d88e1, _0x4d88e1);
  const _0x3c987d = VisuMZ.CreateActionSequenceTargets(_0x4d88e1.Targets);
  const _0x9f4a20 = _0x4d88e1.ChargeRate;
  const _0xd3c4e9 = _0x4d88e1.ChargeRate;
  for (const _0x4ec8db of _0x3c987d) {
    if (!_0x4ec8db) {
      continue;
    }
    if (_0x4ec8db._tpbState === "charging") {
      _0x4ec8db.changeCtbChargeTime(_0x9f4a20);
    } else if (_0x4ec8db._tpbState === 'casting') {
      _0x4ec8db.changeCtbCastTime(_0xd3c4e9);
    }
  }
});
PluginManager.registerCommand(pluginData.name, 'ActSeq_Mechanics_CustomDmgFormula', _0x594ad8 => {
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  VisuMZ.ConvertParams(_0x594ad8, _0x594ad8);
  const _0x471e2b = BattleManager._action;
  if (!_0x471e2b) {
    return;
  }
  let _0x4b11e0 = _0x594ad8.Formula;
  _0x471e2b.setCustomDamageFormula(_0x4b11e0);
});
PluginManager.registerCommand(pluginData.name, "ActSeq_Mechanics_DamagePopup", _0x34967d => {
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  VisuMZ.ConvertParams(_0x34967d, _0x34967d);
  const _0x46b44d = VisuMZ.CreateActionSequenceTargets(_0x34967d.Targets);
  for (const _0x4fdaa8 of _0x46b44d) {
    if (!_0x4fdaa8) {
      continue;
    }
    if (_0x4fdaa8.shouldPopupDamage()) {
      _0x4fdaa8.startDamagePopup();
    }
  }
});
PluginManager.registerCommand(pluginData.name, 'ActSeq_Mechanics_DeathBreak', _0xd5d816 => {
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  VisuMZ.ConvertParams(_0xd5d816, _0xd5d816);
  const _0x3394a0 = $gameTemp.getLastPluginCommandInterpreter();
  const _0x259963 = BattleManager._subject;
  const _0x5d3ae9 = _0xd5d816.JumpToLabel;
  if (!_0x3394a0) {
    return;
  }
  if (!_0x259963) {
    return;
  }
  if (_0x259963 && _0x259963.isDead() && _0x5d3ae9.toUpperCase().trim() !== "UNTITLED") {
    _0x3394a0.command119([_0x5d3ae9]);
  }
});
PluginManager.registerCommand(pluginData.name, "ActSeq_Mechanics_EmulateAttackEffect", _0x5aa29e => {
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  VisuMZ.ConvertParams(_0x5aa29e, _0x5aa29e);
  const _0x9edc6b = $gameTemp.getLastPluginCommandInterpreter();
  const _0x3e9cba = BattleManager._logWindow;
  if (!_0x9edc6b) {
    return;
  }
  const _0x41fcb8 = VisuMZ.CreateActionSequenceTargets(_0x5aa29e.Users);
  const _0x4ae847 = VisuMZ.CreateActionSequenceTargets(_0x5aa29e.Targets);
  for (const _0x4750c1 of _0x41fcb8) {
    for (const _0x5befac of _0x4ae847) {
      if (!_0x5befac) {
        continue;
      }
      const _0x1c35dd = $dataSkills[_0x4750c1.attackSkillId()];
      _0x3e9cba.push("emulateActionEffect", _0x4750c1, _0x5befac, _0x1c35dd);
    }
  }
  _0x9edc6b.setWaitMode("battlelog");
});
PluginManager.registerCommand(pluginData.name, "ActSeq_Mechanics_EmulateGuardEffect", _0x45f8a7 => {
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  VisuMZ.ConvertParams(_0x45f8a7, _0x45f8a7);
  const _0x724bda = $gameTemp.getLastPluginCommandInterpreter();
  const _0x4d8975 = BattleManager._logWindow;
  if (!_0x724bda) {
    return;
  }
  const _0x3aac27 = VisuMZ.CreateActionSequenceTargets(_0x45f8a7.Users);
  const _0x5786c9 = VisuMZ.CreateActionSequenceTargets(_0x45f8a7.Targets);
  for (const _0x573f03 of _0x3aac27) {
    for (const _0x431df9 of _0x5786c9) {
      if (!_0x431df9) {
        continue;
      }
      const _0x15a360 = $dataSkills[_0x573f03.guardSkillId()];
      _0x4d8975.push("emulateActionEffect", _0x573f03, _0x431df9, _0x15a360);
    }
  }
  _0x724bda.setWaitMode("battlelog");
});
PluginManager.registerCommand(pluginData.name, "ActSeq_Mechanics_EmulateItemEffect", _0x52805a => {
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  VisuMZ.ConvertParams(_0x52805a, _0x52805a);
  const _0x5344ec = $gameTemp.getLastPluginCommandInterpreter();
  const _0x2f650a = BattleManager._logWindow;
  const _0x2decf9 = Number(_0x52805a.ItemID || 0x1);
  const _0x4434c2 = $dataItems[_0x2decf9];
  if (!_0x5344ec) {
    return;
  }
  if (!_0x4434c2) {
    return;
  }
  const _0x1e9407 = VisuMZ.CreateActionSequenceTargets(_0x52805a.Users);
  const _0xc72101 = VisuMZ.CreateActionSequenceTargets(_0x52805a.Targets);
  for (const _0x1ffbef of _0x1e9407) {
    for (const _0x5a7887 of _0xc72101) {
      if (!_0x5a7887) {
        continue;
      }
      _0x2f650a.push("emulateActionEffect", _0x1ffbef, _0x5a7887, _0x4434c2);
    }
  }
  _0x5344ec.setWaitMode("battlelog");
});
PluginManager.registerCommand(pluginData.name, "ActSeq_Mechanics_EmulateSkillCost", _0x316e01 => {
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  VisuMZ.ConvertParams(_0x316e01, _0x316e01);
  let _0x2281a4 = Number(_0x316e01.SkillID || 0x0);
  if (_0x2281a4 <= 0x0) {
    const _0x5f2dc9 = BattleManager._action;
    if (_0x5f2dc9 && _0x5f2dc9.isSkill()) {
      _0x2281a4 = _0x5f2dc9.item().id;
    } else {
      return;
    }
  }
  const _0x48db5a = $dataSkills[_0x2281a4];
  if (!_0x48db5a) {
    return;
  }
  const _0x272171 = VisuMZ.CreateActionSequenceTargets(_0x316e01.Users);
  for (const _0x31b4cb of _0x272171) {
    _0x31b4cb.paySkillCost(_0x48db5a);
  }
});
PluginManager.registerCommand(pluginData.name, "ActSeq_Mechanics_EmulateSkillEffect", _0x36c9db => {
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  VisuMZ.ConvertParams(_0x36c9db, _0x36c9db);
  const _0x37e7c2 = $gameTemp.getLastPluginCommandInterpreter();
  const _0x464ce0 = BattleManager._logWindow;
  const _0x5a28a0 = Number(_0x36c9db.SkillID || 0x1);
  const _0x217516 = $dataSkills[_0x5a28a0];
  if (!_0x37e7c2) {
    return;
  }
  if (!_0x217516) {
    return;
  }
  const _0x2cc212 = VisuMZ.CreateActionSequenceTargets(_0x36c9db.Users);
  const _0x308c23 = VisuMZ.CreateActionSequenceTargets(_0x36c9db.Targets);
  for (const _0x579bc2 of _0x2cc212) {
    for (const _0x2a0033 of _0x308c23) {
      if (!_0x2a0033) {
        continue;
      }
      _0x464ce0.push("emulateActionEffect", _0x579bc2, _0x2a0033, _0x217516);
    }
  }
  _0x37e7c2.setWaitMode("battlelog");
});
PluginManager.registerCommand(pluginData.name, 'ActSeq_Mechanics_EnemyEscape', _0x135281 => {
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  VisuMZ.ConvertParams(_0x135281, _0x135281);
  const _0x350819 = VisuMZ.CreateActionSequenceTargets(_0x135281.Targets);
  for (const _0x522716 of _0x350819) {
    if (!_0x522716) {
      continue;
    }
    if (!_0x522716.isEnemy()) {
      continue;
    }
    _0x522716.escape();
  }
});
PluginManager.registerCommand(pluginData.name, 'ActSeq_Mechanics_EtbAction', _0xff1fe4 => {
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  if (!Imported.VisuMZ_2_BattleSystemETB) {
    return;
  }
  if (!BattleManager.isETB()) {
    return;
  }
  VisuMZ.ConvertParams(_0xff1fe4, _0xff1fe4);
  const _0x21ef63 = _0xff1fe4.ActionCount;
  if (BattleManager._subject) {
    BattleManager._subject.friendsUnit().gainCurrentActionsETB(_0x21ef63);
  }
});
PluginManager.registerCommand(pluginData.name, "ActSeq_Mechanics_FtbAction", _0x326f91 => {
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  if (!Imported.VisuMZ_2_BattleSystemFTB) {
    return;
  }
  if (!BattleManager.isFTB()) {
    return;
  }
  VisuMZ.ConvertParams(_0x326f91, _0x326f91);
  const _0x5138f3 = _0x326f91.ActionCount;
  if (BattleManager._subject) {
    BattleManager._subject.friendsUnit().gainCurrentActionsFTB(_0x5138f3);
  }
});
PluginManager.registerCommand(pluginData.name, "ActSeq_Mechanics_HpMpTp", _0xfaa6f7 => {
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  VisuMZ.ConvertParams(_0xfaa6f7, _0xfaa6f7);
  const _0x1cbec5 = VisuMZ.CreateActionSequenceTargets(_0xfaa6f7.Targets);
  const _0x5c8464 = _0xfaa6f7.HP_Rate;
  const _0x31c156 = _0xfaa6f7.HP_Flat;
  const _0xd86320 = _0xfaa6f7.MP_Rate;
  const _0x2e6258 = _0xfaa6f7.MP_Flat;
  const _0x1a8bfc = _0xfaa6f7.TP_Rate;
  const _0x3d5e04 = _0xfaa6f7.TP_Flat;
  const _0x7cc362 = _0xfaa6f7.ShowPopup;
  for (const _0x6128e6 of _0x1cbec5) {
    if (!_0x6128e6) {
      continue;
    }
    const _0x1a2206 = _0x6128e6.isAlive();
    const _0x306240 = Math.round(_0x5c8464 * _0x6128e6.mhp + _0x31c156);
    const _0x3e5b1a = Math.round(_0xd86320 * _0x6128e6.mmp + _0x2e6258);
    const _0x30fd8b = Math.round(_0x1a8bfc * _0x6128e6.maxTp() + _0x3d5e04);
    if (_0x306240 !== 0x0) {
      _0x6128e6.gainHp(_0x306240);
    }
    if (_0x3e5b1a !== 0x0) {
      _0x6128e6.gainMp(_0x3e5b1a);
    }
    if (_0x30fd8b !== 0x0) {
      _0x6128e6.gainTp(_0x30fd8b);
    }
    if (_0x7cc362) {
      _0x6128e6.startDamagePopup();
    }
    if (_0x1a2206 && _0x6128e6.isDead()) {
      _0x6128e6.performCollapse();
    }
  }
});
PluginManager.registerCommand(pluginData.name, "ActSeq_Mechanics_Immortal", _0x494493 => {
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  VisuMZ.ConvertParams(_0x494493, _0x494493);
  const _0x1b51ae = VisuMZ.CreateActionSequenceTargets(_0x494493.Targets);
  for (const _0x215d96 of _0x1b51ae) {
    if (!_0x215d96) {
      continue;
    }
    _0x215d96.setImmortal(_0x494493.Immortal);
  }
});
PluginManager.registerCommand(pluginData.name, 'ActSeq_Mechanics_Multipliers', _0x5e51ce => {
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  VisuMZ.ConvertParams(_0x5e51ce, _0x5e51ce);
  const _0x41960c = BattleManager._action;
  const _0x4c3f8c = {
    'criticalHitRate': _0x5e51ce.CriticalHitRate,
    'criticalHitFlat': _0x5e51ce.CriticalHitFlat,
    'criticalDmgRate': _0x5e51ce.CriticalDmgRate,
    'criticalDmgFlat': _0x5e51ce.CriticalDmgFlat,
    'damageRate': _0x5e51ce.DamageRate,
    'damageFlat': _0x5e51ce.DamageFlat,
    'hitRate': _0x5e51ce.HitRate,
    'hitFlat': _0x5e51ce.HitFlat
  };
  _0x41960c._multipliers = _0x4c3f8c;
});
PluginManager.registerCommand(pluginData.name, "ActSeq_Mechanics_OnceParallel", _0x2e66e9 => {
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  VisuMZ.ConvertParams(_0x2e66e9, _0x2e66e9);
  const _0x2403a0 = _0x2e66e9.CommonEventID;
  SceneManager._scene.playOnceParallelInterpreter(_0x2403a0);
});
PluginManager.registerCommand(pluginData.name, 'ActSeq_Mechanics_OtbOrder', _0x2ca665 => {
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  if (!Imported.VisuMZ_2_BattleSystemOTB) {
    return;
  }
  if (!BattleManager.isOTB()) {
    return;
  }
  VisuMZ.ConvertParams(_0x2ca665, _0x2ca665);
  const _0x5b61ae = VisuMZ.CreateActionSequenceTargets(_0x2ca665.Targets);
  for (const _0x582033 of _0x5b61ae) {
    if (!_0x582033) {
      continue;
    }
    let _0x1bae37 = _0x2ca665.CurrentTurn;
    let _0x33cded = _0x2ca665.NextTurn;
    let _0x3d3d96 = _0x2ca665.FollowTurn;
    if (BattleManager._actionBattlers.includes(_0x582033)) {
      _0x1bae37 += _0x3d3d96;
    } else {
      _0x33cded += _0x3d3d96;
    }
    BattleManager.turnOrderChangeOTB(_0x582033, -_0x1bae37, false);
    BattleManager.turnOrderChangeOTB(_0x582033, -_0x33cded, true);
  }
});
PluginManager.registerCommand(pluginData.name, "ActSeq_Mechanics_PtbAlterCost", _0x37387a => {
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  if (!Imported.VisuMZ_2_BattleSystemPTB) {
    return;
  }
  if (!BattleManager.isPTB()) {
    return;
  }
  VisuMZ.ConvertParams(_0x37387a, _0x37387a);
  const _0x4cb5ef = BattleManager._subject.friendsUnit();
  const _0x552788 = _0x37387a.Override;
  const _0x3f74b1 = _0x37387a.alterChange || 'unchanged';
  const _0x50c294 = _0x37387a.alterType || "unchanged";
  const _0x3c7a9e = _0x37387a.alterCost || 0x0;
  const _0x4a1bd6 = _0x37387a.alterPriority || 0x0;
  if (_0x4cb5ef.canAlterActionCostPTB() || _0x552788) {
    if (_0x552788) {
      _0x4cb5ef._ptbActionCost = _0x4cb5ef._ptbActionCost || {};
      _0x4cb5ef._ptbActionCost.priority = 0x0;
    }
    _0x4cb5ef.alterActionCostPTB(_0x3f74b1, _0x50c294, _0x3c7a9e, _0x4a1bd6);
  }
});
PluginManager.registerCommand(pluginData.name, "ActSeq_Mechanics_PtbConvert", _0x4d9712 => {
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  if (!Imported.VisuMZ_2_BattleSystemPTB) {
    return;
  }
  if (!BattleManager.isPTB()) {
    return;
  }
  VisuMZ.ConvertParams(_0x4d9712, _0x4d9712);
  const _0x34747e = BattleManager._subject.friendsUnit();
  let _0x101789 = Math.max(_0x4d9712.ConvertCount, 0x0);
  let _0x59a050 = _0x34747e.getFullActionsPTB();
  let _0xdc9b6 = _0x34747e.getHalfActionsPTB();
  while (_0x101789--) {
    if (_0x59a050 <= 0x0 && _0xdc9b6 <= 0x0) {
      break;
    } else if (_0x59a050 > 0x0) {
      _0x59a050--;
      _0xdc9b6++;
    } else {
      _0xdc9b6--;
    }
  }
  _0x34747e.setFullActionsPTB(_0x59a050);
  _0x34747e.setHalfActionsPTB(_0xdc9b6);
});
PluginManager.registerCommand(pluginData.name, "ActSeq_Mechanics_PtbFullHalfAction", _0x5a1960 => {
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  if (!Imported.VisuMZ_2_BattleSystemPTB) {
    return;
  }
  if (!BattleManager.isPTB()) {
    return;
  }
  VisuMZ.ConvertParams(_0x5a1960, _0x5a1960);
  const _0x405381 = BattleManager._subject.friendsUnit();
  let _0x34a990 = _0x5a1960.FullActions;
  let _0x2bb042 = _0x5a1960.HalfActions;
  _0x405381.gainFullActionsPTB(_0x34a990);
  _0x405381.gainHalfActionsPTB(_0x2bb042);
});
PluginManager.registerCommand(pluginData.name, 'ActSeq_Mechanics_RemoveBuffDebuff', _0x266a58 => {
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  VisuMZ.ConvertParams(_0x266a58, _0x266a58);
  const _0x8cb106 = ['MAXHP', "MAXMP", "ATK", 'DEF', "MAT", "MDF", 'AGI', 'LUK'];
  const _0x40e22e = _0x266a58.Buffs;
  const _0x55200 = _0x266a58.Debuffs;
  const _0xef4a86 = VisuMZ.CreateActionSequenceTargets(_0x266a58.Targets);
  for (const _0x17f916 of _0xef4a86) {
    if (!_0x17f916) {
      continue;
    }
    for (const _0x4291b8 of _0x40e22e) {
      const _0x511056 = _0x8cb106.indexOf(_0x4291b8.toUpperCase().trim());
      if (_0x511056 >= 0x0 && _0x511056 <= 0x7 && _0x17f916.isBuffAffected(_0x511056)) {
        _0x17f916.removeBuff(_0x511056);
      }
    }
    for (const _0x3bee1d of _0x55200) {
      const _0xf8280c = _0x8cb106.indexOf(_0x3bee1d.toUpperCase().trim());
      if (_0xf8280c >= 0x0 && _0xf8280c <= 0x7 && _0x17f916.isDebuffAffected(_0xf8280c)) {
        _0x17f916.removeBuff(_0xf8280c);
      }
    }
  }
});
PluginManager.registerCommand(pluginData.name, "ActSeq_Mechanics_RemoveState", _0x3172f1 => {
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  VisuMZ.ConvertParams(_0x3172f1, _0x3172f1);
  const _0x42bb2a = _0x3172f1.States;
  const _0x4a2541 = VisuMZ.CreateActionSequenceTargets(_0x3172f1.Targets);
  for (const _0xd35cf8 of _0x4a2541) {
    if (!_0xd35cf8) {
      continue;
    }
    for (const _0x61e3ec of _0x42bb2a) {
      _0xd35cf8.removeState(_0x61e3ec);
    }
  }
});
PluginManager.registerCommand(pluginData.name, "ActSeq_Mechanics_StateTurnsChangeBy", _0x43d73f => {
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  if (!Imported.VisuMZ_1_SkillsStatesCore) {
    return;
  }
  VisuMZ.ConvertParams(_0x43d73f, _0x43d73f);
  const _0xc1cdad = VisuMZ.CreateActionSequenceTargets(_0x43d73f.Targets);
  const _0x397226 = Number(_0x43d73f.StateID);
  const _0x4cb7ba = Number(_0x43d73f.Turns);
  const _0x745207 = _0x43d73f.AutoAddState;
  for (const _0x377797 of _0xc1cdad) {
    if (!_0x377797) {
      continue;
    }
    if (_0x745207 && !_0x377797.isStateAffected(_0x397226)) {
      _0x377797.addState(_0x397226);
      _0x377797.setStateTurns(_0x397226, _0x4cb7ba);
    } else {
      _0x377797.addStateTurns(_0x397226, _0x4cb7ba);
    }
  }
});
PluginManager.registerCommand(pluginData.name, 'ActSeq_Mechanics_StateTurnsChangeTo', _0x4f70e3 => {
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  if (!Imported.VisuMZ_1_SkillsStatesCore) {
    return;
  }
  VisuMZ.ConvertParams(_0x4f70e3, _0x4f70e3);
  const _0x5c85fe = VisuMZ.CreateActionSequenceTargets(_0x4f70e3.Targets);
  const _0x52033b = Number(_0x4f70e3.StateID);
  const _0x4203db = Math.max(Number(_0x4f70e3.Turns), 0x0);
  const _0x3555a9 = _0x4f70e3.AutoAddState;
  for (const _0x1d2bce of _0x5c85fe) {
    if (!_0x1d2bce) {
      continue;
    }
    if (_0x3555a9 && !_0x1d2bce.isStateAffected(_0x52033b)) {
      _0x1d2bce.addState(_0x52033b);
    }
    _0x1d2bce.setStateTurns(_0x52033b, _0x4203db);
  }
});
PluginManager.registerCommand(pluginData.name, "ActSeq_Mechanics_StbExploit", _0x1d1318 => {
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  if (!Imported.VisuMZ_2_BattleSystemSTB) {
    return;
  }
  if (!BattleManager.isSTB()) {
    return;
  }
  VisuMZ.ConvertParams(_0x1d1318, _0x1d1318);
  const _0x5f3998 = _0x1d1318.Exploited;
  const _0x48f6df = VisuMZ.CreateActionSequenceTargets(_0x1d1318.Targets);
  const _0x458bb5 = _0x1d1318.ForceExploited;
  const _0x3031dd = _0x1d1318.Exploiter;
  const _0x57fa5a = _0x1d1318.ForceExploiter;
  const _0x121e32 = BattleManager._action;
  if (_0x5f3998) {
    for (const _0x3b25a7 of _0x48f6df) {
      if (!_0x3b25a7) {
        continue;
      }
      if (_0x3b25a7 === BattleManager._subject) {
        continue;
      }
      if (_0x458bb5) {
        _0x3b25a7.setSTBExploited(false);
      }
      _0x3b25a7.becomeSTBExploited(BattleManager._subject, _0x121e32);
    }
  }
  if (_0x3031dd && BattleManager._subject) {
    if (_0x57fa5a) {
      BattleManager._subject.setSTBExploited(false);
    }
    const _0x4bad4f = _0x48f6df[0x0];
    BattleManager._subject.performSTBExploiter(_0x4bad4f, _0x121e32);
  }
});
PluginManager.registerCommand(pluginData.name, 'ActSeq_Mechanics_StbExtraAction', _0x235489 => {
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  if (!Imported.VisuMZ_2_BattleSystemSTB) {
    return;
  }
  if (!BattleManager.isSTB()) {
    return;
  }
  VisuMZ.ConvertParams(_0x235489, _0x235489);
  const _0x17066e = _0x235489.Actions;
  if (BattleManager._subject) {
    BattleManager._subject.stbGainInstant(_0x17066e);
  }
});
PluginManager.registerCommand(pluginData.name, "ActSeq_Mechanics_StbRemoveExcessActions", _0x13febd => {
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  if (!Imported.VisuMZ_2_BattleSystemSTB) {
    return;
  }
  if (!BattleManager.isSTB()) {
    return;
  }
  VisuMZ.ConvertParams(_0x13febd, _0x13febd);
  let _0x8d239d = _0x13febd.Actions;
  if (BattleManager._subject) {
    BattleManager._subject._actions = BattleManager._subject._actions || [];
    while (_0x8d239d--) {
      if (BattleManager._subject._actions.length <= 0x0) {
        break;
      }
      BattleManager._subject._actions.shift();
    }
  }
});
PluginManager.registerCommand(pluginData.name, "ActSeq_Mechanics_SwapWeapon", _0x3132f6 => {
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  if (!Imported.VisuMZ_2_WeaponSwapSystem) {
    return;
  }
  VisuMZ.ConvertParams(_0x3132f6, _0x3132f6);
  const _0x4b3eaa = VisuMZ.CreateActionSequenceTargets(_0x3132f6.Targets);
  const _0x198659 = _0x3132f6.WeaponTypeID;
  for (const _0x3013db of _0x4b3eaa) {
    if (!_0x3013db) {
      continue;
    }
    if (!_0x3013db.isActor()) {
      continue;
    }
    _0x3013db.switchToWeaponType(_0x198659);
  }
});
PluginManager.registerCommand(pluginData.name, 'ActSeq_Mechanics_TextPopup', _0x18c38a => {
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  VisuMZ.ConvertParams(_0x18c38a, _0x18c38a);
  const _0x584d88 = VisuMZ.CreateActionSequenceTargets(_0x18c38a.Targets);
  const _0x53df25 = _0x18c38a.Text;
  const _0x5493ad = {
    'textColor': ColorManager.getColor(_0x18c38a.TextColor),
    'flashColor': _0x18c38a.FlashColor,
    'flashDuration': _0x18c38a.FlashDuration
  };
  for (const _0x16fb48 of _0x584d88) {
    if (!_0x16fb48) {
      continue;
    }
    _0x16fb48.setupTextPopup(_0x53df25, _0x5493ad);
  }
});
PluginManager.registerCommand(pluginData.name, "ActSeq_Mechanics_VariablePopup", _0x42c3b8 => {
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  VisuMZ.ConvertParams(_0x42c3b8, _0x42c3b8);
  const _0x5a2845 = VisuMZ.CreateActionSequenceTargets(_0x42c3b8.Targets);
  let _0x584cb7 = $gameVariables.value(_0x42c3b8.Variable);
  if (Imported.VisuMZ_0_CoreEngine && _0x42c3b8.DigitGrouping) {
    _0x584cb7 = VisuMZ.GroupDigits(_0x584cb7);
  }
  const _0x3d8454 = String(_0x584cb7);
  const _0x523cbf = {
    'textColor': ColorManager.getColor(_0x42c3b8.TextColor),
    'flashColor': _0x42c3b8.FlashColor,
    'flashDuration': _0x42c3b8.FlashDuration
  };
  for (const _0x5e17f3 of _0x5a2845) {
    if (!_0x5e17f3) {
      continue;
    }
    _0x5e17f3.setupTextPopup(_0x3d8454, _0x523cbf);
  }
});
PluginManager.registerCommand(pluginData.name, "ActSeq_Mechanics_WaitForEffect", _0x4dab7d => {
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  const _0x4d9335 = $gameTemp.getLastPluginCommandInterpreter();
  if (!_0x4d9335) {
    return;
  }
  _0x4d9335.setWaitMode('battleEffect');
});
PluginManager.registerCommand(pluginData.name, 'ActSeq_Motion_ClearFreezeFrame', _0x596365 => {
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  VisuMZ.ConvertParams(_0x596365, _0x596365);
  const _0x50d6e1 = VisuMZ.CreateActionSequenceTargets(_0x596365.Targets);
  for (const _0x24795d of _0x50d6e1) {
    if (!_0x24795d) {
      continue;
    }
    _0x24795d.clearFreezeMotion();
  }
});
PluginManager.registerCommand(pluginData.name, "ActSeq_Motion_FreezeMotionFrame", _0x512143 => {
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  VisuMZ.ConvertParams(_0x512143, _0x512143);
  const _0x1c95f6 = VisuMZ.CreateActionSequenceTargets(_0x512143.Targets);
  const _0x2c7dfd = _0x512143.MotionType.toLowerCase().trim();
  let _0xd4c861 = _0x512143.ShowWeapon;
  const _0x4cb6f0 = _0x512143.Frame;
  if (!["attack", "thrust", "swing", 'missile'].includes(_0x2c7dfd)) {
    _0xd4c861 = false;
  }
  for (const _0x12a537 of _0x1c95f6) {
    if (!_0x12a537) {
      continue;
    }
    _0x12a537.freezeMotion(_0x2c7dfd, _0xd4c861, _0x4cb6f0);
  }
});
PluginManager.registerCommand(pluginData.name, "ActSeq_Motion_MotionType", _0x13075a => {
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  VisuMZ.ConvertParams(_0x13075a, _0x13075a);
  const _0x40e87f = VisuMZ.CreateActionSequenceTargets(_0x13075a.Targets);
  const _0x410598 = _0x13075a.MotionType.toLowerCase().trim();
  const _0x1af068 = _0x13075a.ShowWeapon;
  for (const _0x460204 of _0x40e87f) {
    if (!_0x460204) {
      continue;
    }
    _0x460204._showWeapon = _0x1af068;
    if (_0x410598.match(/ATTACK[ ](\d+)/i)) {
      _0x460204.performAttackSlot(Number(RegExp.$1));
    } else if (_0x410598 === "attack") {
      _0x460204.performAttack();
    } else {
      _0x460204.requestMotion(_0x410598);
    }
    if (!_0x1af068) {
      _0x460204.startWeaponAnimation(0x0);
    } else {
      if (_0x1af068 && ['thrust', "swing", "missle"].includes(_0x410598)) {}
    }
    _0x460204._showWeapon = undefined;
  }
});
PluginManager.registerCommand(pluginData.name, 'ActSeq_Motion_PerformAction', _0x283267 => {
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  VisuMZ.ConvertParams(_0x283267, _0x283267);
  const _0x58d3bb = BattleManager._action;
  if (!_0x58d3bb) {
    return;
  }
  if (!_0x58d3bb.item()) {
    return;
  }
  const _0x548551 = VisuMZ.CreateActionSequenceTargets(_0x283267.Targets);
  for (const _0x5e0867 of _0x548551) {
    if (!_0x5e0867) {
      continue;
    }
    _0x5e0867.performAction(_0x58d3bb);
  }
});
PluginManager.registerCommand(pluginData.name, "ActSeq_Motion_RefreshMotion", _0x10cb0b => {
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  VisuMZ.ConvertParams(_0x10cb0b, _0x10cb0b);
  const _0x2f2cd6 = VisuMZ.CreateActionSequenceTargets(_0x10cb0b.Targets);
  for (const _0x104c1c of _0x2f2cd6) {
    if (!_0x104c1c) {
      continue;
    }
    if (!_0x104c1c.battler()) {
      continue;
    }
    _0x104c1c.battler().refreshMotion();
  }
});
PluginManager.registerCommand(pluginData.name, "ActSeq_Motion_WaitMotionFrame", _0x19a13 => {
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  VisuMZ.ConvertParams(_0x19a13, _0x19a13);
  const _0x84b4ee = $gameTemp.getLastPluginCommandInterpreter();
  const _0x59f5a8 = _0x19a13.MotionFrameWait * Sprite_Battler._motionSpeed;
  _0x84b4ee.wait(_0x59f5a8);
});
PluginManager.registerCommand(pluginData.name, "ActSeq_Movement_BattleStep", _0x7c5752 => {
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  VisuMZ.ConvertParams(_0x7c5752, _0x7c5752);
  const _0x2b9f0 = $gameTemp.getLastPluginCommandInterpreter();
  const _0x127b52 = BattleManager._action;
  if (!_0x2b9f0 || !_0x127b52) {
    return;
  }
  if (!_0x127b52.item()) {
    return;
  }
  const _0x5a3b56 = VisuMZ.CreateActionSequenceTargets(_0x7c5752.Targets);
  for (const _0x183588 of _0x5a3b56) {
    if (!_0x183588) {
      continue;
    }
    _0x183588.performActionStart(_0x127b52);
  }
  if (_0x7c5752.WaitForMovement) {
    _0x2b9f0.setWaitMode("battleMove");
  }
});
PluginManager.registerCommand(pluginData.name, "ActSeq_Movement_HomeMoveBy", _0x568434 => {
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  if (!$gameSystem.isSideView()) {
    return;
  }
  VisuMZ.ConvertParams(_0x568434, _0x568434);
  const _0x5c2888 = $gameTemp.getLastPluginCommandInterpreter();
  const _0x41eb87 = VisuMZ.CreateActionSequenceTargets(_0x568434.Targets);
  const _0x5718a2 = _0x568434.DistanceAdjust;
  const _0x53f1a4 = _0x568434.DistanceX;
  const _0x40c27a = _0x568434.DistanceY;
  const _0x789ba0 = _0x568434.Duration;
  const _0x4a4c86 = _0x568434.FaceDirection;
  const _0x32ed30 = _0x568434.EasingType;
  const _0x77062a = _0x568434.MotionType;
  const _0x48e7c2 = _0x568434.WaitForMovement;
  if (!_0x5c2888) {
    return;
  }
  const _0x3ba30f = VisuMZ.BattleCore.Settings;
  for (const _0x239945 of _0x41eb87) {
    if (!_0x239945) {
      continue;
    }
    let _0x3e50e8 = _0x53f1a4;
    let _0x1a9341 = _0x40c27a;
    if (_0x5718a2.match(/horz/i)) {
      _0x3e50e8 *= _0x239945.isActor() ? -0x1 : 0x1;
    }
    if (_0x5718a2.match(/vert/i)) {
      _0x1a9341 *= _0x239945.isActor() ? -0x1 : 0x1;
    }
    if (_0x239945.isActor()) {
      _0x3e50e8 -= _0x3ba30f.Actor.OffsetX;
      _0x1a9341 -= _0x3ba30f.Actor.OffsetY;
    } else if (_0x239945.isEnemy()) {
      _0x3e50e8 -= _0x3ba30f.Enemy.OffsetX;
      _0x1a9341 -= _0x3ba30f.Enemy.OffsetY;
    }
    _0x239945.moveBattlerHomeDistance(_0x3e50e8, _0x1a9341, _0x789ba0, _0x4a4c86, _0x32ed30);
    _0x239945.requestMotion(_0x77062a);
  }
  if (_0x48e7c2) {
    _0x5c2888.setWaitMode("battleMove");
  }
});
PluginManager.registerCommand(pluginData.name, "ActSeq_Movement_HomeMoveToJsPoint", _0x45ec5b => {
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  if (!$gameSystem.isSideView()) {
    return;
  }
  VisuMZ.ConvertParams(_0x45ec5b, _0x45ec5b);
  const _0x1e28d3 = $gameTemp.getLastPluginCommandInterpreter();
  const _0x5810da = VisuMZ.CreateActionSequenceTargets(_0x45ec5b.Targets);
  const _0xb51255 = _0x45ec5b.OffsetAdjust;
  const _0x4fbbaf = _0x45ec5b.OffsetX;
  const _0x2f8c07 = _0x45ec5b.OffsetY;
  const _0x2f92a0 = _0x45ec5b.Duration;
  const _0x99d0cd = _0x45ec5b.FaceDirection;
  const _0x621866 = _0x45ec5b.EasingType;
  const _0x1a7b56 = _0x45ec5b.MotionType;
  const _0x5ed666 = _0x45ec5b.WaitForMovement;
  if (!_0x1e28d3) {
    return;
  }
  for (const _0x3ed770 of _0x5810da) {
    if (!_0x3ed770) {
      continue;
    }
    const _0x357a16 = _0x45ec5b.DestinationJS(_0x3ed770) || {
      'x': 0x0,
      'y': 0x0
    };
    let _0x5a40bd = _0x357a16.x;
    let _0x468a8b = _0x357a16.y;
    if (_0xb51255.match(/none/i)) {
      _0x5a40bd += _0x4fbbaf;
      _0x468a8b += _0x2f8c07;
    } else {
      if (_0xb51255.match(/horz/i) && _0xb51255.match(/vert/i)) {
        _0x5a40bd += _0x3ed770.isActor() ? -_0x4fbbaf : _0x4fbbaf;
        _0x468a8b += _0x3ed770.isActor() ? -_0x2f8c07 : _0x2f8c07;
      } else {
        if (_0xb51255.match(/horz/i)) {
          _0x5a40bd += _0x3ed770.isActor() ? -_0x4fbbaf : _0x4fbbaf;
          _0x468a8b += _0x2f8c07;
        } else if (_0xb51255.match(/vert/i)) {
          _0x5a40bd += _0x4fbbaf;
          _0x468a8b += _0x3ed770.isActor() ? -_0x2f8c07 : _0x2f8c07;
        }
      }
    }
    _0x3ed770.moveBattlerHomeToPoint(_0x5a40bd, _0x468a8b, _0x2f92a0, _0x99d0cd, _0x621866, -0x1);
    _0x3ed770.requestMotion(_0x1a7b56);
  }
  if (_0x5ed666) {
    _0x1e28d3.setWaitMode("battleMove");
  }
});
PluginManager.registerCommand(pluginData.name, "ActSeq_Movement_HomeMoveToPoint", _0x2a51b8 => {
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  if (!$gameSystem.isSideView()) {
    return;
  }
  VisuMZ.ConvertParams(_0x2a51b8, _0x2a51b8);
  const _0x4843d2 = $gameTemp.getLastPluginCommandInterpreter();
  const _0x2c2860 = VisuMZ.CreateActionSequenceTargets(_0x2a51b8.Targets);
  const _0x529b1d = _0x2a51b8.Destination;
  const _0x5ece10 = _0x2a51b8.OffsetAdjust;
  const _0x393dab = _0x2a51b8.OffsetX;
  const _0x25b3fd = _0x2a51b8.OffsetY;
  const _0x2348db = _0x2a51b8.Duration;
  const _0x387647 = _0x2a51b8.FaceDirection;
  const _0xc16522 = _0x2a51b8.EasingType;
  const _0x382a59 = _0x2a51b8.MotionType;
  const _0xb2eec3 = _0x2a51b8.WaitForMovement;
  if (!_0x4843d2) {
    return;
  }
  for (const _0x3d92af of _0x2c2860) {
    if (!_0x3d92af) {
      continue;
    }
    let _0x59b31e = _0x3d92af.battler()._baseX;
    let _0x15f5b7 = _0x3d92af.battler()._baseY;
    if (_0x529b1d.match(/home/i)) {
      _0x59b31e = _0x3d92af.battler()._homeX;
      _0x15f5b7 = _0x3d92af.battler()._homeY;
    } else {
      if (_0x529b1d.match(/center/i)) {
        _0x59b31e = Graphics.boxWidth / 0x2;
        _0x15f5b7 = Graphics.boxHeight / 0x2;
      } else if (_0x529b1d.match(/point (\d+), (\d+)/i)) {
        _0x59b31e = Number(RegExp.$1);
        _0x15f5b7 = Number(RegExp.$2);
      }
    }
    if (_0x5ece10.match(/none/i)) {
      _0x59b31e += _0x393dab;
      _0x15f5b7 += _0x25b3fd;
    } else {
      if (_0x5ece10.match(/horz/i) && _0x5ece10.match(/vert/i)) {
        _0x59b31e += _0x3d92af.isActor() ? -_0x393dab : _0x393dab;
        _0x15f5b7 += _0x3d92af.isActor() ? -_0x25b3fd : _0x25b3fd;
      } else {
        if (_0x5ece10.match(/horz/i)) {
          _0x59b31e += _0x3d92af.isActor() ? -_0x393dab : _0x393dab;
          _0x15f5b7 += _0x25b3fd;
        } else if (_0x5ece10.match(/vert/i)) {
          _0x59b31e += _0x393dab;
          _0x15f5b7 += _0x3d92af.isActor() ? -_0x25b3fd : _0x25b3fd;
        }
      }
    }
    _0x3d92af.moveBattlerHomeToPoint(_0x59b31e, _0x15f5b7, _0x2348db, _0x387647, _0xc16522, -0x1);
    _0x3d92af.requestMotion(_0x382a59);
  }
  if (_0xb2eec3) {
    _0x4843d2.setWaitMode("battleMove");
  }
});
PluginManager.registerCommand(pluginData.name, "ActSeq_Movement_HomeMoveToTarget", _0x11ff16 => {
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  if (!$gameSystem.isSideView()) {
    return;
  }
  VisuMZ.ConvertParams(_0x11ff16, _0x11ff16);
  const _0x38dae5 = $gameTemp.getLastPluginCommandInterpreter();
  const _0x14f97d = VisuMZ.CreateActionSequenceTargets(_0x11ff16.Targets1);
  const _0x351be4 = VisuMZ.CreateActionSequenceTargets(_0x11ff16.Targets2);
  const _0x43915d = _0x11ff16.TargetLocation;
  let _0x287459 = _0x11ff16.MeleeDistance;
  const _0x3c6b79 = _0x11ff16.OffsetAdjust;
  const _0x21da66 = _0x11ff16.OffsetX;
  const _0xa6ccb3 = _0x11ff16.OffsetY;
  const _0x22cbef = _0x11ff16.Duration;
  const _0x5dd032 = _0x11ff16.FaceDirection;
  const _0x61071d = _0x11ff16.EasingType;
  const _0x342949 = _0x11ff16.MotionType;
  const _0x454283 = _0x11ff16.WaitForMovement;
  const _0x39dae4 = Math.min(..._0x351be4.map(_0xd7a7fc => _0xd7a7fc.battler()._baseX - _0xd7a7fc.battler().mainSpriteWidth() / 0x2));
  const _0x6855a0 = Math.max(..._0x351be4.map(_0x51ace6 => _0x51ace6.battler()._baseX + _0x51ace6.battler().mainSpriteWidth() / 0x2));
  const _0x5075f5 = Math.min(..._0x351be4.map(_0x11aa59 => _0x11aa59.battler()._baseY - _0x11aa59.battler().mainSpriteHeight()));
  const _0xd04f47 = Math.max(..._0x351be4.map(_0x22bb56 => _0x22bb56.battler()._baseY));
  const _0x43c1dd = _0x351be4.filter(_0x9b4b7f => _0x9b4b7f.isActor()).length;
  const _0x208965 = _0x351be4.filter(_0x2e106e => _0x2e106e.isEnemy()).length;
  let _0x1d7f65 = 0x0;
  let _0x38c359 = 0x0;
  if (_0x43915d.match(/front/i)) {
    _0x1d7f65 = _0x43c1dd >= _0x208965 ? _0x39dae4 : _0x6855a0;
  } else {
    if (_0x43915d.match(/middle/i)) {
      _0x1d7f65 = (_0x39dae4 + _0x6855a0) / 0x2;
      _0x287459 = -0x1;
    } else if (_0x43915d.match(/back/i)) {
      _0x1d7f65 = _0x43c1dd >= _0x208965 ? _0x6855a0 : _0x39dae4;
    }
  }
  if (_0x43915d.match(/head/i)) {
    _0x38c359 = _0x5075f5;
  } else {
    if (_0x43915d.match(/center/i)) {
      _0x38c359 = (_0x5075f5 + _0xd04f47) / 0x2;
    } else if (_0x43915d.match(/base/i)) {
      _0x38c359 = _0xd04f47;
    }
  }
  if (!_0x38dae5) {
    return;
  }
  for (const _0x765893 of _0x14f97d) {
    if (!_0x765893) {
      continue;
    }
    let _0x40209d = _0x1d7f65;
    let _0x133c22 = _0x38c359;
    if (_0x3c6b79.match(/none/i)) {
      _0x40209d += _0x21da66;
      _0x133c22 += _0xa6ccb3;
    } else {
      if (_0x3c6b79.match(/horz/i) && _0x3c6b79.match(/vert/i)) {
        _0x40209d += _0x765893.isActor() ? -_0x21da66 : _0x21da66;
        _0x133c22 += _0x765893.isActor() ? -_0xa6ccb3 : _0xa6ccb3;
      } else {
        if (_0x3c6b79.match(/horz/i)) {
          _0x40209d += _0x765893.isActor() ? -_0x21da66 : _0x21da66;
          _0x133c22 += _0xa6ccb3;
        } else if (_0x3c6b79.match(/vert/i)) {
          _0x40209d += _0x21da66;
          _0x133c22 += _0x765893.isActor() ? -_0xa6ccb3 : _0xa6ccb3;
        }
      }
    }
    _0x765893.moveBattlerHomeToPoint(_0x40209d, _0x133c22, _0x22cbef, _0x5dd032, _0x61071d, _0x287459);
    _0x765893.requestMotion(_0x342949);
  }
  if (_0x454283) {
    _0x38dae5.setWaitMode("battleMove");
  }
});
PluginManager.registerCommand(pluginData.name, 'ActSeq_Movement_FaceDirection', _0x387cb2 => {
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  if (!$gameSystem.isSideView()) {
    return;
  }
  VisuMZ.ConvertParams(_0x387cb2, _0x387cb2);
  const _0x185a0b = VisuMZ.CreateActionSequenceTargets(_0x387cb2.Targets);
  let _0x597671 = _0x387cb2.Direction.match(/back/i);
  for (const _0x42cc0d of _0x185a0b) {
    if (!_0x42cc0d) {
      continue;
    }
    if (_0x387cb2.Direction.match(/rand/i)) {
      _0x597671 = Math.randomInt(0x2);
    }
    _0x42cc0d.setBattlerFlip(!!_0x597671);
  }
});
PluginManager.registerCommand(pluginData.name, "ActSeq_Movement_FaceJsPoint", _0x7b7162 => {
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  if (!$gameSystem.isSideView()) {
    return;
  }
  VisuMZ.ConvertParams(_0x7b7162, _0x7b7162);
  const _0x58313f = VisuMZ.CreateActionSequenceTargets(_0x7b7162.Targets);
  const _0x898d18 = _0x7b7162.FaceAway;
  for (const _0x4f2487 of _0x58313f) {
    if (!_0x4f2487) {
      continue;
    }
    const _0x3a8bfa = _0x7b7162.PointJS(_0x4f2487) || {
      'x': 0x0,
      'y': 0x0
    };
    let _0x18d7a9 = _0x3a8bfa.x;
    let _0x470ab0 = _0x3a8bfa.y;
    _0x4f2487.setBattlerFacePoint(Math.round(_0x18d7a9), Math.round(_0x470ab0), !!_0x898d18);
  }
});
PluginManager.registerCommand(pluginData.name, 'ActSeq_Movement_FacePoint', _0x30e965 => {
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  if (!$gameSystem.isSideView()) {
    return;
  }
  VisuMZ.ConvertParams(_0x30e965, _0x30e965);
  const _0x4a7595 = VisuMZ.CreateActionSequenceTargets(_0x30e965.Targets);
  let _0x52c3d2 = _0x30e965.Point;
  const _0x4cedcf = _0x30e965.FaceAway;
  for (const _0xadcb5b of _0x4a7595) {
    if (!_0xadcb5b) {
      continue;
    }
    let _0x17623c = _0xadcb5b.battler()._baseX;
    let _0x569b50 = _0xadcb5b.battler()._baseY;
    if (_0x52c3d2.match(/home/i)) {
      _0x17623c = _0xadcb5b.battler()._homeX;
      _0x569b50 = _0xadcb5b.battler()._homeY;
    } else {
      if (_0x52c3d2.match(/center/i)) {
        _0x17623c = Graphics.boxWidth / 0x2;
        _0x569b50 = Graphics.boxHeight / 0x2;
      } else if (_0x52c3d2.match(/point (\d+), (\d+)/i)) {
        _0x17623c = Number(RegExp.$1);
        _0x569b50 = Number(RegExp.$2);
      }
    }
    _0xadcb5b.setBattlerFacePoint(Math.round(_0x17623c), Math.round(_0x569b50), !!_0x4cedcf);
  }
});
PluginManager.registerCommand(pluginData.name, "ActSeq_Movement_FaceTarget", _0x5b1d3d => {
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  if (!$gameSystem.isSideView()) {
    return;
  }
  VisuMZ.ConvertParams(_0x5b1d3d, _0x5b1d3d);
  const _0x3bdbe1 = VisuMZ.CreateActionSequenceTargets(_0x5b1d3d.Targets1);
  const _0x549948 = VisuMZ.CreateActionSequenceTargets(_0x5b1d3d.Targets2);
  const _0x15a338 = _0x549948.map(_0x531b79 => _0x531b79 && _0x531b79.battler() ? _0x531b79.battler()._baseX : 0x0) / (_0x549948.length || 0x1);
  const _0x423e48 = _0x549948.map(_0xea42e2 => _0xea42e2 && _0xea42e2.battler() ? _0xea42e2.battler()._baseY : 0x0) / (_0x549948.length || 0x1);
  const _0x452482 = _0x5b1d3d.FaceAway;
  for (const _0x3b1b8a of _0x3bdbe1) {
    if (!_0x3b1b8a) {
      continue;
    }
    _0x3b1b8a.setBattlerFacePoint(Math.round(_0x15a338), Math.round(_0x423e48), !!_0x452482);
  }
});
PluginManager.registerCommand(pluginData.name, "ActSeq_Movement_Float", _0x1fc7cb => {
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  VisuMZ.ConvertParams(_0x1fc7cb, _0x1fc7cb);
  const _0x184058 = $gameTemp.getLastPluginCommandInterpreter();
  const _0x1b3445 = VisuMZ.CreateActionSequenceTargets(_0x1fc7cb.Targets);
  const _0x2f3845 = _0x1fc7cb.Height;
  const _0x2624be = _0x1fc7cb.Duration;
  const _0x47ce54 = _0x1fc7cb.EasingType;
  const _0x5af7b1 = _0x1fc7cb.WaitForFloat;
  if (!_0x184058) {
    return;
  }
  for (const _0x276217 of _0x1b3445) {
    if (!_0x276217) {
      continue;
    }
    _0x276217.floatBattler(_0x2f3845, _0x2624be, _0x47ce54);
  }
  if (_0x5af7b1) {
    _0x184058.setWaitMode('battleFloat');
  }
});
PluginManager.registerCommand(pluginData.name, 'ActSeq_Movement_HomeReset', _0x4762f7 => {
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  VisuMZ.ConvertParams(_0x4762f7, _0x4762f7);
  const _0x453340 = $gameTemp.getLastPluginCommandInterpreter();
  if (!_0x453340) {
    return;
  }
  const _0x2ee233 = VisuMZ.CreateActionSequenceTargets(_0x4762f7.Targets);
  for (const _0x47551a of _0x2ee233) {
    if (!_0x47551a) {
      continue;
    }
    _0x47551a.performActionEndMembers();
  }
  if (BattleManager._subject) {
    BattleManager._subject.performActionEnd();
  }
  if (_0x4762f7.WaitForMovement) {
    _0x453340.setWaitMode("battleMove");
  }
});
PluginManager.registerCommand(pluginData.name, "ActSeq_Movement_Jump", _0x29cf57 => {
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  VisuMZ.ConvertParams(_0x29cf57, _0x29cf57);
  const _0x380c93 = $gameTemp.getLastPluginCommandInterpreter();
  const _0x17394d = VisuMZ.CreateActionSequenceTargets(_0x29cf57.Targets);
  const _0x9c96ca = _0x29cf57.Height;
  const _0x22642e = _0x29cf57.Duration;
  const _0x113c57 = _0x29cf57.WaitForJump;
  if (!_0x380c93) {
    return;
  }
  for (const _0x2edd47 of _0x17394d) {
    if (!_0x2edd47) {
      continue;
    }
    _0x2edd47.jumpBattler(_0x9c96ca, _0x22642e);
  }
  if (_0x113c57) {
    _0x380c93.setWaitMode('battleJump');
  }
});
PluginManager.registerCommand(pluginData.name, "ActSeq_Movement_MoveBy", _0x372c23 => {
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  if (!$gameSystem.isSideView()) {
    return;
  }
  VisuMZ.ConvertParams(_0x372c23, _0x372c23);
  const _0x210e92 = $gameTemp.getLastPluginCommandInterpreter();
  const _0x18db61 = VisuMZ.CreateActionSequenceTargets(_0x372c23.Targets);
  const _0x2f6525 = _0x372c23.DistanceAdjust;
  const _0x19b828 = _0x372c23.DistanceX;
  const _0x5635f7 = _0x372c23.DistanceY;
  const _0x1cd4c0 = _0x372c23.Duration;
  const _0x5892a4 = _0x372c23.FaceDirection;
  const _0x4255b8 = _0x372c23.EasingType;
  const _0x4e136c = _0x372c23.MotionType;
  const _0x2b28ad = _0x372c23.WaitForMovement;
  if (!_0x210e92) {
    return;
  }
  for (const _0x2b9e8e of _0x18db61) {
    if (!_0x2b9e8e) {
      continue;
    }
    let _0x305c73 = _0x19b828;
    let _0x9a7fba = _0x5635f7;
    if (_0x2f6525.match(/horz/i)) {
      _0x305c73 *= _0x2b9e8e.isActor() ? -0x1 : 0x1;
    }
    if (_0x2f6525.match(/vert/i)) {
      _0x9a7fba *= _0x2b9e8e.isActor() ? -0x1 : 0x1;
    }
    _0x2b9e8e.moveBattlerDistance(_0x305c73, _0x9a7fba, _0x1cd4c0, _0x5892a4, _0x4255b8);
    _0x2b9e8e.requestMotion(_0x4e136c);
  }
  if (_0x2b28ad) {
    _0x210e92.setWaitMode("battleMove");
  }
});
PluginManager.registerCommand(pluginData.name, "ActSeq_Movement_MoveToJsPoint", _0xb7476f => {
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  if (!$gameSystem.isSideView()) {
    return;
  }
  VisuMZ.ConvertParams(_0xb7476f, _0xb7476f);
  const _0xbfe8dc = $gameTemp.getLastPluginCommandInterpreter();
  const _0x9ff509 = VisuMZ.CreateActionSequenceTargets(_0xb7476f.Targets);
  const _0x5dc2f5 = _0xb7476f.OffsetAdjust;
  const _0x49b5b3 = _0xb7476f.OffsetX;
  const _0x471225 = _0xb7476f.OffsetY;
  const _0x8c2720 = _0xb7476f.Duration;
  const _0x4e29a7 = _0xb7476f.FaceDirection;
  const _0x242e5f = _0xb7476f.EasingType;
  const _0x23bb00 = _0xb7476f.MotionType;
  const _0x4e326d = _0xb7476f.WaitForMovement;
  if (!_0xbfe8dc) {
    return;
  }
  for (const _0x396e0e of _0x9ff509) {
    if (!_0x396e0e) {
      continue;
    }
    const _0x1996e9 = _0xb7476f.DestinationJS(_0x396e0e) || {
      'x': 0x0,
      'y': 0x0
    };
    let _0x57e515 = _0x1996e9.x;
    let _0x49a6a8 = _0x1996e9.y;
    if (_0x5dc2f5.match(/none/i)) {
      _0x57e515 += _0x49b5b3;
      _0x49a6a8 += _0x471225;
    } else {
      if (_0x5dc2f5.match(/horz/i) && _0x5dc2f5.match(/vert/i)) {
        _0x57e515 += _0x396e0e.isActor() ? -_0x49b5b3 : _0x49b5b3;
        _0x49a6a8 += _0x396e0e.isActor() ? -_0x471225 : _0x471225;
      } else {
        if (_0x5dc2f5.match(/horz/i)) {
          _0x57e515 += _0x396e0e.isActor() ? -_0x49b5b3 : _0x49b5b3;
          _0x49a6a8 += _0x471225;
        } else if (_0x5dc2f5.match(/vert/i)) {
          _0x57e515 += _0x49b5b3;
          _0x49a6a8 += _0x396e0e.isActor() ? -_0x471225 : _0x471225;
        }
      }
    }
    _0x396e0e.moveBattlerToPoint(_0x57e515, _0x49a6a8, _0x8c2720, _0x4e29a7, _0x242e5f, -0x1);
    _0x396e0e.requestMotion(_0x23bb00);
  }
  if (_0x4e326d) {
    _0xbfe8dc.setWaitMode("battleMove");
  }
});
PluginManager.registerCommand(pluginData.name, 'ActSeq_Movement_MoveToPoint', _0x5f2f79 => {
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  if (!$gameSystem.isSideView()) {
    return;
  }
  VisuMZ.ConvertParams(_0x5f2f79, _0x5f2f79);
  const _0x44f62d = $gameTemp.getLastPluginCommandInterpreter();
  const _0x745245 = VisuMZ.CreateActionSequenceTargets(_0x5f2f79.Targets);
  const _0xe10704 = _0x5f2f79.Destination;
  const _0xc0e218 = _0x5f2f79.OffsetAdjust;
  const _0x28e48d = _0x5f2f79.OffsetX;
  const _0x24443b = _0x5f2f79.OffsetY;
  const _0x37eeb7 = _0x5f2f79.Duration;
  const _0x1377d6 = _0x5f2f79.FaceDirection;
  const _0x105757 = _0x5f2f79.EasingType;
  const _0x383090 = _0x5f2f79.MotionType;
  const _0x2bf0ce = _0x5f2f79.WaitForMovement;
  if (!_0x44f62d) {
    return;
  }
  for (const _0x3c2110 of _0x745245) {
    if (!_0x3c2110) {
      continue;
    }
    let _0x62b237 = _0x3c2110.battler()._baseX;
    let _0x3bd68b = _0x3c2110.battler()._baseY;
    if (_0xe10704.match(/home/i)) {
      _0x62b237 = _0x3c2110.battler()._homeX;
      _0x3bd68b = _0x3c2110.battler()._homeY;
    } else {
      if (_0xe10704.match(/center/i)) {
        _0x62b237 = Graphics.boxWidth / 0x2;
        _0x3bd68b = Graphics.boxHeight / 0x2;
      } else if (_0xe10704.match(/point (\d+), (\d+)/i)) {
        _0x62b237 = Number(RegExp.$1);
        _0x3bd68b = Number(RegExp.$2);
      }
    }
    if (_0xc0e218.match(/none/i)) {
      _0x62b237 += _0x28e48d;
      _0x3bd68b += _0x24443b;
    } else {
      if (_0xc0e218.match(/horz/i) && _0xc0e218.match(/vert/i)) {
        _0x62b237 += _0x3c2110.isActor() ? -_0x28e48d : _0x28e48d;
        _0x3bd68b += _0x3c2110.isActor() ? -_0x24443b : _0x24443b;
      } else {
        if (_0xc0e218.match(/horz/i)) {
          _0x62b237 += _0x3c2110.isActor() ? -_0x28e48d : _0x28e48d;
          _0x3bd68b += _0x24443b;
        } else if (_0xc0e218.match(/vert/i)) {
          _0x62b237 += _0x28e48d;
          _0x3bd68b += _0x3c2110.isActor() ? -_0x24443b : _0x24443b;
        }
      }
    }
    _0x3c2110.moveBattlerToPoint(_0x62b237, _0x3bd68b, _0x37eeb7, _0x1377d6, _0x105757, -0x1);
    _0x3c2110.requestMotion(_0x383090);
  }
  if (_0x2bf0ce) {
    _0x44f62d.setWaitMode("battleMove");
  }
});
PluginManager.registerCommand(pluginData.name, "ActSeq_Movement_MoveToTarget", _0x409570 => {
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  if (!$gameSystem.isSideView()) {
    return;
  }
  VisuMZ.ConvertParams(_0x409570, _0x409570);
  const _0x4303d4 = $gameTemp.getLastPluginCommandInterpreter();
  const _0x434980 = VisuMZ.CreateActionSequenceTargets(_0x409570.Targets1);
  const _0x51a39f = VisuMZ.CreateActionSequenceTargets(_0x409570.Targets2);
  const _0x2fab9f = _0x409570.TargetLocation;
  let _0x2f0071 = _0x409570.MeleeDistance;
  const _0x234d46 = _0x409570.OffsetAdjust;
  const _0x7e9a24 = _0x409570.OffsetX;
  const _0x55dec3 = _0x409570.OffsetY;
  const _0x537870 = _0x409570.Duration;
  const _0x3ab31f = _0x409570.FaceDirection;
  const _0x29e4e1 = _0x409570.EasingType;
  const _0x18e8ef = _0x409570.MotionType;
  const _0x1bb9e9 = _0x409570.WaitForMovement;
  const _0x215306 = Math.min(..._0x51a39f.map(_0xdf130c => _0xdf130c.battler()._baseX - _0xdf130c.battler().mainSpriteWidth() / 0x2));
  const _0x963d0e = Math.max(..._0x51a39f.map(_0x3b6e45 => _0x3b6e45.battler()._baseX + _0x3b6e45.battler().mainSpriteWidth() / 0x2));
  const _0x4d20d6 = Math.min(..._0x51a39f.map(_0x322c45 => _0x322c45.battler()._baseY - _0x322c45.battler().mainSpriteHeight()));
  const _0x687bc1 = Math.max(..._0x51a39f.map(_0x331234 => _0x331234.battler()._baseY));
  const _0x52c983 = _0x51a39f.filter(_0x2bbc2c => _0x2bbc2c.isActor()).length;
  const _0x41324a = _0x51a39f.filter(_0x570a44 => _0x570a44.isEnemy()).length;
  let _0x1f0e55 = 0x0;
  let _0x6caeef = 0x0;
  if (_0x2fab9f.match(/front/i)) {
    _0x1f0e55 = _0x52c983 >= _0x41324a ? _0x215306 : _0x963d0e;
  } else {
    if (_0x2fab9f.match(/middle/i)) {
      _0x1f0e55 = (_0x215306 + _0x963d0e) / 0x2;
      _0x2f0071 = -0x1;
    } else if (_0x2fab9f.match(/back/i)) {
      _0x1f0e55 = _0x52c983 >= _0x41324a ? _0x963d0e : _0x215306;
    }
  }
  if (_0x2fab9f.match(/head/i)) {
    _0x6caeef = _0x4d20d6;
  } else {
    if (_0x2fab9f.match(/center/i)) {
      _0x6caeef = (_0x4d20d6 + _0x687bc1) / 0x2;
    } else if (_0x2fab9f.match(/base/i)) {
      _0x6caeef = _0x687bc1;
    }
  }
  if (!_0x4303d4) {
    return;
  }
  for (const _0x42747e of _0x434980) {
    if (!_0x42747e) {
      continue;
    }
    let _0x5c7c79 = _0x1f0e55;
    let _0x273d31 = _0x6caeef;
    if (_0x234d46.match(/none/i)) {
      _0x5c7c79 += _0x7e9a24;
      _0x273d31 += _0x55dec3;
    } else {
      if (_0x234d46.match(/horz/i) && _0x234d46.match(/vert/i)) {
        _0x5c7c79 += _0x42747e.isActor() ? -_0x7e9a24 : _0x7e9a24;
        _0x273d31 += _0x42747e.isActor() ? -_0x55dec3 : _0x55dec3;
      } else {
        if (_0x234d46.match(/horz/i)) {
          _0x5c7c79 += _0x42747e.isActor() ? -_0x7e9a24 : _0x7e9a24;
          _0x273d31 += _0x55dec3;
        } else if (_0x234d46.match(/vert/i)) {
          _0x5c7c79 += _0x7e9a24;
          _0x273d31 += _0x42747e.isActor() ? -_0x55dec3 : _0x55dec3;
        }
      }
    }
    _0x42747e.moveBattlerToPoint(_0x5c7c79, _0x273d31, _0x537870, _0x3ab31f, _0x29e4e1, _0x2f0071);
    _0x42747e.requestMotion(_0x18e8ef);
  }
  if (_0x1bb9e9) {
    _0x4303d4.setWaitMode("battleMove");
  }
});
PluginManager.registerCommand(pluginData.name, 'ActSeq_Movement_Opacity', _0xaa7dc2 => {
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  VisuMZ.ConvertParams(_0xaa7dc2, _0xaa7dc2);
  const _0x1f08bf = $gameTemp.getLastPluginCommandInterpreter();
  const _0x518457 = VisuMZ.CreateActionSequenceTargets(_0xaa7dc2.Targets);
  const _0x5618a3 = _0xaa7dc2.Opacity;
  const _0x5e9f7e = _0xaa7dc2.Duration;
  const _0x2d7cb0 = _0xaa7dc2.EasingType;
  const _0x261c7c = _0xaa7dc2.WaitForOpacity;
  if (!_0x1f08bf) {
    return;
  }
  for (const _0xb4947b of _0x518457) {
    if (!_0xb4947b) {
      continue;
    }
    _0xb4947b.changeBattlerOpacity(_0x5618a3, _0x5e9f7e, _0x2d7cb0);
  }
  if (_0x261c7c) {
    _0x1f08bf.setWaitMode("battleOpacity");
  }
});
PluginManager.registerCommand(pluginData.name, 'ActSeq_Movement_Scale', _0x3ecf7e => {
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  VisuMZ.ConvertParams(_0x3ecf7e, _0x3ecf7e);
  const _0x1576d1 = $gameTemp.getLastPluginCommandInterpreter();
  const _0x4c1da1 = VisuMZ.CreateActionSequenceTargets(_0x3ecf7e.Targets);
  const _0x3ccda1 = _0x3ecf7e.ScaleX;
  const _0x5d26bc = _0x3ecf7e.ScaleY;
  const _0x150e5f = _0x3ecf7e.Duration;
  const _0x306531 = _0x3ecf7e.EasingType;
  const _0x12aa7d = _0x3ecf7e.WaitForScale;
  if (!_0x1576d1) {
    return;
  }
  for (const _0x32ae3f of _0x4c1da1) {
    if (!_0x32ae3f) {
      continue;
    }
    _0x32ae3f.growBattler(_0x3ccda1, _0x5d26bc, _0x150e5f, _0x306531);
  }
  if (_0x12aa7d) {
    _0x1576d1.setWaitMode('battleGrow');
  }
});
PluginManager.registerCommand(pluginData.name, "ActSeq_Movement_Skew", _0x35b6b0 => {
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  VisuMZ.ConvertParams(_0x35b6b0, _0x35b6b0);
  const _0x44c0cd = $gameTemp.getLastPluginCommandInterpreter();
  const _0x5051a2 = VisuMZ.CreateActionSequenceTargets(_0x35b6b0.Targets);
  const _0x3fcf5c = _0x35b6b0.SkewX;
  const _0x5500dd = _0x35b6b0.SkewY;
  const _0xbd93db = _0x35b6b0.Duration;
  const _0x3ddae8 = _0x35b6b0.EasingType;
  const _0x41956d = _0x35b6b0.WaitForSkew;
  if (!_0x44c0cd) {
    return;
  }
  for (const _0x21212c of _0x5051a2) {
    if (!_0x21212c) {
      continue;
    }
    _0x21212c.skewBattler(_0x3fcf5c, _0x5500dd, _0xbd93db, _0x3ddae8);
  }
  if (_0x41956d) {
    _0x44c0cd.setWaitMode("battleSpriteSkew");
  }
});
PluginManager.registerCommand(pluginData.name, "ActSeq_Movement_Spin", _0x4a00ef => {
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  VisuMZ.ConvertParams(_0x4a00ef, _0x4a00ef);
  const _0x40881c = $gameTemp.getLastPluginCommandInterpreter();
  const _0x31d6ae = VisuMZ.CreateActionSequenceTargets(_0x4a00ef.Targets);
  const _0x2ae156 = _0x4a00ef.Angle;
  const _0x27d59b = _0x4a00ef.Duration;
  const _0xf395fb = _0x4a00ef.EasingType;
  const _0x2c3b24 = _0x4a00ef.RevertAngle;
  const _0x5b9fdb = _0x4a00ef.WaitForSpin;
  if (!_0x40881c) {
    return;
  }
  for (const _0x148336 of _0x31d6ae) {
    if (!_0x148336) {
      continue;
    }
    _0x148336.spinBattler(_0x2ae156, _0x27d59b, _0xf395fb, _0x2c3b24);
  }
  if (_0x5b9fdb) {
    _0x40881c.setWaitMode("battleSpin");
  }
});
PluginManager.registerCommand(pluginData.name, 'ActSeq_Movement_WaitForFloat', _0x51625f => {
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  const _0x354e43 = $gameTemp.getLastPluginCommandInterpreter();
  if (!_0x354e43) {
    return;
  }
  _0x354e43.setWaitMode("battleFloat");
});
PluginManager.registerCommand(pluginData.name, 'ActSeq_Movement_WaitForJump', _0x59195e => {
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  const _0x436f32 = $gameTemp.getLastPluginCommandInterpreter();
  if (!_0x436f32) {
    return;
  }
  _0x436f32.setWaitMode("battleJump");
});
PluginManager.registerCommand(pluginData.name, "ActSeq_Movement_WaitForMovement", _0x2dc94a => {
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  const _0x4d4ef0 = $gameTemp.getLastPluginCommandInterpreter();
  if (!_0x4d4ef0) {
    return;
  }
  _0x4d4ef0.setWaitMode('battleMove');
});
PluginManager.registerCommand(pluginData.name, "ActSeq_Movement_WaitForOpacity", _0x496c79 => {
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  const _0x2e93a3 = $gameTemp.getLastPluginCommandInterpreter();
  if (!_0x2e93a3) {
    return;
  }
  _0x2e93a3.setWaitMode("battleOpacity");
});
PluginManager.registerCommand(pluginData.name, "ActSeq_Movement_WaitForScale", _0x45e580 => {
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  const _0xf8ba52 = $gameTemp.getLastPluginCommandInterpreter();
  if (!_0xf8ba52) {
    return;
  }
  _0xf8ba52.setWaitMode("battleGrow");
});
PluginManager.registerCommand(pluginData.name, "ActSeq_Movement_WaitForSkew", _0x450992 => {
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  const _0x3b0a36 = $gameTemp.getLastPluginCommandInterpreter();
  if (!_0x3b0a36) {
    return;
  }
  _0x3b0a36.setWaitMode('battleSpriteSkew');
});
PluginManager.registerCommand(pluginData.name, "ActSeq_Movement_WaitForSpin", _0x197fb8 => {
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  const _0x2457f2 = $gameTemp.getLastPluginCommandInterpreter();
  if (!_0x2457f2) {
    return;
  }
  _0x2457f2.setWaitMode("battleSpin");
});
VisuMZ.BattleCore.CheckActSeqProjectileVersion = function () {
  if (!Imported.VisuMZ_3_ActSeqProjectiles) {
    return;
  }
  if (VisuMZ.ActSeqProjectiles.version < 1.08) {
    let _0x2bf1b6 = '';
    _0x2bf1b6 += "VisuMZ_3_ActSeqProjectiles needs to be updated ";
    _0x2bf1b6 += "in order for VisuMZ_1_BattleCore to work.";
    alert(_0x2bf1b6);
    SceneManager.exit();
  }
};
PluginManager.registerCommand(pluginData.name, "ActSeq_Projectile_Animation", _0x11c0a2 => {
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  if (!Imported.VisuMZ_3_ActSeqProjectiles) {
    return;
  }
  VisuMZ.ConvertParams(_0x11c0a2, _0x11c0a2);
  VisuMZ.BattleCore.CheckActSeqProjectileVersion();
  const _0x4f13c6 = $gameTemp.getLastPluginCommandInterpreter();
  const _0x321a5a = _0x11c0a2.WaitForProjectile;
  if (!_0x4f13c6) {
    return;
  }
  const _0x1535ab = BattleManager._spriteset;
  if (!_0x1535ab) {
    return;
  }
  _0x1535ab.createActionSequenceProjectile(_0x11c0a2);
  if (_0x321a5a) {
    _0x4f13c6.setWaitMode('battleProjectiles');
  }
});
PluginManager.registerCommand(pluginData.name, 'ActSeq_Projectile_Icon', _0x339373 => {
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  if (!Imported.VisuMZ_3_ActSeqProjectiles) {
    return;
  }
  VisuMZ.ConvertParams(_0x339373, _0x339373);
  VisuMZ.BattleCore.CheckActSeqProjectileVersion();
  const _0x561491 = $gameTemp.getLastPluginCommandInterpreter();
  const _0x5c4011 = _0x339373.WaitForProjectile;
  if (!_0x561491) {
    return;
  }
  const _0x54e8e8 = BattleManager._spriteset;
  if (!_0x54e8e8) {
    return;
  }
  _0x54e8e8.createActionSequenceProjectile(_0x339373);
  if (_0x5c4011) {
    _0x561491.setWaitMode("battleProjectiles");
  }
});
PluginManager.registerCommand(pluginData.name, 'ActSeq_Projectile_Picture', _0x169b95 => {
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  if (!Imported.VisuMZ_3_ActSeqProjectiles) {
    return;
  }
  VisuMZ.ConvertParams(_0x169b95, _0x169b95);
  VisuMZ.BattleCore.CheckActSeqProjectileVersion();
  const _0x12197d = $gameTemp.getLastPluginCommandInterpreter();
  const _0x339c37 = _0x169b95.WaitForProjectile;
  if (!_0x12197d) {
    return;
  }
  const _0x3b2b32 = BattleManager._spriteset;
  if (!_0x3b2b32) {
    return;
  }
  _0x3b2b32.createActionSequenceProjectile(_0x169b95);
  if (_0x339c37) {
    _0x12197d.setWaitMode('battleProjectiles');
  }
});
PluginManager.registerCommand(pluginData.name, "ActSeq_ChangeSkew", _0x5d23cd => {
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  if (!Imported.VisuMZ_3_ActSeqCamera) {
    return;
  }
  VisuMZ.ConvertParams(_0x5d23cd, _0x5d23cd);
  const _0x18d351 = $gameTemp.getLastPluginCommandInterpreter();
  const _0x5bbb73 = _0x5d23cd.WaitForSkew;
  if (!_0x18d351) {
    return;
  }
  $gameScreen.setBattleSkew(_0x5d23cd.SkewX, _0x5d23cd.SkewY, _0x5d23cd.Duration, _0x5d23cd.EasingType);
  if (_0x5bbb73) {
    _0x18d351.setWaitMode("battleSkew");
  }
});
PluginManager.registerCommand(pluginData.name, "ActSeq_Skew_Reset", _0x2a657f => {
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  if (!Imported.VisuMZ_3_ActSeqCamera) {
    return;
  }
  VisuMZ.ConvertParams(_0x2a657f, _0x2a657f);
  const _0x4293b9 = $gameTemp.getLastPluginCommandInterpreter();
  const _0x2e8c19 = _0x2a657f.WaitForSkew;
  if (!_0x4293b9) {
    return;
  }
  $gameScreen.setBattleSkew(0x0, 0x0, _0x2a657f.Duration, _0x2a657f.EasingType);
  if (_0x2e8c19) {
    _0x4293b9.setWaitMode('battleSkew');
  }
});
PluginManager.registerCommand(pluginData.name, "ActSeq_Skew_WaitForSkew", _0x1896cc => {
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  if (!Imported.VisuMZ_3_ActSeqCamera) {
    return;
  }
  const _0x5d6c61 = $gameTemp.getLastPluginCommandInterpreter();
  if (!_0x5d6c61) {
    return;
  }
  _0x5d6c61.setWaitMode("battleSkew");
});
PluginManager.registerCommand(pluginData.name, "ActSeq_Target_CurrentIndex", _0x17de2e => {
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  VisuMZ.ConvertParams(_0x17de2e, _0x17de2e);
  const _0x44190e = $gameTemp.getLastPluginCommandInterpreter();
  const _0x3c5fb2 = _0x17de2e.Index;
  const _0x566f8c = _0x17de2e.JumpToLabel;
  if (!_0x44190e) {
    return;
  }
  BattleManager._targetIndex = _0x3c5fb2;
  BattleManager._target = BattleManager._allTargets ? BattleManager._allTargets[BattleManager._targetIndex] || null : null;
  if (BattleManager._target && _0x566f8c.toUpperCase().trim() !== "UNTITLED") {
    _0x44190e.command119([_0x566f8c]);
  }
});
PluginManager.registerCommand(pluginData.name, "ActSeq_Target_NextTarget", _0x1b91bf => {
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  VisuMZ.ConvertParams(_0x1b91bf, _0x1b91bf);
  const _0x4b86a1 = $gameTemp.getLastPluginCommandInterpreter();
  const _0x4666c4 = _0x1b91bf.JumpToLabel;
  if (!_0x4b86a1) {
    return;
  }
  BattleManager._targetIndex++;
  BattleManager._target = BattleManager._allTargets[BattleManager._targetIndex] || null;
  if (BattleManager._target && _0x4666c4.toUpperCase().trim() !== "UNTITLED") {
    _0x4b86a1.command119([_0x4666c4]);
  }
});
PluginManager.registerCommand(pluginData.name, 'ActSeq_Target_PrevTarget', _0x316c22 => {
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  VisuMZ.ConvertParams(_0x316c22, _0x316c22);
  const _0x1ba2de = $gameTemp.getLastPluginCommandInterpreter();
  const _0xd91aea = _0x316c22.JumpToLabel;
  if (!_0x1ba2de) {
    return;
  }
  BattleManager._targetIndex--;
  BattleManager._target = BattleManager._allTargets[BattleManager._targetIndex] || null;
  if (BattleManager._target && _0xd91aea.toUpperCase().trim() !== "UNTITLED") {
    _0x1ba2de.command119([_0xd91aea]);
  }
});
PluginManager.registerCommand(pluginData.name, "ActSeq_Target_RandTarget", _0x13254d => {
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  VisuMZ.ConvertParams(_0x13254d, _0x13254d);
  const _0x3f089f = $gameTemp.getLastPluginCommandInterpreter();
  const _0x5351fa = _0x13254d.ForceRandom;
  const _0x70d7b1 = _0x13254d.JumpToLabel;
  if (!_0x3f089f) {
    return;
  }
  const _0x9a6820 = BattleManager._targetIndex;
  for (;;) {
    BattleManager._targetIndex = Math.randomInt(BattleManager._allTargets.length);
    if (!_0x5351fa) {
      break;
    }
    if (BattleManager._targetIndex !== _0x9a6820) {
      break;
    }
    if (BattleManager._allTargets.length <= 0x1) {
      BattleManager._targetIndex = 0x0;
      break;
    }
  }
  BattleManager._target = BattleManager._allTargets[BattleManager._targetIndex] || null;
  if (BattleManager._target && _0x70d7b1.toUpperCase().trim() !== "UNTITLED") {
    _0x3f089f.command119([_0x70d7b1]);
  }
});
PluginManager.registerCommand(pluginData.name, "ActSeq_BattleVoice_PlayCommonLine", _0x441e0c => {
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  if (!Imported.VisuMZ_3_BattleVoices) {
    return;
  }
  if (!ConfigManager.battleVoices) {
    return;
  }
  VisuMZ.ConvertParams(_0x441e0c, _0x441e0c);
  const _0xf27bf0 = VisuMZ.CreateActionSequenceTargets(_0x441e0c.Targets);
  let _0x3d2d41 = _0x441e0c.VoiceLine || '';
  for (const _0x582069 of _0xf27bf0) {
    if (!_0x582069) {
      continue;
    }
    _0x582069.playBattleVoice(_0x3d2d41);
  }
});
PluginManager.registerCommand(pluginData.name, 'ActSeq_BattleVoice_PlaySpecialLine', _0x24d755 => {
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  if (!Imported.VisuMZ_3_BattleVoices) {
    return;
  }
  if (!ConfigManager.battleVoices) {
    return;
  }
  VisuMZ.ConvertParams(_0x24d755, _0x24d755);
  const _0x334728 = VisuMZ.CreateActionSequenceTargets(_0x24d755.Targets);
  let _0x3cd87f = (_0x24d755.VoiceLineType || '') + (_0x24d755.Letter || '');
  for (const _0x427593 of _0x334728) {
    if (!_0x427593) {
      continue;
    }
    _0x427593.playBattleVoice(_0x3cd87f);
  }
});
PluginManager.registerCommand(pluginData.name, "ActSeq_Weapon_ClearActiveWeapon", _0x383b15 => {
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  VisuMZ.ConvertParams(_0x383b15, _0x383b15);
  const _0x5c9332 = VisuMZ.CreateActionSequenceTargets(_0x383b15.Targets);
  for (const _0x475cc7 of _0x5c9332) {
    if (!_0x475cc7) {
      continue;
    }
    if (!_0x475cc7.isActor()) {
      continue;
    }
    _0x475cc7.clearActiveWeaponSlot();
  }
});
PluginManager.registerCommand(pluginData.name, "ActSeq_Weapon_NextActiveWeapon", _0x2252b9 => {
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  VisuMZ.ConvertParams(_0x2252b9, _0x2252b9);
  const _0x24835e = $gameTemp.getLastPluginCommandInterpreter();
  let _0x1c8325 = false;
  const _0x1944c7 = _0x2252b9.JumpToLabel;
  const _0x59271d = VisuMZ.CreateActionSequenceTargets(_0x2252b9.Targets);
  for (const _0x49c160 of _0x59271d) {
    if (!_0x49c160) {
      continue;
    }
    if (!_0x49c160.isActor()) {
      continue;
    }
    _0x49c160.nextActiveWeaponSlot();
    if (_0x49c160.weapons().length > 0x0) {
      _0x1c8325 = true;
    } else {
      _0x49c160.clearActiveWeaponSlot();
    }
  }
  if (_0x1c8325 && _0x1944c7.toUpperCase().trim() !== "UNTITLED") {
    _0x24835e.command119([_0x1944c7]);
  }
});
PluginManager.registerCommand(pluginData.name, "ActSeq_Weapon_SetActiveWeapon", _0x850e3e => {
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  VisuMZ.ConvertParams(_0x850e3e, _0x850e3e);
  let _0x5260bd = _0x850e3e.SlotID;
  _0x5260bd--;
  _0x5260bd = Math.max(_0x5260bd, 0x0);
  const _0xb4e7de = VisuMZ.CreateActionSequenceTargets(_0x850e3e.Targets);
  for (const _0x5e6ed3 of _0xb4e7de) {
    if (!_0x5e6ed3) {
      continue;
    }
    if (!_0x5e6ed3.isActor()) {
      continue;
    }
    _0x5e6ed3.setActiveWeaponSlot(_0x5260bd);
  }
});
PluginManager.registerCommand(pluginData.name, "ActSeq_Zoom_Scale", _0x2b4497 => {
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  if (!Imported.VisuMZ_3_ActSeqCamera) {
    return;
  }
  VisuMZ.ConvertParams(_0x2b4497, _0x2b4497);
  const _0x2d1b58 = $gameTemp.getLastPluginCommandInterpreter();
  const _0x1caa77 = _0x2b4497.WaitForZoom;
  if (!_0x2d1b58) {
    return;
  }
  $gameScreen.setBattleZoom(_0x2b4497.Scale, _0x2b4497.Duration, _0x2b4497.EasingType);
  if (_0x1caa77) {
    _0x2d1b58.setWaitMode("battleZoom");
  }
});
PluginManager.registerCommand(pluginData.name, "ActSeq_Zoom_Reset", _0x44913b => {
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  if (!Imported.VisuMZ_3_ActSeqCamera) {
    return;
  }
  VisuMZ.ConvertParams(_0x44913b, _0x44913b);
  const _0x21b763 = $gameTemp.getLastPluginCommandInterpreter();
  const _0x4963aa = _0x44913b.WaitForZoom;
  if (!_0x21b763) {
    return;
  }
  $gameScreen.setBattleZoom(0x1, _0x44913b.Duration, _0x44913b.EasingType);
  if (_0x4963aa) {
    _0x21b763.setWaitMode("battleZoom");
  }
});
PluginManager.registerCommand(pluginData.name, "ActSeq_Zoom_WaitForZoom", _0x52160c => {
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  if (!Imported.VisuMZ_3_ActSeqCamera) {
    return;
  }
  const _0x78fbc6 = $gameTemp.getLastPluginCommandInterpreter();
  if (!_0x78fbc6) {
    return;
  }
  _0x78fbc6.setWaitMode("battleZoom");
});
VisuMZ.BattleCore.Scene_Boot_onDatabaseLoaded = Scene_Boot.prototype.onDatabaseLoaded;
Scene_Boot.prototype.onDatabaseLoaded = function () {
  this.process_VisuMZ_BattleCore_Failsafes();
  this.process_VisuMZ_BattleCore_PluginParams();
  this.process_VisuMZ_BattleCore_DamageStyles();
  this.process_VisuMZ_BattleCore_CreateRegExp();
  VisuMZ.BattleCore.Scene_Boot_onDatabaseLoaded.call(this);
  this.process_VisuMZ_BattleCore_Notetags();
  this.process_VisuMZ_BattleCore_BaseTroops();
  this.process_VisuMZ_BattleCore_PreBattleCommonEvent();
  this.process_VisuMZ_BattleCore_CommonEventKeys();
};
Scene_Boot.prototype.process_VisuMZ_BattleCore_Notetags = function () {
  if (VisuMZ.ParseAllNotetags) {
    return;
  }
  this.process_VisuMZ_BattleCore_Action_Notetags();
  this.process_VisuMZ_BattleCore_TraitObject_Notetags();
  this.process_VisuMZ_BattleCore_jsFunctions();
};
Scene_Boot.prototype.process_VisuMZ_BattleCore_Failsafes = function () {
  const _0x4d4876 = $dataSystem.weaponTypes.length;
  for (let _0x295277 = 0x0; _0x295277 < _0x4d4876; _0x295277++) {
    const _0x3c99d1 = $dataSystem.attackMotions[_0x295277];
    if (_0x3c99d1) {
      continue;
    }
    $dataSystem.attackMotions[_0x295277] = {
      'type': 0x1,
      'weaponImageId': 0x1
    };
  }
};
Scene_Boot.prototype.process_VisuMZ_BattleCore_PluginParams = function () {
  const _0x52733b = VisuMZ.BattleCore.Settings;
  if (_0x52733b.Damage.PopupPosition === undefined) {
    _0x52733b.Damage.PopupPosition = "base";
  }
  if (_0x52733b.Actor.SmoothImage === undefined) {
    _0x52733b.Actor.SmoothImage = false;
  }
  if (_0x52733b.Enemy.SmoothImage === undefined) {
    _0x52733b.Enemy.SmoothImage = true;
  }
  if (_0x52733b.Actor.PrioritySortActive === undefined) {
    _0x52733b.Actor.PrioritySortActive = false;
  }
  if (_0x52733b.Actor.PrioritySortActors === undefined) {
    _0x52733b.Actor.PrioritySortActors = true;
  }
};
VisuMZ.DamageStyles = {};
Scene_Boot.prototype.process_VisuMZ_BattleCore_DamageStyles = function () {
  for (const _0x562ecc of VisuMZ.BattleCore.Settings.Damage.DamageStyleList) {
    if (!_0x562ecc) {
      continue;
    }
    const _0xf6a72f = _0x562ecc.Name.toUpperCase().trim();
    VisuMZ.DamageStyles[_0xf6a72f] = _0x562ecc;
  }
};
VisuMZ.BattleCore.RegExp = {
  'jsAccuracy': /<JS (?:ACCURACY|ACC|HIT|EVA)>\s*([\s\S]*?)\s*<\/JS (?:ACCURACY|ACC|HIT|EVA)>/i,
  'jsAccuracyAsUser': /<JS (?:ACCURACY|ACC|HIT|EVA) AS USER>\s*([\s\S]*?)\s*<\/JS (?:ACCURACY|ACC|HIT|EVA) AS USER>/i,
  'jsAccuracyAsTarget': /<JS (?:ACCURACY|ACC|HIT|EVA) AS TARGET>\s*([\s\S]*?)\s*<\/JS (?:ACCURACY|ACC|HIT|EVA) AS TARGET>/i,
  'jsCritRateAsUser': /<JS (?:CRITICAL RATE|CRI) AS USER>\s*([\s\S]*?)\s*<\/JS (?:CRITICAL RATE|CRI) AS USER>/i,
  'jsCritRateAsTarget': /<JS (?:CRITICAL RATE|CRI) AS TARGET>\s*([\s\S]*?)\s*<\/JS (?:CRITICAL RATE|CRI) AS TARGET>/i
};
Scene_Boot.prototype.process_VisuMZ_BattleCore_CreateRegExp = function () {
  const _0x3df1e2 = VisuMZ.BattleCore.RegExp;
  const _0x134a6a = [["Pre", "PRE-"], ["Post", 'POST-']];
  const _0xfe5471 = [["%1Apply%2JS", "JS %1APPLY %2"], ['%1Damage%2JS', "JS %1DAMAGE %2"]];
  const _0x44dc1b = [['', ''], ["AsUser", "AS USER"], ['AsTarget', "AS TARGET"]];
  for (const _0x71740a of _0xfe5471) {
    for (const _0x373626 of _0x44dc1b) {
      for (const _0x38909d of _0x134a6a) {
        const _0x1c4d40 = _0x71740a[0x0].format(_0x38909d[0x0], _0x373626[0x0]);
        const _0x2db1b7 = _0x71740a[0x1].format(_0x38909d[0x1], _0x373626[0x1]).trim();
        const _0x49e74c = new RegExp("<%1>\\s*([\\s\\S]*)\\s*<\\/%1>".format(_0x2db1b7), 'i');
        _0x3df1e2[_0x1c4d40] = _0x49e74c;
      }
    }
  }
  const _0x2eb11b = [['%1StartActionJS', "JS %1START ACTION"], ['%1EndActionJS', "JS %1END ACTION"]];
  for (const _0x4e078d of _0x2eb11b) {
    for (const _0x13193d of _0x134a6a) {
      const _0x26aa21 = _0x4e078d[0x0].format(_0x13193d[0x0]);
      const _0xcd4807 = _0x4e078d[0x1].format(_0x13193d[0x1]);
      const _0x5ccb28 = new RegExp("<%1>\\s*([\\s\\S]*)\\s*<\\/%1>".format(_0xcd4807), 'i');
      _0x3df1e2[_0x26aa21] = _0x5ccb28;
    }
  }
  const _0x9929c1 = [["%1StartBattleJS", "JS %1START BATTLE"], ['%1EndBattleJS', "JS %1END BATTLE"], ["BattleVictoryJS", "JS BATTLE VICTORY"], ["BattleDefeatJS", "JS BATTLE DEFEAT"], ["EscapeSuccessJS", "JS ESCAPE SUCCESS"], ["EscapeFailureJS", "JS ESCAPE FAILURE"], ['%1StartTurnJS', "JS %1START TURN"], ["%1EndTurnJS", "JS %1END TURN"], ['%1RegenerateJS', "JS %1REGENERATE"]];
  for (const _0x1cf95a of _0x9929c1) {
    for (const _0x20162d of _0x134a6a) {
      const _0x7b7ce2 = _0x1cf95a[0x0].format(_0x20162d[0x0]);
      const _0x3c7c91 = _0x1cf95a[0x1].format(_0x20162d[0x1]);
      const _0x60d78d = new RegExp("<%1>\\s*([\\s\\S]*)\\s*<\\/%1>".format(_0x3c7c91), 'i');
      _0x3df1e2[_0x7b7ce2] = _0x60d78d;
    }
  }
};
Scene_Boot.prototype.process_VisuMZ_BattleCore_Action_Notetags = function () {
  const _0x11cb1e = $dataSkills.concat($dataItems);
  for (const _0x24ce3a of _0x11cb1e) {
    if (!_0x24ce3a) {
      continue;
    }
    VisuMZ.BattleCore.Parse_Notetags_Action(_0x24ce3a);
  }
};
Scene_Boot.prototype.process_VisuMZ_BattleCore_TraitObject_Notetags = function () {
  const _0x2a739f = $dataActors.concat($dataClasses, $dataWeapons, $dataArmors, $dataEnemies, $dataStates);
  for (const _0x44f6c6 of _0x2a739f) {
    if (!_0x44f6c6) {
      continue;
    }
    VisuMZ.BattleCore.Parse_Notetags_TraitObjects(_0x44f6c6);
  }
};
Scene_Boot.prototype.process_VisuMZ_BattleCore_BaseTroops = function () {
  const _0x1749fe = VisuMZ.BattleCore.Settings.Mechanics.BaseTroopIDs;
  const _0x818171 = [];
  for (const _0x6e123c of _0x1749fe) {
    const _0x22a7cc = $dataTroops[_0x6e123c];
    if (_0x22a7cc) {
      _0x818171.push(JsonEx.makeDeepCopy(_0x22a7cc));
    }
  }
  for (const _0x217ff3 of $dataTroops) {
    if (!_0x217ff3) {
      continue;
    }
    for (const _0x53c162 of _0x818171) {
      if (_0x53c162.id === _0x217ff3.id) {
        continue;
      }
      _0x217ff3.pages = _0x217ff3.pages.concat(_0x53c162.pages);
    }
  }
};
Scene_Boot.prototype.process_VisuMZ_BattleCore_PreBattleCommonEvent = function () {
  const _0x31af90 = VisuMZ.BattleCore.Settings.Mechanics;
  if (_0x31af90.BattleStartEvent > 0x0 && $dataCommonEvents[_0x31af90.BattleStartEvent]) {
    const _0x40bd33 = $dataCommonEvents[_0x31af90.BattleStartEvent];
    const _0x27ae8a = _0x40bd33.list.length - 0x2;
    const _0x3b9d8a = _0x40bd33.list[_0x27ae8a];
    if (_0x3b9d8a && _0x3b9d8a.code !== 0xe6) {
      const _0x4298cc = {
        'code': 0xe6,
        'indent': 0x0,
        'parameters': [0x1]
      };
      const _0x1283d6 = _0x40bd33.list.pop();
      _0x40bd33.list.unshift(_0x4298cc);
      _0x40bd33.list.unshift(_0x1283d6);
    }
  }
};
Scene_Boot.prototype.process_VisuMZ_BattleCore_CommonEventKeys = function () {
  VisuMZ.BattleCore.CreateCommonEventKeys();
  VisuMZ.BattleCore.BindCommonEventKeysForGroup($dataSkills);
  VisuMZ.BattleCore.BindCommonEventKeysForGroup($dataItems);
};
VisuMZ.BattleCore.CreateCommonEventKeys = function () {
  VisuMZ.BattleCore._commonEventKey = {};
  for (const _0x4a221f of $dataCommonEvents) {
    if (!_0x4a221f) {
      continue;
    }
    if (_0x4a221f.name.match(/\[(.*)\]/i)) {
      let _0x16b26a = String(RegExp.$1).replace(/,/g, '').toUpperCase().trim();
      VisuMZ.BattleCore._commonEventKey[_0x16b26a] = _0x4a221f.id;
    }
  }
};
VisuMZ.BattleCore.BindCommonEventKeysForGroup = function (_0x3cc6c3) {
  for (const _0x1c6cd6 of _0x3cc6c3) {
    if (!_0x1c6cd6) {
      continue;
    }
    VisuMZ.BattleCore.BindCommonEventKeysForObj(_0x1c6cd6);
  }
};
VisuMZ.BattleCore.BindCommonEventKeysForObj = function (_0x2a34dd) {
  if (!_0x2a34dd) {
    return;
  }
  if (!_0x2a34dd.effects) {
    return;
  }
  VisuMZ.BattleCore._commonEventKey = VisuMZ.BattleCore._commonEventKey || {};
  const _0x371f3e = /<COMMON EVENT (?:KEY|KEYS):[ ](.*)>/gi;
  const _0x390509 = /<COMMON EVENT (?:KEY|KEYS)>\s*([\s\S]*)\s*<\/COMMON EVENT (?:KEY|KEYS)>/i;
  let _0x35da6e = [];
  const _0x114652 = _0x2a34dd.note.match(_0x371f3e);
  if (_0x114652) {
    for (const _0x168b90 of _0x114652) {
      _0x168b90.match(_0x371f3e);
      const _0xda989c = String(RegExp.$1).split(',').map(_0x1a3790 => String(_0x1a3790).toUpperCase().trim());
      _0x35da6e = _0x35da6e.concat(_0xda989c);
    }
    if (!_0x2a34dd.note.match(/<CUSTOM ACTION SEQUENCE>/i)) {
      _0x2a34dd.note += "<CUSTOM ACTION SEQUENCE>";
    }
    ;
  }
  if (_0x2a34dd.note.match(_0x390509)) {
    const _0x3fc670 = String(RegExp.$1).split(/[\r\n]+/).map(_0x32cb67 => String(_0x32cb67).toUpperCase().trim());
    _0x35da6e = _0x35da6e.concat(_0x3fc670);
    if (!_0x2a34dd.note.match(/<CUSTOM ACTION SEQUENCE>/i)) {
      _0x2a34dd.note += "<CUSTOM ACTION SEQUENCE>";
    }
    ;
  }
  for (const _0x46a83f of _0x35da6e) {
    if (VisuMZ.BattleCore._commonEventKey[_0x46a83f]) {
      const _0x3031ec = VisuMZ.BattleCore._commonEventKey[_0x46a83f];
      const _0x33132 = {
        'code': 0x2c,
        'dataId': _0x3031ec,
        'value1': 0x1,
        'value2': 0x0
      };
      _0x2a34dd.effects.push(_0x33132);
    }
  }
};
Scene_Boot.prototype.process_VisuMZ_BattleCore_jsFunctions = function () {
  const _0x32a40a = $dataSkills.concat($dataItems);
  for (const _0x4acc08 of _0x32a40a) {
    if (!_0x4acc08) {
      continue;
    }
    VisuMZ.BattleCore.Parse_Notetags_Targets(_0x4acc08);
  }
};
VisuMZ.BattleCore.ParseActorNotetags = VisuMZ.ParseActorNotetags;
VisuMZ.ParseActorNotetags = function (_0x4ce59f) {
  if (VisuMZ.BattleCore.ParseActorNotetags) {
    VisuMZ.BattleCore.ParseActorNotetags.call(this, _0x4ce59f);
  }
  VisuMZ.BattleCore.Parse_Notetags_TraitObjects(_0x4ce59f);
};
VisuMZ.BattleCore.ParseClassNotetags = VisuMZ.ParseClassNotetags;
VisuMZ.ParseClassNotetags = function (_0x58f87b) {
  if (VisuMZ.BattleCore.ParseClassNotetags) {
    VisuMZ.BattleCore.ParseClassNotetags.call(this, _0x58f87b);
  }
  VisuMZ.BattleCore.Parse_Notetags_TraitObjects(_0x58f87b);
};
VisuMZ.BattleCore.ParseSkillNotetags = VisuMZ.ParseSkillNotetags;
VisuMZ.ParseSkillNotetags = function (_0x59cd74) {
  if (VisuMZ.BattleCore.ParseSkillNotetags) {
    VisuMZ.BattleCore.ParseSkillNotetags.call(this, _0x59cd74);
  }
  VisuMZ.BattleCore.Parse_Notetags_Action(_0x59cd74);
  VisuMZ.BattleCore.Parse_Notetags_Targets(_0x59cd74);
};
VisuMZ.BattleCore.ParseItemNotetags = VisuMZ.ParseItemNotetags;
VisuMZ.ParseItemNotetags = function (_0xb8da51) {
  if (VisuMZ.BattleCore.ParseItemNotetags) {
    VisuMZ.BattleCore.ParseItemNotetags.call(this, _0xb8da51);
  }
  VisuMZ.BattleCore.Parse_Notetags_Action(_0xb8da51);
  VisuMZ.BattleCore.Parse_Notetags_Targets(_0xb8da51);
};
VisuMZ.BattleCore.ParseWeaponNotetags = VisuMZ.ParseWeaponNotetags;
VisuMZ.ParseWeaponNotetags = function (_0x26614b) {
  if (VisuMZ.BattleCore.ParseWeaponNotetags) {
    VisuMZ.BattleCore.ParseWeaponNotetags.call(this, _0x26614b);
  }
  VisuMZ.BattleCore.Parse_Notetags_TraitObjects(_0x26614b);
};
VisuMZ.BattleCore.ParseArmorNotetags = VisuMZ.ParseArmorNotetags;
VisuMZ.ParseArmorNotetags = function (_0x39c63b) {
  if (VisuMZ.BattleCore.ParseArmorNotetags) {
    VisuMZ.BattleCore.ParseArmorNotetags.call(this, _0x39c63b);
  }
  VisuMZ.BattleCore.Parse_Notetags_TraitObjects(_0x39c63b);
};
VisuMZ.BattleCore.ParseEnemyNotetags = VisuMZ.ParseEnemyNotetags;
VisuMZ.ParseEnemyNotetags = function (_0x4d696d) {
  if (VisuMZ.BattleCore.ParseEnemyNotetags) {
    VisuMZ.BattleCore.ParseEnemyNotetags.call(this, _0x4d696d);
  }
  VisuMZ.BattleCore.Parse_Notetags_TraitObjects(_0x4d696d);
};
VisuMZ.BattleCore.ParseStateNotetags = VisuMZ.ParseStateNotetags;
VisuMZ.ParseStateNotetags = function (_0x280d26) {
  if (VisuMZ.BattleCore.ParseStateNotetags) {
    VisuMZ.BattleCore.ParseStateNotetags.call(this, _0x280d26);
  }
  VisuMZ.BattleCore.Parse_Notetags_TraitObjects(_0x280d26);
};
VisuMZ.BattleCore.Parse_Notetags_Action = function (_0x15b009) {
  const _0x4f3f0f = ["PreApplyJS", "PostApplyJS", "PreDamageJS", 'PostDamageJS', "PreStartActionJS", "PostStartActionJS", "PreEndActionJS", "PostEndActionJS"];
  for (const _0x501741 of _0x4f3f0f) {
    VisuMZ.BattleCore.createJS(_0x15b009, _0x501741);
  }
  const _0x567df2 = _0x15b009.note;
  if (_0x567df2.match(/<ALWAYS CRITICAL/i)) {
    _0x15b009.damage.critical = true;
  }
  if (_0x567df2.match(/<(?:REPEAT|REPEATS|REPEAT HITS):[ ](\d+)/i)) {
    _0x15b009.repeats = Math.max(0x1, Number(RegExp.$1));
  }
  if (_0x567df2.match(/<TARGET:[ ](.*)>/i)) {
    _0x15b009.scope = String(RegExp.$1).toUpperCase().trim();
  }
};
VisuMZ.BattleCore.Parse_Notetags_TraitObjects = function (_0x477b8d) {
  const _0x38c6a0 = ["PreApplyAsUserJS", 'PostApplyAsUserJS', "PreDamageAsUserJS", "PostDamageAsUserJS", "PreApplyAsTargetJS", "PostApplyAsTargetJS", 'PreDamageAsTargetJS', 'PostDamageAsTargetJS', 'PreStartActionJS', 'PostStartActionJS', "PreEndActionJS", 'PostEndActionJS', "PreStartBattleJS", "PostStartBattleJS", "PreEndBattleJS", "PostEndBattleJS", "BattleVictoryJS", "BattleDefeatJS", "EscapeSuccessJS", "EscapeFailureJS", "PreStartTurnJS", 'PostStartTurnJS', 'PreEndTurnJS', "PostEndTurnJS", "PreRegenerateJS", "PostRegenerateJS"];
  for (const _0x174116 of _0x38c6a0) {
    VisuMZ.BattleCore.createJS(_0x477b8d, _0x174116);
  }
  const _0x18a23e = ["jsAccuracy", "jsAccuracyAsUser", "jsAccuracyAsTarget", "jsCritRateAsUser", "jsCritRateAsTarget"];
  for (const _0x342ed4 of _0x18a23e) {
    VisuMZ.BattleCore.createRateJS(_0x477b8d, _0x342ed4);
  }
};
VisuMZ.BattleCore.Parse_Notetags_Targets = function (_0x3148a2) {
  const _0x1bea01 = _0x3148a2.note;
  if (_0x1bea01.match(/<JS TARGETS>\s*([\s\S]*)\s*<\/JS TARGETS>/i)) {
    const _0x40567e = String(RegExp.$1);
    const _0x3b94ea = VisuMZ.BattleCore.createKeyJS(_0x3148a2, "Targets");
    VisuMZ.BattleCore.createTargetsJS(_0x40567e, _0x3b94ea);
  }
  if (_0x1bea01.match(/<JS COMMAND (?:VISIBLE|SHOW|HIDE)>\s*([\s\S]*)\s*<\/JS COMMAND (?:VISIBLE|SHOW|HIDE)>/i)) {
    const _0x5a049d = String(RegExp.$1);
    const _0x2dfcf3 = VisuMZ.BattleCore.createKeyJS(_0x3148a2, "CommandVisible");
    VisuMZ.BattleCore.createCommandVisibleJS(_0x5a049d, _0x2dfcf3);
  }
};
VisuMZ.BattleCore.JS = {};
VisuMZ.BattleCore.createJS = function (_0x6b91b6, _0x781314) {
  const _0x12c984 = _0x6b91b6.note;
  if (_0x12c984.match(VisuMZ.BattleCore.RegExp[_0x781314])) {
    const _0x16f9d5 = RegExp.$1;
    const _0x15dae1 = "\n            // Declare Arguments\n            const user = arguments[0];\n            const target = arguments[1];\n            const obj = arguments[2];\n            let value = arguments[3] || 0;\n            let originalValue = value;\n\n            // Declare Constants\n            const action = (this.constructor === Game_Action) ? this : user.currentAction();\n            const a = user;\n            const b = target;\n            const attacker = user;\n            const defender = target;\n            const healer = user;\n            const receiver = target;\n            const actor = obj;\n            const currentClass = obj;\n            const skill = (this.constructor === Game_Action) ? this.item() : obj;\n            const item = (this.constructor === Game_Action) ? this.item() : obj;\n            const weapon = obj;\n            const armor = obj;\n            const enemy = obj;\n            const state = obj;\n\n            // Create Compatibility Variables\n            let origin = user;\n            if (Imported.VisuMZ_1_SkillsStatesCore && $dataStates.includes(obj)) {\n                origin = target.getStateOrigin(obj.id);\n            }\n\n            // Process Code\n            try {\n                %1\n            } catch (e) {\n                if ($gameTemp.isPlaytest()) console.log(e);\n            }\n\n            // NaN Check\n            if (isNaN(value)){\n                if ($gameTemp.isPlaytest()) {\n                    console.log('NaN value created by %2'.format('',obj.name));\n                    console.log('Restoring value to %2'.format('',originalValue));\n                }\n                value = originalValue;\n            }\n\n            // Return Value\n            return value;\n        ".format(_0x16f9d5);
    const _0x588fc5 = VisuMZ.BattleCore.createKeyJS(_0x6b91b6, _0x781314);
    VisuMZ.BattleCore.JS[_0x588fc5] = new Function(_0x15dae1);
  }
};
VisuMZ.BattleCore.createKeyJS = function (_0x49ada9, _0x535104) {
  if (VisuMZ.createKeyJS) {
    return VisuMZ.createKeyJS(_0x49ada9, _0x535104);
  }
  let _0x44f749 = '';
  if ($dataActors.includes(_0x49ada9)) {
    _0x44f749 = 'Actor-%1-%2'.format(_0x49ada9.id, _0x535104);
  }
  if ($dataClasses.includes(_0x49ada9)) {
    _0x44f749 = 'Class-%1-%2'.format(_0x49ada9.id, _0x535104);
  }
  if ($dataSkills.includes(_0x49ada9)) {
    _0x44f749 = "Skill-%1-%2".format(_0x49ada9.id, _0x535104);
  }
  if ($dataItems.includes(_0x49ada9)) {
    _0x44f749 = "Item-%1-%2".format(_0x49ada9.id, _0x535104);
  }
  if ($dataWeapons.includes(_0x49ada9)) {
    _0x44f749 = "Weapon-%1-%2".format(_0x49ada9.id, _0x535104);
  }
  if ($dataArmors.includes(_0x49ada9)) {
    _0x44f749 = "Armor-%1-%2".format(_0x49ada9.id, _0x535104);
  }
  if ($dataEnemies.includes(_0x49ada9)) {
    _0x44f749 = "Enemy-%1-%2".format(_0x49ada9.id, _0x535104);
  }
  if ($dataStates.includes(_0x49ada9)) {
    _0x44f749 = "State-%1-%2".format(_0x49ada9.id, _0x535104);
  }
  return _0x44f749;
};
VisuMZ.BattleCore.createTargetsJS = function (_0xf578b5, _0x1d3058) {
  const _0x5495da = "\n        // Declare Arguments\n        const user = arguments[0];\n        const a = user;\n        const b = user;\n        let targets = arguments[1];\n\n        // Process Code\n        try {\n            %1\n        } catch (e) {\n            if ($gameTemp.isPlaytest()) console.log(e);\n        }\n\n        // Return Value\n        return targets || [];\n    ".format(_0xf578b5);
  VisuMZ.BattleCore.JS[_0x1d3058] = new Function(_0x5495da);
};
VisuMZ.BattleCore.createCommandVisibleJS = function (_0x113ff7, _0x4eab59) {
  const _0x4b9092 = "\n        // Declare Arguments\n        const user = arguments[0];\n        const skill = arguments[1];\n        const a = user;\n        const b = user;\n        let visible = true;\n\n        // Process Code\n        try {\n            %1\n        } catch (e) {\n            if ($gameTemp.isPlaytest()) console.log(e);\n        }\n\n        // Return Value\n        return visible;\n    ".format(_0x113ff7);
  VisuMZ.BattleCore.JS[_0x4eab59] = new Function(_0x4b9092);
};
VisuMZ.BattleCore.createRateJS = function (_0x44b97c, _0x31b64c) {
  const _0x1fd191 = _0x44b97c.note;
  if (_0x1fd191.match(VisuMZ.BattleCore.RegExp[_0x31b64c])) {
    const _0x2da1f7 = RegExp.$1;
    const _0x18e84e = "\n            // Declare Arguments\n            const user = arguments[0];\n            const target = arguments[1];\n            const obj = arguments[2];\n            let rate = arguments[3] || 0;\n            let originalRate = rate;\n\n            // Declare Constants\n            const action = (this.constructor === Game_Action) ? this : user.currentAction();\n            const a = user;\n            const b = target;\n            const attacker = user;\n            const defender = target;\n            const healer = user;\n            const receiver = target;\n            const actor = obj;\n            const currentClass = obj;\n            const skill = (this.constructor === Game_Action) ? this.item() : obj;\n            const item = (this.constructor === Game_Action) ? this.item() : obj;\n            const weapon = obj;\n            const armor = obj;\n            const enemy = obj;\n            const state = obj;\n\n            // Create Compatibility Variables\n            let origin = user;\n            if (Imported.VisuMZ_1_SkillsStatesCore && $dataStates.includes(obj)) {\n                origin = target.getStateOrigin(obj.id);\n            }\n\n            // Process Code\n            try {\n                %1\n            } catch (e) {\n                if ($gameTemp.isPlaytest()) console.log(e);\n            }\n\n            // NaN Check\n            if (isNaN(rate)){\n                if ($gameTemp.isPlaytest()) {\n                    console.log('NaN rate created by %2'.format('',obj.name));\n                    console.log('Restoring rate to %2'.format('',originalRate));\n                }\n                value = originalRate;\n            }\n\n            // Return rate\n            return rate;\n        ".format(_0x2da1f7);
    const _0x3f328e = VisuMZ.BattleCore.createKeyJS(_0x44b97c, _0x31b64c);
    VisuMZ.BattleCore.JS[_0x3f328e] = new Function(_0x18e84e);
  }
};
TextManager.autoBattle = VisuMZ.BattleCore.Settings.PartyCmd.CmdTextAutoBattle;
TextManager.autoBattleStart = VisuMZ.BattleCore.Settings.AutoBattle.StartName;
TextManager.autoBattleStyle = VisuMZ.BattleCore.Settings.AutoBattle.StyleName;
TextManager.visualHpGauge = VisuMZ.BattleCore.Settings.HpGauge.Name;
ColorManager.getColor = function (_0x1f583d) {
  _0x1f583d = String(_0x1f583d);
  return _0x1f583d.match(/#(.*)/i) ? "#%1".format(String(RegExp.$1)) : this.textColor(Number(_0x1f583d));
};
DataManager.getDamageStyle = function (_0x4a64ce) {
  if (_0x4a64ce.note.match(/<DAMAGE STYLE:[ ](.*)>/i)) {
    const _0x63adfc = String(RegExp.$1).toUpperCase().trim();
    if (_0x63adfc === 'MANUAL') {
      return "MANUAL";
    }
    if (VisuMZ.DamageStyles[_0x63adfc]) {
      return _0x63adfc;
    }
  }
  const _0x369544 = VisuMZ.BattleCore.Settings.Damage.DefaultDamageStyle.toUpperCase().trim();
  if (VisuMZ.DamageStyles[_0x369544]) {
    return _0x369544;
  }
  return 'MANUAL';
};
DataManager.getStypeIdWithName = function (_0x390f6f) {
  _0x390f6f = _0x390f6f.toUpperCase().trim();
  this._stypeIDs = this._stypeIDs || {};
  if (this._stypeIDs[_0x390f6f]) {
    return this._stypeIDs[_0x390f6f];
  }
  for (let _0x79d11e = 0x1; _0x79d11e < 0x64; _0x79d11e++) {
    if (!$dataSystem.skillTypes[_0x79d11e]) {
      continue;
    }
    let _0x145105 = $dataSystem.skillTypes[_0x79d11e].toUpperCase().trim();
    _0x145105 = _0x145105.replace(/\x1I\[(\d+)\]/gi, '');
    _0x145105 = _0x145105.replace(/\\I\[(\d+)\]/gi, '');
    this._stypeIDs[_0x145105] = _0x79d11e;
  }
  return this._stypeIDs[_0x390f6f] || 0x0;
};
DataManager.getSkillIdWithName = function (_0x2ef05e) {
  _0x2ef05e = _0x2ef05e.toUpperCase().trim();
  this._skillIDs = this._skillIDs || {};
  if (this._skillIDs[_0x2ef05e]) {
    return this._skillIDs[_0x2ef05e];
  }
  for (const _0x3451a8 of $dataSkills) {
    if (!_0x3451a8) {
      continue;
    }
    this._skillIDs[_0x3451a8.name.toUpperCase().trim()] = _0x3451a8.id;
  }
  return this._skillIDs[_0x2ef05e] || 0x0;
};
DataManager.getEnemyIdWithName = function (_0xd0853b) {
  _0xd0853b = _0xd0853b.toUpperCase().trim();
  this._enemyIDs = this._enemyIDs || {};
  if (this._enemyIDs[_0xd0853b]) {
    return this._enemyIDs[_0xd0853b];
  }
  for (const _0x2c46fb of $dataEnemies) {
    if (!_0x2c46fb) {
      continue;
    }
    this._enemyIDs[_0x2c46fb.name.toUpperCase().trim()] = _0x2c46fb.id;
  }
  return this._enemyIDs[_0xd0853b] || 0x0;
};
DataManager.getWtypeIdWithName = function (_0x498211) {
  _0x498211 = _0x498211.toUpperCase().trim();
  this._wtypeIDs = this._wtypeIDs || {};
  if (this._wtypeIDs[_0x498211]) {
    return this._wtypeIDs[_0x498211];
  }
  for (let _0x1ab339 = 0x1; _0x1ab339 < 0x64; _0x1ab339++) {
    if (!$dataSystem.weaponTypes[_0x1ab339]) {
      continue;
    }
    let _0x1ac0c0 = $dataSystem.weaponTypes[_0x1ab339].toUpperCase().trim();
    _0x1ac0c0 = _0x1ac0c0.replace(/\x1I\[(\d+)\]/gi, '');
    _0x1ac0c0 = _0x1ac0c0.replace(/\\I\[(\d+)\]/gi, '');
    this._wtypeIDs[_0x1ac0c0] = _0x1ab339;
  }
  this._wtypeIDs["BARE HANDS"] = 0x0;
  return this._wtypeIDs[_0x498211] || 0x0;
};
DataManager.battleDisplayText = function (_0x227673) {
  let _0x2d1804 = _0x227673.iconIndex;
  let _0x128650 = _0x227673.name;
  const _0x2d9bbd = _0x227673.note;
  if (_0x2d9bbd.match(/<DISPLAY ICON: (\d+)>/i)) {
    _0x2d1804 = Number(RegExp.$1);
  }
  if (_0x2d9bbd.match(/<DISPLAY TEXT: (.*)>/i)) {
    _0x128650 = String(RegExp.$1);
  }
  return "\\I[%1]%2".format(_0x2d1804, _0x128650);
};
DataManager.battleCommandName = function (_0x2f7fa9) {
  return _0x2f7fa9.note.match(/<COMMAND TEXT: (.*)>/i) ? String(RegExp.$1) : _0x2f7fa9.name;
};
DataManager.battleCommandIcon = function (_0x4bd759) {
  return _0x4bd759.note.match(/<COMMAND ICON: (\d+)>/i) ? Number(RegExp.$1) : _0x4bd759.iconIndex;
};
DataManager.swapEnemyIDs = function (_0x16a807) {
  const _0xf1857f = $dataEnemies[_0x16a807];
  if (_0xf1857f) {
    if (_0xf1857f.note.match(/<SWAP ENEMIES>\s*([\s\S]*)\s*<\/SWAP ENEMIES>/i)) {
      const _0x234a65 = String(RegExp.$1).split(/[\r\n]+/).remove('');
      const _0xc97e04 = this.processRandomizedData(_0x234a65);
      _0x16a807 = this.getEnemyIdWithName(_0xc97e04) || _0x16a807;
      _0x16a807 = DataManager.swapEnemyIDs(_0x16a807);
    }
  }
  return _0x16a807;
};
DataManager.processRandomizedData = function (_0x30caa0) {
  let _0x3eac03 = 0x0;
  const _0x1dc56f = {};
  for (const _0x1ab002 of _0x30caa0) {
    if (_0x1ab002.match(/(.*):[ ](\d+)/i)) {
      const _0x41a22e = String(RegExp.$1).trim();
      const _0x31f177 = Number(RegExp.$2);
      _0x1dc56f[_0x41a22e] = _0x31f177;
      _0x3eac03 += _0x31f177;
    } else {
      if (_0x1ab002.match(/(.*):[ ](\d+\.?\d+)/i)) {
        const _0x4be1f7 = String(RegExp.$1).trim();
        const _0x5e47e5 = Number(RegExp.$2);
        _0x1dc56f[_0x4be1f7] = _0x5e47e5;
        _0x3eac03 += _0x5e47e5;
      } else if (_0x1ab002 !== '') {
        _0x1dc56f[_0x1ab002] = 0x1;
        _0x3eac03++;
      }
    }
  }
  if (_0x3eac03 <= 0x0) {
    return '';
  }
  let _0xcc6711 = Math.random() * _0x3eac03;
  for (const _0x5e06cf in _0x1dc56f) {
    _0xcc6711 -= _0x1dc56f[_0x5e06cf];
    if (_0xcc6711 <= 0x0) {
      return _0x5e06cf;
    }
  }
  return '';
};
DataManager.checkAutoCustomActionSequenceNotetagEffect = function (_0x46580d) {
  if (!_0x46580d) {
    return false;
  }
  if (!VisuMZ.BattleCore.Settings.ActionSequence.AutoNotetag) {
    return false;
  }
  if (_0x46580d.note.match(/<AUTO ACTION SEQUENCE>/i)) {
    return false;
  }
  if (_0x46580d.note.match(/<COMMON (?:EVENT|EVENTS):[ ](.*)>/gi)) {
    return true;
  }
  for (const _0x46c2d8 of _0x46580d.effects) {
    if (!_0x46c2d8) {
      continue;
    }
    if (_0x46c2d8.code === Game_Action.EFFECT_COMMON_EVENT) {
      return true;
    }
  }
  return false;
};
DataManager.createTroopNote = function (_0x3732a9) {
  const _0xc83978 = $dataTroops[_0x3732a9];
  if (!_0xc83978) {
    return '';
  }
  let _0x5b707e = '';
  _0x5b707e += _0xc83978.name;
  for (const _0x4bfb12 of _0xc83978.pages) {
    for (const _0x1f80d6 of _0x4bfb12.list) {
      if ([0x6c, 0x198].includes(_0x1f80d6.code)) {
        _0x5b707e += "\n";
        _0x5b707e += _0x1f80d6.parameters[0x0];
      }
    }
  }
  return _0x5b707e;
};
ConfigManager.autoBattleAtStart = ConfigManager.autoBattleAtStart ?? false;
ConfigManager.autoBattleUseSkills = ConfigManager.autoBattleUseSkills ?? false;
ConfigManager.visualHpGauge = ConfigManager.visualHpGauge ?? true;
VisuMZ.BattleCore.ConfigManager_makeData = ConfigManager.makeData;
ConfigManager.makeData = function () {
  const _0x4856ba = VisuMZ.BattleCore.ConfigManager_makeData.call(this);
  _0x4856ba.autoBattleAtStart = this.autoBattleAtStart;
  _0x4856ba.autoBattleUseSkills = this.autoBattleUseSkills;
  _0x4856ba.visualHpGauge = this.visualHpGauge;
  return _0x4856ba;
};
VisuMZ.BattleCore.ConfigManager_applyData = ConfigManager.applyData;
ConfigManager.applyData = function (_0x3fe455) {
  VisuMZ.BattleCore.ConfigManager_applyData.call(this, _0x3fe455);
  if ("autoBattleAtStart" in _0x3fe455) {
    this.autoBattleAtStart = _0x3fe455.autoBattleAtStart;
  } else {
    this.autoBattleAtStart = false;
  }
  if ("autoBattleUseSkills" in _0x3fe455) {
    this.autoBattleUseSkills = _0x3fe455.autoBattleUseSkills;
  } else {
    this.autoBattleUseSkills = false;
  }
  if ("visualHpGauge" in _0x3fe455) {
    this.visualHpGauge = _0x3fe455.visualHpGauge;
  } else {
    this.visualHpGauge = true;
  }
};
ImageManager.svActorHorzCells = ImageManager.svActorHorzCells || 0x9;
ImageManager.svActorVertCells = ImageManager.svActorVertCells || 0x6;
VisuMZ.BattleCore.BattleManager_setup = BattleManager.setup;
BattleManager.setup = function (_0x33afd1, _0x45202d, _0x1a91d7) {
  VisuMZ.BattleCore.BattleManager_setup.call(this, _0x33afd1, _0x45202d, _0x1a91d7);
  this._battlerKeyCache = {};
};
VisuMZ.BattleCore.BattleManager_initMembers = BattleManager.initMembers;
BattleManager.initMembers = function () {
  VisuMZ.BattleCore.BattleManager_initMembers.call(this);
  this._forcedBattlers = [];
};
BattleManager.refreshStatusWindow = function () {
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  const _0x3e4e47 = SceneManager._scene._statusWindow;
  if (_0x3e4e47) {
    _0x3e4e47.requestRefresh();
  }
};
BattleManager.battleSys = function () {
  if (BattleManager.isTpb()) {
    return "TPB";
  }
  return 'DTB';
};
BattleManager.isBattleSys = function (_0x196e63) {
  _0x196e63 = _0x196e63.toUpperCase().trim();
  return this.battleSys() === _0x196e63;
};
BattleManager.isDTB = function () {
  return this.isBattleSys("DTB");
};
BattleManager.isTurnBased = function () {
  return this.isDTB();
};
BattleManager.isTickBased = function () {
  return !this.isTurnBased();
};
BattleManager.isTeamBased = function () {
  return !this.isTurnBased() && !this.isTickBased();
};
BattleManager.getBattlerFromKey = function (_0x45e3e6) {
  this._battlerKeyCache = this._battlerKeyCache || {};
  if (this._battlerKeyCache[_0x45e3e6] !== undefined) {
    return this._battlerKeyCache[_0x45e3e6];
  }
  this._battlerKeyCache[_0x45e3e6] = null;
  const _0xd0e8eb = this.allBattleMembers();
  const _0x374439 = _0xd0e8eb.find(_0x31729b => _0x31729b.battlerKey() === _0x45e3e6);
  if (_0x374439) {
    this._battlerKeyCache[_0x45e3e6] = _0x374439;
  }
  return this._battlerKeyCache[_0x45e3e6];
};
Game_BattlerBase.prototype.battlerKey = function () {
  return "%1-%2".format(this.isActor() ? "actor" : "enemy", this.name());
};
Game_Action.prototype.setTargetBattlerKey = function (_0x4faddb) {
  if (this._targetBattlerKey !== '') {
    return;
  }
  if (typeof _0x4faddb === "string") {
    this._targetBattlerKey = _0x4faddb.toLowerCase().trim();
  } else {
    this._targetBattlerKey = _0x4faddb.battlerKey();
  }
};
Game_Action.prototype.getBattlerKeyTargets = function () {
  return [this.getSpecificBattlerKeyTarget()];
};
Game_Action.prototype.getSpecificBattlerKeyTarget = function () {
  const _0x8eb279 = this._targetBattlerKey || '';
  const _0x579060 = BattleManager.getBattlerFromKey(_0x8eb279);
  if (!_0x579060) {
    return this.getBattlerKeyTargetReplacement();
  }
  if (!_0x579060.isAlive()) {
    return this.getBattlerKeyTargetReplacement();
  }
  return _0x579060;
};
Game_Action.prototype.getBattlerKeyTargetReplacement = function () {
  const _0x98b9cc = this._targetBattlerKey;
  return _0x98b9cc.match(/ACTOR/i) ? this.friendsUnit().trueRandomTarget() : this.opponentsUnit().trueRandomTarget();
};
BattleManager.selectedBattlers = function () {
  return this.allBattleMembers().filter(_0x15cc1f => _0x15cc1f.isSelected());
};
BattleManager.processBattleCoreJS = function (_0x2a2d24) {
  if (_0x2a2d24 === "BattleVictoryJS") {
    this._endingBattle = true;
  }
  $gameParty.processBattleCoreJS(_0x2a2d24);
  $gameTroop.processBattleCoreJS(_0x2a2d24);
};
VisuMZ.BattleCore.BattleManager_startBattle = BattleManager.startBattle;
BattleManager.startBattle = function () {
  this._endBattle = false;
  this._autoBattle = ConfigManager.autoBattleAtStart;
  this._endingBattle = false;
  this.processBattleCoreJS("PreStartBattleJS");
  VisuMZ.BattleCore.BattleManager_startBattle.call(this);
  this.processBattleCoreJS("PostStartBattleJS");
};
BattleManager.processPostBattleCommonEvents = function (_0x2dd0a5) {
  const _0x286920 = VisuMZ.BattleCore.Settings.Mechanics;
  if (_0x2dd0a5 !== "EscapeFail" && _0x286920.BattleEndEvent && VisuMZ.BattleCore.CheckMapBattleEventValid(_0x286920.BattleEndEvent)) {
    $gameTemp.reserveCommonEvent(_0x286920.BattleEndEvent);
  }
  const _0x4c1abb = "%1Event".format(_0x2dd0a5);
  if (_0x286920[_0x4c1abb] && VisuMZ.BattleCore.CheckMapBattleEventValid(_0x286920[_0x4c1abb])) {
    $gameTemp.reserveCommonEvent(_0x286920[_0x4c1abb]);
  }
};
VisuMZ.BattleCore.BattleManager_abort = BattleManager.abort;
BattleManager.abort = function () {
  VisuMZ.BattleCore.BattleManager_abort.call(this);
  if (SceneManager.isSceneBattle()) {
    BattleManager.updateEvent();
  }
};
VisuMZ.BattleCore.BattleManager_checkBattleEnd = BattleManager.checkBattleEnd;
BattleManager.checkBattleEnd = function () {
  if (this._phase === 'turn') {
    if ($gameTemp.isCommonEventReserved()) {
      return false;
    }
  }
  return VisuMZ.BattleCore.BattleManager_checkBattleEnd.call(this);
};
VisuMZ.BattleCore.BattleManager_processVictory = BattleManager.processVictory;
BattleManager.processVictory = function () {
  this._endingBattle = true;
  this.processBattleCoreJS("BattleVictoryJS");
  VisuMZ.BattleCore.BattleManager_processVictory.call(this);
  this.processPostBattleCommonEvents("Victory");
};
VisuMZ.BattleCore.BattleManager_processAbort = BattleManager.processAbort;
BattleManager.processAbort = function () {
  this._endingBattle = true;
  VisuMZ.BattleCore.BattleManager_processAbort.call(this);
};
VisuMZ.BattleCore.BattleManager_processDefeat = BattleManager.processDefeat;
BattleManager.processDefeat = function () {
  this._endingBattle = true;
  this.processBattleCoreJS("BattleDefeatJS");
  VisuMZ.BattleCore.BattleManager_processDefeat.call(this);
  this.processPostBattleCommonEvents("Defeat");
};
VisuMZ.BattleCore.BattleManager_endBattle = BattleManager.endBattle;
BattleManager.endBattle = function (_0x3dd432) {
  this._endBattle = true;
  this._autoBattle = false;
  this.processBattleCoreJS('PreEndBattleJS');
  VisuMZ.BattleCore.BattleManager_endBattle.call(this, _0x3dd432);
  this.processBattleCoreJS("PostEndBattleJS");
};
VisuMZ.BattleCore.BattleManager_startTurn = BattleManager.startTurn;
BattleManager.startTurn = function () {
  if (this.isTurnBased()) {
    this.processBattleCoreJS('PreStartTurnJS');
  }
  VisuMZ.BattleCore.BattleManager_startTurn.call(this);
  if (this.isTurnBased()) {
    this.processBattleCoreJS("PostStartTurnJS");
  }
};
BattleManager.processTurn = function () {
  const _0x1b0b3b = this._subject;
  const _0x57ee38 = _0x1b0b3b.currentAction();
  if (_0x57ee38) {
    _0x57ee38.prepare();
    if (_0x57ee38.isValid()) {
      this.startAction();
      _0x1b0b3b.removeCurrentAction();
    } else {
      _0x1b0b3b.removeCurrentAction();
      this.endAction();
    }
  } else {
    this.endAction();
    this._subject = null;
  }
};
VisuMZ.BattleCore.BattleManager_startAction = BattleManager.startAction;
BattleManager.startAction = function () {
  const _0x489844 = this._subject.currentAction();
  const _0x295dc3 = this._subject;
  if (_0x489844 && _0x489844.subject() === _0x295dc3) {
    _0x489844.actionBattleCoreJS('PreStartActionJS');
  }
  VisuMZ.BattleCore.BattleManager_startAction.call(this);
  if (_0x489844 && _0x489844.subject() === _0x295dc3) {
    _0x489844.actionBattleCoreJS("PostStartActionJS");
  }
};
VisuMZ.BattleCore.BattleManager_endAction = BattleManager.endAction;
BattleManager.endAction = function () {
  const _0x5d6650 = this._action;
  const _0x2b4168 = this._subject;
  if (_0x5d6650 && _0x5d6650 !== this._lastAction && _0x5d6650.subject() === _0x2b4168) {
    _0x5d6650.actionBattleCoreJS('PreEndActionJS');
  }
  if (this._subject) {
    VisuMZ.BattleCore.BattleManager_endAction.call(this);
  } else {
    this._phase = "turn";
  }
  if (_0x5d6650 && _0x5d6650 !== this._lastAction && _0x5d6650.subject() === _0x2b4168) {
    _0x5d6650.actionBattleCoreJS("PostEndActionJS");
  }
  this.refreshBattlerMotions(this.allBattleMembers());
  this._lastAction = this._action;
};
BattleManager.refreshBattlerMotions = function (_0x465fd3) {
  for (const _0x38cad4 of _0x465fd3) {
    if (!_0x38cad4) {
      continue;
    }
    if (!_0x38cad4.battler()) {
      continue;
    }
    _0x38cad4.battler().refreshMotion();
  }
};
BattleManager.updateAction = function () {
  if (!this._logWindow.isBusy()) {
    this.endAction();
  }
};
Game_Battler.prototype.onAllActionsEnd = function () {
  this.clearResult();
  if (Imported.VisuMZ_1_SkillsStatesCore) {
    const _0x3074ee = VisuMZ.SkillsStatesCore.Settings.States;
    if (_0x3074ee && _0x3074ee.ActionEndUpdate === false) {
      this.removeStatesAuto(0x1);
    }
  } else {
    this.removeStatesAuto(0x1);
  }
  this.removeBuffsAuto();
};
BattleManager.makeEscapeRatio = function () {
  this._escapeRatio = VisuMZ.BattleCore.Settings.Mechanics.CalcEscapeRatioJS.call(this);
};
VisuMZ.BattleCore.BattleManager_onEscapeSuccess = BattleManager.onEscapeSuccess;
BattleManager.onEscapeSuccess = function () {
  this.processBattleCoreJS("EscapeSuccessJS");
  BattleManager._spriteset.processEscape();
  VisuMZ.BattleCore.BattleManager_onEscapeSuccess.call(this);
  this.processPostBattleCommonEvents("EscapeSuccess");
};
VisuMZ.BattleCore.BattleManager_onEscapeFailure = BattleManager.onEscapeFailure;
BattleManager.onEscapeFailure = function () {
  this.processBattleCoreJS("EscapeFailureJS");
  const _0x28546b = this._escapeRatio;
  VisuMZ.BattleCore.BattleManager_onEscapeFailure.call(this);
  this._escapeRatio = _0x28546b + VisuMZ.BattleCore.Settings.Mechanics.CalcEscapeRaiseJS.call(this);
  this._inputting = false;
  this.processPostBattleCommonEvents("EscapeFail");
};
BattleManager.displayStartMessages = function () {
  let _0x3d3b76 = false;
  if (this.isDisplayEmergedEnemies()) {
    for (const _0x3876fe of $gameTroop.enemyNames()) {
      this._logWindow.push("addText", TextManager.emerge.format(_0x3876fe));
      this._logWindow.push("wait");
      _0x3d3b76 = true;
    }
  }
  if (this._preemptive) {
    this._logWindow.push("addText", TextManager.preemptive.format($gameParty.name()));
    this._logWindow.push('wait');
  } else if (this._surprise) {
    this._logWindow.push("addText", TextManager.surprise.format($gameParty.name()));
    this._logWindow.push("wait");
  }
  if (_0x3d3b76) {
    this._logWindow.push("wait");
    this._logWindow.push("clear");
  }
  if (this.isTpb() && this.isSkipPartyCommandWindow()) {
    this._tpbNeedsPartyCommand = false;
  }
};
BattleManager.isDisplayEmergedEnemies = function () {
  if (BattleManager._autoBattle) {
    return false;
  }
  return VisuMZ.BattleCore.Settings.Enemy.EmergeText;
};
VisuMZ.BattleCore.BattleManager_startInput = BattleManager.startInput;
BattleManager.startInput = function () {
  VisuMZ.BattleCore.BattleManager_startInput.call(this);
  if (this.isDTB() && this.isSkipPartyCommandWindow() && !this._surprise && $gameParty.canInput()) {
    this.selectNextCommand();
  }
};
BattleManager.isSkipPartyCommandWindow = function () {
  return VisuMZ.BattleCore.Settings.PartyCmd.SkipPartyCmd;
};
BattleManager.checkTpbInputOpen = function () {
  if (this.isPartyTpbInputtable()) {
    this.selectNextCommand();
  }
};
VisuMZ.BattleCore.Scene_Battle_startActorCommandSelection = Scene_Battle.prototype.startActorCommandSelection;
Scene_Battle.prototype.startActorCommandSelection = function () {
  VisuMZ.BattleCore.Scene_Battle_startActorCommandSelection.call(this);
  if (BattleManager.isTpb() && BattleManager._tpbNeedsPartyCommand) {
    BattleManager._tpbNeedsPartyCommand = false;
    this.actorCommandCancelTPB();
  }
};
BattleManager.emulateAction = function (_0x117375, _0x53ceb5, _0x3bd0cc) {
  if (!_0x3bd0cc) {
    return;
  }
  if (!_0x117375) {
    return;
  }
  if (!_0x53ceb5) {
    return;
  }
  const _0x3cbecc = this._action;
  this._action = new Game_Action(_0x117375);
  if (DataManager.isItem(_0x3bd0cc)) {
    this._action.setItem(_0x3bd0cc.id);
  }
  if (DataManager.isSkill(_0x3bd0cc)) {
    this._action.setSkill(_0x3bd0cc.id);
  }
  if (this._action.item()) {
    BattleManager.invokeAction(_0x117375, _0x53ceb5);
  }
  this._action = _0x3cbecc;
};
BattleManager.invokeMagicReflection = function (_0x52c814, _0x1dd882) {
  this._action._reflectionTarget = _0x1dd882;
  this._logWindow.displayReflection(_0x1dd882);
  this._logWindow.displayReflectionPlayBack(_0x52c814, this._action);
  this._action.apply(_0x52c814);
  this._logWindow.displayActionResults(_0x52c814, _0x52c814);
};
VisuMZ.BattleCore.BattleManager_makeActionOrders = BattleManager.makeActionOrders;
BattleManager.makeActionOrders = function () {
  VisuMZ.BattleCore.BattleManager_makeActionOrders.call(this);
  this._actionBattlers = this._actionBattlers.filter(_0x418f17 => _0x418f17 && _0x418f17.isAppeared());
};
VisuMZ.BattleCore.BattleManager_updatePhase = BattleManager.updatePhase;
BattleManager.updatePhase = function (_0x12ba68) {
  if (this._phase === "custom") {
    this.updateCustomActionSequence();
  } else if (this._phase === "forceAction") {
    this.updateForceAction();
  } else {
    VisuMZ.BattleCore.BattleManager_updatePhase.call(this, _0x12ba68);
  }
};
BattleManager.prepareCustomActionSequence = function () {
  this._allTargets = this._targets.slice(0x0);
  this._targetIndex = 0x0;
  this._target = this._allTargets[0x0] || null;
  this._phase = "custom";
};
BattleManager.updateCustomActionSequence = function () {
  if (!this.updateEventMain() && !this._logWindow.isBusy()) {
    this._phase = 'action';
  }
};
BattleManager.forceAction = function (_0x31ef7c) {
  this._actionBattlers.remove(_0x31ef7c);
  if (_0x31ef7c === this._subject) {
    return;
  }
  const _0x4bb724 = JsonEx.makeDeepCopy(_0x31ef7c.currentAction());
  this._forcedBattlers.push([_0x31ef7c, _0x4bb724]);
};
BattleManager.processForcedAction = function () {};
BattleManager.updateStart = function () {
  if (this.isTpb()) {
    this._phase = "turn";
  } else if (this._forcedBattlers.length > 0x0) {
    this._phase = "turn";
  } else {
    this.startInput();
  }
};
BattleManager.getNextSubject = function () {
  const _0xb6ac6 = this._subject;
  if (_0xb6ac6 && this.isTpb()) {
    _0xb6ac6.setActionState("undecided");
  }
  for (;;) {
    const _0xd1b5b0 = this.getNextSubjectFromPool();
    if (!_0xd1b5b0) {
      return null;
    }
    if (_0xd1b5b0.isBattleMember() && _0xd1b5b0.isAlive()) {
      return _0xd1b5b0;
    }
  }
};
BattleManager.getNextSubjectFromPool = function () {
  if (this._forcedBattlers.length > 0x0) {
    const _0x508f2d = this._forcedBattlers.shift();
    const _0x57dfff = _0x508f2d[0x0];
    _0x57dfff._actions = _0x57dfff._actions || [];
    _0x57dfff._actions[0x0] = _0x508f2d[0x1];
    return _0x57dfff;
  } else {
    return this._actionBattlers.shift();
  }
};
VisuMZ.BattleCore.Game_Battler_forceAction = Game_Battler.prototype.forceAction;
Game_Battler.prototype.forceAction = function (_0x1dbd9b, _0x434daa) {
  VisuMZ.BattleCore.Game_Battler_forceAction.call(this, _0x1dbd9b, _0x434daa);
  this._actions[this._actions.length - 0x1]._forceAction = true;
};
Game_Interpreter.prototype.command339 = function (_0x29cc44) {
  this.iterateBattler(_0x29cc44[0x0], _0x29cc44[0x1], _0x1794fe => {
    if (!_0x1794fe.isDeathStateAffected()) {
      _0x1794fe.forceAction(_0x29cc44[0x2], _0x29cc44[0x3]);
      BattleManager.forceAction(_0x1794fe);
    }
  });
  return true;
};
VisuMZ.BattleCore.Game_Battler_makeSpeed = Game_Battler.prototype.makeSpeed;
Game_Battler.prototype.makeSpeed = function () {
  VisuMZ.BattleCore.Game_Battler_makeSpeed.call(this);
  if (this._actions.length <= 0x0) {
    this._speed = Number.MIN_SAFE_INTEGER;
  }
};
BattleManager.shouldHideBattleEndPopups = function () {
  if (VisuMZ.BattleCore.Settings.Damage.EndBattlePopups ?? true) {
    return false;
  }
  return SceneManager.isSceneBattle() && this._endingBattle;
};
VisuMZ.BattleCore.BattleManager_selectNextCommand = BattleManager.selectNextCommand;
BattleManager.selectNextCommand = function () {
  if (this.isTpb()) {
    this.selectNextCommandTpb();
  } else {
    VisuMZ.BattleCore.BattleManager_selectNextCommand.call(this);
  }
};
BattleManager.selectNextCommandTpb = function () {
  if (this._currentActor) {
    if (this._currentActor.selectNextCommand()) {
      return;
    }
    this.finishActorInput();
    this.checkTpbInputClose();
    if (!this._subject && !this._currentActor) {
      SceneManager._scene.updateBattleProcess();
    }
  } else if (!this._subject) {
    this.selectNextActor();
  }
};
BattleManager.checkTpbInputClose = function () {
  if (!this.isPartyTpbInputtable() || this.needsActorInputCancel()) {
    if (this._tpbSceneChangeCacheActor) {
      if (!$gameParty.battleMembers().includes(this._tpbSceneChangeCacheActor)) {
        this._tpbSceneChangeCacheActor = null;
      }
    }
    if (!this._tpbSceneChangeCacheActor) {
      this.cancelActorInput();
      this._currentActor = null;
      this._inputting = false;
    } else {
      this.revertTpbCachedActor();
    }
  }
};
BattleManager.revertTpbCachedActor = function () {
  if (!$gameParty.battleMembers().includes(this._tpbSceneChangeCacheActor)) {
    this._tpbSceneChangeCacheActor = null;
  }
  if (this._tpbSceneChangeCacheActor) {
    this._currentActor = this._tpbSceneChangeCacheActor;
    this._currentActor._tpbState = 'charged';
    this._inputting = true;
    this._tpbSceneChangeCacheActor = null;
  } else {
    this.cancelActorInput();
    this._currentActor = null;
    this._inputting = false;
  }
};
VisuMZ.BattleCore.BattleManager_isTpbMainPhase = BattleManager.isTpbMainPhase;
BattleManager.isTpbMainPhase = function () {
  return this._phase === "custom" ? this.battleCoreTpbMainPhase() : VisuMZ.BattleCore.BattleManager_isTpbMainPhase.call(this);
};
BattleManager.battleCoreTpbMainPhase = function () {
  return this.isActiveTpb();
};
VisuMZ.BattleCore.BattleManager_cancelActorInput = BattleManager.cancelActorInput;
BattleManager.cancelActorInput = function () {
  if (this.isTpb() && this._phase === 'battleEnd') {
    this._currentActor = null;
  }
  VisuMZ.BattleCore.BattleManager_cancelActorInput.call(this);
};
VisuMZ.BattleCore.BattleManager_inputtingAction = BattleManager.inputtingAction;
BattleManager.inputtingAction = function () {
  const _0x6727aa = this._currentActor;
  if (_0x6727aa && !_0x6727aa.inputtingAction()) {
    const _0x39d34f = _0x6727aa._actionInputIndex;
    _0x6727aa._actions[_0x39d34f] = new Game_Action(_0x6727aa);
  }
  return VisuMZ.BattleCore.BattleManager_inputtingAction.call(this);
};
VisuMZ.BattleCore.BattleManager_checkSubstitute = BattleManager.checkSubstitute;
BattleManager.checkSubstitute = function (_0x2099d1) {
  if (this._action.isForFriend()) {
    return false;
  }
  return VisuMZ.BattleCore.BattleManager_checkSubstitute.call(this, _0x2099d1);
};
SceneManager.isSceneBattle = function () {
  return this._scene && this._scene.constructor === Scene_Battle;
};
SceneManager.isBattleFlipped = function () {
  return Spriteset_Battle.prototype.isFlipped();
};
SceneManager.isPreviousSceneBattleTransitionable = function () {
  if (SceneManager.isPreviousScene(Scene_Options)) {
    return true;
  }
  return false;
};
SceneManager.isNextSceneBattleTransitionable = function () {
  if (SceneManager.isNextScene(Scene_Options)) {
    return true;
  }
  return false;
};
SceneManager.checkSceneBattleTransitionable = function (_0x70a620) {
  if (!SceneManager.isSceneBattle()) {
    return true;
  }
  const _0x21bf04 = ["Scene_Options", "Scene_Party", "Scene_QuickLoad"];
  return _0x21bf04.includes(_0x70a620.name);
};
VisuMZ.BattleCore.SceneManager_push = SceneManager.push;
SceneManager.push = function (_0x38d1a4) {
  if (!SceneManager.checkSceneBattleTransitionable(_0x38d1a4)) {
    return this.displayBattleCoreTransitionErrorMsg(_0x38d1a4);
  }
  VisuMZ.BattleCore.SceneManager_push.call(this, _0x38d1a4);
};
SceneManager.displayBattleCoreTransitionErrorMsg = function (_0x36ff65) {
  if (!$gameTemp.isPlaytest()) {
    return;
  }
  if (this._displayBattleCoreTransitionErrorMsg) {
    return;
  }
  this._displayBattleCoreTransitionErrorMsg = true;
  let _0xbec3ff = '';
  _0xbec3ff += "VisuMZ_1_BattleCore does NOT support changing";
  _0xbec3ff += " to %1 midbattle.".format(_0x36ff65.name);
  alert(_0xbec3ff);
};
VisuMZ.BattleCore.Game_Temp_initialize = Game_Temp.prototype.initialize;
Game_Temp.prototype.initialize = function () {
  VisuMZ.BattleCore.Game_Temp_initialize.call(this);
  this._battleBalloonQueue = [];
};
VisuMZ.BattleCore.Game_Temp_requestAnimation = Game_Temp.prototype.requestAnimation;
Game_Temp.prototype.requestAnimation = function (_0x405b75, _0x4b7410, _0x44a192) {
  _0x405b75 = _0x405b75.filter((_0x3379c3, _0xa3e62b, _0x3d6580) => _0x3d6580.indexOf(_0x3379c3) === _0xa3e62b);
  if (SceneManager.isSceneBattle() && SceneManager.isBattleFlipped()) {
    _0x44a192 = !_0x44a192;
  }
  VisuMZ.BattleCore.Game_Temp_requestAnimation.call(this, _0x405b75, _0x4b7410, _0x44a192);
  if (SceneManager.isSceneBattle()) {
    BattleManager._spriteset.processAnimationRequests();
  }
  for (const _0x3cdb10 of _0x405b75) {
    if (_0x3cdb10 && _0x3cdb10.isEnemy && _0x3cdb10.isEnemy()) {
      _0x3cdb10.resetNameTempVisibility();
    }
  }
};
Game_Temp.prototype.setLastPluginCommandInterpreter = function (_0x4dabd4) {
  this._lastPluginCommandInterpreter = _0x4dabd4;
};
Game_Temp.prototype.getLastPluginCommandInterpreter = function () {
  return this._lastPluginCommandInterpreter;
};
Game_Temp.prototype.clearForcedGameTroopSettingsBattleCore = function () {
  this._forcedBattleLayout = undefined;
};
Game_Temp.prototype.applyForcedGameTroopSettingsBattleCore = function (_0x3f393f) {
  if ($gameMap && $dataMap && $dataMap.note) {
    this.parseForcedGameTroopSettingsBattleCore($dataMap.note);
  }
  const _0x476176 = $dataTroops[_0x3f393f];
  if (_0x476176) {
    let _0x372063 = DataManager.createTroopNote(_0x476176.id);
    this.parseForcedGameTroopSettingsBattleCore(_0x372063);
  }
};
Game_Temp.prototype.parseForcedGameTroopSettingsBattleCore = function (_0x3d0ea8) {
  if (!_0x3d0ea8) {
    return;
  }
  if (_0x3d0ea8.match(/<(?:BATTLELAYOUT|BATTLE LAYOUT|LAYOUT):[ ](.*?)>/i)) {
    const _0x49687c = String(RegExp.$1);
    if (_0x49687c.match(/DEFAULT/i)) {
      this._forcedBattleLayout = "default";
    } else {
      if (_0x49687c.match(/LIST/i)) {
        this._forcedBattleLayout = 'list';
      } else {
        if (_0x49687c.match(/XP/i)) {
          this._forcedBattleLayout = 'xp';
        } else {
          if (_0x49687c.match(/PORTRAIT/i)) {
            this._forcedBattleLayout = "portrait";
          } else {
            if (_0x49687c.match(/BORDER/i)) {
              this._forcedBattleLayout = 'border';
            } else {
              if (_0x49687c.match(/(?:SIDEVIEW UI|SIDEVIEW)/i)) {
                if (Imported.VisuMZ_3_SideviewBattleUI) {
                  this._forcedBattleLayout = 'sideview_ui';
                } else {
                  this._forcedBattleLayout = "default";
                }
              } else if (_0x49687c.match(/(?:FRONTVIEW UI|FRONTVIEW)/i)) {
                if (Imported.VisuMZ_3_FrontviewBattleUI) {
                  this._forcedBattleLayout = "frontview_ui";
                } else {
                  this._forcedBattleLayout = "default";
                }
              }
            }
          }
        }
      }
    }
  }
};
VisuMZ.BattleCore.Game_Temp_requestBalloon = Game_Temp.prototype.requestBalloon;
Game_Temp.prototype.requestBalloon = function (_0x50b22c, _0x41d09c) {
  if (SceneManager.isSceneBattle()) {
    this.requestBattleBalloon(_0x50b22c, _0x41d09c);
  } else {
    VisuMZ.BattleCore.Game_Temp_requestBalloon.call(this, _0x50b22c, _0x41d09c);
  }
};
Game_Temp.prototype.requestBattleBalloon = function (_0x33df1c, _0x3ea068) {
  const _0x65a706 = {
    'target': _0x33df1c,
    'balloonId': _0x3ea068
  };
  this._battleBalloonQueue = this._battleBalloonQueue || [];
  this._battleBalloonQueue.push(_0x65a706);
};
Game_Temp.prototype.retrieveBattleBalloon = function () {
  this._battleBalloonQueue = this._battleBalloonQueue || [];
  return this._battleBalloonQueue.shift();
};
Game_Temp.prototype.clearBattleBalloons = function () {
  this._battleBalloonQueue = [];
};
Spriteset_Battle.prototype.updateBattleBalloons = function () {
  if (this._battleBalloonSprites === undefined) {
    this._battleBalloonSprites = [];
  }
  for (const _0x286b90 of this._battleBalloonSprites) {
    if (!_0x286b90.isPlaying()) {
      this.removeBattleBalloon(_0x286b90);
    }
  }
  this.processBattleBalloonRequests();
};
Spriteset_Battle.prototype.processBattleBalloonRequests = function () {
  for (;;) {
    const _0xf09245 = $gameTemp.retrieveBattleBalloon();
    if (_0xf09245) {
      this.createBattleBalloon(_0xf09245);
    } else {
      break;
    }
  }
};
Spriteset_Battle.prototype.createBattleBalloon = function (_0x33a9e7) {
  const _0x47cfe1 = this.findTargetSprite(_0x33a9e7.target);
  if (_0x47cfe1) {
    let _0x12e0fe = null;
    if (Imported.VisuMZ_4_IconBalloons && Array.isArray(_0x33a9e7.balloonId)) {
      _0x12e0fe = new Sprite_IconBalloon();
    } else {
      _0x12e0fe = new Sprite_Balloon();
    }
    _0x12e0fe.targetObject = _0x33a9e7.target;
    _0x12e0fe._target = _0x47cfe1;
    _0x12e0fe._target._character = _0x47cfe1;
    _0x12e0fe.setup(_0x47cfe1, _0x33a9e7.balloonId);
    BattleManager.addChildToUiContainer(_0x12e0fe);
    this._battleBalloonSprites.push(_0x12e0fe);
  }
};
Spriteset_Battle.prototype.removeBattleBalloon = function (_0x1c9d6c) {
  this._battleBalloonSprites.remove(_0x1c9d6c);
  BattleManager.removeChildFromUiContainer(_0x1c9d6c);
  _0x1c9d6c.destroy();
};
Sprite_Battler.prototype.setBalloonPose = function (_0x4fff56, _0x3de888) {};
Sprite_Battler.prototype.isSpriteVS8dir = function () {
  return false;
};
Spriteset_Battle.prototype.isAnyBattleBalloonPlaying = function () {
  this._battleBalloonSprites = this._battleBalloonSprites || [];
  return this._battleBalloonSprites.length > 0x0;
};
VisuMZ.BattleCore.Game_System_initialize = Game_System.prototype.initialize;
Game_System.prototype.initialize = function () {
  VisuMZ.BattleCore.Game_System_initialize.call(this);
  this.initBattleCore();
};
Game_System.prototype.initBattleCore = function () {
  this._defeatedEnemies = this._defeatedEnemies || [];
};
Game_System.prototype.getDefeatedEnemies = function () {
  if (this._defeatedEnemies === undefined) {
    this.initBattleCore();
  }
  return this._defeatedEnemies;
};
Game_System.prototype.registerDefeatedEnemy = function (_0x546f81) {
  if (this._defeatedEnemies === undefined) {
    this.initBattleCore();
  }
  if (!_0x546f81) {
    return;
  }
  if (this._defeatedEnemies.includes(_0x546f81)) {
    return;
  }
  this._defeatedEnemies.push(_0x546f81);
  this._defeatedEnemies.sort((_0x387cc4, _0x3aaedb) => _0x387cc4 - _0x3aaedb);
};
VisuMZ.BattleCore.Game_BattlerBase_addNewState = Game_BattlerBase.prototype.addNewState;
Game_BattlerBase.prototype.addNewState = function (_0x505124) {
  const _0xf52fd8 = this.isAlive();
  const _0x4945c6 = this.stateMotionIndex();
  VisuMZ.BattleCore.Game_BattlerBase_addNewState.call(this, _0x505124);
  if (this.isEnemy() && _0xf52fd8 && this.isDead()) {
    this._visualHpGauge_JustDied = !this.hasBeenDefeatedBefore();
    $gameSystem.registerDefeatedEnemy(this.enemyId());
  }
  if (SceneManager.isSceneBattle() && _0x4945c6 !== this.stateMotionIndex()) {
    if (this.battler()) {
      this.battler().refreshMotion();
    }
  }
};
Game_Enemy.prototype.hasBeenDefeatedBefore = function () {
  return $gameSystem.getDefeatedEnemies().includes(this._enemyId);
};
VisuMZ.BattleCore.Game_BattlerBase_eraseState = Game_BattlerBase.prototype.eraseState;
Game_BattlerBase.prototype.eraseState = function (_0x23505c) {
  VisuMZ.BattleCore.Game_BattlerBase_eraseState.call(this, _0x23505c);
  if (this.isEnemy() && _0x23505c === this.deathStateId() && this.isAlive()) {
    this._visualHpGauge_JustDied = false;
  }
  if (!this._tempActor && !this._tempBattler && SceneManager.isSceneBattle()) {
    this.requestMotionRefresh();
  }
};
VisuMZ.BattleCore.Game_Action_clear = Game_Action.prototype.clear;
Game_Action.prototype.clear = function () {
  VisuMZ.BattleCore.Game_Action_clear.call(this);
  this._armorPenetration = {
    'arPenRate': 0x0,
    'arPenFlat': 0x0,
    'arRedRate': 0x0,
    'arRedFlat': 0x0
  };
  this._multipliers = {
    'criticalHitRate': 0x1,
    'criticalHitFlat': 0x0,
    'criticalDmgRate': 0x1,
    'criticalDmgFlat': 0x0,
    'damageRate': 0x1,
    'damageFlat': 0x0,
    'hitRate': 0x1,
    'hitFlat': 0x0
  };
  this._customDamageFormula = 'default';
  this.clearTargetBattlerKey();
};
Game_Action.prototype.clearTargetBattlerKey = function () {
  this._targetBattlerKey = '';
};
VisuMZ.BattleCore.Game_Action_setSubject = Game_Action.prototype.setSubject;
Game_Action.prototype.setSubject = function (_0x72414b) {
  VisuMZ.BattleCore.Game_Action_setSubject.call(this, _0x72414b);
  this.clearTargetBattlerKey();
};
VisuMZ.BattleCore.Game_Action_setSkill = Game_Action.prototype.setSkill;
Game_Action.prototype.setSkill = function (_0x3db08b) {
  VisuMZ.BattleCore.Game_Action_setSkill.call(this, _0x3db08b);
  this.clearTargetBattlerKey();
};
VisuMZ.BattleCore.Game_Action_setItem = Game_Action.prototype.setItem;
Game_Action.prototype.setItem = function (_0xb9215) {
  VisuMZ.BattleCore.Game_Action_setItem.call(this, _0xb9215);
  this.clearTargetBattlerKey();
};
Game_Action.prototype.makeDamageValue = function (_0x16981c, _0x5f5a42) {
  return VisuMZ.BattleCore.Settings.Damage.OverallFormulaJS.call(this, _0x16981c, _0x5f5a42);
};
Game_Action.prototype.applyVariance = function (_0x141872, _0x183937) {
  return VisuMZ.BattleCore.Settings.Damage.VarianceFormulaJS.call(this, _0x141872, _0x183937);
};
Game_Action.prototype.applyGuard = function (_0x4f09e7, _0x430e30) {
  return VisuMZ.BattleCore.Settings.Damage.GuardFormulaJS.call(this, _0x4f09e7, _0x430e30);
};
VisuMZ.BattleCore.Game_Action_itemHit = Game_Action.prototype.itemHit;
Game_Action.prototype.itemHit = function (_0x1a1edd) {
  const _0x42955c = this.item().note;
  if (_0x42955c.match(/<ALWAYS HIT>/i)) {
    return 0x1;
  } else {
    if (_0x42955c.match(/<ALWAYS HIT RATE: (\d+)([%])>/i)) {
      return Number(RegExp.$1) / 0x64;
    } else {
      let _0x2d3ed9 = VisuMZ.BattleCore.Game_Action_itemHit.call(this, _0x1a1edd);
      _0x2d3ed9 = this._multipliers.hitRate * _0x2d3ed9 + this._multipliers.hitFlat;
      if ($gameParty.inBattle()) {
        _0x2d3ed9 = this.applyBattleCoreHitRateJS(_0x2d3ed9, _0x1a1edd);
      }
      return _0x2d3ed9;
    }
  }
};
VisuMZ.BattleCore.Game_Action_updateLastTarget = Game_Action.prototype.updateLastTarget;
Game_Action.prototype.updateLastTarget = function (_0x44079c) {
  this._bypass_applyBattleCoreHitRateJS = true;
  VisuMZ.BattleCore.Game_Action_updateLastTarget.call(this, _0x44079c);
  this._bypass_applyBattleCoreHitRateJS = undefined;
};
Game_Action.prototype.declareGlobalVariables = function (_0x33e75b) {
  window.action = this;
  window.a = this.subject();
  window.b = _0x33e75b;
  window.user = this.subject();
  window.target = _0x33e75b;
  window.obj = this.item();
  window.skill = this.item();
  window.item = this.item();
};
Game_Action.prototype.clearGlobalVariables = function (_0x35081e) {
  window.action = undefined;
  window.a = undefined;
  window.b = undefined;
  window.user = undefined;
  window.target = undefined;
  window.obj = undefined;
  window.skill = undefined;
  window.item = undefined;
};
Game_Action.prototype.applyBattleCoreHitRateJS = function (_0x20aabd, _0x372d54) {
  if (this._bypass_applyBattleCoreHitRateJS) {
    return _0x20aabd;
  }
  this.declareGlobalVariables(_0x372d54);
  if (this.item()) {
    let _0x4800ca = VisuMZ.BattleCore.createKeyJS(this.item(), "jsAccuracy");
    if (VisuMZ.BattleCore.JS[_0x4800ca]) {
      _0x20aabd = VisuMZ.BattleCore.JS[_0x4800ca].call(this, this.subject(), _0x372d54, this.item(), _0x20aabd);
    }
  }
  for (const _0x4db9aa of this.subject().traitObjects()) {
    if (!_0x4db9aa) {
      continue;
    }
    key = VisuMZ.BattleCore.createKeyJS(_0x4db9aa, "jsAccuracyAsUser");
    if (VisuMZ.BattleCore.JS[key]) {
      _0x20aabd = VisuMZ.BattleCore.JS[key].call(this, this.subject(), _0x372d54, this.item(), _0x20aabd);
    }
  }
  for (const _0x343faa of _0x372d54.traitObjects()) {
    if (!_0x343faa) {
      continue;
    }
    key = VisuMZ.BattleCore.createKeyJS(_0x343faa, "jsAccuracyAsTarget");
    if (VisuMZ.BattleCore.JS[key]) {
      _0x20aabd = VisuMZ.BattleCore.JS[key].call(this, this.subject(), _0x372d54, this.item(), _0x20aabd);
    }
  }
  this.clearGlobalVariables(_0x372d54);
  return _0x20aabd;
};
Game_Action.prototype.itemCri = function (_0x5b32db) {
  if (!this.item().damage.critical) {
    return 0x0;
  }
  let _0x286c1d = VisuMZ.BattleCore.Settings.Damage.CriticalHitRateJS.call(this, _0x5b32db);
  _0x286c1d = this._multipliers.criticalHitRate * _0x286c1d + this._multipliers.criticalHitFlat;
  if ($gameParty.inBattle()) {
    _0x286c1d = this.applyBattleCoreCriticalHitRateJS(_0x286c1d, _0x5b32db);
  }
  return _0x286c1d;
};
Game_Action.prototype.applyBattleCoreCriticalHitRateJS = function (_0x1775f1, _0x497ec1) {
  this.declareGlobalVariables(_0x497ec1);
  window.rate = _0x1775f1;
  {
    const _0x4e9165 = this.subject().traitObjects();
    for (const _0x57b45a of _0x4e9165) {
      if (!_0x57b45a) {
        continue;
      }
      if (_0x57b45a.note.match(/<JS (?:CRITICAL RATE|CRI) AS USER>\s*([\s\S]*?)\s*<\/JS (?:CRITICAL RATE|CRI) AS USER>/i)) {
        const _0x127204 = String(RegExp.$1);
        try {
          eval(_0x127204);
        } catch (_0x1be42e) {
          if ($gameTemp.isPlaytest()) {
            console.log(_0x1be42e);
          }
        }
      }
    }
  }
  {
    const _0x2ebca9 = _0x497ec1.traitObjects();
    for (const _0xc9829a of _0x2ebca9) {
      if (!_0xc9829a) {
        continue;
      }
      if (_0xc9829a.note.match(/<JS (?:CRITICAL RATE|CRI) AS TARGET>\s*([\s\S]*?)\s*<\/JS (?:CRITICAL RATE|CRI) AS TARGET>/i)) {
        const _0x3faf1f = String(RegExp.$1);
        try {
          eval(_0x3faf1f);
        } catch (_0x1f8136) {
          if ($gameTemp.isPlaytest()) {
            console.log(_0x1f8136);
          }
        }
      }
    }
  }
  _0x1775f1 = window.rate;
  this.clearGlobalVariables(_0x497ec1);
  return _0x1775f1;
};
Game_Action.prototype.applyBattleCoreCriticalHitRateJS = function (_0x155fb9, _0x40f9d6) {
  this.declareGlobalVariables(_0x40f9d6);
  for (const _0x2c196a of this.subject().traitObjects()) {
    if (!_0x2c196a) {
      continue;
    }
    key = VisuMZ.BattleCore.createKeyJS(_0x2c196a, "jsCritRateAsUser");
    if (VisuMZ.BattleCore.JS[key]) {
      _0x155fb9 = VisuMZ.BattleCore.JS[key].call(this, this.subject(), _0x40f9d6, this.item(), _0x155fb9);
    }
  }
  for (const _0x399a0d of _0x40f9d6.traitObjects()) {
    if (!_0x399a0d) {
      continue;
    }
    key = VisuMZ.BattleCore.createKeyJS(_0x399a0d, "jsCritRateAsTarget");
    if (VisuMZ.BattleCore.JS[key]) {
      _0x155fb9 = VisuMZ.BattleCore.JS[key].call(this, this.subject(), _0x40f9d6, this.item(), _0x155fb9);
    }
  }
  this.clearGlobalVariables(_0x40f9d6);
  return _0x155fb9;
};
Game_Action.prototype.applyCritical = function (_0x3ce8a6) {
  _0x3ce8a6 = VisuMZ.BattleCore.Settings.Damage.CriticalHitMultiplier.call(this, _0x3ce8a6);
  _0x3ce8a6 = this._multipliers.criticalDmgRate * _0x3ce8a6 + this._multipliers.criticalDmgFlat;
  return _0x3ce8a6;
};
VisuMZ.BattleCore.Game_Action_evalDamageFormula = Game_Action.prototype.evalDamageFormula;
Game_Action.prototype.evalDamageFormula = function (_0xbde308) {
  if (this._customDamageFormula !== 'default') {
    return this.customDamageFormula(_0xbde308);
  } else {
    return DataManager.getDamageStyle(this.item()) === "MANUAL" ? VisuMZ.BattleCore.Game_Action_evalDamageFormula.call(this, _0xbde308) : this.evalDamageFormulaBattleCore(_0xbde308);
  }
};
Game_Action.prototype.setCustomDamageFormula = function (_0x5343f2) {
  this._customDamageFormula = _0x5343f2;
};
Game_Action.prototype.customDamageFormula = function (_0x4a597f) {
  const _0x3fb633 = this.item();
  const _0x270079 = _0x3fb633.damage.formula;
  _0x3fb633.damage.formula = this._customDamageFormula;
  let _0x2ccee7 = VisuMZ.BattleCore.Game_Action_evalDamageFormula.call(this, _0x4a597f);
  _0x3fb633.damage.formula = _0x270079;
  return _0x2ccee7;
};
Game_Action.prototype.damageStyle = function () {
  if (this.item().note.match(/<DAMAGE STYLE:[ ](.*)>/i)) {
    const _0x2522c7 = String(RegExp.$1).toUpperCase().trim();
    return _0x2522c7;
  }
  return "MANUAL";
};
Game_Action.prototype.evalDamageFormulaBattleCore = function (_0x2ed7c3) {
  const _0x14370d = DataManager.getDamageStyle(this.item());
  const _0x483cd2 = VisuMZ.DamageStyles[_0x14370d];
  try {
    return _0x483cd2.Formula.call(this, _0x2ed7c3);
  } catch (_0x590b5d) {
    if ($gameTemp.isPlaytest()) {
      console.log(_0x590b5d);
    }
    return VisuMZ.BattleCore.Game_Action_evalDamageFormula.call(this);
  }
};
Game_Action.prototype.applyArmorModifiers = function (_0x25be4f, _0x476345) {
  if (this.isCertainHit()) {
    return _0x476345;
  }
  const _0x272ad8 = this.subject();
  let _0x2d3197 = [];
  let _0xe24a57 = [];
  _0x2d3197.push(this._armorPenetration.arPenFlat, this._armorPenetration.arRedFlat);
  _0xe24a57.push(this._armorPenetration.arPenRate, this._armorPenetration.arRedRate);
  const _0x515411 = this.isPhysical() ? /<ARMOR REDUCTION:[ ](\d+\.?\d*)>/i : /<MAGIC REDUCTION:[ ](\d+\.?\d*)>/i;
  const _0x488426 = this.isPhysical() ? /<ARMOR REDUCTION:[ ](\d+\.?\d*)([%])>/i : /<MAGIC REDUCTION:[ ](\d+\.?\d*)([%])>/i;
  const _0x4a465b = this.isPhysical() ? /<ARMOR PENETRATION:[ ](\d+\.?\d*)>/i : /<MAGIC PENETRATION:[ ](\d+\.?\d*)>/i;
  const _0x52c70e = this.isPhysical() ? /<ARMOR PENETRATION:[ ](\d+\.?\d*)([%])>/i : /<MAGIC PENETRATION:[ ](\d+\.?\d*)([%])>/i;
  _0x2d3197 = _0x2d3197.concat(_0x25be4f.traitObjects().map(_0x45e32d => _0x45e32d && _0x45e32d.note.match(_0x515411) ? Number(RegExp.$1) : 0x0));
  _0xe24a57 = _0xe24a57.concat(_0x25be4f.traitObjects().map(_0x5943c0 => _0x5943c0 && _0x5943c0.note.match(_0x488426) ? Number(RegExp.$1) / 0x64 : 0x0));
  _0x2d3197 = _0x2d3197.concat(_0x272ad8.traitObjects().map(_0x50f963 => _0x50f963 && _0x50f963.note.match(_0x4a465b) ? Number(RegExp.$1) : 0x0));
  _0xe24a57 = _0xe24a57.concat(_0x272ad8.traitObjects().map(_0x4fce3a => _0x4fce3a && _0x4fce3a.note.match(_0x52c70e) ? Number(RegExp.$1) / 0x64 : 0x0));
  if (this.item().note.match(_0x4a465b)) {
    _0x2d3197.push(Number(RegExp.$1));
  }
  if (this.item().note.match(_0x52c70e)) {
    _0xe24a57.push(Number(RegExp.$1));
  }
  _0x476345 = _0x2d3197.reduce((_0x210ac2, _0x167001) => _0x210ac2 - _0x167001, _0x476345);
  if (_0x476345 > 0x0) {
    _0x476345 = _0xe24a57.reduce((_0x4e60ce, _0x426196) => _0x4e60ce * (0x1 - _0x426196), _0x476345);
  }
  return _0x476345;
};
VisuMZ.BattleCore.Game_Action_executeDamage = Game_Action.prototype.executeDamage;
Game_Action.prototype.executeDamage = function (_0x27223d, _0x115067) {
  _0x115067 = _0x115067 * this._multipliers.damageRate;
  _0x115067 += this._multipliers.damageFlat * (_0x115067 >= 0x0 ? 0x1 : -0x1);
  _0x115067 = this.applyBattleCoreJS('PreDamage%1JS', _0x27223d, _0x115067, false);
  _0x115067 = this.applyDamageCaps(_0x115067);
  if (_0x115067 > 0x0) {
    _0x115067 = Math.ceil(_0x115067);
  } else {
    _0x115067 = Math.floor(_0x115067);
  }
  this._executedValue = _0x115067;
  this._totalValue = this._totalValue || 0x0;
  this._totalValue += _0x115067;
  VisuMZ.BattleCore.Game_Action_executeDamage.call(this, _0x27223d, _0x115067);
  this.applyBattleCoreJS('PostDamage%1JS', _0x27223d, _0x115067, true);
};
Game_Action.prototype.applyDamageCaps = function (_0x5608d4) {
  if (this.isBypassDamageCap()) {
    return _0x5608d4;
  }
  _0x5608d4 = this.applySoftDamageCap(_0x5608d4);
  _0x5608d4 = this.applyHardDamageCap(_0x5608d4);
  return _0x5608d4;
};
Game_Action.prototype.isBypassDamageCap = function () {
  const _0x1c0ff8 = /<BYPASS DAMAGE CAP>/i;
  if (this.item().note.match(_0x1c0ff8)) {
    return true;
  }
  if (this.subject().traitObjects().some(_0x2a994e => _0x2a994e && _0x2a994e.note.match(_0x1c0ff8))) {
    return true;
  }
  return !VisuMZ.BattleCore.Settings.Damage.EnableDamageCap;
};
Game_Action.prototype.applySoftDamageCap = function (_0x6d201d) {
  if (!VisuMZ.BattleCore.Settings.Damage.EnableSoftCap) {
    return _0x6d201d;
  }
  const _0x46e3c8 = /<BYPASS SOFT DAMAGE CAP>/i;
  if (this.item().note.match(_0x46e3c8)) {
    return _0x6d201d;
  }
  if (this.subject().traitObjects().some(_0x4f5795 => _0x4f5795 && _0x4f5795.note.match(_0x46e3c8))) {
    return _0x6d201d;
  }
  const _0x2d91fb = _0x6d201d < 0x0 ? -0x1 : 0x1;
  _0x6d201d = Math.abs(_0x6d201d);
  let _0x32971c = this.subject().softDamageCapRate();
  if (this.item().note.match(/<SOFT DAMAGE CAP:[ ]([\+\-]\d+)([%])>/i)) {
    _0x32971c += Number(RegExp.$1) / 0x64;
  }
  _0x32971c = _0x32971c.clamp(0.01, 0x1);
  const _0x1cb4f2 = this.getHardDamageCap();
  const _0x5b08c6 = _0x32971c * _0x1cb4f2;
  if (_0x6d201d > _0x5b08c6 && _0x1cb4f2 > _0x5b08c6) {
    _0x6d201d -= _0x5b08c6;
    const _0x4e1a01 = VisuMZ.BattleCore.Settings.Damage.DefaultSoftScaler;
    const _0x4fc50e = Math.max(0x1 - _0x6d201d / ((_0x1cb4f2 - _0x5b08c6) * _0x4e1a01 + _0x6d201d), 0.01);
    _0x6d201d *= _0x4fc50e;
    _0x6d201d += _0x5b08c6;
  }
  return _0x6d201d * _0x2d91fb;
};
Game_Action.prototype.getHardDamageCap = function () {
  return this.item().note.match(/<DAMAGE CAP:[ ](\d+)>/i) ? Number(RegExp.$1) : this.subject().hardDamageCap();
};
Game_Action.prototype.applyHardDamageCap = function (_0x7c5e12) {
  let _0x3e5d04 = this.getHardDamageCap();
  return _0x7c5e12.clamp(-_0x3e5d04, _0x3e5d04);
};
Game_Action.prototype.shouldDisperseDamage = function () {
  if (!this.item()) {
    return false;
  }
  if (!$gameParty.inBattle()) {
    return false;
  }
  return (this.item().note || '').match(/<DISPERSE DAMAGE>/i);
};
Game_Action.prototype.disperseDamage = function (_0x22bbf9) {
  if (this.shouldDisperseDamage()) {
    let _0xab8bb7 = BattleManager._targets;
    _0x22bbf9 /= _0xab8bb7.length;
    if (this.isAttack()) {
      _0x22bbf9 *= this.subject().attackTimesAdd() + 0x1;
    }
    _0x22bbf9 = _0x22bbf9 > 0x0 ? Math.ceil(_0x22bbf9) : Math.floor(_0x22bbf9);
  }
  return _0x22bbf9;
};
VisuMZ.BattleCore.Game_Action_makeDamageValueDisperse = Game_Action.prototype.makeDamageValue;
Game_Action.prototype.makeDamageValue = function (_0x421ee7, _0x4593ff) {
  let _0x42b438 = VisuMZ.BattleCore.Game_Action_makeDamageValueDisperse.call(this, _0x421ee7, _0x4593ff);
  return this.disperseDamage(_0x42b438);
};
Game_Action.prototype.itemEffectRecoverHp = function (_0x134143, _0x34a5fc) {
  let _0x9b2391 = (_0x134143.mhp * _0x34a5fc.value1 + _0x34a5fc.value2) * _0x134143.rec;
  _0x9b2391 = this.disperseDamage(_0x9b2391);
  if (this.isItem()) {
    _0x9b2391 *= this.subject().pha;
  }
  _0x9b2391 = Math.floor(_0x9b2391);
  if (_0x9b2391 !== 0x0) {
    _0x134143.gainHp(_0x9b2391);
    this.makeSuccess(_0x134143);
  }
};
Game_Action.prototype.itemEffectRecoverMp = function (_0x212589, _0x22d757) {
  let _0x21fbf4 = (_0x212589.mmp * _0x22d757.value1 + _0x22d757.value2) * _0x212589.rec;
  _0x21fbf4 = this.disperseDamage(_0x21fbf4);
  if (this.isItem()) {
    _0x21fbf4 *= this.subject().pha;
  }
  _0x21fbf4 = Math.floor(_0x21fbf4);
  if (_0x21fbf4 !== 0x0) {
    _0x212589.gainMp(_0x21fbf4);
    this.makeSuccess(_0x212589);
  }
};
Game_Action.prototype.itemEffectGainTp = function (_0x3e9231, _0xb4a5bd) {
  let _0x401e42 = Math.floor(_0xb4a5bd.value1);
  _0x401e42 = this.disperseDamage(_0x401e42);
  if (_0x401e42 !== 0x0) {
    _0x3e9231.gainTp(_0x401e42);
    this.makeSuccess(_0x3e9231);
  }
};
VisuMZ.BattleCore.Game_Action_apply = Game_Action.prototype.apply;
Game_Action.prototype.apply = function (_0x5e95f9) {
  if (_0x5e95f9 && _0x5e95f9.isEnemy()) {
    _0x5e95f9.resetNameTempVisibility();
  }
  this.applyBattleCoreJS('PreApply%1JS', _0x5e95f9, 0x0, true);
  VisuMZ.BattleCore.Game_Action_apply.call(this, _0x5e95f9);
  this.applyBattleCoreJS("PostApply%1JS", _0x5e95f9, this._executedValue || 0x0, true);
  this.applyResultSwitches(_0x5e95f9);
};
Game_Action.prototype.applyBattleCoreJS = function (_0xd606b5, _0x4bcc00, _0x586c7c, _0x3a7905) {
  if (this._tempBattler || this._tempActor) {
    return;
  }
  _0x586c7c = _0x586c7c || 0x0;
  const _0x7e205 = _0x586c7c;
  const _0x14d226 = VisuMZ.BattleCore.Settings.Mechanics;
  const _0x4f0a66 = _0xd606b5.format('');
  if (_0x14d226[_0x4f0a66]) {
    _0x586c7c = _0x14d226[_0x4f0a66].call(this, _0x586c7c, _0x4bcc00);
    if (_0x3a7905) {
      _0x586c7c = _0x7e205;
    }
  }
  let _0x509dc7 = VisuMZ.BattleCore.createKeyJS(this.item(), _0xd606b5.format(''));
  if (VisuMZ.BattleCore.JS[_0x509dc7]) {
    _0x586c7c = VisuMZ.BattleCore.JS[_0x509dc7].call(this, this.subject(), _0x4bcc00, this.item(), _0x586c7c);
    if (_0x3a7905) {
      _0x586c7c = _0x7e205;
    }
  }
  for (const _0x55fd08 of this.subject().traitObjects()) {
    if (!_0x55fd08) {
      continue;
    }
    _0x509dc7 = VisuMZ.BattleCore.createKeyJS(_0x55fd08, _0xd606b5.format("AsUser"));
    if (VisuMZ.BattleCore.JS[_0x509dc7]) {
      _0x586c7c = VisuMZ.BattleCore.JS[_0x509dc7].call(this, this.subject(), _0x4bcc00, _0x55fd08, _0x586c7c);
      if (_0x3a7905) {
        _0x586c7c = _0x7e205;
      }
    }
  }
  for (const _0x46a19e of _0x4bcc00.traitObjects()) {
    if (!_0x46a19e) {
      continue;
    }
    _0x509dc7 = VisuMZ.BattleCore.createKeyJS(_0x46a19e, _0xd606b5.format("AsTarget"));
    if (VisuMZ.BattleCore.JS[_0x509dc7]) {
      _0x586c7c = VisuMZ.BattleCore.JS[_0x509dc7].call(this, this.subject(), _0x4bcc00, _0x46a19e, _0x586c7c);
      if (_0x3a7905) {
        _0x586c7c = _0x7e205;
      }
    }
  }
  return _0x586c7c;
};
Game_Action.prototype.actionBattleCoreJS = function (_0xb80f50) {
  const _0x11cb87 = this._totalValue || 0x0;
  const _0x3260f2 = VisuMZ.BattleCore.Settings.Mechanics;
  const _0x58767e = _0xb80f50.format('');
  if (_0x3260f2[_0x58767e]) {
    _0x3260f2[_0x58767e].call(this, _0x11cb87);
  }
  let _0x3f4748 = VisuMZ.BattleCore.createKeyJS(this.item(), _0xb80f50);
  if (VisuMZ.BattleCore.JS[_0x3f4748]) {
    VisuMZ.BattleCore.JS[_0x3f4748].call(this, this.subject(), this.subject(), this.item(), _0x11cb87);
  }
  for (const _0xac2952 of this.subject().traitObjects()) {
    if (!_0xac2952) {
      continue;
    }
    _0x3f4748 = VisuMZ.BattleCore.createKeyJS(_0xac2952, _0xb80f50);
    if (VisuMZ.BattleCore.JS[_0x3f4748]) {
      VisuMZ.BattleCore.JS[_0x3f4748].call(this, this.subject(), this.subject(), _0xac2952, _0x11cb87);
    }
  }
};
Game_Action.prototype.speed = function () {
  return VisuMZ.BattleCore.Settings.Mechanics.CalcActionSpeedJS.call(this);
};
Game_Action.prototype.allowRandomSpeed = function () {
  return VisuMZ.BattleCore.Settings.Mechanics.AllowRandomSpeed;
};
Game_Action.prototype.isCustomBattleScope = function () {
  if (this._targetBattlerKey === "all actors") {
    return false;
  }
  if (this._targetBattlerKey === "all enemies") {
    return false;
  }
  if (!this.item()) {
    return false;
  }
  return this.item().note.match(/<JS TARGETS>/i);
};
Game_Action.prototype.isBattleCoreTargetScope = function () {
  if (this._targetBattlerKey === "all actors") {
    return false;
  }
  if (this._targetBattlerKey === "all enemies") {
    return false;
  }
  if (!this._forcing && this.subject().isConfused()) {
    return false;
  }
  if (this.isCustomBattleScope()) {
    return true;
  }
  if (!this.item()) {
    return false;
  }
  return typeof this.item().scope === 'string';
};
VisuMZ.BattleCore.Game_Action_isForOpponent = Game_Action.prototype.isForOpponent;
Game_Action.prototype.isForOpponent = function () {
  if (this._targetBattlerKey === "all actors") {
    return false;
  }
  if (this._targetBattlerKey === "all enemies") {
    return true;
  }
  return this.isBattleCoreTargetScope() && !this.isCustomBattleScope() ? this.isForOpponentBattleCore() : VisuMZ.BattleCore.Game_Action_isForOpponent.call(this);
};
Game_Action.prototype.isForOpponentBattleCore = function () {
  const _0x2a89e7 = String(this.item().scope);
  if (_0x2a89e7.match(/ANY/i)) {
    return true;
  }
  return _0x2a89e7.match(/(?:ENEMY|ENEMIES|FOE|FOES)/i);
};
VisuMZ.BattleCore.Game_Action_isForFriend = Game_Action.prototype.isForFriend;
Game_Action.prototype.isForFriend = function () {
  if (this._targetBattlerKey === "all actors") {
    return true;
  }
  if (this._targetBattlerKey === "all enemies") {
    return false;
  }
  return this.isBattleCoreTargetScope() && !this.isCustomBattleScope() ? this.isForFriendBattleCore() : VisuMZ.BattleCore.Game_Action_isForFriend.call(this);
};
Game_Action.prototype.isForFriendBattleCore = function () {
  const _0x4def55 = String(this.item().scope);
  return _0x4def55.match(/(?:ALLY|ALLIES|FRIEND|FRIENDS)/i);
};
Game_Action.prototype.isForAnyone = function () {
  if (this.isBattleCoreTargetScope() && !this.isCustomBattleScope()) {
    const _0x2d53e6 = String(this.item().scope);
    return _0x2d53e6.match(/(?:ENEMY|FOE)/i) && _0x2d53e6.match(/OR/i) && _0x2d53e6.match(/(?:ALLY|FRIEND)/i);
  } else {
    return false;
  }
};
Game_Action.prototype.isForAnyoneFocusFriends = function () {
  if (this.isForAnyone()) {
    const _0x3d7f25 = String(this.item().scope);
    if (_0x3d7f25.match(/(?:ALLY|FRIEND) OR (?:ENEMY|FOE)/i)) {
      return true;
    }
  }
  return false;
};
Game_Action.prototype.isForAnyoneFocusOpponents = function () {
  if (this.isForAnyone()) {
    const _0x10f95b = String(this.item().scope);
    if (_0x10f95b.match(/(?:ENEMY|FOE) OR (?:ALLY|FRIEND)/i)) {
      return true;
    }
  }
  return false;
};
VisuMZ.BattleCore.Game_Action_isForAliveFriend = Game_Action.prototype.isForAliveFriend;
Game_Action.prototype.isForAliveFriend = function () {
  if (this._targetBattlerKey === "all actors") {
    return true;
  }
  return this.isBattleCoreTargetScope() && !this.isCustomBattleScope() ? this.isForAliveFriendBattleCore() : VisuMZ.BattleCore.Game_Action_isForAliveFriend.call(this);
};
VisuMZ.BattleCore.Game_Action_isForDeadFriend = Game_Action.prototype.isForDeadFriend;
Game_Action.prototype.isForDeadFriend = function () {
  if (this._targetBattlerKey === "all actors") {
    return VisuMZ.BattleCore.Game_Action_isForDeadFriend.call(this);
  }
  return VisuMZ.BattleCore.Game_Action_isForDeadFriend.call(this);
};
Game_Action.prototype.isForAliveFriendBattleCore = function () {
  if (this.isForAnyone()) {
    return true;
  }
  return false;
};
Game_Action.prototype.isForNotUser = function () {
  return this.item() && this.item().note.match(/<CANNOT TARGET (?:USER|SELF)>/i);
};
VisuMZ.BattleCore.Game_Action_isForOne = Game_Action.prototype.isForOne;
Game_Action.prototype.isForOne = function () {
  if (this._targetBattlerKey === "all actors") {
    return false;
  }
  if (this._targetBattlerKey === "all enemies") {
    return false;
  }
  return this.isBattleCoreTargetScope() && !this.isCustomBattleScope() ? this.isForOneBattleCore() : VisuMZ.BattleCore.Game_Action_isForOne.call(this);
};
Game_Action.prototype.isForOneBattleCore = function () {
  if (this.isForAnyone()) {
    return true;
  }
  return false;
};
VisuMZ.BattleCore.Game_Action_isForRandom = Game_Action.prototype.isForRandom;
Game_Action.prototype.isForRandom = function () {
  if (this._targetBattlerKey === "all actors") {
    return false;
  }
  if (this._targetBattlerKey === "all enemies") {
    return false;
  }
  return this.isBattleCoreTargetScope() && !this.isCustomBattleScope() ? this.isForRandomBattleCore() : VisuMZ.BattleCore.Game_Action_isForRandom.call(this);
};
Game_Action.prototype.isForRandomBattleCore = function () {
  const _0x3ccdaf = String(this.item().scope);
  return _0x3ccdaf.match(/(?:RAND|RANDOM)/i);
};
VisuMZ.BattleCore.Game_Action_isForAll = Game_Action.prototype.isForAll;
Game_Action.prototype.isForAll = function () {
  if (this._targetBattlerKey === "all actors") {
    return true;
  }
  if (this._targetBattlerKey === "all enemies") {
    return true;
  }
  return VisuMZ.BattleCore.Game_Action_isForAll.call(this);
};
Game_Action.prototype.canSingleOrMultipleSelect = function () {
  if (!this.item()) {
    return false;
  }
  if (this.isForDeadFriend()) {
    return false;
  }
  return (this.item().note || '').match(/<SINGLE OR MULTIPLE SELECT>/i);
};
VisuMZ.BattleCore.Game_Action_testApply = Game_Action.prototype.testApply;
Game_Action.prototype.testApply = function (_0x9b0bd7) {
  if (this.isForNotUser() && _0x9b0bd7 === this.subject()) {
    return false;
  }
  return VisuMZ.BattleCore.Game_Action_testApply.call(this, _0x9b0bd7);
};
VisuMZ.BattleCore.Game_Action_itemTargetCandidates = Game_Action.prototype.itemTargetCandidates;
Game_Action.prototype.itemTargetCandidates = function () {
  const _0x231429 = VisuMZ.BattleCore.Game_Action_itemTargetCandidates.call(this);
  if (this.isForNotUser()) {
    _0x231429.remove(this.subject());
  }
  return _0x231429;
};
VisuMZ.BattleCore.Game_Action_needsSelection = Game_Action.prototype.needsSelection;
Game_Action.prototype.needsSelection = function () {
  return this.isBattleCoreTargetScope() && !this.isCustomBattleScope() ? this.needsSelectionBattleCore() : VisuMZ.BattleCore.Game_Action_needsSelection.call(this);
};
Game_Action.prototype.needsSelectionBattleCore = function () {
  const _0x730cf5 = String(this.item().scope);
  if (_0x730cf5.match(/RANDOM/i)) {
    return false;
  }
  if (_0x730cf5.match(/ALL (?:ALLY|ALLIES|FRIEND|FRIENDS)/i)) {
    return false;
  }
  if (_0x730cf5.match(/ALL (?:ENEMY|ENEMIES|FOE|FOES)/i)) {
    return false;
  }
  if (_0x730cf5.match(/(?:ENEMY|FOE) OR (?:ALLY|FRIEND)/i)) {
    return true;
  }
  if (_0x730cf5.match(/(?:ALLY|FRIEND) OR (?:ENEMY|FOE)/i)) {
    return true;
  }
  return VisuMZ.BattleCore.Game_Action_needsSelection.call(this);
};
VisuMZ.BattleCore.Game_Action_makeTargets = Game_Action.prototype.makeTargets;
Game_Action.prototype.makeTargets = function () {
  let _0xd01a19 = [];
  if (this.isBattleCoreTargetScope()) {
    if (this.isCustomBattleScope()) {
      _0xd01a19 = this.makeTargetsBattleCoreJS();
    } else {
      _0xd01a19 = this.makeTargetsBattleCore();
    }
  } else {
    _0xd01a19 = VisuMZ.BattleCore.Game_Action_makeTargets.call(this);
  }
  _0xd01a19 = this.applyTargetFilters(_0xd01a19);
  return _0xd01a19;
};
Game_Action.prototype.isSubjectValidForAnyoneSelect = function () {
  return this.subject().isActor() && !this.subject().isAutoBattle();
};
Game_Action.prototype.makeTargetsBattleCoreJS = function () {
  const _0x244017 = VisuMZ.BattleCore.createKeyJS(this.item(), "Targets");
  if (VisuMZ.BattleCore.JS[_0x244017]) {
    targets = VisuMZ.BattleCore.Game_Action_makeTargets.call(this);
    const _0x24c621 = VisuMZ.BattleCore.createKeyJS(this.item(), "Targets");
    targets = VisuMZ.BattleCore.JS[_0x24c621].call(this, this.subject(), targets);
    return this.repeatTargets(targets);
  }
  return this.makeTargetsBattleCore();
};
Game_Action.prototype.makeTargetsBattleCore = function () {
  let _0x27c883 = [];
  const _0x1547bc = String(this.item().scope);
  if (this.isForAnyoneFocusOpponents()) {
    return this.isSubjectValidForAnyoneSelect() ? (_0x27c883 = this.getBattlerKeyTargets(), this.repeatTargets(_0x27c883)) : (this._targetIndex = -0x1, _0x27c883.push(...this.targetsForOpponents()), this.repeatTargets(_0x27c883));
  }
  if (this.isForAnyoneFocusFriends()) {
    if (this.isSubjectValidForAnyoneSelect()) {
      _0x27c883 = this.getBattlerKeyTargets();
      return this.repeatTargets(_0x27c883);
    } else {
      if (Imported.VisuMZ_3_BattleAI) {
        if (VisuMZ.BattleAI.version < 1.19) {
          let _0x1dc412 = '';
          _0x1dc412 += "VisuMZ_3_BattleAI needs to be updated ";
          _0x1dc412 += "in order for Ally or Enemy targeting to work ";
          _0x1dc412 += "with latest version of VisuMZ_1_BattleCore!";
          alert(_0x1dc412);
          SceneManager.exit();
        }
      }
      this._targetIndex = -0x1;
      _0x27c883.push(...this.targetsForFriends());
      return this.repeatTargets(_0x27c883);
    }
  }
  if (_0x1547bc.match(/(\d+) RANDOM ANY/i)) {
    let _0x2dec86 = Number(RegExp.$1);
    while (_0x2dec86--) {
      const _0x4de444 = Math.randomInt(0x2) === 0x0 ? this.opponentsUnit() : this.friendsUnit();
      _0x27c883.push(_0x4de444.trueRandomTarget());
    }
    return this.repeatTargets(_0x27c883);
  }
  if (_0x1547bc.match(/(\d+) RANDOM (?:ENEMY|ENEMIES|FOE|FOES)/i)) {
    let _0x3f9364 = Number(RegExp.$1);
    while (_0x3f9364--) {
      _0x27c883.push(this.opponentsUnit().trueRandomTarget());
    }
    return this.repeatTargets(_0x27c883);
  }
  if (_0x1547bc.match(/(\d+) RANDOM (?:ALLY|ALLIES|FRIEND|FRIENDS)/i)) {
    let _0x5ac9e5 = Number(RegExp.$1);
    while (_0x5ac9e5--) {
      _0x27c883.push(this.friendsUnit().trueRandomTarget());
    }
    return this.repeatTargets(_0x27c883);
  }
  if (_0x1547bc.match(/ALL (?:ALLY|ALLIES|FRIEND|FRIENDS) (?:BUT|EXCEPT) (?:USER|SELF)/i)) {
    _0x27c883.push(...this.friendsUnit().aliveMembers().filter(_0x25b4ea => _0x25b4ea !== this.subject()));
    return this.repeatTargets(_0x27c883);
  }
  return VisuMZ.BattleCore.Game_Action_makeTargets.call(this);
};
Game_Action.prototype.randomTargets = function (_0x18abf9) {
  const _0x2dd884 = [];
  for (let _0xc73bf6 = 0x0; _0xc73bf6 < this.numTargets(); _0xc73bf6++) {
    _0x2dd884.push(_0x18abf9.trueRandomTarget());
  }
  return _0x2dd884;
};
Game_Action.prototype.applyTargetFilters = function (_0x24a509) {
  if (!this.item()) {
    return _0x24a509;
  }
  if (this.isForNotUser()) {
    if (this.isForAll()) {
      _0x24a509.remove(this.subject());
    }
    if (_0x24a509.includes(this.subject())) {
      const _0x9a958e = this.friendsUnit().aliveMembers().remove(this.subject());
      if (_0x9a958e.length > 0x0) {
        _0x9a958e.sort((_0x4f8f1b, _0x162716) => _0x4f8f1b.hpRate() - _0x162716.hpRate());
        while (_0x24a509.includes(this.subject())) {
          const _0x42044f = _0x24a509.indexOf(this.subject());
          _0x24a509[_0x42044f] = _0x9a958e[Math.randomInt(_0x9a958e.length)];
        }
      } else {
        _0x24a509.remove(this.subject());
      }
    }
  }
  return _0x24a509;
};
VisuMZ.BattleCore.Game_Action_itemEffectAddAttackState = Game_Action.prototype.itemEffectAddAttackState;
Game_Action.prototype.itemEffectAddAttackState = function (_0x310fc4, _0x4ce62c) {
  VisuMZ.BattleCore.Game_Action_itemEffectAddAttackState.call(this, _0x310fc4, _0x4ce62c);
  if (!_0x310fc4.isImmortal()) {
    return;
  }
  for (const _0x6ca90e of this.subject().attackStates()) {
    if (_0x6ca90e === _0x310fc4.deathStateId()) {
      let _0x31ec02 = _0x4ce62c.value1;
      _0x31ec02 *= _0x310fc4.stateRate(_0x6ca90e);
      _0x31ec02 *= this.subject().attackStatesRate(_0x6ca90e);
      _0x31ec02 *= this.lukEffectRate(_0x310fc4);
      if (Math.random() < _0x31ec02) {
        _0x310fc4._deathStateApplied = true;
        this.makeSuccess(_0x310fc4);
      }
    }
  }
};
VisuMZ.BattleCore.Game_Action_itemEffectAddNormalState = Game_Action.prototype.itemEffectAddNormalState;
Game_Action.prototype.itemEffectAddNormalState = function (_0x1a29f9, _0x34783b) {
  VisuMZ.BattleCore.Game_Action_itemEffectAddNormalState.call(this, _0x1a29f9, _0x34783b);
  if (!_0x1a29f9.isImmortal()) {
    return;
  }
  if (_0x34783b.dataId !== _0x1a29f9.deathStateId()) {
    return;
  }
  let _0x5c49d0 = _0x34783b.value1;
  if (!this.isCertainHit()) {
    _0x5c49d0 *= _0x1a29f9.stateRate(_0x34783b.dataId);
    _0x5c49d0 *= this.lukEffectRate(_0x1a29f9);
  }
  if (Math.random() < _0x5c49d0) {
    _0x1a29f9._deathStateApplied = true;
    this.makeSuccess(_0x1a29f9);
  }
};
VisuMZ.BattleCore.Game_Action_applyGlobal = Game_Action.prototype.applyGlobal;
Game_Action.prototype.applyGlobal = function () {
  VisuMZ.BattleCore.Game_Action_applyGlobal.call(this);
  this.applyGlobalCommonEventNotetags();
  this.resetResultSwitches();
};
Game_Action.prototype.applyGlobalCommonEventNotetags = function () {
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  const _0x4b17e4 = /<COMMON (?:EVENT|EVENTS):[ ](.*)>/gi;
  const _0x399e3c = this.item().note.match(_0x4b17e4);
  if (_0x399e3c) {
    for (const _0x3e4954 of _0x399e3c) {
      if (!_0x3e4954) {
        continue;
      }
      _0x3e4954.match(_0x4b17e4);
      const _0x40087e = String(RegExp.$1).split(',').map(_0x4cb8cb => String(_0x4cb8cb).trim());
      const _0x199145 = _0x40087e.map(_0x2e0f28 => DataManager.getCommonEventIdWithName(_0x2e0f28));
      for (const _0x36d499 of _0x199145) {
        const _0x4776bb = $dataCommonEvents[_0x36d499];
        if (_0x4776bb) {
          $gameTemp.reserveCommonEvent(_0x36d499);
        }
      }
    }
  }
};
DataManager.getCommonEventIdWithName = function (_0x19fab7) {
  _0x19fab7 = _0x19fab7.toUpperCase().trim();
  this._commonEventIDs = this._commonEventIDs || {};
  if (this._commonEventIDs[_0x19fab7]) {
    return this._commonEventIDs[_0x19fab7];
  }
  for (const _0x315352 of $dataCommonEvents) {
    if (!_0x315352) {
      continue;
    }
    let _0x39b1ce = _0x315352.name;
    _0x39b1ce = _0x39b1ce.replace(/\x1I\[(\d+)\]/gi, '');
    _0x39b1ce = _0x39b1ce.replace(/\\I\[(\d+)\]/gi, '');
    this._commonEventIDs[_0x39b1ce.toUpperCase().trim()] = _0x315352.id;
  }
  return this._commonEventIDs[_0x19fab7] || 0x0;
};
Game_Action.prototype.resetResultSwitches = function () {
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  const _0xa23dd5 = VisuMZ.BattleCore.Settings.Mechanics;
  if (_0xa23dd5.SwitchCritical) {
    $gameSwitches.setValue(_0xa23dd5.SwitchCritical, false);
  }
  if (_0xa23dd5.SwitchMissEvade) {
    $gameSwitches.setValue(_0xa23dd5.SwitchMissEvade, false);
  }
  if (_0xa23dd5.VariableDmg) {
    $gameVariables.setValue(_0xa23dd5.VariableDmg, 0x0);
  }
  if (_0xa23dd5.VariableHeal) {
    $gameVariables.setValue(_0xa23dd5.VariableHeal, 0x0);
  }
};
Game_Action.prototype.applyResultSwitches = function (_0x3be2dd) {
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  if (!_0x3be2dd) {
    return;
  }
  const _0x4a02cc = _0x3be2dd.result();
  const _0x2d0dff = VisuMZ.BattleCore.Settings.Mechanics;
  if (_0x2d0dff.SwitchCritical && _0x4a02cc.critical) {
    $gameSwitches.setValue(_0x2d0dff.SwitchCritical, true);
  }
  if (_0x2d0dff.SwitchMissEvade && (_0x4a02cc.missed || _0x4a02cc.evaded)) {
    $gameSwitches.setValue(_0x2d0dff.SwitchMissEvade, true);
  }
  if (_0x2d0dff.VariableDmg) {
    let _0x5e3b38 = $gameVariables.value(_0x2d0dff.VariableDmg);
    if (_0x4a02cc.hpDamage > 0x0) {
      _0x5e3b38 += Math.abs(_0x4a02cc.hpDamage);
    }
    $gameVariables.setValue(_0x2d0dff.VariableDmg, _0x5e3b38);
  }
  if (_0x2d0dff.VariableHeal) {
    let _0x373b6f = $gameVariables.value(_0x2d0dff.VariableHeal);
    if (_0x4a02cc.hpDamage < 0x0) {
      _0x373b6f += Math.abs(_0x4a02cc.hpDamage);
    }
    $gameVariables.setValue(_0x2d0dff.VariableHeal, _0x373b6f);
  }
};
VisuMZ.BattleCore.LifeStealRegExp = {
  'lifeSteaItem': /<(.*?) (?:LIFE|MANA) STEAL:[ ](\d+)([%])>/gi,
  'lifeStealTrait': /<(.*?) (?:LIFE|MANA) STEAL (.*?):[ ]([\+\-]\d+)([%])>/gi,
  'cancelLifeSteal': /<CANCEL LIFE STEAL>/i,
  'cancelHpLifeSteal': /<CANCEL HP LIFE STEAL>/i,
  'cancelMpLifeSteal': /<CANCEL MP LIFE STEAL>/i,
  'guardLifeSteal': /<GUARD LIFE STEAL>/i,
  'guardHpLifeSteal': /<GUARD HP LIFE STEAL>/i,
  'guardMpLifeSteal': /<GUARD MP LIFE STEAL>/i,
  'disarmLifeSteal': /<DISARM LIFE STEAL>/i,
  'disarmHpLifeSteal': /<DISARM HP LIFE STEAL>/i,
  'disarmMpLifeSteal': /<DISARM MP LIFE STEAL>/i,
  'negativeLifeSteal': /<REVERSE LIFE STEAL>/i,
  'negativeHpLifeSteal': /<REVERSE HP LIFE STEAL>/i,
  'negativeMpLifeSteal': /<REVERSE MP LIFE STEAL>/i
};
VisuMZ.BattleCore.Game_Action_executeHpDamage = Game_Action.prototype.executeHpDamage;
Game_Action.prototype.executeHpDamage = function (_0x357aa1, _0x258a4c) {
  VisuMZ.BattleCore.Game_Action_executeHpDamage.call(this, _0x357aa1, _0x258a4c);
  if (!this.isDrain() && _0x357aa1 && _0x357aa1.result().hpDamage > 0x0) {
    this.performLifeSteal('HP', _0x357aa1, _0x357aa1.result().hpDamage);
  }
  if (_0x357aa1) {
    this._executeHpDamage = this._executeHpDamage || {};
    const _0xd56678 = _0x357aa1.battlerKey();
    this._executeHpDamage[_0xd56678] = _0x258a4c;
  }
};
Game_Action.prototype.getLastHpDamage = function (_0x2a721f) {
  this._executeHpDamage = this._executeHpDamage || {};
  const _0x4319e3 = _0x2a721f.battlerKey();
  return this._executeHpDamage[_0x4319e3] || 0x0;
};
VisuMZ.BattleCore.Game_Action_executeMpDamage = Game_Action.prototype.executeMpDamage;
Game_Action.prototype.executeMpDamage = function (_0x348df8, _0x309813) {
  VisuMZ.BattleCore.Game_Action_executeMpDamage.call(this, _0x348df8, _0x309813);
  if (!this.isDrain() && _0x348df8 && _0x348df8.result().mpDamage > 0x0) {
    this.performLifeSteal('MP', _0x348df8, _0x348df8.result().mpDamage);
  }
};
Game_Action.prototype.performLifeSteal = function (_0x33d09d, _0x370040, _0x5dc162) {
  _0x33d09d = _0x33d09d.toUpperCase().trim();
  const _0x223b26 = this.lifeStealRate(_0x33d09d, _0x370040);
  if (_0x223b26 <= 0x0) {
    return;
  }
  const _0x30e344 = Math.round(_0x5dc162 * _0x223b26);
  if (_0x30e344 <= 0x0) {
    return;
  }
  let _0xd6c278 = this.subject();
  if (this._reflectionTarget) {
    _0xd6c278 = this._reflectionTarget;
  }
  const _0x58fdaf = _0x370040.isNegativeLifeSteal(_0x33d09d) ? -0x1 : 0x1;
  if (_0x33d09d === 'HP') {
    _0xd6c278.gainHp(_0x58fdaf * _0x30e344);
  }
  if (_0x33d09d === 'MP') {
    _0xd6c278.gainMp(_0x58fdaf * _0x30e344);
  }
};
Game_Action.prototype.lifeStealRate = function (_0xb323bb, _0x13b2b7) {
  if (this.isCancelLifeSteal(_0xb323bb)) {
    return 0x0;
  }
  if (this.subject().isDisarmLifeSteal(_0xb323bb)) {
    return 0x0;
  }
  if (_0x13b2b7.isGuardLifeSteal(_0xb323bb)) {
    return 0x0;
  }
  let _0x3af436 = 0x0;
  _0x3af436 += this.itemLifeStealRate(_0xb323bb);
  _0x3af436 += this.subject().lifeStealRate(_0xb323bb, this.item().hitType);
  return _0x3af436.clamp(0x0, 0x1);
};
Game_Action.prototype.isCancelLifeSteal = function (_0x551c5e) {
  _0x551c5e = _0x551c5e.toUpperCase().trim();
  const _0x12ae02 = VisuMZ.BattleCore.LifeStealRegExp;
  const _0xb0349a = this.item().note || '';
  if (_0xb0349a.match(_0x12ae02.cancelLifeSteal)) {
    return true;
  }
  if (_0x551c5e === 'HP' && _0xb0349a.match(_0x12ae02.cancelHpLifeSteal)) {
    return true;
  }
  if (_0x551c5e === 'MP' && _0xb0349a.match(_0x12ae02.cancelMpLifeSteal)) {
    return true;
  }
  return false;
};
Game_Action.prototype.itemLifeStealRate = function (_0x3a375c) {
  const _0x290163 = VisuMZ.BattleCore.LifeStealRegExp;
  const _0x411600 = this.item().note || '';
  _0x3a375c = _0x3a375c.toUpperCase().trim();
  const _0x54d437 = _0x411600.match(_0x290163.lifeSteaItem);
  if (_0x54d437) {
    for (const _0x48f797 of _0x54d437) {
      _0x48f797.match(_0x290163.lifeSteaItem);
      const _0x2a461d = String(RegExp.$1).toUpperCase().trim();
      const _0x32a695 = Number(RegExp.$2) * 0.01;
      if (_0x2a461d !== _0x3a375c) {
        continue;
      }
      return _0x32a695;
    }
  }
  return 0x0;
};
Game_BattlerBase.prototype.lifeStealRate = function (_0x59cdc7, _0x1a3e28) {
  const _0x2c2d0c = VisuMZ.BattleCore.LifeStealRegExp;
  let _0x4755cf = 0x0;
  _0x59cdc7 = _0x59cdc7.toUpperCase().trim();
  for (const _0x19b92d of this.traitObjects()) {
    if (!_0x19b92d) {
      continue;
    }
    const _0x4fd8eb = _0x19b92d.note || '';
    const _0x17a6ef = _0x4fd8eb.match(_0x2c2d0c.lifeStealTrait);
    if (_0x17a6ef) {
      for (const _0x5bacf2 of _0x17a6ef) {
        _0x5bacf2.match(_0x2c2d0c.lifeStealTrait);
        const _0x296811 = String(RegExp.$1).toUpperCase().trim();
        const _0x421934 = String(RegExp.$2);
        const _0x2151a0 = Number(RegExp.$3) * 0.01;
        if (_0x296811 !== _0x59cdc7) {
          continue;
        }
        if (_0x1a3e28 === Game_Action.HITTYPE_CERTAIN && _0x421934.match(/CERTAIN/i)) {
          _0x4755cf += _0x2151a0;
        } else {
          if (_0x1a3e28 === Game_Action.HITTYPE_PHYSICAL && _0x421934.match(/PHYS/i)) {
            _0x4755cf += _0x2151a0;
          } else if (_0x1a3e28 === Game_Action.HITTYPE_MAGICAL && _0x421934.match(/MAGIC/i)) {
            _0x4755cf += _0x2151a0;
          }
        }
      }
    }
  }
  return _0x4755cf;
};
Game_BattlerBase.prototype.isDisarmLifeSteal = function (_0x3ca69b) {
  _0x3ca69b = _0x3ca69b.toUpperCase().trim();
  const _0x1716a0 = VisuMZ.BattleCore.LifeStealRegExp;
  for (const _0x1d13c1 of this.traitObjects()) {
    if (!_0x1d13c1) {
      continue;
    }
    const _0x4abe41 = _0x1d13c1.note || '';
    if (_0x4abe41.match(_0x1716a0.disarmLifeSteal)) {
      return true;
    }
    if (_0x3ca69b === 'HP' && _0x4abe41.match(_0x1716a0.disarmHpLifeSteal)) {
      return true;
    }
    if (_0x3ca69b === 'MP' && _0x4abe41.match(_0x1716a0.disarmMpLifeSteal)) {
      return true;
    }
  }
  return false;
};
Game_BattlerBase.prototype.isNegativeLifeSteal = function (_0x246192) {
  _0x246192 = _0x246192.toUpperCase().trim();
  const _0xb6bffa = VisuMZ.BattleCore.LifeStealRegExp;
  for (const _0x5d32d4 of this.traitObjects()) {
    if (!_0x5d32d4) {
      continue;
    }
    const _0x57fd6a = _0x5d32d4.note || '';
    if (_0x57fd6a.match(_0xb6bffa.negativeLifeSteal)) {
      return true;
    }
    if (_0x246192 === 'HP' && _0x57fd6a.match(_0xb6bffa.negativeHpLifeSteal)) {
      return true;
    }
    if (_0x246192 === 'MP' && _0x57fd6a.match(_0xb6bffa.negativeMpLifeSteal)) {
      return true;
    }
  }
  return false;
};
Game_BattlerBase.prototype.isGuardLifeSteal = function (_0x545232) {
  _0x545232 = _0x545232.toUpperCase().trim();
  const _0xf09365 = VisuMZ.BattleCore.LifeStealRegExp;
  for (const _0x596a7d of this.traitObjects()) {
    if (!_0x596a7d) {
      continue;
    }
    const _0x2705a9 = _0x596a7d.note || '';
    if (_0x2705a9.match(_0xf09365.guardLifeSteal)) {
      return true;
    }
    if (_0x545232 === 'HP' && _0x2705a9.match(_0xf09365.guardHpLifeSteal)) {
      return true;
    }
    if (_0x545232 === 'MP' && _0x2705a9.match(_0xf09365.guardMpLifeSteal)) {
      return true;
    }
  }
  return false;
};
VisuMZ.BattleCore.Game_BattlerBase_initMembers = Game_BattlerBase.prototype.initMembers;
Game_BattlerBase.prototype.initMembers = function () {
  VisuMZ.BattleCore.Game_BattlerBase_initMembers.call(this);
  this.initMembersBattleCore();
};
Game_BattlerBase.prototype.initMembersBattleCore = function () {
  this._immortal = false;
};
VisuMZ.BattleCore.Game_BattlerBase_refresh = Game_BattlerBase.prototype.refresh;
Game_BattlerBase.prototype.refresh = function () {
  this._cache = {};
  VisuMZ.BattleCore.Game_BattlerBase_refresh.call(this);
};
Game_BattlerBase.prototype.checkCacheKey = function (_0xc4c0ae) {
  this._cache = this._cache || {};
  return this._cache[_0xc4c0ae] !== undefined;
};
Game_BattlerBase.prototype.hardDamageCap = function () {
  if (this._cache.hardDamageCap !== undefined) {
    return this._cache.hardDamageCap;
  }
  const _0x136abf = /<DAMAGE CAP:[ ](\d+)>/i;
  const _0x314f5b = this.traitObjects().map(_0x14e39f => _0x14e39f && _0x14e39f.note.match(_0x136abf) ? Number(RegExp.$1) : 0x0);
  let _0xf06cb1 = _0x314f5b.length > 0x0 ? Math.max(..._0x314f5b) : 0x0;
  if (_0xf06cb1 <= 0x0) {
    _0xf06cb1 = VisuMZ.BattleCore.Settings.Damage.DefaultHardCap;
  }
  this._cache.hardDamageCap = _0xf06cb1;
  return this._cache.hardDamageCap;
};
Game_BattlerBase.prototype.softDamageCapRate = function () {
  if (this._cache.softDamageCap !== undefined) {
    return this._cache.softDamageCap;
  }
  let _0x3d6a8f = VisuMZ.BattleCore.Settings.Damage.DefaultSoftCap;
  const _0x40e7e7 = /<SOFT DAMAGE CAP:[ ]([\+\-]\d+)([%])>/i;
  const _0x47a070 = this.traitObjects().map(_0x24af77 => _0x24af77 && _0x24af77.note.match(_0x40e7e7) ? Number(RegExp.$1) / 0x64 : 0x0);
  _0x3d6a8f = _0x47a070.reduce((_0x270851, _0x20ac7f) => _0x270851 + _0x20ac7f, _0x3d6a8f);
  this._cache.softDamageCap = _0x3d6a8f;
  return this._cache.softDamageCap.clamp(0.01, 0x1);
};
VisuMZ.BattleCore.Game_BattlerBase_die = Game_BattlerBase.prototype.die;
Game_BattlerBase.prototype.die = function () {
  VisuMZ.BattleCore.Game_BattlerBase_die.call(this);
  if (SceneManager.isSceneBattle()) {
    this.requestMotion("dead");
    this._performDamageMotion = undefined;
  }
};
Game_BattlerBase.prototype.battler = function () {
  if (!SceneManager.isSceneBattle()) {
    return null;
  }
  if (!SceneManager._scene._spriteset) {
    return null;
  }
  return SceneManager._scene._spriteset.findTargetSprite(this);
};
Game_BattlerBase.prototype.svBattlerAnchorX = function () {
  return VisuMZ.BattleCore.Settings.Actor.AnchorX;
};
Game_BattlerBase.prototype.svBattlerAnchorY = function () {
  return VisuMZ.BattleCore.Settings.Actor.AnchorY;
};
Game_BattlerBase.prototype.svBattlerShadowVisible = function () {
  return this.isActor && this.isActor() ? VisuMZ.BattleCore.Settings.Actor.Shadow : VisuMZ.BattleCore.Settings.Enemy.Shadow;
};
Game_BattlerBase.prototype.battlerSmoothImage = function () {
  return true;
};
Game_BattlerBase.prototype.battleUIOffsetX = function () {
  return 0x0;
};
Game_BattlerBase.prototype.battleUIOffsetY = function () {
  return 0x0;
};
Game_BattlerBase.prototype.createBattleUIOffsetX = function (_0xf307f9) {
  if (!_0xf307f9) {
    return 0x0;
  }
  let _0x4e3a6b = 0x0;
  const _0x32bc9c = _0xf307f9.note;
  if (_0x32bc9c.match(/<BATTLE UI OFFSET X:[ ]([\+\-]\d+)>/i)) {
    _0x4e3a6b += Number(RegExp.$1);
  }
  if (_0x32bc9c.match(/<BATTLE UI OFFSET:[ ]([\+\-]\d+),[ ]([\+\-]\d+)>/i)) {
    _0x4e3a6b += Number(RegExp.$1);
  }
  return _0x4e3a6b;
};
Game_BattlerBase.prototype.createBattleUIOffsetY = function (_0x2870f0) {
  if (!_0x2870f0) {
    return 0x0;
  }
  let _0x436dbe = 0x0;
  const _0x425682 = _0x2870f0.note;
  if (_0x425682.match(/<BATTLE UI OFFSET Y:[ ]([\+\-]\d+)>/i)) {
    _0x436dbe += Number(RegExp.$1);
  }
  if (_0x425682.match(/<BATTLE UI OFFSET:[ ]([\+\-]\d+),[ ]([\+\-]\d+)>/i)) {
    _0x436dbe += Number(RegExp.$2);
  }
  return _0x436dbe;
};
VisuMZ.BattleCore.Game_BattlerBase_isStateResist = Game_BattlerBase.prototype.isStateResist;
Game_BattlerBase.prototype.isStateResist = function (_0x1859af) {
  if (_0x1859af === this.deathStateId() && this.isImmortal()) {
    return true;
  }
  return VisuMZ.BattleCore.Game_BattlerBase_isStateResist.call(this, _0x1859af);
};
Game_BattlerBase.prototype.isImmortal = function () {
  return this._immortal;
};
Game_BattlerBase.prototype.setImmortal = function (_0xea7607) {
  if (_0xea7607) {
    this.addImmortal();
  } else {
    this.removeImmortal();
  }
};
Game_BattlerBase.prototype.addImmortal = function () {
  if (this.isDead()) {
    return;
  }
  this._immortal = true;
  this._deathStateApplied = false;
};
Game_BattlerBase.prototype.removeImmortal = function () {
  const _0x4b2794 = this.isAlive();
  this._immortal = false;
  if (_0x4b2794 && this._deathStateApplied) {
    this.die();
  }
  this._deathStateApplied = false;
  this.refresh();
  if (this.isDead() && _0x4b2794) {
    this.performCollapse();
    this.requestMotionRefresh();
  }
};
VisuMZ.BattleCore.Game_Action_numRepeats = Game_Action.prototype.numRepeats;
Game_Action.prototype.numRepeats = function () {
  return this.item() ? VisuMZ.BattleCore.Game_Action_numRepeats.call(this) : 0x0;
};
VisuMZ.BattleCore.Game_Action_setAttack = Game_Action.prototype.setAttack;
Game_Action.prototype.setAttack = function () {
  if (this.subject() && this.subject().canAttack()) {
    VisuMZ.BattleCore.Game_Action_setAttack.call(this);
  } else {
    this.clear();
  }
};
VisuMZ.BattleCore.Game_BattlerBase_canAttack = Game_BattlerBase.prototype.canAttack;
Game_BattlerBase.prototype.canAttack = function () {
  if (!this.canAttackBattleCore()) {
    return false;
  }
  return VisuMZ.BattleCore.Game_BattlerBase_canAttack.call(this);
};
Game_BattlerBase.prototype.canAttackBattleCore = function () {
  for (const _0x328739 of this.traitObjects()) {
    if (!_0x328739) {
      continue;
    }
    if (_0x328739.note.match(/<(?:ATTACK SEAL|SEAL ATTACK)>/i)) {
      return false;
    }
  }
  return true;
};
VisuMZ.BattleCore.Game_Action_setGuard = Game_Action.prototype.setGuard;
Game_Action.prototype.setGuard = function () {
  if (this.subject().canGuard()) {
    VisuMZ.BattleCore.Game_Action_setGuard.call(this);
  }
};
VisuMZ.BattleCore.Game_BattlerBase_canGuard = Game_BattlerBase.prototype.canGuard;
Game_BattlerBase.prototype.canGuard = function () {
  if (!this.canGuardBattleCore()) {
    return false;
  }
  return VisuMZ.BattleCore.Game_BattlerBase_canGuard.call(this);
};
Game_BattlerBase.prototype.canGuardBattleCore = function () {
  for (const _0x22d68b of this.traitObjects()) {
    if (!_0x22d68b) {
      continue;
    }
    if (_0x22d68b.note.match(/<(?:GUARD SEAL|SEAL GUARD)>/i)) {
      return false;
    }
  }
  return true;
};
Game_BattlerBase.prototype.canUseItemCommand = function () {
  for (const _0x366d11 of this.traitObjects()) {
    if (!_0x366d11) {
      continue;
    }
    if (_0x366d11.note.match(/<(?:ITEM SEAL|SEAL ITEM|SEAL ITEMS)>/i)) {
      return false;
    }
  }
  return true;
};
VisuMZ.BattleCore.Game_BattlerBase_meetsUsableItemConditions = Game_BattlerBase.prototype.meetsUsableItemConditions;
Game_BattlerBase.prototype.meetsUsableItemConditions = function (_0x5b1a1d) {
  if (_0x5b1a1d && _0x5b1a1d.note.match(/<CANNOT TARGET (?:USER|SELF)>/i)) {
    const _0x55c1c3 = this.friendsUnit().aliveMembers();
    if (_0x55c1c3.length === 0x1 && _0x55c1c3[0x0] === this) {
      return false;
    }
  }
  return VisuMZ.BattleCore.Game_BattlerBase_meetsUsableItemConditions.call(this, _0x5b1a1d);
};
Game_Battler.prototype.allowRandomSpeed = function () {
  return VisuMZ.BattleCore.Settings.Mechanics.AllowRandomSpeed;
};
VisuMZ.BattleCore.Game_Battler_regenerateAll = Game_Battler.prototype.regenerateAll;
Game_Battler.prototype.regenerateAll = function () {
  if (SceneManager.isSceneBattle()) {
    if (BattleManager.isTpb()) {} else {
      if ($gameTroop.turnCount() <= 0x0) {
        return;
      }
    }
  }
  if (SceneManager.isSceneBattle() && BattleManager.isTpb() && this._lastRegenFrameCount === Graphics.frameCount) {
    return;
  }
  this._lastRegenFrameCount = Graphics.frameCount;
  if (SceneManager.isSceneBattle()) {
    this.processBattleCoreJS('PreRegenerateJS');
  }
  VisuMZ.BattleCore.Game_Battler_regenerateAll.call(this);
  if (SceneManager.isSceneBattle()) {
    this.regenerateAllBattleCore();
    this.processBattleCoreJS("PostRegenerateJS");
  }
};
Game_Battler.prototype.regenerateAllBattleCore = function () {
  if (SceneManager.isSceneBattle()) {
    for (const _0x5cfd1d of this.traitObjects()) {
      if (!_0x5cfd1d) {
        continue;
      }
      this.onRegeneratePlayStateAnimation(_0x5cfd1d);
    }
  }
};
Game_Battler.prototype.onRegeneratePlayStateAnimation = function (_0x32a39b) {
  if (!Imported.VisuMZ_0_CoreEngine) {
    return;
  }
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  if (this.isDead()) {
    return;
  }
  if (this.isHidden()) {
    return;
  }
  if (_0x32a39b.note.match(/<(?:REGENERATE|REGEN|DEGEN|DOT|SLIP)[ ]ANIMATION:[ ](\d+)>/i)) {
    const _0x6b7263 = Number(RegExp.$1);
    $gameTemp.requestFauxAnimation([this], _0x6b7263, false, false);
  }
};
VisuMZ.BattleCore.Game_Battler_startTpbTurn = Game_Battler.prototype.startTpbTurn;
Game_Battler.prototype.startTpbTurn = function () {
  this.processBattleCoreJS('PreStartTurnJS');
  VisuMZ.BattleCore.Game_Battler_startTpbTurn.call(this);
  this.processBattleCoreJS("PostStartTurnJS");
};
VisuMZ.BattleCore.Game_Battler_onTurnEnd = Game_Battler.prototype.onTurnEnd;
Game_Battler.prototype.onTurnEnd = function () {
  this.processBattleCoreJS("PreEndTurnJS");
  VisuMZ.BattleCore.Game_Battler_onTurnEnd.call(this);
  if (VisuMZ.BattleCore.Settings.Mechanics.SyncBuffExpire) {
    this.removeBuffsAuto();
  }
  this.processBattleCoreJS('PostEndTurnJS');
};
Game_Battler.prototype.processBattleCoreJS = function (_0x57fdf0) {
  if (this._tempBattler || this._tempActor) {
    return;
  }
  const _0x310d69 = VisuMZ.BattleCore.Settings.Mechanics;
  if (_0x310d69[_0x57fdf0]) {
    _0x310d69[_0x57fdf0].call(this);
  }
  for (const _0x50aef6 of this.traitObjects()) {
    if (!_0x50aef6) {
      continue;
    }
    key = VisuMZ.BattleCore.createKeyJS(_0x50aef6, _0x57fdf0);
    if (VisuMZ.BattleCore.JS[key]) {
      VisuMZ.BattleCore.JS[key].call(this, this, this, _0x50aef6, 0x0);
    }
  }
};
Game_Battler.prototype.chantStyle = function () {
  return VisuMZ.BattleCore.Settings.Actor.ChantStyle || false;
};
Game_Battler.prototype.isChanting = function () {
  if (this.isWaiting()) {
    if (this.chantStyle()) {
      if (this._actions.some(_0xa3220a => _0xa3220a.item() && _0xa3220a.isMagical())) {
        return true;
      }
    } else {
      if (this._actions.some(_0x22da50 => _0x22da50.item() && _0x22da50.isMagicSkill())) {
        return true;
      }
    }
  }
  if (BattleManager.isTpb() && this._tpbState === "casting") {
    return this.chantStyle() ? this.currentAction() && this.currentAction().item() && this.currentAction().isMagical() : this.currentAction() && this.currentAction().item() && this.currentAction().isMagicSkill();
  }
  return false;
};
Game_Battler.prototype.isCharging = function () {
  if (BattleManager.isTpb() && this._tpbState === "casting") {
    return this.chantStyle() ? this.currentAction() && this.currentAction().item() && !this.currentAction().isMagical() : this.currentAction() && this.currentAction().item() && !this.currentAction().isMagicSkill();
  }
  return false;
};
VisuMZ.BattleCore.Game_Battler_clearDamagePopup = Game_Battler.prototype.clearDamagePopup;
Game_Battler.prototype.clearDamagePopup = function () {
  VisuMZ.BattleCore.Game_Battler_clearDamagePopup.call(this);
  this._damagePopupArray = [];
};
Game_Battler.prototype.isDamagePopupRequested = function () {
  if (!this._damagePopupArray) {
    this.clearDamagePopup();
  }
  return this._damagePopupArray.length > 0x0;
};
Game_Battler.prototype.startDamagePopup = function () {
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  if (BattleManager.shouldHideBattleEndPopups()) {
    return;
  }
  if (!this._damagePopupArray) {
    this.clearDamagePopup();
  }
  this.createSeparateDamagePopups();
  const _0x2cd1d2 = this.battler();
  if (_0x2cd1d2) {
    _0x2cd1d2.setupDamagePopup();
  }
};
Game_Battler.prototype.createSeparateDamagePopups = function () {
  const _0x52bef6 = this.result();
  if (_0x52bef6.missed || _0x52bef6.evaded) {
    const _0x392e26 = JsonEx.makeDeepCopy(_0x52bef6);
    _0x392e26.hpAffected = false;
    _0x392e26.mpDamage = 0x0;
    this._damagePopupArray.push(_0x392e26);
    if (!_0x52bef6.hpDamage && !_0x52bef6.mpDamage) {
      return;
    }
  }
  if (_0x52bef6.hpAffected) {
    const _0x53cfb1 = JsonEx.makeDeepCopy(_0x52bef6);
    _0x53cfb1.missed = false;
    _0x53cfb1.evaded = false;
    _0x53cfb1.mpDamage = 0x0;
    this._damagePopupArray.push(_0x53cfb1);
  }
  if (_0x52bef6.mpDamage !== 0x0) {
    const _0x1cf6a4 = JsonEx.makeDeepCopy(_0x52bef6);
    _0x1cf6a4.missed = false;
    _0x1cf6a4.evaded = false;
    _0x1cf6a4.hpAffected = false;
    this._damagePopupArray.push(_0x1cf6a4);
  }
};
Game_Battler.prototype.getNextDamagePopup = function () {
  if (!this._damagePopupArray) {
    this.clearDamagePopup();
  }
  return VisuMZ.BattleCore.Settings.Damage.NewPopupBottom ? this._damagePopupArray.shift() : this._damagePopupArray.pop();
};
Game_Battler.prototype.setupTextPopup = function (_0x27edae, _0x29b0a0) {
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  if (BattleManager.shouldHideBattleEndPopups()) {
    return;
  }
  if (!this.battler()) {
    return;
  }
  if (_0x27edae.length <= 0x0) {
    return;
  }
  _0x29b0a0 = _0x29b0a0 || {};
  _0x29b0a0.textColor = _0x29b0a0.textColor || "#ffffff";
  _0x29b0a0.flashColor = _0x29b0a0.flashColor || [0x0, 0x0, 0x0, 0x0];
  _0x29b0a0.flashDuration = _0x29b0a0.flashDuration || 0x0;
  this.battler().setupTextPopup(_0x27edae, _0x29b0a0);
};
Game_Battler.prototype.setupIconTextPopup = function (_0x58cc67, _0x368c72, _0x594282) {
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  if (BattleManager.shouldHideBattleEndPopups()) {
    return;
  }
  if (!this.battler()) {
    return;
  }
  if (_0x368c72.length <= 0x0) {
    return;
  }
  _0x594282 = _0x594282 || {};
  _0x594282.textColor = _0x594282.textColor || "#ffffff";
  _0x594282.flashColor = _0x594282.flashColor || [0x0, 0x0, 0x0, 0x0];
  _0x594282.flashDuration = _0x594282.flashDuration || 0x0;
  this.battler().setupIconTextPopup(_0x58cc67, _0x368c72, _0x594282);
};
Game_Battler.prototype.notFocusValid = function () {
  if (this.isHidden()) {
    return false;
  }
  if (this.isAlive() && this.isAppeared()) {
    return true;
  }
  if (this.isEnemy() && this.hasSvBattler()) {
    if (this.isDead() && this.allowCollapse()) {
      return false;
    }
  } else {
    if (this.isDead()) {
      return false;
    }
  }
  return true;
};
VisuMZ.BattleCore.Game_Battler_clearMotion = Game_Battler.prototype.clearMotion;
Game_Battler.prototype.clearMotion = function () {
  VisuMZ.BattleCore.Game_Battler_clearMotion.call(this);
  this.clearFreezeMotion();
};
Game_Battler.prototype.canBattlerMove = function () {
  return true;
};
Game_Battler.prototype.isBattlerGrounded = function () {
  return false;
};
VisuMZ.BattleCore.Game_Battler_onBattleStart = Game_Battler.prototype.onBattleStart;
Game_Battler.prototype.onBattleStart = function (_0x4aee8b) {
  VisuMZ.BattleCore.Game_Battler_onBattleStart.call(this, _0x4aee8b);
  this.onBattleStartBattleCore(_0x4aee8b);
  this.clearDamagePopup();
};
Game_Battler.prototype.onBattleStartBattleCore = function (_0x37f2e2) {
  this.setBattlerFlip(false);
  this._forcedHomeX = undefined;
  this._forcedHomeY = undefined;
};
VisuMZ.BattleCore.Game_Battler_onBattleEnd = Game_Battler.prototype.onBattleEnd;
Game_Battler.prototype.onBattleEnd = function () {
  VisuMZ.BattleCore.Game_Battler_onBattleEnd.call(this);
  this.onBattleEndBattleCore();
};
Game_Battler.prototype.onBattleEndBattleCore = function () {
  this._forcedHomeX = undefined;
  this._forcedHomeY = undefined;
};
VisuMZ.BattleCore.Game_Battler_performActionStart = Game_Battler.prototype.performActionStart;
Game_Battler.prototype.performActionStart = function (_0x47b118) {
  VisuMZ.BattleCore.Game_Battler_performActionStart.call(this, _0x47b118);
  if (!_0x47b118.isGuard()) {
    const _0x3ac030 = this.battler();
    if (_0x3ac030) {
      _0x3ac030.stepForward();
    }
  }
  this.setBattlerFlip(false);
};
Game_Battler.prototype.performActionEndMembers = function () {
  this._performDamageMotion = undefined;
  const _0x1276e4 = this._flinched;
  this._flinched = false;
  if (BattleManager.isActiveTpb() && this.isInputting()) {
    const _0x1dcb4d = this.battler();
    if (_0x1dcb4d && _0x1276e4) {
      _0x1dcb4d.stepForward();
    }
    return;
  }
  const _0x562bb8 = this.battler();
  if (_0x562bb8) {
    _0x562bb8.stepBack();
  }
  this.setBattlerFlip(false);
  this.requestMotionRefresh();
};
Game_Battler.prototype.performActionMotions = function (_0x24bbb0) {
  if (_0x24bbb0.isAttack()) {
    this.performAttack();
  } else {
    if (_0x24bbb0.isGuard()) {
      this.requestMotion('guard');
    } else {
      if (_0x24bbb0.isMagical()) {
        this.requestMotion('spell');
      } else {
        if (_0x24bbb0.isSkill()) {
          if ([0x1, 0x2, 0x5, 0x6].includes(_0x24bbb0.item().damage.type)) {
            this.performAttack();
          } else {
            this.requestMotion("skill");
          }
        } else if (_0x24bbb0.isItem()) {
          this.requestMotion("item");
        }
      }
    }
  }
};
Game_Battler.prototype.getAttackMotion = function () {
  return $dataSystem.attackMotions[0x0];
};
Game_Battler.prototype.getAttackWeaponAnimationId = function () {
  const _0x34e8ef = this.getAttackMotion();
  return _0x34e8ef ? _0x34e8ef.weaponImageId : 0x0;
};
Game_Battler.prototype.performSubstitute = function (_0xfddf1b) {
  if (!$gameSystem.isSideView()) {
    return;
  }
  const _0x2691a5 = this.battler();
  const _0x56a4df = _0xfddf1b.battler();
  if (!_0x2691a5 || !_0x56a4df) {
    return;
  }
  const _0x46bb8f = _0x56a4df._baseX;
  const _0x2ffd6b = _0x56a4df._baseY;
  this.moveBattlerToPoint(_0x46bb8f, _0x2ffd6b, 0x0, false, "Linear", -0x1);
  _0x2691a5.updatePosition();
  const _0x3e6501 = VisuMZ.BattleCore.Settings.ActionSequence;
  let _0x131f39 = (_0x56a4df.width + _0x2691a5.width) / 0x2;
  _0x131f39 *= this.isActor() ? 0x1 : -0x1;
  let _0x44c62a = _0x3e6501.StepDistanceY * (this.isActor() ? 0x1 : -0x1);
  _0xfddf1b.moveBattlerDistance(_0x131f39, _0x44c62a, 0x0, false, "Linear");
  _0x56a4df.updatePosition();
};
Game_Battler.prototype.requestMotion = function (_0xd62bd1) {
  if (SceneManager.isSceneBattle()) {
    const _0x1e48d3 = this.battler();
    if (_0x1e48d3) {
      _0x1e48d3.forceMotion(_0xd62bd1);
      if (['swing', 'thrust', 'missile'].includes(_0xd62bd1)) {
        this.performWeaponAnimation();
      }
    }
  }
  this.clearFreezeMotion();
};
Game_Battler.prototype.performWeaponAnimation = function () {};
Game_Battler.prototype.startWeaponAnimation = function (_0x10be02) {
  if (SceneManager.isSceneBattle()) {
    const _0x30675e = this.battler();
    if (_0x30675e) {
      _0x30675e.forceWeaponAnimation(_0x10be02);
    }
  }
};
Game_Battler.prototype.startAttackWeaponAnimation = function () {
  if (SceneManager.isSceneBattle()) {
    const _0x2fba58 = this.getAttackWeaponAnimationId();
    this.startWeaponAnimation(_0x2fba58);
  }
};
Game_Battler.prototype.performCastAnimation = function (_0x2a79aa, _0x368a47) {
  if (!_0x2a79aa) {
    return;
  }
  if (!_0x2a79aa.item()) {
    return;
  }
  if (_0x2a79aa.isAttack()) {
    return;
  }
  if (_0x2a79aa.isGuard()) {
    return;
  }
  if (_0x2a79aa.isItem()) {
    return;
  }
  if ($gameTemp._playTestFastMode) {
    return;
  }
  let _0x2775c6 = 0x0;
  const _0x5239e9 = VisuMZ.BattleCore.Settings.ActionSequence;
  const _0x1e9364 = _0x2a79aa.item().note;
  if (_0x1e9364.match(/<CAST ANIMATION: (\d+)>/i)) {
    _0x2775c6 = Number(RegExp.$1);
  } else {
    if (_0x1e9364.match(/<NO CAST ANIMATION>/i)) {
      return;
    } else {
      if (_0x2a79aa.isCertainHit()) {
        _0x2775c6 = _0x5239e9.CastCertain;
      } else {
        if (_0x2a79aa.isPhysical()) {
          _0x2775c6 = _0x5239e9.CastPhysical;
        } else if (_0x2a79aa.isMagical()) {
          _0x2775c6 = _0x5239e9.CastMagical;
        }
      }
    }
  }
  if (_0x2775c6 > 0x0) {
    $gameTemp.requestAnimation([this], _0x2775c6, !!_0x368a47);
  }
};
Game_Battler.prototype.performReflection = function () {
  SoundManager.playReflection();
  let _0x28e87f = VisuMZ.BattleCore.Settings.ActionSequence.ReflectAnimation;
  if (_0x28e87f > 0x0) {
    if (Imported.VisuMZ_0_CoreEngine) {
      $gameTemp.requestFauxAnimation([this], _0x28e87f);
    } else {
      $gameTemp.requestAnimation([this], _0x28e87f);
    }
  }
};
Game_Battler.prototype.isActiveTpbReady = function () {
  if (!$gameSystem.isSideView()) {
    return false;
  }
  if (!BattleManager.isActiveTpb()) {
    return false;
  }
  if (!this.isAlive()) {
    return false;
  }
  if (this.isInputting()) {
    return true;
  }
  if (this.isTpbReady()) {
    return true;
  }
  if (this._tpbChargeTime >= 0x1) {
    return true;
  }
  return false;
};
VisuMZ.BattleCore.Game_Battler_performDamage = Game_Battler.prototype.performDamage;
Game_Battler.prototype.performDamage = function () {
  if (this.isActiveTpbReady()) {
    this._performDamageMotion = true;
  }
  VisuMZ.BattleCore.Game_Battler_performDamage.call(this);
  this.performFlinch();
  this.performShakeFlinch();
};
VisuMZ.BattleCore.Game_Battler_performMiss = Game_Battler.prototype.performMiss;
Game_Battler.prototype.performMiss = function () {
  if (this.isActiveTpbReady()) {
    this._performDamageMotion = true;
  }
  VisuMZ.BattleCore.Game_Battler_performMiss.call(this);
  this.performFlinch();
};
VisuMZ.BattleCore.Game_Battler_performEvasion = Game_Battler.prototype.performEvasion;
Game_Battler.prototype.performEvasion = function () {
  if (this.isActiveTpbReady()) {
    this._performDamageMotion = true;
  }
  VisuMZ.BattleCore.Game_Battler_performEvasion.call(this);
  this.performFlinch();
};
Game_Battler.prototype.performFlinch = function () {
  if (!$gameSystem.isSideView()) {
    return;
  }
  if (this._flinched) {
    return;
  }
  this._flinched = true;
  const _0x5b9bd6 = this.battler();
  if (_0x5b9bd6) {
    _0x5b9bd6.stepFlinch();
  }
};
Game_Battler.prototype.performShakeFlinch = function () {
  if (!this.canBattlerMove()) {
    return;
  }
  const _0x2d3175 = VisuMZ.BattleCore.Settings.Actor;
  if (!(_0x2d3175.ShakeFlinch ?? false)) {
    return;
  }
  if (this._lastHpDamage <= 0x0) {
    return;
  }
  const _0x2ee62a = this.battler();
  if (_0x2ee62a) {
    const _0x518dde = this._lastHpDamage;
    const _0x5cb97f = (_0x518dde / this.mhp).clamp(0.8, 0x1);
    const _0x44c9b2 = _0x2d3175.ShakeFlinchPower ?? 0x30;
    const _0x83149c = _0x5cb97f * _0x44c9b2;
    _0x2ee62a.startShakeFlinch(_0x83149c, _0x5cb97f);
  }
};
Game_Battler.prototype.requestMotionRefresh = function () {
  if (this.isDead() && this._motionType !== "dead") {
    this.requestMotion("dead");
    return;
  }
  if (this.isDead() && this._motionType === "dead") {
    return;
  }
  if (!!this._freezeMotionData) {
    return;
  }
  if (this.isEnemy()) {
    if (!this.isDuringNonLoopingMotion() && this !== BattleManager._subject) {
      if (this.battler()) {
        this.battler().refreshMotion();
      }
    }
    this.clearFreezeMotion();
    return;
  }
  if (this._motionType === "victory") {
    return;
  }
  if (this._motionType === "escape" && !BattleManager.isInputting()) {
    return;
  }
  if (this._motionType === "guard" && !BattleManager.isInputting()) {
    return;
  }
  this.clearMotion();
  if (BattleManager.isActiveTpb() && this === BattleManager._subject) {
    return;
  }
  if (this.battler() && BattleManager.isInputting()) {
    this.battler().refreshMotion();
    this.clearFreezeMotion();
    return;
  }
  if (this.battler() && BattleManager.isActiveTpb() && this !== BattleManager._subject) {
    this.battler().refreshMotion();
  }
};
Game_Enemy.prototype.isDuringNonLoopingMotion = function () {
  if (!this.hasSvBattler()) {
    return false;
  }
  const _0x3ab273 = this.battler();
  if (!_0x3ab273) {
    return false;
  }
  const _0x10cad7 = _0x3ab273._svBattlerSprite;
  if (!_0x10cad7) {
    return false;
  }
  const _0x3c6ffe = _0x10cad7._motion;
  return _0x3c6ffe && !_0x3c6ffe.loop;
};
Game_Battler.prototype.isBattlerFlipped = function () {
  return this._isBattlerFlipped;
};
Game_Battler.prototype.setBattlerFlip = function (_0x35a7d2) {
  if (!$gameSystem.isSideView()) {
    return;
  }
  this._isBattlerFlipped = _0x35a7d2;
  const _0x454747 = this.battler();
  if (_0x454747) {
    _0x454747.updateFlip();
  }
};
Game_Battler.prototype.setBattlerFacePoint = function (_0x39fb0d, _0x10cc37, _0x1695a2) {
  if (!$gameSystem.isSideView()) {
    return;
  }
  const _0x38abc6 = this.battler();
  if (!_0x38abc6) {
    return;
  }
  if (_0x39fb0d === _0x38abc6._baseX) {
    return;
  }
  let _0x117429 = false;
  if (this.isActor()) {
    if (_0x39fb0d > _0x38abc6._baseX) {
      _0x117429 = true;
    }
    if (_0x39fb0d < _0x38abc6._baseX) {
      _0x117429 = false;
    }
  } else {
    if (this.isEnemy()) {
      if (_0x39fb0d > _0x38abc6._baseX) {
        _0x117429 = false;
      }
      if (_0x39fb0d < _0x38abc6._baseX) {
        _0x117429 = true;
      }
    }
  }
  ;
  this.setBattlerFlip(_0x1695a2 ? !_0x117429 : _0x117429);
  _0x38abc6.updateFlip();
};
Game_Battler.prototype.moveBattlerDistance = function (_0xe3854c, _0x5c53d3, _0x401ec7, _0x231b55, _0x5eeefc) {
  if (!$gameSystem.isSideView()) {
    return;
  }
  const _0x2cb71d = this.battler();
  if (!_0x2cb71d) {
    return;
  }
  if (_0x231b55) {
    this.setBattlerFacePoint(_0xe3854c + _0x2cb71d._baseX, _0x5c53d3 + _0x2cb71d._baseY, false);
  }
  _0xe3854c += _0x2cb71d._baseX - _0x2cb71d._homeX;
  _0x5c53d3 += _0x2cb71d._baseY - _0x2cb71d._homeY;
  _0x2cb71d.startMove(_0xe3854c, _0x5c53d3, _0x401ec7);
  if (Imported.VisuMZ_0_CoreEngine) {
    _0x2cb71d.setMoveEasingType(_0x5eeefc || "Linear");
  }
};
Game_Battler.prototype.moveBattlerToPoint = function (_0x2534f5, _0x38e80c, _0x16a87a, _0x3b45b0, _0x4745b1, _0x206e1c) {
  if (!$gameSystem.isSideView()) {
    return;
  }
  const _0x1a6ff2 = this.battler();
  if (!_0x1a6ff2) {
    return;
  }
  if (_0x2534f5 === Infinity || _0x38e80c === Infinity) {
    return;
  }
  if (isNaN(_0x2534f5) || isNaN(_0x38e80c)) {
    return;
  }
  _0x206e1c = _0x206e1c || 0x0;
  if (_0x206e1c > 0x0) {
    if (_0x1a6ff2._baseX > _0x2534f5) {
      _0x2534f5 += _0x1a6ff2.width / 0x2 + _0x206e1c;
    }
    if (_0x1a6ff2._baseX < _0x2534f5) {
      _0x2534f5 -= _0x1a6ff2.width / 0x2 + _0x206e1c;
    }
  }
  if (_0x3b45b0) {
    this.setBattlerFacePoint(_0x2534f5, _0x38e80c, false);
  }
  _0x2534f5 -= _0x1a6ff2._homeX;
  _0x38e80c -= _0x1a6ff2._homeY;
  _0x1a6ff2.startMove(_0x2534f5, _0x38e80c, _0x16a87a);
  if (Imported.VisuMZ_0_CoreEngine) {
    _0x1a6ff2.setMoveEasingType(_0x4745b1 || "Linear");
  }
};
Game_Battler.prototype.moveBattlerHomeDistance = function (_0x53aab0, _0x26bafd, _0x1eb961, _0x341715, _0x392374) {
  if (!$gameSystem.isSideView()) {
    return;
  }
  const _0x2bb72f = this.battler();
  if (!_0x2bb72f) {
    return;
  }
  if (_0x341715) {
    this.setBattlerFacePoint(_0x53aab0 + _0x2bb72f._baseX, _0x26bafd + _0x2bb72f._baseY, false);
  }
  _0x53aab0 += _0x2bb72f._homeX;
  _0x26bafd += _0x2bb72f._homeY;
  _0x2bb72f.startHomeMove(_0x53aab0, _0x26bafd, _0x1eb961, _0x392374);
  this._forcedHomeX = _0x53aab0;
  this._forcedHomeY = _0x26bafd;
};
Game_Battler.prototype.moveBattlerHomeToPoint = function (_0x1a5b40, _0x7f5048, _0x5d11ef, _0x482f60, _0x214dc0, _0x360901) {
  if (!$gameSystem.isSideView()) {
    return;
  }
  const _0x6ea51 = this.battler();
  if (!_0x6ea51) {
    return;
  }
  _0x360901 = _0x360901 || 0x0;
  if (_0x360901 > 0x0) {
    if (_0x6ea51._baseX > _0x1a5b40) {
      _0x1a5b40 += _0x6ea51.width / 0x2 + _0x360901;
    }
    if (_0x6ea51._baseX < _0x1a5b40) {
      _0x1a5b40 -= _0x6ea51.width / 0x2 + _0x360901;
    }
  }
  if (_0x482f60) {
    this.setBattlerFacePoint(_0x1a5b40, _0x7f5048, false);
  }
  _0x6ea51.startHomeMove(_0x1a5b40, _0x7f5048, _0x5d11ef, _0x214dc0);
  this._forcedHomeX = _0x1a5b40;
  this._forcedHomeY = _0x7f5048;
};
Game_Battler.prototype.floatBattler = function (_0x5869d7, _0x4be704, _0x4a1ea3) {
  if (!$gameSystem.isSideView()) {
    return;
  }
  const _0x461449 = this.battler();
  if (!_0x461449) {
    return;
  }
  _0x461449.startFloat(_0x5869d7, _0x4be704, _0x4a1ea3);
};
Game_Battler.prototype.jumpBattler = function (_0x181024, _0x309a7f) {
  if (!$gameSystem.isSideView()) {
    return;
  }
  const _0x419858 = this.battler();
  if (!_0x419858) {
    return;
  }
  _0x419858.startJump(_0x181024, _0x309a7f);
};
Game_Battler.prototype.spinBattler = function (_0x2fa136, _0x539428, _0x23eae0, _0x4dd4e6) {
  if (!$gameSystem.isSideView()) {
    return;
  }
  const _0x206795 = this.battler();
  if (!_0x206795) {
    return;
  }
  _0x206795.startSpin(_0x2fa136, _0x539428, _0x23eae0, _0x4dd4e6);
};
Game_Battler.prototype.skewBattler = function (_0x2380c7, _0x42d27e, _0x2659b2, _0x3213f6) {
  if (!$gameSystem.isSideView()) {
    return;
  }
  const _0xee7f27 = this.battler();
  if (!_0xee7f27) {
    return;
  }
  if (this.isActor()) {
    _0x2380c7 *= -0x1;
    _0x42d27e *= -0x1;
  }
  _0xee7f27.startSkew(_0x2380c7, _0x42d27e, _0x2659b2, _0x3213f6);
};
Game_Battler.prototype.growBattler = function (_0x9e5d09, _0x5eda95, _0x57159a, _0x5578ca) {
  if (!$gameSystem.isSideView()) {
    return;
  }
  const _0x363491 = this.battler();
  if (!_0x363491) {
    return;
  }
  _0x363491.startGrow(_0x9e5d09, _0x5eda95, _0x57159a, _0x5578ca);
};
Game_Battler.prototype.changeBattlerOpacity = function (_0x364d87, _0x3c5ba1, _0x425723) {
  if (!$gameSystem.isSideView()) {
    return;
  }
  const _0x4be0e4 = this.battler();
  if (!_0x4be0e4) {
    return;
  }
  _0x4be0e4.startOpacity(_0x364d87, _0x3c5ba1, _0x425723);
};
Game_Battler.prototype.clearFreezeMotion = function () {
  const _0x55ad9e = !!this._freezeMotionData;
  this._freezeMotionData = undefined;
  if (_0x55ad9e) {
    this.requestMotionRefresh();
    this.clearFreezeMotionForWeapons();
  }
};
Game_Battler.prototype.clearFreezeMotionForWeapons = function () {
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  const _0x321a2a = this.battler();
  if (!_0x321a2a) {
    return;
  }
  let _0x5cdf88 = this.isActor() ? _0x321a2a._weaponSprite : _0x321a2a._svBattlerSprite._weaponSprite;
  if (_0x5cdf88) {
    _0x5cdf88.setup(0x0);
  }
};
Game_Battler.prototype.freezeMotion = function (_0x28571c, _0x3d74d6, _0x2bccef) {
  if (this.isEnemy() && !this.hasSvBattler()) {
    return;
  }
  let _0x508d84 = 0x0;
  let _0x2aa50a = 0x0;
  if (_0x28571c.match(/ATTACK[ ](\d+)/i)) {
    _0x2aa50a = Number(RegExp.$1);
    _0x2aa50a--;
  }
  if (this.isActor()) {
    const _0xc99296 = this.weapons();
    _0x508d84 = _0xc99296[_0x2aa50a] ? _0xc99296[_0x2aa50a].wtypeId : 0x0;
  } else if (this.isEnemy()) {
    _0x508d84 = this.svBattlerData().wtypeId || 0x0;
  }
  const _0x11b2b5 = $dataSystem.attackMotions[_0x508d84];
  if (_0x28571c.match(/attack/i)) {
    _0x28571c = ['thrust', "swing", "missile"][_0x11b2b5.type] || "swing";
  }
  this._freezeMotionData = {
    'motionType': _0x28571c,
    'weaponImageId': _0x3d74d6 ? _0x11b2b5.weaponImageId : 0x0,
    'pattern': _0x2bccef
  };
};
Game_Battler.prototype.isFriendly = function (_0xfab710) {
  if (!_0xfab710) {
    return false;
  }
  return _0xfab710.friendsUnit() === this.friendsUnit();
};
Game_Battler.prototype.isOpponent = function (_0x10a346) {
  if (!_0x10a346) {
    return false;
  }
  return _0x10a346.opponentsUnit() === this.friendsUnit();
};
Game_Battler.prototype.hasStaticSvBattler = function () {
  return false;
};
Game_Actor.prototype.hasStaticSvBattler = function () {
  return this.battlerName().match(/\$/i);
};
Game_Enemy.prototype.hasStaticSvBattler = function () {
  return this.hasSvBattler() && this.svBattlerName().match(/\$/i);
};
VisuMZ.BattleCore.Game_Actor_setup = Game_Actor.prototype.setup;
Game_Actor.prototype.setup = function (_0x2c983c) {
  VisuMZ.BattleCore.Game_Actor_setup.call(this, _0x2c983c);
  this.initBattlePortrait();
};
Game_Actor.prototype.initBattlePortrait = function () {
  this._battlePortrait = '';
  if (this.actor() && this.actor().note.match(/<BATTLE (?:IMAGE|PORTRAIT):[ ](.*)>/i)) {
    this._battlePortrait = String(RegExp.$1);
  }
};
Game_Actor.prototype.getBattlePortraitFilename = function () {
  if (this.getBattlePortrait() !== '') {
    return this.getBattlePortrait();
  } else {
    if (Imported.VisuMZ_1_MainMenuCore && this.getMenuImage() !== '') {
      return this.getMenuImage();
    }
  }
  return '';
};
Game_Actor.prototype.getBattlePortrait = function () {
  if (this._battlePortrait === undefined) {
    this.initBattlePortrait();
  }
  return this._battlePortrait;
};
Game_Actor.prototype.setBattlePortrait = function (_0x3b26d7) {
  if (this._battlePortrait === undefined) {
    this.initBattlePortrait();
  }
  this._battlePortrait = _0x3b26d7;
  if (SceneManager.isSceneBattle() && $gameParty.battleMembers().includes(this)) {
    const _0x57a62f = SceneManager._scene._statusWindow;
    if (_0x57a62f) {
      _0x57a62f.refreshActorPortrait(this);
    }
  }
};
Game_Actor.prototype.isSpriteVisible = function () {
  return true;
};
Game_Actor.prototype.isAutoBattle = function () {
  if (!this.isConfused() && BattleManager._autoBattle) {
    return true;
  }
  return Game_Battler.prototype.isAutoBattle.call(this);
};
VisuMZ.BattleCore.Game_Actor_makeActionList = Game_Actor.prototype.makeActionList;
Game_Actor.prototype.makeActionList = function () {
  if (BattleManager._autoBattle && !ConfigManager.autoBattleUseSkills) {
    return this.makeActionListAutoAttack();
  } else {
    return VisuMZ.BattleCore.Game_Actor_makeActionList.call(this);
    ;
  }
};
Game_Actor.prototype.makeActionListAutoAttack = function () {
  const _0x1afe73 = [];
  const _0x2f4242 = new Game_Action(this);
  _0x2f4242.setAttack();
  _0x1afe73.push(_0x2f4242);
  return _0x1afe73;
};
Game_Actor.prototype.battleCommands = function () {
  return this.currentClass().note.match(/<BATTLE COMMANDS>\s*([\s\S]*)\s*<\/BATTLE COMMANDS>/i) ? String(RegExp.$1).split(/[\r\n]+/) : VisuMZ.BattleCore.Settings.ActorCmd.BattleCmdList;
};
Game_Actor.prototype.svBattlerAnchorX = function () {
  if (this._cache.svAnchorX !== undefined) {
    return this._cache.svAnchorX;
  }
  if (this.actor().note.match(/<SIDEVIEW ANCHOR: (.*), (.*)>/i)) {
    this._cache.svAnchorX = eval(RegExp.$1);
    this._cache.svAnchorY = eval(RegExp.$2);
  } else {
    this._cache.svAnchorX = Game_Battler.prototype.svBattlerAnchorX.call(this);
  }
  return this._cache.svAnchorX;
};
Game_Actor.prototype.svBattlerAnchorY = function () {
  if (this._cache.svAnchorY !== undefined) {
    return this._cache.svAnchorY;
  }
  if (this.actor().note.match(/<SIDEVIEW ANCHOR: (.*), (.*)>/i)) {
    this._cache.svAnchorX = eval(RegExp.$1);
    this._cache.svAnchorY = eval(RegExp.$2);
  } else {
    this._cache.svAnchorY = Game_Battler.prototype.svBattlerAnchorY.call(this);
  }
  return this._cache.svAnchorY;
};
Game_Actor.prototype.svBattlerShadowVisible = function () {
  if (this._cache.svShadow !== undefined) {
    return this._cache.svShadow;
  }
  if (this.actor().note.match(/<SIDEVIEW SHOW SHADOW>/i)) {
    this._cache.svShadow = true;
  } else if (this.actor().note.match(/<SIDEVIEW HIDE SHADOW>/i)) {
    this._cache.svShadow = false;
  } else {
    this._cache.svShadow = Game_Battler.prototype.svBattlerShadowVisible.call(this);
  }
  return this._cache.svShadow;
};
Game_Actor.prototype.battlerSmoothImage = function () {
  return VisuMZ.BattleCore.Settings.Actor.SmoothImage;
};
Game_Actor.prototype.performWeaponAnimation = function () {
  const _0x50e5be = this.weapons();
  const _0x4bc5a1 = _0x50e5be[0x0] ? _0x50e5be[0x0].wtypeId : 0x0;
  const _0x28ae55 = $dataSystem.attackMotions[_0x4bc5a1];
  if (_0x28ae55) {
    this.startWeaponAnimation(_0x28ae55.weaponImageId);
  }
};
Game_Actor.prototype.performAction = function (_0x3cf5b7) {
  Game_Battler.prototype.performAction.call(this, _0x3cf5b7);
  this.performActionMotions(_0x3cf5b7);
};
Game_Actor.prototype.getAttackMotion = function () {
  const _0x3e0b3a = this.weapons();
  const _0x12c668 = _0x3e0b3a[0x0] ? _0x3e0b3a[0x0].wtypeId : 0x0;
  return $dataSystem.attackMotions[_0x12c668];
};
Game_Actor.prototype.attackAnimationIdSlot = function (_0x52d0a8) {
  _0x52d0a8 = _0x52d0a8 || 0x1;
  _0x52d0a8--;
  const _0x34a41e = this.weapons();
  return _0x34a41e[_0x52d0a8] ? _0x34a41e[_0x52d0a8].animationId : 0x0;
};
Game_Actor.prototype.getAttackMotionSlot = function (_0x1cce97) {
  _0x1cce97 = _0x1cce97 || 0x1;
  _0x1cce97--;
  const _0x1eb1da = this.weapons();
  const _0x5ef2fc = _0x1eb1da[_0x1cce97] ? _0x1eb1da[_0x1cce97].wtypeId : 0x0;
  return $dataSystem.attackMotions[_0x5ef2fc];
};
Game_Actor.prototype.performAttackSlot = function (_0x533a6c) {
  _0x533a6c = _0x533a6c || 0x1;
  _0x533a6c--;
  const _0x43181a = this.weapons();
  const _0x7f2a7b = _0x43181a[_0x533a6c] ? _0x43181a[_0x533a6c].wtypeId : 0x0;
  const _0xd30e00 = $dataSystem.attackMotions[_0x7f2a7b];
  if (_0xd30e00) {
    if (_0xd30e00.type === 0x0) {
      this.requestMotion("thrust");
    } else {
      if (_0xd30e00.type === 0x1) {
        this.requestMotion('swing');
      } else if (_0xd30e00.type === 0x2) {
        this.requestMotion("missile");
      }
    }
    this.startWeaponAnimation(_0xd30e00.weaponImageId);
  }
};
Game_Battler.prototype.setActiveWeaponSlot = function (_0x3bc15d) {
  if (this.isActor()) {
    const _0x3b9180 = this.weapons();
    if (_0x3b9180.length > 0x0) {
      const _0x24c5fd = _0x3b9180[_0x3bc15d];
      if (_0x24c5fd) {
        _0x3bc15d = this.equips().indexOf(_0x24c5fd);
      }
    }
  }
  this._activeWeaponSlot = _0x3bc15d || 0x0;
  this._cache = {};
};
Game_Battler.prototype.nextActiveWeaponSlot = function () {
  this._activeWeaponSlot = this._activeWeaponSlot || 0x0;
  this._activeWeaponSlot++;
  this._cache = {};
};
Game_Battler.prototype.clearActiveWeaponSlot = function () {
  this._activeWeaponSlot = undefined;
  this._cache = {};
};
VisuMZ.BattleCore.Game_Actor_equips = Game_Actor.prototype.equips;
Game_Actor.prototype.equips = function () {
  let _0x31f0eb = VisuMZ.BattleCore.Game_Actor_equips.call(this);
  if (this._tempEquipCheck) {
    return _0x31f0eb;
  }
  if (this._activeWeaponSlot !== undefined) {
    this._tempEquipCheck = true;
    const _0x3baee2 = this.equipSlots();
    for (let _0x4703d3 = 0x0; _0x4703d3 < _0x3baee2.length; _0x4703d3++) {
      if (_0x3baee2[_0x4703d3] === 0x1 && this._activeWeaponSlot !== _0x4703d3) {
        _0x31f0eb[_0x4703d3] = null;
      }
    }
    this._tempEquipCheck = undefined;
  }
  return _0x31f0eb;
};
Window_BattleLog.prototype.getDualWieldTimes = function (_0x2c15be) {
  return _0x2c15be.isActor() ? _0x2c15be.weapons().length || 0x1 : 0x1;
};
Window_BattleLog.prototype.setActiveWeaponSet = function (_0x58f677, _0x42b00) {
  if (_0x58f677 && _0x58f677.isActor()) {
    _0x58f677.setActiveWeaponSlot(_0x42b00);
  }
  this.callNextMethod();
};
Window_BattleLog.prototype.clearActiveWeaponSet = function (_0xa52ecf) {
  if (_0xa52ecf && _0xa52ecf.isActor()) {
    _0xa52ecf.clearActiveWeaponSlot();
  }
  this.callNextMethod();
};
Game_Actor.prototype.battleUIOffsetX = function () {
  if (this.checkCacheKey("battleUIOffsetX")) {
    return this._cache.battleUIOffsetX;
  }
  this._cache.battleUIOffsetX = this.createBattleUIOffsetX(this.actor());
  return this._cache.battleUIOffsetX;
};
Game_Actor.prototype.battleUIOffsetY = function () {
  if (this.checkCacheKey("battleUIOffsetY")) {
    return this._cache.battleUIOffsetY;
  }
  this._cache.battleUIOffsetY = this.createBattleUIOffsetY(this.actor());
  return this._cache.battleUIOffsetY;
};
VisuMZ.BattleCore.Game_Enemy_setup = Game_Enemy.prototype.setup;
Game_Enemy.prototype.setup = function (_0x4c8ae3, _0x2b5e58, _0x36a5ff) {
  _0x4c8ae3 = DataManager.swapEnemyIDs(_0x4c8ae3);
  VisuMZ.BattleCore.Game_Enemy_setup.call(this, _0x4c8ae3, _0x2b5e58, _0x36a5ff);
  if (Imported.VisuMZ_1_ElementStatusCore) {
    this.initElementStatusCore();
  }
  this.clearBattleCoreData();
  this.setupBattleCoreData();
  if (Imported.VisuMZ_1_ElementStatusCore) {
    this.recoverAll();
  }
};
Game_Enemy.prototype.clearBattleCoreData = function () {
  const _0xa11a7a = VisuMZ.BattleCore.Settings.Enemy;
  this._attackAnimationId = _0xa11a7a.AttackAnimation;
  this._svBattlerData = {};
  this.resetNameTempVisibility();
};
Game_Enemy.prototype.setupBattleCoreData = function () {
  const _0x9bd04b = VisuMZ.BattleCore.Settings.Enemy;
  const _0xae8ae0 = this.enemy().note;
  this._svBattlerData = {
    'name': '',
    'wtypeId': _0x9bd04b.WtypeId,
    'collapse': _0x9bd04b.AllowCollapse,
    'motionIdle': _0x9bd04b.MotionIdle,
    'width': _0x9bd04b.Width || 0x40,
    'height': _0x9bd04b.Height || 0x40,
    'anchorX': _0x9bd04b.AnchorX || 0x0,
    'anchorY': _0x9bd04b.AnchorY || 0x0,
    'shadow': _0x9bd04b.Shadow
  };
  if (_0xae8ae0.match(/<ATTACK ANIMATION:[ ](\d+)>/i)) {
    this._attackAnimationId = Number(RegExp.$1);
  }
  const _0x83604b = this._svBattlerData;
  if (_0xae8ae0.match(/<SIDEVIEW BATTLER: (.*)>/i)) {
    _0x83604b.name = String(RegExp.$1);
  } else {
    if (_0xae8ae0.match(/<SIDEVIEW BATTLERS>\s*([\s\S]*)\s*<\/SIDEVIEW BATTLERS>/i)) {
      const _0x5c792e = String(RegExp.$1).split(/[\r\n]+/).remove('');
      _0x83604b.name = DataManager.processRandomizedData(_0x5c792e);
    }
  }
  if (_0xae8ae0.match(/<SIDEVIEW ANCHOR: (.*), (.*)>/i)) {
    _0x83604b.anchorX = eval(RegExp.$1);
    _0x83604b.anchorY = eval(RegExp.$2);
  }
  if (_0xae8ae0.match(/<SIDEVIEW COLLAPSE>/i)) {
    _0x83604b.collapse = true;
  } else if (_0xae8ae0.match(/<SIDEVIEW NO COLLAPSE>/i)) {
    _0x83604b.collapse = false;
  }
  if (_0xae8ae0.match(/<SIDEVIEW SHOW SHADOW>/i)) {
    _0x83604b.shadow = true;
  } else if (_0xae8ae0.match(/<SIDEVIEW HIDE SHADOW>/i)) {
    _0x83604b.shadow = false;
  }
  if (_0xae8ae0.match(/<SIDEVIEW IDLE MOTION: (.*)>/i)) {
    _0x83604b.motionIdle = String(RegExp.$1).toLowerCase().trim();
  } else {
    if (_0xae8ae0.match(/<SIDEVIEW IDLE MOTIONS>\s*([\s\S]*)\s*<\/SIDEVIEW IDLE MOTIONS>/i)) {
      const _0x4a612c = String(RegExp.$1).split(/[\r\n]+/).remove('');
      _0x83604b.motionIdle = DataManager.processRandomizedData(_0x4a612c);
    }
  }
  if (_0xae8ae0.match(/<SIDEVIEW SIZE: (\d+), (\d+)>/i)) {
    _0x83604b.width = Number(RegExp.$1);
    _0x83604b.height = Number(RegExp.$2);
  }
  if (_0xae8ae0.match(/<SIDEVIEW WEAPON: (.*)>/i)) {
    _0x83604b.wtypeId = DataManager.getWtypeIdWithName(RegExp.$1);
  } else {
    if (_0xae8ae0.match(/<SIDEVIEW WEAPONS>\s*([\s\S]*)\s*<\/SIDEVIEW WEAPONS>/i)) {
      const _0x47816a = String(RegExp.$1).split(/[\r\n]+/).remove('');
      const _0x3adca4 = DataManager.processRandomizedData(_0x47816a);
      _0x83604b.wtypeId = DataManager.getWtypeIdWithName(_0x3adca4);
    }
  }
  if (Imported.VisuMZ_1_ElementStatusCore) {
    const _0x1fe6e1 = this.getTraitSetKeys();
    for (const _0x3a1dd0 of _0x1fe6e1) {
      const _0x44a5c1 = this.traitSet(_0x3a1dd0).Name.toUpperCase().trim();
      const _0x262792 = _0x3a1dd0.toUpperCase().trim();
      if (_0xae8ae0.match(VisuMZ.ElementStatusCore.RegExp["SvBattlerSolo-%1-%2".format(_0x262792, _0x44a5c1)])) {
        _0x83604b.name = String(RegExp.$1);
      } else {
        if (_0xae8ae0.match(VisuMZ.ElementStatusCore.RegExp["SvBattlerMass-%1-%2".format(_0x262792, _0x44a5c1)])) {
          const _0x284306 = String(RegExp.$1).split(/[\r\n]+/).remove('');
          _0x83604b.name = DataManager.processRandomizedData(_0x284306);
        }
      }
      if (_0xae8ae0.match(VisuMZ.ElementStatusCore.RegExp["SvWeaponSolo-%1-%2".format(_0x262792, _0x44a5c1)])) {
        _0x83604b.wtypeId = DataManager.getWtypeIdWithName(RegExp.$1);
      } else {
        if (_0xae8ae0.match(VisuMZ.ElementStatusCore.RegExp["SvWeaponMass-%1-%2".format(_0x262792, _0x44a5c1)])) {
          const _0x28efe1 = String(RegExp.$1).split(/[\r\n]+/).remove('');
          const _0x286c96 = DataManager.processRandomizedData(_0x28efe1);
          _0x83604b.wtypeId = DataManager.getWtypeIdWithName(_0x286c96);
        }
      }
      if (_0xae8ae0.match(VisuMZ.ElementStatusCore.RegExp["SvMotionIdleSolo-%1-%2".format(_0x262792, _0x44a5c1)])) {
        _0x83604b.motionIdle = String(RegExp.$1).toLowerCase().trim();
      } else {
        if (_0xae8ae0.match(VisuMZ.ElementStatusCore.RegExp["SvMotionIdleMass-%1-%2".format(_0x262792, _0x44a5c1)])) {
          const _0x1fd9ea = String(RegExp.$1).split(/[\r\n]+/).remove('');
          _0x83604b.motionIdle = DataManager.processRandomizedData(_0x1fd9ea);
        }
      }
    }
  }
};
Game_Enemy.prototype.attackAnimationId1 = function () {
  return this._attackAnimationId || 0x0;
};
Game_Enemy.prototype.attackAnimationId2 = function () {
  return this.attackAnimationId1();
};
Game_Enemy.prototype.attackAnimationIdSlot = function (_0x203fa0) {
  return this.attackAnimationId1();
};
Game_Enemy.prototype.canBattlerMove = function () {
  if (this.enemy().note.match(/<BATTLER SPRITE CANNOT MOVE>/i)) {
    return false;
  }
  return Game_Battler.prototype.canBattlerMove.call(this);
};
Game_Enemy.prototype.isBattlerGrounded = function () {
  if (this.enemy().note.match(/<BATTLER SPRITE GROUNDED>/i)) {
    return true;
  }
  return false;
};
Game_Enemy.prototype.skills = function () {
  const _0x31a0c2 = [];
  for (const _0x503239 of this.enemy().actions) {
    const _0xbdb635 = $dataSkills[_0x503239.skillId];
    if (_0xbdb635 && !_0x31a0c2.includes(_0xbdb635)) {
      _0x31a0c2.push(_0xbdb635);
    }
  }
  return _0x31a0c2;
};
Game_Enemy.prototype.battleUIOffsetX = function () {
  if (this.checkCacheKey('battleUIOffsetX')) {
    return this._cache.battleUIOffsetX;
  }
  this._cache.battleUIOffsetX = this.createBattleUIOffsetX(this.enemy());
  return this._cache.battleUIOffsetX;
};
Game_Enemy.prototype.battleUIOffsetY = function () {
  if (this.checkCacheKey("battleUIOffsetY")) {
    return this._cache.battleUIOffsetY;
  }
  this._cache.battleUIOffsetY = this.createBattleUIOffsetY(this.enemy());
  return this._cache.battleUIOffsetY;
};
Game_Enemy.prototype.svBattlerData = function () {
  if (this._svBattlerData !== undefined) {
    return this._svBattlerData;
  }
  this.setupBattleCoreData();
  return this._svBattlerData;
};
Game_Enemy.prototype.hasSvBattler = function () {
  return this.svBattlerData().name !== '';
};
Game_Enemy.prototype.svBattlerName = function () {
  return this.svBattlerData().name;
};
Game_Enemy.prototype.battlerSmoothImage = function () {
  return this.hasSvBattler() ? VisuMZ.BattleCore.Settings.Actor.SmoothImage : VisuMZ.BattleCore.Settings.Enemy.SmoothImage;
};
Game_Enemy.prototype.performAction = function (_0x337e9a) {
  Game_Battler.prototype.performAction.call(this, _0x337e9a);
  if (this.hasSvBattler()) {
    this.performActionMotions(_0x337e9a);
  }
};
Game_Enemy.prototype.performAttack = function () {
  const _0x19169c = this.svBattlerData().wtypeId || 0x0;
  const _0x2dda46 = $dataSystem.attackMotions[_0x19169c];
  if (_0x2dda46) {
    if (_0x2dda46.type === 0x0) {
      this.requestMotion("thrust");
    } else {
      if (_0x2dda46.type === 0x1) {
        this.requestMotion("swing");
      } else if (_0x2dda46.type === 0x2) {
        this.requestMotion("missile");
      }
    }
  }
};
Game_Enemy.prototype.performWeaponAnimation = function () {
  const _0x1a5da2 = this.svBattlerData().wtypeId || 0x0;
  const _0x328414 = $dataSystem.attackMotions[_0x1a5da2];
  if (_0x328414) {
    this.startWeaponAnimation(_0x328414.weaponImageId);
  }
};
Game_Enemy.prototype.getAttackMotion = function () {
  const _0x318da3 = this.svBattlerData().wtypeId || 0x0;
  return $dataSystem.attackMotions[_0x318da3];
};
Game_Enemy.prototype.getAttackMotionSlot = function (_0x3f1bce) {
  return this.getAttackMotion();
};
Game_Enemy.prototype.performDamage = function () {
  Game_Battler.prototype.performDamage.call(this);
  if (this.isSpriteVisible() && this.hasSvBattler()) {
    this.requestMotion("damage");
  }
  SoundManager.playEnemyDamage();
};
Game_Enemy.prototype.performEvasion = function () {
  Game_Battler.prototype.performEvasion.call(this);
  this.requestMotion("evade");
};
Game_Enemy.prototype.performMagicEvasion = function () {
  Game_Battler.prototype.performMagicEvasion.call(this);
  this.requestMotion('evade');
};
Game_Enemy.prototype.performCounter = function () {
  Game_Battler.prototype.performCounter.call(this);
  this.performAttack();
};
Game_Enemy.prototype.allowCollapse = function () {
  if (this.hasSvBattler()) {
    if (this.collapseType() >= 0x1) {
      return true;
    }
    return this.svBattlerData().collapse;
  } else {
    return true;
  }
};
Game_Enemy.prototype.svBattlerAnchorX = function () {
  return this.svBattlerData().anchorX;
};
Game_Enemy.prototype.svBattlerAnchorY = function () {
  return this.svBattlerData().anchorY;
};
Game_Enemy.prototype.svBattlerShadowVisible = function () {
  return this.svBattlerData().shadow;
};
VisuMZ.BattleCore.Game_Enemy_transform = Game_Enemy.prototype.transform;
Game_Enemy.prototype.transform = function (_0x56aa99) {
  VisuMZ.BattleCore.Game_Enemy_transform.call(this, _0x56aa99);
  this.clearBattleCoreData();
  this.setupBattleCoreData();
  const _0x2991dd = this.battler();
  if (_0x2991dd) {
    _0x2991dd._battlerName = undefined;
    _0x2991dd.setBattler(this);
  }
};
Game_Enemy.prototype.resetNameTempVisibility = function () {
  const _0x3bdb55 = VisuMZ.BattleCore.Settings.Enemy;
  this._nameTempVisibleDuration = _0x3bdb55.NameDamageVisibility ?? 0x0;
};
Game_Enemy.prototype.isNameTemporarilyVisible = function () {
  return this._nameTempVisibleDuration && this._nameTempVisibleDuration > 0x0;
};
Game_Enemy.prototype.updateNameTempVisibility = function () {
  if (this._nameTempVisibleDuration && this._nameTempVisibleDuration > 0x0) {
    this._nameTempVisibleDuration--;
  }
};
Game_Enemy.prototype.clearNameTempVisibility = function () {
  this._nameTempVisibleDuration = 0x0;
};
Game_Unit.prototype.processBattleCoreJS = function (_0xbe6dee) {
  for (const _0x1c684a of this.members()) {
    if (_0x1c684a) {
      _0x1c684a.processBattleCoreJS(_0xbe6dee);
    }
  }
};
Game_Unit.prototype.trueRandomTarget = function () {
  const _0x4bf250 = this.aliveMembers();
  return _0x4bf250[Math.randomInt(_0x4bf250.length)];
};
VisuMZ.BattleCore.Game_Party_addActor = Game_Party.prototype.addActor;
Game_Party.prototype.addActor = function (_0x491b6f) {
  VisuMZ.BattleCore.Game_Party_addActor.call(this, _0x491b6f);
  BattleManager.refreshStatusWindow();
};
VisuMZ.BattleCore.Game_Party_removeActor = Game_Party.prototype.removeActor;
Game_Party.prototype.removeActor = function (_0x228cd1) {
  VisuMZ.BattleCore.Game_Party_removeActor.call(this, _0x228cd1);
  BattleManager.refreshStatusWindow();
};
VisuMZ.BattleCore.Game_Troop_setup = Game_Troop.prototype.setup;
Game_Troop.prototype.setup = function (_0x1368f1) {
  $gameTemp.clearForcedGameTroopSettingsBattleCore();
  $gameTemp.applyForcedGameTroopSettingsBattleCore(_0x1368f1);
  VisuMZ.BattleCore.Game_Troop_setup.call(this, _0x1368f1);
  this.extendTroopMembers();
};
VisuMZ.BattleCore.Game_Troop_expTotal = Game_Troop.prototype.expTotal;
Game_Troop.prototype.expTotal = function () {
  let _0x2637b2 = VisuMZ.BattleCore.Game_Troop_expTotal.call(this);
  if (this.expRate) {
    _0x2637b2 *= this.expRate();
  }
  return Math.ceil(_0x2637b2);
};
Game_Troop.prototype.expRate = function () {
  return 0x1;
};
Game_Troop.prototype.extendTroopMembers = function () {
  const _0x7c1eb = DataManager.createTroopNote(this.troop().id);
  if (_0x7c1eb.match(/<(?:EXTEND|ADD):[ ](.*?)>/i)) {
    const _0x35adb7 = RegExp.$1.split(',').map(_0x38ac22 => Number(_0x38ac22));
    this.checkExtendTroopCompatibility();
    this.processExtendTroopMembers(_0x35adb7);
  }
};
Game_Troop.prototype.checkExtendTroopCompatibility = function () {
  let _0x2c4069 = "Update your Battle System - %1 to the latest\n";
  _0x2c4069 += "version in order to use the <Extend: x> function.";
  if (Imported.VisuMZ_2_BattleSystemBTB) {
    if (VisuMZ.BattleSystemBTB.version < 1.11) {
      alert(_0x2c4069.format('BTB'));
      SceneManager.exit();
    }
  }
  if (Imported.VisuMZ_2_BattleSystemCTB) {
    if (VisuMZ.BattleSystemCTB.version < 1.19) {
      alert(_0x2c4069.format("CTB"));
      SceneManager.exit();
    }
  }
  if (Imported.VisuMZ_2_BattleSystemSTB) {
    if (VisuMZ.BattleSystemSTB.version < 1.15) {
      alert(_0x2c4069.format("STB"));
      SceneManager.exit();
    }
  }
};
Game_Troop.prototype.processExtendTroopMembers = function (_0x1abae0) {
  this._namesCount = {};
  for (const _0x33a0e2 of this.members()) {
    if (!_0x33a0e2) {
      continue;
    }
    _0x33a0e2.setLetter('');
  }
  for (const _0x7086f2 of _0x1abae0) {
    const _0x3c5219 = $dataTroops[_0x7086f2];
    if (_0x3c5219) {
      this.addExtendedTroopMembers(_0x3c5219);
    }
  }
  this.makeUniqueNames();
};
Game_Troop.prototype.addExtendedTroopMembers = function (_0x586f28) {
  for (const _0x134c22 of _0x586f28.members) {
    if ($dataEnemies[_0x134c22.enemyId]) {
      const _0x580d95 = _0x134c22.enemyId;
      const _0x3a22a0 = _0x134c22.x;
      const _0x3b31d8 = _0x134c22.y;
      const _0x384379 = new Game_Enemy(_0x580d95, _0x3a22a0, _0x3b31d8);
      if (_0x134c22.hidden) {
        _0x384379.hide();
      }
      this._enemies.push(_0x384379);
    }
  }
};
VisuMZ.BattleCore.Game_Map_setupBattleback = Game_Map.prototype.setupBattleback;
Game_Map.prototype.setupBattleback = function () {
  VisuMZ.BattleCore.Game_Map_setupBattleback.call(this);
  this.setupBattlebackBattleCore();
};
Game_Map.prototype.setupBattlebackBattleCore = function () {
  this._regionBattleback1 = {};
  this._regionBattleback2 = {};
  if (!$dataMap) {
    return;
  }
  const _0xd273a7 = $dataMap.note;
  if (!_0xd273a7) {
    return;
  }
  const _0x8b12be = _0xd273a7.match(/<REGION (\d+) BATTLEBACK(\d+): (.*)>/gi);
  if (_0x8b12be) {
    for (const _0xb99858 of _0x8b12be) {
      _0xb99858.match(/<REGION (\d+) BATTLEBACK(\d+): (.*)>/i);
      const _0x18ca47 = Number(RegExp.$1);
      const _0x5ebb73 = Number(RegExp.$2);
      const _0xc69452 = _0x5ebb73 === 0x1 ? this._regionBattleback1 : this._regionBattleback2;
      const _0x3f5203 = String(RegExp.$3);
      _0xc69452[_0x18ca47] = _0x3f5203;
    }
  }
};
VisuMZ.BattleCore.Game_Map_battleback1Name = Game_Map.prototype.battleback1Name;
Game_Map.prototype.battleback1Name = function () {
  if (!BattleManager.isBattleTest()) {
    const _0x35b167 = $gamePlayer.regionId($gamePlayer.x, $gamePlayer.y);
    if (this._regionBattleback1 && this._regionBattleback1[_0x35b167]) {
      return this._regionBattleback1[_0x35b167];
    }
  }
  return VisuMZ.BattleCore.Game_Map_battleback1Name.call(this);
};
VisuMZ.BattleCore.Game_Map_battleback2Name = Game_Map.prototype.battleback2Name;
Game_Map.prototype.battleback2Name = function () {
  if (!BattleManager.isBattleTest()) {
    const _0x567edb = $gamePlayer.regionId($gamePlayer.x, $gamePlayer.y);
    if (this._regionBattleback1 && this._regionBattleback2[_0x567edb]) {
      return this._regionBattleback2[_0x567edb];
    }
  }
  return VisuMZ.BattleCore.Game_Map_battleback2Name.call(this);
};
VisuMZ.BattleCore.Game_Map_encounterList = Game_Map.prototype.encounterList;
Game_Map.prototype.encounterList = function () {
  let _0x574510 = JsonEx.makeDeepCopy(VisuMZ.BattleCore.Game_Map_encounterList.call(this));
  return VisuMZ.BattleCore.ShuffleArray(_0x574510);
};
VisuMZ.BattleCore.ShuffleArray = function (_0xc7c851) {
  var _0x3d9ccf;
  var _0x4acee6;
  var _0x534ecf;
  for (_0x534ecf = _0xc7c851.length - 0x1; _0x534ecf > 0x0; _0x534ecf--) {
    _0x3d9ccf = Math.floor(Math.random() * (_0x534ecf + 0x1));
    _0x4acee6 = _0xc7c851[_0x534ecf];
    _0xc7c851[_0x534ecf] = _0xc7c851[_0x3d9ccf];
    _0xc7c851[_0x3d9ccf] = _0x4acee6;
  }
  return _0xc7c851;
};
VisuMZ.BattleCore.Game_Interpreter_PluginCommand = Game_Interpreter.prototype.command357;
Game_Interpreter.prototype.command357 = function (_0x2f7813) {
  $gameTemp.setLastPluginCommandInterpreter(this);
  return VisuMZ.BattleCore.Game_Interpreter_PluginCommand.call(this, _0x2f7813);
};
VisuMZ.BattleCore.Game_Interpreter_updateWaitMode = Game_Interpreter.prototype.updateWaitMode;
Game_Interpreter.prototype.updateWaitMode = function () {
  if (SceneManager.isSceneBattle()) {
    switch (this._waitMode) {
      case "battleAngle":
        if (Imported.VisuMZ_3_ActSeqCamera) {
          if ($gameScreen.battleCameraData().angleDuration > 0x0) {
            return true;
          }
          this._waitMode = '';
        }
        break;
      case "battleAnimation":
        if (BattleManager._spriteset.isAnimationPlaying()) {
          return true;
        }
        this._waitMode = '';
        break;
      case 'battleBalloon':
        if (BattleManager._spriteset.isAnyBattleBalloonPlaying()) {
          return true;
        }
        this._waitMode = '';
        break;
      case "battleCamera":
        if (Imported.VisuMZ_3_ActSeqCamera) {
          if ($gameScreen.battleCameraData().cameraDuration > 0x0) {
            return true;
          }
          if ($gameScreen.battleCameraData().cameraOffsetDuration > 0x0) {
            return true;
          }
          this._waitMode = '';
        }
        break;
      case "battleEffect":
        if (BattleManager._spriteset.isEffecting()) {
          return true;
        }
        this._waitMode = '';
        break;
      case 'battleFloat':
        if (BattleManager._spriteset.isAnyoneFloating()) {
          return true;
        }
        this._waitMode = '';
        break;
      case "battleJump":
        if (BattleManager._spriteset.isAnyoneJumping()) {
          return true;
        }
        this._waitMode = '';
        break;
      case "battlelog":
        if (BattleManager._logWindow.isBusy()) {
          return true;
        }
        this._waitMode = '';
        break;
      case "battleMove":
        if (BattleManager._spriteset.isAnyoneMoving()) {
          return true;
        }
        this._waitMode = '';
        break;
      case "battleOpacity":
        if (BattleManager._spriteset.isAnyoneChangingOpacity()) {
          return true;
        }
        this._waitMode = '';
        break;
      case "battleGrow":
        if (BattleManager._spriteset.isAnyoneGrowing()) {
          return true;
        }
        this._waitMode = '';
        break;
      case "battleSpriteSkew":
        if (BattleManager._spriteset.isAnyoneSkewing()) {
          return true;
        }
        this._waitMode = '';
        break;
      case "battleProjectiles":
        if (Imported.VisuMZ_3_ActSeqProjectiles) {
          if (BattleManager._spriteset.isAnyProjectilePresent()) {
            return true;
          }
          this._waitMode = '';
        }
        break;
      case 'battleSkew':
        if (Imported.VisuMZ_3_ActSeqCamera) {
          if ($gameScreen.battleCameraData().skewDuration > 0x0) {
            return true;
          }
          this._waitMode = '';
        }
        break;
      case "battleSpin":
        if (BattleManager._spriteset.isAnyoneSpinning()) {
          return true;
        }
        this._waitMode = '';
        break;
      case 'battleZoom':
        if (Imported.VisuMZ_3_ActSeqCamera) {
          if ($gameScreen.battleCameraData().zoomDuration > 0x0) {
            return true;
          }
          this._waitMode = '';
        }
        break;
      case 'battleInjectPrep':
        if (Imported.VisuMZ_3_ActSeqImpact) {
          if (BattleManager._spriteset.isAnyoneInjectAniPrepping) {
            if (BattleManager._spriteset.isAnyoneInjectAniPrepping()) {
              return true;
            }
            this._waitMode = "battleInjectAni";
          } else {
            this._waitMode = '';
          }
          break;
        }
        break;
      case "battleInjectAni":
        if (Imported.VisuMZ_3_ActSeqImpact) {
          if (BattleManager._spriteset.isAnyoneInjectAnimating()) {
            return true;
          }
          this._waitMode = '';
        }
        break;
    }
  }
  return VisuMZ.BattleCore.Game_Interpreter_updateWaitMode.call(this);
};
VisuMZ.BattleCore.Game_Interpreter_command301 = Game_Interpreter.prototype.command301;
Game_Interpreter.prototype.command301 = function (_0x14ab4a) {
  return !$gameParty.inBattle() ? this.command301_PreBattleEvent(_0x14ab4a) : VisuMZ.BattleCore.Game_Interpreter_command301.call(this, _0x14ab4a);
};
Game_Interpreter.prototype.command3011 = function (_0x3aa140) {
  VisuMZ.BattleCore.Game_Interpreter_command301.call(this, _0x3aa140);
  BattleManager.setEventCallback(_0x11b513 => {
    this._branch[this._indent] = _0x11b513;
  });
  return true;
};
VisuMZ.BattleCore.CheckMapBattleEventValid = function (_0x500ea7) {
  const _0x1728e4 = $dataCommonEvents[_0x500ea7];
  if (!_0x1728e4) {
    return false;
  }
  if (_0x1728e4.list.length <= 0x1) {
    return false;
  }
  return true;
};
Game_Interpreter.prototype.command301_PreBattleEvent = function (_0x3c48da) {
  const _0x496207 = VisuMZ.BattleCore.Settings.Mechanics;
  const _0x19dd8c = _0x496207.BattleStartEvent;
  const _0x24914b = $dataCommonEvents[_0x19dd8c];
  if (_0x24914b && VisuMZ.BattleCore.CheckMapBattleEventValid(_0x19dd8c)) {
    const _0x11fc41 = this.isOnCurrentMap() ? this._eventId : 0x0;
    const _0x19f2ab = _0x24914b.list;
    this.setupChild(_0x19f2ab, _0x11fc41);
    this._list = JsonEx.makeDeepCopy(this._list);
    const _0x24d736 = {
      'code': 0xbc3,
      'indent': this._indent,
      'parameters': JsonEx.makeDeepCopy(_0x3c48da)
    };
    this._list.splice(this._index + 0x1, 0x0, _0x24d736);
    return true;
  } else {
    return VisuMZ.BattleCore.Game_Interpreter_command301.call(this, _0x3c48da);
  }
};
VisuMZ.BattleCore.BattleManager_onEncounter = BattleManager.onEncounter;
BattleManager.onEncounter = function () {
  VisuMZ.BattleCore.BattleManager_onEncounter.call(this);
  this.onEncounterBattleCore();
};
BattleManager.onEncounterBattleCore = function () {
  const _0x1eb06c = VisuMZ.BattleCore.Settings.Mechanics;
  const _0x2064bf = _0x1eb06c.BattleStartEvent;
  if (_0x2064bf && VisuMZ.BattleCore.CheckMapBattleEventValid(_0x2064bf)) {
    this._battleCoreBattleStartEvent = true;
    $gameTemp.reserveCommonEvent(_0x1eb06c.BattleStartEvent);
    $gameMap.updateInterpreter();
    $gameMap._interpreter._preBattleCommonEvent = true;
  }
  if (_0x1eb06c.DefeatEvent > 0x0) {
    this._canLose = true;
  }
};
VisuMZ.BattleCore.Scene_Map_updateCallMenu = Scene_Map.prototype.updateCallMenu;
Scene_Map.prototype.updateCallMenu = function () {
  if (BattleManager._battleCoreBattleStartEvent) {
    return;
  }
  VisuMZ.BattleCore.Scene_Map_updateCallMenu.call(this);
};
VisuMZ.BattleCore.Scene_Map_launchBattle = Scene_Map.prototype.launchBattle;
Scene_Map.prototype.launchBattle = function () {
  if (BattleManager._battleCoreBattleStartEvent) {
    this.battleCorePreBattleCommonEvent();
  } else {
    VisuMZ.BattleCore.Scene_Map_launchBattle.call(this);
  }
};
Scene_Map.prototype.battleCorePreBattleCommonEvent = function () {
  this._active = true;
};
VisuMZ.BattleCore.SceneManager_isSceneChanging = SceneManager.isSceneChanging;
SceneManager.isSceneChanging = function () {
  if (BattleManager._battleCoreBattleStartEvent) {
    return false;
  }
  return VisuMZ.BattleCore.SceneManager_isSceneChanging.call(this);
};
VisuMZ.BattleCore.Game_Interpreter_terminate = Game_Interpreter.prototype.terminate;
Game_Interpreter.prototype.terminate = function () {
  VisuMZ.BattleCore.Game_Interpreter_terminate.call(this);
  if (this._preBattleCommonEvent) {
    this._preBattleCommonEvent = undefined;
    SceneManager._scene.battleCoreResumeLaunchBattle();
  }
};
Scene_Map.prototype.battleCoreResumeLaunchBattle = function () {
  BattleManager._battleCoreBattleStartEvent = undefined;
  BattleManager._battleCoreBattleResumeAfter = true;
  this.stop();
};
VisuMZ.BattleCore.Scene_Map_initializeAfter = Scene_Map.prototype.initialize;
Scene_Map.prototype.initialize = function () {
  VisuMZ.BattleCore.Scene_Map_initializeAfter.call(this);
  if (BattleManager._battleCoreBattleResumeAfter) {
    this._active = true;
    BattleManager._battleCoreBattleResumeAfter = undefined;
  }
};
VisuMZ.BattleCore.Scene_Map_initialize = Scene_Map.prototype.initialize;
Scene_Map.prototype.initialize = function () {
  VisuMZ.BattleCore.Scene_Map_initialize.call(this);
  $gameTemp.clearForcedGameTroopSettingsBattleCore();
};
VisuMZ.BattleCore.Scene_ItemBase_applyItem = Scene_ItemBase.prototype.applyItem;
Scene_ItemBase.prototype.applyItem = function () {
  VisuMZ.BattleCore.Scene_ItemBase_applyItem.call(this);
  if (this.item().note.match(/<BYPASS AUTO ACTION SEQUENCE>/i)) {
    return;
  }
  if (this.item().note.match(/<CUSTOM ACTION SEQUENCE>/i)) {
    $gameTemp._commonEventQueue = [];
  }
  if (DataManager.checkAutoCustomActionSequenceNotetagEffect(this.item())) {
    $gameTemp._commonEventQueue = [];
  }
};
VisuMZ.BattleCore.Scene_Options_maxCommands = Scene_Options.prototype.maxCommands;
Scene_Options.prototype.maxCommands = function () {
  let _0x2fea43 = VisuMZ.BattleCore.Scene_Options_maxCommands.call(this);
  const _0x58d948 = VisuMZ.BattleCore.Settings;
  if (_0x58d948.AutoBattle.AddOption && _0x58d948.AutoBattle.AdjustRect) {
    _0x2fea43 += 0x2;
  }
  if (_0x58d948.HpGauge.AddOption && _0x58d948.HpGauge.AdjustRect) {
    _0x2fea43 += 0x1;
  }
  return _0x2fea43;
};
VisuMZ.BattleCore.Scene_Battle_initialize = Scene_Battle.prototype.initialize;
Scene_Battle.prototype.initialize = function () {
  VisuMZ.BattleCore.Scene_Battle_initialize.call(this);
  this.clearOnceParallelInterpreters();
};
VisuMZ.BattleCore.Scene_Battle_start = Scene_Battle.prototype.start;
Scene_Battle.prototype.start = function () {
  if (SceneManager.isPreviousSceneBattleTransitionable()) {
    Scene_Message.prototype.start.call(this);
    if (this._spriteset) {
      this._spriteset.update();
    }
    if (BattleManager._tpbSceneChangeCacheActor) {
      BattleManager.revertTpbCachedActor();
    }
  } else {
    VisuMZ.BattleCore.Scene_Battle_start.call(this);
    $gameTroop.onBattleStartOnceParallels();
  }
};
VisuMZ.BattleCore.Scene_Battle_stop = Scene_Battle.prototype.stop;
Scene_Battle.prototype.stop = function () {
  if (SceneManager.isNextSceneBattleTransitionable()) {
    Scene_Message.prototype.stop.call(this);
  } else {
    VisuMZ.BattleCore.Scene_Battle_stop.call(this);
  }
};
VisuMZ.BattleCore.Scene_Battle_terminate = Scene_Battle.prototype.terminate;
Scene_Battle.prototype.terminate = function () {
  if (SceneManager.isNextSceneBattleTransitionable()) {
    Scene_Message.prototype.terminate.call(this);
  } else {
    VisuMZ.BattleCore.Scene_Battle_terminate.call(this);
  }
  $gameTemp.clearBattleBalloons();
  this.clearOnceParallelInterpreters();
};
Scene_Battle.prototype.isRightInputMode = function () {
  if (ConfigManager.uiMenuStyle && ConfigManager.uiInputPosition !== undefined) {
    return ConfigManager.uiInputPosition;
  } else {
    if (this.battleLayoutStyle() === 'border') {
      return false;
    } else {
      return Scene_Message.prototype.isRightInputMode.call(this);
      ;
    }
  }
};
VisuMZ.BattleCore.Scene_Battle_createAllWindows = Scene_Battle.prototype.createAllWindows;
Scene_Battle.prototype.createAllWindows = function () {
  this.createEnemyNameContainer();
  VisuMZ.BattleCore.Scene_Battle_createAllWindows.call(this);
  this.createAutoBattleWindow();
};
VisuMZ.BattleCore.Scene_Battle_createEnemyWindow = Scene_Battle.prototype.createEnemyWindow;
Scene_Battle.prototype.createEnemyWindow = function () {
  VisuMZ.BattleCore.Scene_Battle_createEnemyWindow.call(this);
  this.createMultiTargetWindows();
};
Scene_Battle.prototype.createMultiTargetWindows = function () {
  this.createMultiTargetWindow(true);
  this.createMultiTargetWindow(false);
};
Scene_Battle.prototype.multiTargetWindowRect = function (_0x3b8203) {
  const _0xc20ea2 = Window_BattleMultiTarget.WIDTH;
  const _0x1d77f7 = this.calcWindowHeight(0x1, true);
  let _0x42adfe = _0x3b8203 ? Graphics.boxWidth - _0xc20ea2 : 0x0;
  _0x42adfe += _0x3b8203 ? Window_BattleMultiTarget.ACTOR_OFFSET_X : Window_BattleMultiTarget.ENEMY_OFFSET_X;
  const _0x366784 = ['frontview_ui'].includes(this.battleLayoutStyle()) ? 0x0 : this._statusWindow.height;
  let _0x5177cf = Graphics.boxHeight - _0x366784 - _0x1d77f7;
  _0x5177cf += _0x3b8203 ? Window_BattleMultiTarget.ACTOR_OFFSET_Y : Window_BattleMultiTarget.ENEMY_OFFSET_Y;
  return new Rectangle(_0x42adfe, _0x5177cf, _0xc20ea2, _0x1d77f7);
};
Scene_Battle.prototype.createMultiTargetWindow = function (_0x2dedf2) {
  const _0xfb4f27 = this.multiTargetWindowRect(_0x2dedf2);
  const _0x52f4e5 = new Window_BattleMultiTarget(_0xfb4f27, _0x2dedf2);
  this.addWindow(_0x52f4e5);
  if (_0x2dedf2) {
    this._actorMultiTargetWindow = _0x52f4e5;
  } else {
    this._enemyMultiTargetWindow = _0x52f4e5;
  }
};
VisuMZ.BattleCore.Scene_Battle_createCancelButton = Scene_Battle.prototype.createCancelButton;
Scene_Battle.prototype.createCancelButton = function () {
  VisuMZ.BattleCore.Scene_Battle_createCancelButton.call(this);
  if (this.battleLayoutStyle() === "border") {
    this.repositionCancelButtonBorderStyle();
  }
};
Scene_Battle.prototype.setVisibleUI = function (_0x349cad) {
  if (_0x349cad) {
    this._windowLayer.x = (Graphics.width - Graphics.boxWidth) / 0x2;
    this._windowLayer.y = (Graphics.height - Graphics.boxHeight) / 0x2;
  } else {
    this._windowLayer.x = Graphics.width * 0xa;
    this._windowLayer.y = Graphics.height * 0xa;
  }
};
VisuMZ.BattleCore.Scene_Battle_selectNextCommand = Scene_Battle.prototype.selectNextCommand;
Scene_Battle.prototype.selectNextCommand = function () {
  const _0x3250bd = BattleManager.actor();
  VisuMZ.BattleCore.Scene_Battle_selectNextCommand.call(this);
  if (_0x3250bd) {
    if (_0x3250bd === BattleManager.actor()) {
      return;
    }
    if (_0x3250bd === BattleManager._subject) {
      return;
    }
    if (_0x3250bd.battler()) {
      _0x3250bd.battler().stepBack();
    }
  }
};
VisuMZ.BattleCore.Scene_Battle_selectPreviousCommand = Scene_Battle.prototype.selectPreviousCommand;
Scene_Battle.prototype.selectPreviousCommand = function () {
  const _0x2823b0 = BattleManager.actor();
  if (_0x2823b0 && _0x2823b0.battler) {
    _0x2823b0.battler().stepBack();
  }
  VisuMZ.BattleCore.Scene_Battle_selectPreviousCommand.call(this);
};
VisuMZ.BattleCore.Scene_Battle_logWindowRect = Scene_Battle.prototype.logWindowRect;
Scene_Battle.prototype.logWindowRect = function () {
  if (VisuMZ.BattleCore.Settings.BattleLog.BattleLogRectJS) {
    return VisuMZ.BattleCore.Settings.BattleLog.BattleLogRectJS.call(this);
  }
  return VisuMZ.BattleCore.Scene_Battle_logWindowRect.call(this);
};
VisuMZ.BattleCore.Scene_Battle_createPartyCommandWindow = Scene_Battle.prototype.createPartyCommandWindow;
Scene_Battle.prototype.createPartyCommandWindow = function () {
  VisuMZ.BattleCore.Scene_Battle_createPartyCommandWindow.call(this);
  this.createPartyCommandWindowBattleCore();
};
Scene_Battle.prototype.createPartyCommandWindowBattleCore = function () {
  const _0x51044f = this._partyCommandWindow;
  _0x51044f.setHandler("autoBattle", this.commandAutoBattle.bind(this));
  _0x51044f.setHandler("options", this.commandOptions.bind(this));
  const _0x505467 = this.battleLayoutStyle();
  switch (_0x505467) {
    case 'xp':
    case "portrait":
      return this._partyCommandWindow.setBackgroundType(0x1);
      break;
  }
};
Scene_Battle.prototype.commandAutoBattle = function () {
  BattleManager._autoBattle = true;
  $gameParty.makeActions();
  this.selectNextCommand();
  if (BattleManager.isTpb()) {
    BattleManager._inputting = false;
  }
};
Scene_Battle.prototype.commandOptions = function () {
  if (this.isQueueOptionsMenu()) {
    this._callSceneOptions = true;
    this._logWindow.push('addText', VisuMZ.BattleCore.Settings.PartyCmd.ActiveTpbOptionsMessage);
  } else {
    this.callOptions();
  }
};
Scene_Battle.prototype.isQueueOptionsMenu = function () {
  return BattleManager.isActiveTpb();
};
Scene_Battle.prototype.callOptions = function () {
  this._callSceneOptions = false;
  this._spriteset.update();
  this._windowLayer.visible = false;
  if (BattleManager.isBattleTest()) {
    if ($dataSystem.battleback1Name || $dataSystem.battleback2Name) {
      SceneManager.snapForBackground();
    }
  } else if ($gameMap.battleback1Name() || $gameMap.battleback2Name()) {
    SceneManager.snapForBackground();
  }
  SceneManager.push(Scene_Options);
  if (BattleManager.isTpb()) {
    BattleManager._tpbSceneChangeCacheActor = BattleManager.actor();
  }
};
VisuMZ.BattleCore.Scene_Battle_updateBattleProcess = Scene_Battle.prototype.updateBattleProcess;
Scene_Battle.prototype.updateBattleProcess = function () {
  VisuMZ.BattleCore.Scene_Battle_updateBattleProcess.call(this);
  if (this._callSceneOptions && !BattleManager._subject) {
    this.callOptions();
  }
};
VisuMZ.BattleCore.Scene_Battle_update = Scene_Battle.prototype.update;
Scene_Battle.prototype.update = function () {
  VisuMZ.BattleCore.Scene_Battle_update.call(this);
  this.updateOnceParallelInterpreters();
};
Scene_Battle.prototype.createAutoBattleWindow = function () {
  const _0x16813a = this.autoBattleWindowRect();
  this._autoBattleWindow = new Window_AutoBattleCancel(_0x16813a);
  this._autoBattleWindow.hide();
  this.addChild(this._autoBattleWindow);
};
Scene_Battle.prototype.autoBattleWindowRect = function () {
  return VisuMZ.BattleCore.Settings.AutoBattle.AutoBattleRect.call(this);
};
Scene_Battle.prototype.clearOnceParallelInterpreters = function () {
  this._onceParallelInterpreters = [];
};
Scene_Battle.prototype.updateOnceParallelInterpreters = function () {
  if (!this._onceParallelInterpreters) {
    return;
  }
  for (const _0x500d84 of this._onceParallelInterpreters) {
    if (_0x500d84) {
      _0x500d84.update();
    }
  }
};
Scene_Battle.prototype.playOnceParallelInterpreter = function (_0x21148e) {
  const _0x418efa = $dataCommonEvents[_0x21148e];
  if (!_0x418efa) {
    return;
  }
  const _0x4e1fd5 = new Game_BattleOnceParallelInterpreter();
  this.addOnceParallelInterpreter(_0x4e1fd5);
  _0x4e1fd5.setCommonEvent(_0x21148e);
};
Scene_Battle.prototype.addOnceParallelInterpreter = function (_0x251dab) {
  this._onceParallelInterpreters = this._onceParallelInterpreters || [];
  this._onceParallelInterpreters.push(_0x251dab);
};
Scene_Battle.prototype.removeOnceParallelInterpreter = function (_0x4d8604) {
  this._onceParallelInterpreters = this._onceParallelInterpreters || [];
  this._onceParallelInterpreters.remove(_0x4d8604);
};
Game_Troop.prototype.onBattleStartOnceParallels = function () {
  for (const _0x248328 of this.troop().pages) {
    if (!this.doesPageHaveOnceParallelStart(_0x248328)) {
      continue;
    }
    SceneManager._scene.playOnceParallelTroopPage(_0x248328);
  }
};
Game_Troop.prototype.doesPageHaveOnceParallelStart = function (_0x399605) {
  if (!_0x399605) {
    return;
  }
  for (const _0x28083c of _0x399605.list) {
    if ([0x6c, 0x198].includes(_0x28083c.code)) {
      const _0xc6f169 = _0x28083c.parameters[0x0];
      if (_0xc6f169.match(/<ONCE PARALLEL WHEN START BATTLE>/i)) {
        return true;
      }
    }
  }
  return false;
};
Scene_Battle.prototype.playOnceParallelTroopPage = function (_0x3ff4f0) {
  if (!_0x3ff4f0) {
    return;
  }
  const _0x24ac5d = new Game_BattleOnceParallelInterpreter();
  this.addOnceParallelInterpreter(_0x24ac5d);
  _0x24ac5d.setTroopPage(_0x3ff4f0);
};
function Game_BattleOnceParallelInterpreter() {
  this.initialize(...arguments);
}
Game_BattleOnceParallelInterpreter.prototype = Object.create(Game_Interpreter.prototype);
Game_BattleOnceParallelInterpreter.prototype.constructor = Game_BattleOnceParallelInterpreter;
Game_BattleOnceParallelInterpreter.prototype.setCommonEvent = function (_0x16f726) {
  const _0x56f29d = $dataCommonEvents[_0x16f726];
  if (_0x56f29d) {
    this.setup(_0x56f29d.list, 0x0);
  } else {
    this.terminate();
  }
};
Game_BattleOnceParallelInterpreter.prototype.terminate = function () {
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  SceneManager._scene.removeOnceParallelInterpreter(this);
  Game_Interpreter.prototype.terminate.call(this);
};
Game_BattleOnceParallelInterpreter.prototype.setTroopPage = function (_0x378e61) {
  if (_0x378e61) {
    this.setup(_0x378e61.list, 0x0);
  } else {
    this.terminate();
  }
};
Scene_Battle.prototype.isPartyCommandWindowDisabled = function () {
  return VisuMZ.BattleCore.Settings.PartyCmd.DisablePartyCmd;
};
VisuMZ.BattleCore.Scene_Battle_startPartyCommandSelection = Scene_Battle.prototype.startPartyCommandSelection;
Scene_Battle.prototype.startPartyCommandSelection = function () {
  if (this.isPartyCommandWindowDisabled()) {
    this.onDisabledPartyCommandSelection();
  } else {
    VisuMZ.BattleCore.Scene_Battle_startPartyCommandSelection.call(this);
  }
};
Scene_Battle.prototype.onDisabledPartyCommandSelection = function () {
  if (BattleManager.isDTB()) {
    this.selectNextCommand();
  } else if (BattleManager.isTpb()) {
    VisuMZ.BattleCore.Scene_Battle_startPartyCommandSelection.call(this);
  }
};
VisuMZ.BattleCore.Scene_Battle_commandFight = Scene_Battle.prototype.commandFight;
Scene_Battle.prototype.commandFight = function () {
  if (BattleManager.isTpb()) {
    this.tpbCommandFight();
    this.startActorCommandSelection();
  } else {
    VisuMZ.BattleCore.Scene_Battle_commandFight.call(this);
  }
};
Scene_Battle.prototype.tpbCommandFight = function () {
  if (!VisuMZ.BattleCore.TpbActiveChangeEnabled) {
    return;
  }
  if (Imported.VisuMZ_2_BattleSystemCTB && BattleManager.isCTB()) {
    return;
  }
  const _0x35a5da = $gameParty.aliveMembers().filter(_0x28f8d6 => _0x28f8d6.isTpbCharged() && _0x28f8d6.canInput());
  BattleManager._currentActor = _0x35a5da[0x0] || null;
  if (BattleManager._currentActor) {
    BattleManager._currentActor.setActionState("inputting");
  }
};
VisuMZ.BattleCore.Scene_Battle_commandEscape = Scene_Battle.prototype.commandEscape;
Scene_Battle.prototype.commandEscape = function () {
  VisuMZ.BattleCore.Scene_Battle_commandEscape.call(this);
  if (!BattleManager.isTpb()) {
    BattleManager._currentActor = null;
  }
};
VisuMZ.BattleCore.Scene_Battle_createActorCommandWindow = Scene_Battle.prototype.createActorCommandWindow;
Scene_Battle.prototype.createActorCommandWindow = function () {
  VisuMZ.BattleCore.Scene_Battle_createActorCommandWindow.call(this);
  this.createActorCommandWindowBattleCore();
};
Scene_Battle.prototype.createActorCommandWindowBattleCore = function () {
  const _0x66c613 = this._actorCommandWindow;
  _0x66c613.setHandler('escape', this.actorCommandEscape.bind(this));
  _0x66c613.setHandler("autoBattle", this.actorCommandAutoBattle.bind(this));
  _0x66c613.setHandler('singleSkill', this.actorCommandSingleSkill.bind(this));
  if (BattleManager.isTpb()) {
    if (this.isPartyCommandWindowDisabled()) {
      delete _0x66c613._handlers.cancel;
    } else {
      _0x66c613.setHandler("cancel", this.actorCommandCancelTPB.bind(this));
    }
  }
};
Scene_Battle.prototype.actorCommandEscape = function () {
  this.commandEscape();
};
Scene_Battle.prototype.actorCommandAutoBattle = function () {
  BattleManager.actor().makeAutoBattleActions();
  BattleManager.finishActorInput();
  BattleManager.selectNextActor();
  this.changeInputWindow();
};
Scene_Battle.prototype.actorCommandSingleSkill = function () {
  const _0x2cc291 = BattleManager.inputtingAction();
  const _0x3b991b = this._actorCommandWindow.currentExt();
  _0x2cc291.setSkill(_0x3b991b);
  BattleManager.actor().setLastBattleSkill($dataSkills[_0x3b991b]);
  this.onSelectAction();
};
Scene_Battle.prototype.actorCommandCancelTPB = function () {
  if (this.tpbActorSwitchConditionsMet()) {
    this.performTpbActiveCheckSwitch();
  } else {
    this.processActorCommandCancelTPB();
  }
};
VisuMZ.BattleCore.TpbActiveChangeEnabled = false;
Scene_Battle.prototype.tpbActorSwitchConditionsMet = function () {
  if (Imported.VisuMZ_2_BattleSystemCTB && BattleManager.isCTB()) {
    return false;
  } else {
    if (!VisuMZ.BattleCore.TpbActiveChangeEnabled) {
      return false;
    }
    const _0xaa419f = $gameParty.aliveMembers().filter(_0x226777 => _0x226777.isTpbCharged() && _0x226777.canInput());
    return _0xaa419f.length > 0x0 && BattleManager.actor() !== _0xaa419f[_0xaa419f.length - 0x1];
  }
};
Scene_Battle.prototype.performTpbActiveCheckSwitch = function () {
  const _0x2b329b = BattleManager.actor();
  const _0x21df20 = _0x2b329b.battler();
  if (_0x21df20) {
    _0x21df20.stepBack();
  }
  const _0x58d06a = $gameParty.aliveMembers().filter(_0x7697d4 => _0x7697d4.isTpbCharged() && _0x7697d4.canInput());
  const _0x444a8e = _0x58d06a.indexOf(_0x2b329b);
  const _0x4b6071 = _0x58d06a[_0x444a8e + 0x1];
  BattleManager._currentActor = _0x4b6071 || null;
  if (_0x4b6071) {
    _0x4b6071.setActionState("inputting");
  }
  _0x2b329b.setActionState("undecided");
  this.changeInputWindow();
};
Scene_Battle.prototype.processActorCommandCancelTPB = function () {
  this._partyCommandWindow.setup();
  this._actorCommandWindow.close();
  if (!VisuMZ.BattleCore.TpbActiveChangeEnabled) {
    return;
  }
  if (Imported.VisuMZ_2_BattleSystemCTB && BattleManager.isCTB()) {
    return;
  }
  if (BattleManager._currentActor) {
    BattleManager._currentActor.setActionState("undecided");
    const _0x35be08 = BattleManager._currentActor.battler();
    if (_0x35be08) {
      _0x35be08.stepBack();
    }
  }
  BattleManager._currentActor = null;
};
VisuMZ.BattleCore.Scene_Battle_createHelpWindow = Scene_Battle.prototype.createHelpWindow;
Scene_Battle.prototype.createHelpWindow = function () {
  VisuMZ.BattleCore.Scene_Battle_createHelpWindow.call(this);
  this.createHelpWindowBattleCore();
};
Scene_Battle.prototype.createHelpWindowBattleCore = function () {
  this._actorCommandWindow.setHelpWindow(this._helpWindow);
  this._partyCommandWindow.setHelpWindow(this._helpWindow);
};
Scene_Battle.prototype.battleLayoutStyle = function () {
  if ($gameTemp._forcedBattleLayout !== undefined) {
    return $gameTemp._forcedBattleLayout;
  }
  if (this._battleLayoutStyle) {
    return this._battleLayoutStyle;
  }
  this._battleLayoutStyle = VisuMZ.BattleCore.Settings.BattleLayout.Style.toLowerCase().trim();
  if (this._battleLayoutStyle === 'sideview_ui' && !Imported.VisuMZ_3_SideviewBattleUI) {
    this._battleLayoutStyle = "default";
  }
  if (this._battleLayoutStyle === "frontview_ui" && !Imported.VisuMZ_3_FrontviewBattleUI) {
    this._battleLayoutStyle = "default";
  }
  return this._battleLayoutStyle;
};
VisuMZ.BattleCore.Scene_Battle_windowAreaHeight = Scene_Battle.prototype.windowAreaHeight;
Scene_Battle.prototype.windowAreaHeight = function () {
  const _0x364926 = this.battleLayoutStyle();
  switch (_0x364926) {
    case "list":
      return this.calcWindowHeight(Math.max(0x1, $gameParty.maxBattleMembers()), true);
      break;
    default:
      return VisuMZ.BattleCore.Scene_Battle_windowAreaHeight.call(this);
      break;
  }
};
VisuMZ.BattleCore.Scene_Battle_helpWindowRect = Scene_Battle.prototype.helpWindowRect;
Scene_Battle.prototype.helpWindowRect = function () {
  const _0x1b3e7 = this.battleLayoutStyle();
  switch (_0x1b3e7) {
    case "border":
      return this.helpWindowRectBorderStyle();
      break;
    case "default":
    case "list":
    case 'xp':
    case "portrait":
    default:
      return VisuMZ.BattleCore.Scene_Battle_helpWindowRect.call(this);
      break;
  }
};
Scene_Battle.prototype.statusWindowRect = function () {
  const _0x26243a = this.battleLayoutStyle();
  switch (_0x26243a) {
    case 'xp':
    case "portrait":
      return this.statusWindowRectXPStyle();
      break;
    case "border":
      return this.statusWindowRectBorderStyle();
      break;
    case 'default':
    case "list":
    default:
      return this.statusWindowRectDefaultStyle();
      break;
  }
};
VisuMZ.BattleCore.Scene_Battle_partyCommandWindowRect = Scene_Battle.prototype.partyCommandWindowRect;
Scene_Battle.prototype.partyCommandWindowRect = function () {
  const _0x590397 = this.battleLayoutStyle();
  switch (_0x590397) {
    case 'xp':
    case "portrait":
      return this.partyCommandWindowRectXPStyle();
      break;
    case "border":
      return this.partyCommandWindowRectBorderStyle();
    case "default":
    case 'list':
    default:
      return this.partyCommandWindowRectDefaultStyle();
      break;
  }
};
Scene_Battle.prototype.partyCommandWindowRectDefaultStyle = function () {
  const _0x2673d = VisuMZ.BattleCore.Settings.BattleLayout;
  const _0x389c16 = _0x2673d.CommandWidth || 0xc0;
  const _0x4993e9 = this.windowAreaHeight();
  const _0x8bc0b8 = this.isRightInputMode() ? Graphics.boxWidth - _0x389c16 : 0x0;
  const _0x3083b2 = Graphics.boxHeight - _0x4993e9;
  return new Rectangle(_0x8bc0b8, _0x3083b2, _0x389c16, _0x4993e9);
};
Scene_Battle.prototype.actorCommandWindowRect = function () {
  return this.partyCommandWindowRect();
};
VisuMZ.BattleCore.Scene_Battle_updateStatusWindowPosition = Scene_Battle.prototype.updateStatusWindowPosition;
Scene_Battle.prototype.updateStatusWindowPosition = function () {
  const _0x4b34b9 = this.battleLayoutStyle();
  switch (_0x4b34b9) {
    case 'xp':
    case 'portrait':
    case "border":
      break;
    case "default":
    case 'list':
    default:
      VisuMZ.BattleCore.Scene_Battle_updateStatusWindowPosition.call(this);
      break;
  }
};
VisuMZ.BattleCore.Scene_Battle_startActorSelection = Scene_Battle.prototype.startActorSelection;
Scene_Battle.prototype.startActorSelection = function () {
  VisuMZ.BattleCore.Scene_Battle_startActorSelection.call(this);
  this.makeTargetSelectionMoreVisible();
};
VisuMZ.BattleCore.Scene_Battle_startEnemySelection = Scene_Battle.prototype.startEnemySelection;
Scene_Battle.prototype.startEnemySelection = function () {
  VisuMZ.BattleCore.Scene_Battle_startEnemySelection.call(this);
  this._enemyWindow.autoSelect();
  this.makeTargetSelectionMoreVisible();
};
Scene_Battle.prototype.makeTargetSelectionMoreVisible = function () {
  const _0x30b9ad = this.battleLayoutStyle();
  if (['xp', 'portrait', "border"].includes(_0x30b9ad)) {
    this._actorCommandWindow.close();
  }
  if (_0x30b9ad === "border" || this.isSkillItemWindowsMiddle()) {
    this._skillWindow.close();
    this._itemWindow.close();
  }
};
VisuMZ.BattleCore.Scene_Battle_onActorOk = Scene_Battle.prototype.onActorOk;
Scene_Battle.prototype.onActorOk = function () {
  VisuMZ.BattleCore.Scene_Battle_onActorOk.call(this);
  this.okTargetSelectionVisibility();
};
Scene_Battle.prototype.isNonSubmenuCancel = function () {
  return ["attack", "guard", "singleSkill"].includes(this._actorCommandWindow.currentSymbol());
};
VisuMZ.BattleCore.Scene_Battle_onActorCancel = Scene_Battle.prototype.onActorCancel;
Scene_Battle.prototype.onActorCancel = function () {
  if (this.isNonSubmenuCancel()) {
    this._statusWindow.show();
    this._actorWindow.hide();
    this._actorCommandWindow.activate();
  } else {
    VisuMZ.BattleCore.Scene_Battle_onActorCancel.call(this);
  }
  this.cancelTargetSelectionVisibility();
};
VisuMZ.BattleCore.Scene_Battle_onEnemyOk = Scene_Battle.prototype.onEnemyOk;
Scene_Battle.prototype.onEnemyOk = function () {
  if (!this._enemyWindow.enemy()) {
    this._enemyWindow.activate();
    return;
  }
  const _0x74f00a = BattleManager.inputtingAction();
  _0x74f00a.setTargetBattlerKey(this._enemyWindow.enemy());
  this._enemyWindow.closeBattleActorWindow();
  VisuMZ.BattleCore.Scene_Battle_onEnemyOk.call(this);
  this.okTargetSelectionVisibility();
};
VisuMZ.BattleCore.Scene_Battle_onEnemyCancel = Scene_Battle.prototype.onEnemyCancel;
Scene_Battle.prototype.onEnemyCancel = function () {
  if (this.isNonSubmenuCancel()) {
    this._statusWindow.show();
    this._enemyWindow.hide();
    this._actorCommandWindow.activate();
  } else {
    VisuMZ.BattleCore.Scene_Battle_onEnemyCancel.call(this);
  }
  this.cancelTargetSelectionVisibility();
  this._enemyWindow.closeBattleActorWindow();
};
Scene_Battle.prototype.okTargetSelectionVisibility = function () {
  const _0x11578b = this.battleLayoutStyle();
  if (_0x11578b === "border" || this.isSkillItemWindowsMiddle()) {
    this._skillWindow.open();
    if (this._skillWindow.active) {
      this._skillWindow.show();
    }
    this._itemWindow.open();
    if (this._itemWindow.active) {
      this._itemWindow.show();
    }
  }
};
Scene_Battle.prototype.cancelTargetSelectionVisibility = function () {
  const _0x3899b3 = this.battleLayoutStyle();
  if (['xp', "portrait", "border"].includes(_0x3899b3)) {
    this._actorCommandWindow.open();
  }
  this.okTargetSelectionVisibility();
};
Scene_Battle.prototype.statusWindowRectDefaultStyle = function () {
  const _0x561524 = VisuMZ.BattleCore.Settings.BattleLayout;
  const _0x8fad32 = Window_BattleStatus.prototype.extraHeight();
  const _0x34ac21 = Graphics.boxWidth - (_0x561524.CommandWidth || 0xc0);
  const _0x55e68d = this.windowAreaHeight() + _0x8fad32;
  const _0x16d831 = this.isRightInputMode() ? 0x0 : Graphics.boxWidth - _0x34ac21;
  const _0x46436f = Graphics.boxHeight - _0x55e68d + _0x8fad32;
  return new Rectangle(_0x16d831, _0x46436f, _0x34ac21, _0x55e68d);
};
Scene_Battle.prototype.statusWindowRectXPStyle = function () {
  const _0x2cc57e = Window_BattleStatus.prototype.extraHeight();
  const _0x42d13a = Graphics.boxWidth;
  const _0x1b7c5f = this.windowAreaHeight() + _0x2cc57e;
  const _0x17e5e8 = Graphics.boxHeight - _0x1b7c5f + _0x2cc57e;
  return new Rectangle(0x0, _0x17e5e8, _0x42d13a, _0x1b7c5f);
};
Scene_Battle.prototype.partyCommandWindowRectXPStyle = function () {
  const _0x44790e = Graphics.boxWidth / 0x2;
  const _0x9eed80 = this.calcWindowHeight(VisuMZ.BattleCore.Settings.BattleLayout.XPActorCommandLines, true);
  const _0x2378af = Math.round((Graphics.boxWidth - _0x44790e) / 0x2);
  const _0x181a3f = Graphics.boxHeight - _0x9eed80 - this.statusWindowRectXPStyle().height;
  return new Rectangle(_0x2378af, _0x181a3f, _0x44790e, _0x9eed80);
};
Scene_Battle.prototype.helpWindowRectBorderStyle = function () {
  const _0x23a5bf = Graphics.width;
  const _0x5e5085 = Math.round((Graphics.boxWidth - _0x23a5bf) / 0x2);
  const _0x5cb761 = this.helpAreaHeight();
  const _0x2d9f69 = (Graphics.height - Graphics.boxHeight) / -0x2;
  return new Rectangle(_0x5e5085, _0x2d9f69, _0x23a5bf, _0x5cb761);
};
Scene_Battle.prototype.statusWindowRectBorderStyle = function () {
  const _0x2591bf = Graphics.width;
  const _0x826164 = Math.round((Graphics.boxWidth - _0x2591bf) / 0x2);
  const _0x326bcf = this.calcWindowHeight(0x4, true);
  const _0x3e3a7e = Graphics.boxHeight - _0x326bcf + (Graphics.height - Graphics.boxHeight) / 0x2;
  return new Rectangle(_0x826164, _0x3e3a7e, _0x2591bf, _0x326bcf);
};
Scene_Battle.prototype.partyCommandWindowRectBorderStyle = function () {
  const _0x28d859 = Math.floor(Graphics.width / 0x3);
  const _0x1afd2c = this.isRightInputMode() ? (Graphics.width + Graphics.boxWidth) / 0x2 - _0x28d859 : (Graphics.width - Graphics.boxWidth) / -0x2;
  const _0x37f702 = this.helpWindowRectBorderStyle();
  const _0x45c0d1 = _0x37f702.y + _0x37f702.height;
  const _0x350563 = this.statusWindowRectBorderStyle();
  const _0x12be59 = _0x350563.y - _0x45c0d1;
  return new Rectangle(_0x1afd2c, _0x45c0d1, _0x28d859, _0x12be59);
};
Scene_Battle.prototype.skillItemWindowRectBorderStyle = function () {
  const _0x359910 = Math.ceil(Graphics.width / 0x3);
  const _0x2134b0 = Math.round((Graphics.boxWidth - _0x359910) / 0x2);
  const _0x40ca79 = this.partyCommandWindowRectBorderStyle();
  const _0x434141 = _0x40ca79.y;
  const _0x5d8458 = _0x40ca79.height;
  return new Rectangle(_0x2134b0, _0x434141, _0x359910, _0x5d8458);
};
Scene_Battle.prototype.repositionCancelButtonBorderStyle = function () {
  this._cancelButton.y = this._helpWindow.y + this._helpWindow.height;
  if (this.isRightInputMode()) {
    if (this.battleLayoutStyle() === 'border') {
      this._cancelButton.x = 0x8;
    } else {
      this._cancelButton.x = -this._cancelButton.width - 0x4;
    }
  } else {
    this._cancelButton.x = Graphics.width - (Graphics.width - Graphics.boxWidth) / 0x2 - this._cancelButton.width - 0x4;
  }
};
VisuMZ.BattleCore.Scene_Battle_skillWindowRect = Scene_Battle.prototype.skillWindowRect;
Scene_Battle.prototype.skillWindowRect = function () {
  if (this.battleLayoutStyle() === "border") {
    return this.skillItemWindowRectBorderStyle();
  } else {
    return this.isSkillItemWindowsMiddle() ? this.skillItemWindowRectMiddle() : VisuMZ.BattleCore.Scene_Battle_skillWindowRect.call(this);
  }
};
VisuMZ.BattleCore.Scene_Battle_itemWindowRect = Scene_Battle.prototype.itemWindowRect;
Scene_Battle.prototype.itemWindowRect = function () {
  if (this.battleLayoutStyle() === "border") {
    return this.skillItemWindowRectBorderStyle();
  } else {
    return this.isSkillItemWindowsMiddle() ? this.skillItemWindowRectMiddle() : VisuMZ.BattleCore.Scene_Battle_itemWindowRect.call(this);
  }
};
Scene_Battle.prototype.isSkillItemWindowsMiddle = function () {
  return VisuMZ.BattleCore.Settings.BattleLayout.SkillItemMiddleLayout;
};
Scene_Battle.prototype.skillItemWindowRectMiddle = function () {
  const _0x4b6645 = Sprite_Button.prototype.blockWidth() * 0x2 + 0x4;
  let _0x350ec3 = Graphics.boxWidth - _0x4b6645;
  if (Imported.VisuMZ_0_CoreEngine && SceneManager.isSideButtonLayout()) {
    _0x350ec3 += _0x4b6645;
  }
  const _0x4396f6 = this.helpAreaBottom();
  const _0xcc7fb2 = Graphics.boxHeight - _0x4396f6 - this.statusWindowRect().height + Window_BattleStatus.prototype.extraHeight();
  return new Rectangle(0x0, _0x4396f6, _0x350ec3, _0xcc7fb2);
};
Scene_Battle.prototype.createEnemyNameContainer = function () {
  if (!VisuMZ.BattleCore.Settings.Enemy.NameLegacy) {
    return;
  }
  this._enemyNameContainer = new Sprite();
  this._enemyNameContainer.x = this._windowLayer.x;
  this._enemyNameContainer.y = this._windowLayer.y;
  const _0x2e8ed1 = this.children.indexOf(this._windowLayer);
  this.addChildAt(this._enemyNameContainer, _0x2e8ed1);
  for (let _0xf0f1e2 = 0x0; _0xf0f1e2 < 0x8; _0xf0f1e2++) {
    const _0x2f901e = new Window_EnemyName(_0xf0f1e2);
    this._enemyNameContainer.addChild(_0x2f901e);
  }
};
Sprite_Battler._motionSpeed = VisuMZ.BattleCore.Settings.Actor.MotionSpeed;
VisuMZ.BattleCore.Sprite_Battler_initMembers = Sprite_Battler.prototype.initMembers;
Sprite_Battler.prototype.initMembers = function () {
  VisuMZ.BattleCore.Sprite_Battler_initMembers.call(this);
  this.initMembersBattleCore();
  if (this.constructor === Sprite_Enemy) {
    this.createShadowSprite();
  }
  this.createDistortionSprite();
};
Sprite_Battler.prototype.initMembersBattleCore = function () {
  this._baseX = 0x0;
  this._baseY = 0x0;
  this._floatHeight = 0x0;
  this._targetFloatHeight = 0x0;
  this._floatDuration = 0x0;
  this._floatWholeDuration = 0x0;
  this._floatEasing = "Linear";
  this._jumpHeight = 0x0;
  this._jumpMaxHeight = 0x0;
  this._jumpDuration = 0x0;
  this._jumpWholeDuration = 0x0;
  this._targetOpacity = 0xff;
  this._opacityDuration = 0x0;
  this._opacityWholeDuration = 0x0;
  this._opacityEasing = "Linear";
  this._currentAngle = 0x0;
  this._targetAngle = 0x0;
  this._angleDuration = 0x0;
  this._angleWholeDuration = 0x0;
  this._angleEasing = "Linear";
  this._angleRevertOnFinish = true;
  this._skewX = 0x0;
  this._skewY = 0x0;
  this._targetSkewX = 0x0;
  this._targetSkewY = 0x0;
  this._skewDuration = 0x0;
  this._skewWholeDuration = 0x0;
  this._skewEasing = "Linear";
  this._growX = 0x1;
  this._growY = 0x1;
  this._targetGrowX = 0x1;
  this._targetGrowY = 0x1;
  this._growDuration = 0x0;
  this._growWholeDuration = 0x0;
  this._growEasing = "Linear";
  this._flipScaleX = 0x1;
  this._targetHomeX = 0x0;
  this._targetHomeY = 0x0;
  this._homeDuration = 0x0;
  this._homeWholeDuration = 0x0;
  this._homeEasing = "Linear";
  this._shakeFlinchDuration = 0x0;
  this._shakeFlinchPower = 0x0;
};
Sprite_Battler.prototype.createShadowSprite = function () {
  this._shadowSprite = new Sprite();
  this._shadowSprite.bitmap = ImageManager.loadSystem("Shadow2");
  this._shadowSprite.bitmap.smooth = VisuMZ.BattleCore.Settings.Actor.SmoothImage;
  this._shadowSprite.anchor.x = 0.5;
  this._shadowSprite.anchor.y = 0.5;
  this._shadowSprite.y = -0x2;
  this._shadowSprite.visible = false;
  this.addChild(this._shadowSprite);
};
Sprite_Battler.prototype.createDistortionSprite = function () {
  this._distortionSprite = new Sprite();
  this._distortionSprite.anchor.x = 0.5;
  this._distortionSprite.anchor.y = 0.5;
  this.addChild(this._distortionSprite);
};
Sprite_Battler.prototype._updateColorFilter = function () {
  if (this.getDragonbones && this.getDragonbones()) {
    Sprite.prototype._updateColorFilter.call(this);
    return;
  }
  const _0x3f0269 = this._distortionSprite;
  if (!_0x3f0269) {
    return;
  }
  if (!_0x3f0269._colorFilter) {
    _0x3f0269._createColorFilter();
  }
  _0x3f0269._colorFilter.setHue(this._hue);
  _0x3f0269._colorFilter.setBlendColor(this._blendColor);
  _0x3f0269._colorFilter.setColorTone(this._colorTone);
};
Sprite_Battler.prototype.attachSpritesToDistortionSprite = function () {
  if (!this._distortionSprite) {
    return;
  }
  if (this._shadowSprite) {
    const _0x35ba2a = this.getChildIndex(this._distortionSprite);
    this.addChildAt(this._shadowSprite, _0x35ba2a);
    this.updateShadowVisibility();
  }
  if (this._svBattlerSprite) {
    this._distortionSprite.addChild(this._svBattlerSprite);
  }
  if (this._weaponSprite) {
    this._distortionSprite.addChild(this._weaponSprite);
  }
  if (this._mainSprite) {
    this._distortionSprite.addChild(this._mainSprite);
  }
  if (this._injectAnimationSprite) {
    this._distortionSprite.addChild(this._injectAnimationSprite);
  }
  if (this._dragonbonesSpriteContainer) {
    this._distortionSprite.addChild(this._dragonbonesSpriteContainer);
  }
};
Sprite_Battler.prototype.updateShadowVisibility = function () {
  if (!this._shadowSprite) {
    return;
  }
  if (this._battler && this._battler.svBattlerShadowVisible()) {
    const _0x2ab280 = this._shadowSprite.bitmap;
    this._shadowSprite.setFrame(0x0, 0x0, _0x2ab280.width, _0x2ab280.height);
  } else {
    this._shadowSprite.setFrame(0x0, 0x0, 0x0, 0x0);
  }
};
Sprite_Battler.prototype.damageContainer = function () {
  return SceneManager.isSceneBattle() ? SceneManager._scene._spriteset._damageContainer : this.parent;
};
Sprite_Battler.prototype.setupTextPopup = function (_0x14b141, _0x3a4f9f) {
  if (!this._battler.isSpriteVisible()) {
    return;
  }
  if (BattleManager.shouldHideBattleEndPopups()) {
    return;
  }
  const _0x57f1f4 = VisuMZ.BattleCore.Settings.Damage;
  const _0x1ea7b8 = new Sprite_Damage();
  _0x1ea7b8._duration = _0x57f1f4.PopupDuration;
  this.sortDamageSprites(_0x1ea7b8);
  _0x1ea7b8.setupTextPopup(_0x14b141, _0x3a4f9f);
  this.addDamageSprite(_0x1ea7b8);
};
Sprite_Battler.prototype.setupIconTextPopup = function (_0x1747c9, _0xc9e01d, _0x493f47) {
  if (!this._battler.isSpriteVisible()) {
    return;
  }
  if (BattleManager.shouldHideBattleEndPopups()) {
    return;
  }
  const _0xb7bc4 = VisuMZ.BattleCore.Settings.Damage;
  const _0x1333c3 = new Sprite_Damage();
  _0x1333c3._duration = _0xb7bc4.PopupDuration;
  this.sortDamageSprites(_0x1333c3);
  _0x1333c3.setupIconTextPopup(_0x1747c9, _0xc9e01d, _0x493f47);
  this.addDamageSprite(_0x1333c3);
};
Sprite_Battler.prototype.setupDamagePopup = function () {
  if (!this._battler.isDamagePopupRequested()) {
    return;
  }
  while (this._battler.isDamagePopupRequested()) {
    if (this._battler.isSpriteVisible()) {
      this.createDamageSprite();
    }
  }
  this._battler.clearDamagePopup();
  this._battler.clearResult();
};
Sprite_Battler.prototype.createDamageSprite = function () {
  if (BattleManager.shouldHideBattleEndPopups()) {
    return;
  }
  const _0x3f228f = VisuMZ.BattleCore.Settings.Damage;
  const _0x64288f = new Sprite_Damage();
  _0x64288f._duration = _0x3f228f.PopupDuration;
  this.sortDamageSprites(_0x64288f);
  _0x64288f.setup(this._battler);
  _0x64288f.setupBattleCore(this._battler);
  this.addDamageSprite(_0x64288f);
};
Sprite_Battler.prototype.addDamageSprite = function (_0x15607e) {
  this._damages.push(_0x15607e);
  if (this.isShownOnBattlePortrait()) {
    const _0x31ad61 = SceneManager._scene._statusWindow;
    if (_0x31ad61) {
      _0x31ad61.addDamageSprite(_0x15607e, this._battler);
    }
  } else {
    this.damageContainer().addChild(_0x15607e);
    if (SceneManager.isBattleFlipped()) {
      _0x15607e.scale.x = -0x1;
    }
  }
};
Sprite_Battler.prototype.isShownOnBattlePortrait = function () {
  return !$gameSystem.isSideView() && this._battler && this._battler.isActor();
  return !$gameSystem.isSideView() && this._battler && this._battler.isActor() && Window_BattleStatus.prototype.battleLayoutStyle() === 'portrait';
};
Sprite_Battler.prototype.sortDamageSprites = function (_0x9bb38f) {
  this.alignBattleCoreDamageSprite(_0x9bb38f, true);
  const _0x10d9c2 = VisuMZ.BattleCore.Settings.Damage;
  const _0x5f5826 = SceneManager.isBattleFlipped() ? -0x1 : 0x1;
  if (_0x10d9c2.NewPopupBottom) {
    for (const _0x11b70c of this._damages) {
      _0x11b70c.x += _0x10d9c2.PopupShiftX * _0x5f5826;
      _0x11b70c.y += _0x10d9c2.PopupShiftY;
    }
  } else {
    const _0x4202fa = this._damages[this._damages.length - 0x1];
    if (_0x4202fa) {
      _0x9bb38f.x = _0x4202fa.x + _0x10d9c2.PopupShiftX * _0x5f5826;
      _0x9bb38f.y = _0x4202fa.y + _0x10d9c2.PopupShiftY;
    }
  }
};
Sprite_Battler.prototype.alignBattleCoreDamageSprite = function (_0x54d423, _0x1f2184) {
  const _0x18e324 = SceneManager.isBattleFlipped() ? -0x1 : 0x1;
  let _0x577e24 = this._baseX;
  _0x577e24 += this.extraPositionX();
  let _0x40b0f4 = this._baseY;
  _0x40b0f4 += this.extraPositionY();
  const _0x51304d = SceneManager._scene._statusWindow;
  if (_0x51304d && this.parent === _0x51304d) {
    _0x577e24 += _0x51304d.x - this.damageOffsetX();
    const _0x3fdc14 = _0x51304d.lineHeight() * 0x3 / 0x4;
    _0x40b0f4 = _0x51304d.y + _0x3fdc14;
    _0x40b0f4 = Math.min(_0x40b0f4, _0x51304d.y + this.y - this.height + _0x3fdc14);
  }
  _0x54d423.x = Math.round(_0x577e24 + this.damageOffsetX() * _0x18e324);
  _0x54d423.y = Math.round(_0x40b0f4 + this.damageOffsetY());
};
VisuMZ.BattleCore.Sprite_Battler_damageOffsetX = Sprite_Battler.prototype.damageOffsetX;
Sprite_Battler.prototype.damageOffsetX = function () {
  let _0x1177e1 = VisuMZ.BattleCore.Sprite_Battler_damageOffsetX.call(this);
  let _0x5caee3 = VisuMZ.BattleCore.Settings.Damage.PopupOffsetX || 0x0;
  return Math.round(_0x1177e1 + _0x5caee3);
};
VisuMZ.BattleCore.Sprite_Battler_damageOffsetY = Sprite_Battler.prototype.damageOffsetY;
Sprite_Battler.prototype.damageOffsetY = function () {
  let _0x429026 = VisuMZ.BattleCore.Sprite_Battler_damageOffsetY.call(this);
  switch (VisuMZ.BattleCore.Settings.Damage.PopupPosition) {
    case "head":
      _0x429026 -= this.height * this.scale.y;
      break;
    case "center":
      _0x429026 -= this.height * this.scale.y * 0.5;
      break;
  }
  let _0x52f8eb = VisuMZ.BattleCore.Settings.Damage.PopupOffsetY || 0x0;
  return Math.round(_0x429026 + _0x52f8eb);
};
Sprite_Actor.prototype.damageOffsetX = function () {
  return Sprite_Battler.prototype.damageOffsetX.call(this);
};
Sprite_Actor.prototype.damageOffsetY = function () {
  return Sprite_Battler.prototype.damageOffsetY.call(this);
};
Sprite_Battler.prototype.destroyDamageSprite = function (_0x3a1e66) {
  if (this.isShownOnBattlePortrait()) {
    SceneManager._scene._statusWindow.removeDamageSprite(_0x3a1e66);
  } else {
    this.damageContainer().removeChild(_0x3a1e66);
    this._damages.remove(_0x3a1e66);
    _0x3a1e66.destroy();
  }
};
VisuMZ.BattleCore.Sprite_Battler_setHome = Sprite_Battler.prototype.setHome;
Sprite_Battler.prototype.setHome = function (_0x9677d3, _0x5cfc5d) {
  const _0x1b952c = VisuMZ.BattleCore.Settings;
  if (this.constructor === Sprite_Actor) {
    _0x9677d3 += _0x1b952c.Actor.OffsetX || 0x0;
    _0x5cfc5d += _0x1b952c.Actor.OffsetY || 0x0;
  } else if (this.constructor === Sprite_Enemy) {
    _0x9677d3 += _0x1b952c.Enemy.OffsetX || 0x0;
    _0x5cfc5d += _0x1b952c.Enemy.OffsetY || 0x0;
  }
  if (this._battler) {
    _0x9677d3 = this._battler._forcedHomeX ?? _0x9677d3;
    _0x5cfc5d = this._battler._forcedHomeY ?? _0x5cfc5d;
  }
  VisuMZ.BattleCore.Sprite_Battler_setHome.call(this, _0x9677d3, _0x5cfc5d);
  this._targetHomeX = this._homeX;
  this._targetHomeY = this._homeY;
  this._homeDuration = 0x0;
  this._homeWholeDuration = 0x0;
  this._homeEasing = "Linear";
};
VisuMZ.BattleCore.Sprite_Battler_update = Sprite_Battler.prototype.update;
Sprite_Battler.prototype.update = function () {
  VisuMZ.BattleCore.Sprite_Battler_update.call(this);
  if (!this._battler && this._hpGaugeSprite) {
    this._hpGaugeSprite.visible = false;
  }
};
VisuMZ.BattleCore.Sprite_Battler_updateMain = Sprite_Battler.prototype.updateMain;
Sprite_Battler.prototype.updateMain = function () {
  this.updateScale();
  this.updateSkew();
  this.updateSpin();
  this.updateFlip();
  VisuMZ.BattleCore.Sprite_Battler_updateMain.call(this);
  this.updateHpGaugePosition();
  this.updateShakeFlinch();
  if (this.constructor === Sprite_Enemy) {
    this.updateShadow();
  }
};
VisuMZ.BattleCore.Sprite_Battler_updatePosition = Sprite_Battler.prototype.updatePosition;
Sprite_Battler.prototype.updatePosition = function () {
  this.updateHomeMove();
  VisuMZ.BattleCore.Sprite_Battler_updatePosition.call(this);
  this.updatePositionBattleCore();
  this.updateOpacity();
};
Sprite_Battler.prototype.updateSelectionEffect = function () {
  const _0x3c4257 = this.mainSprite();
  if (this._battler.isSelected()) {
    this._selectionEffectCount++;
    if (Graphics.frameCount % 0x1e < 0xf) {
      _0x3c4257.setBlendColor([0xff, 0xff, 0xff, 0x40]);
    } else {
      _0x3c4257.setBlendColor([0x0, 0x0, 0x0, 0x0]);
    }
  } else if (this._selectionEffectCount > 0x0) {
    this._selectionEffectCount = 0x0;
    _0x3c4257.setBlendColor([0x0, 0x0, 0x0, 0x0]);
  }
};
Sprite_Battler.prototype.silentHomeMove = function (_0xd9507f, _0x3a167f) {
  const _0x586cb4 = VisuMZ.BattleCore.Settings;
  if (this.constructor === Sprite_Actor) {
    _0xd9507f += _0x586cb4.Actor.OffsetX || 0x0;
    _0x3a167f += _0x586cb4.Actor.OffsetY || 0x0;
  } else if (this.constructor === Sprite_Enemy) {
    _0xd9507f += _0x586cb4.Enemy.OffsetX || 0x0;
    _0x3a167f += _0x586cb4.Enemy.OffsetY || 0x0;
  }
  const _0x23c286 = _0xd9507f - this._homeX;
  const _0x1d8f8a = _0x3a167f - this._homeY;
  this._homeX = _0xd9507f;
  this._homeY = _0x3a167f;
  this._offsetX -= _0x23c286;
  this._offsetY -= _0x1d8f8a;
  this._targetOffsetX -= _0x23c286;
  this._targetOffsetY -= _0x1d8f8a;
  this.updatePosition();
};
Sprite_Battler.prototype.startHomeMove = function (_0x1cd9dd, _0x514bd2, _0x4fbb9e, _0x214ea2) {
  const _0x4732f7 = VisuMZ.BattleCore.Settings;
  if (this.constructor === Sprite_Actor) {
    _0x1cd9dd += _0x4732f7.Actor.OffsetX || 0x0;
    _0x514bd2 += _0x4732f7.Actor.OffsetY || 0x0;
  } else if (this.constructor === Sprite_Enemy) {
    _0x1cd9dd += _0x4732f7.Enemy.OffsetX || 0x0;
    _0x514bd2 += _0x4732f7.Enemy.OffsetY || 0x0;
  }
  if (this._targetHomeX !== _0x1cd9dd || this._targetHomeY !== _0x514bd2) {
    this._targetHomeX = _0x1cd9dd;
    this._targetHomeY = _0x514bd2;
    this._homeDuration = _0x4fbb9e;
    this._homeWholeDuration = _0x4fbb9e;
    this._homeEasing = _0x214ea2;
    if (_0x4fbb9e <= 0x0) {
      this.onHomeMoveEnd();
    }
  }
};
Sprite_Battler.prototype.updateHomeMove = function () {
  if (this._homeDuration <= 0x0) {
    return;
  }
  const _0x2ad040 = this._homeDuration;
  const _0x5868e3 = this._homeWholeDuration;
  const _0xddabd5 = this._homeEasing;
  if (Imported.VisuMZ_0_CoreEngine) {
    this._homeX = this.applyEasing(this._homeX, this._targetHomeX, _0x2ad040, _0x5868e3, _0xddabd5);
    this._homeY = this.applyEasing(this._homeY, this._targetHomeY, _0x2ad040, _0x5868e3, _0xddabd5);
  } else {
    this._homeX = (this._homeX * (_0x2ad040 - 0x1) + this._targetHomeX) / _0x2ad040;
    this._homeY = (this._homeY * (_0x2ad040 - 0x1) + this._targetHomeY) / _0x2ad040;
  }
  this._homeDuration--;
  if (this._homeDuration <= 0x0) {
    this.onHomeMoveEnd();
  }
};
Sprite_Battler.prototype.onHomeMoveEnd = function () {
  this._homeX = this._targetHomeX;
  this._homeY = this._targetHomeY;
};
Sprite_Battler.prototype.updatePositionBattleCore = function () {
  this._baseX = this.x;
  this._baseY = this.y;
  this.updateFloat();
  this.updateJump();
  this.x += this.extraPositionX();
  this.y += this.extraPositionY();
  this.y += this.extraPositionScaledY();
  this.x = Math.floor(this.x);
  this.y = Math.floor(this.y);
};
Sprite_Battler.prototype.extraPositionX = function () {
  return 0x0;
};
Sprite_Battler.prototype.extraPositionY = function () {
  let _0x3dbb17 = 0x0;
  if (this._battler && !this._battler.isBattlerGrounded()) {
    _0x3dbb17 -= this._floatHeight;
    _0x3dbb17 -= this._jumpHeight;
  }
  return _0x3dbb17;
};
Sprite_Battler.prototype.extraPositionScaledY = function () {
  let _0x325370 = 0x0;
  if (this._distortionSprite && this.constructor !== Sprite_SvEnemy) {
    const _0x59cf27 = this._distortionSprite.scale.y;
    _0x325370 -= (_0x59cf27 - 0x1) * this.height;
  }
  return _0x325370;
};
Sprite_Battler.prototype.updateFlip = function () {
  const _0x1a9212 = this._battler && this._battler.isBattlerFlipped();
  this._flipScaleX = (_0x1a9212 ? -0x1 : 0x1) * Math.abs(this.scale.x);
};
Sprite_Battler.prototype.startFloat = function (_0xa36f08, _0x524d69, _0x57685a) {
  if (!this.canMove()) {
    return;
  }
  if (this._targetFloatHeight === _0xa36f08) {
    return;
  }
  this._targetFloatHeight = _0xa36f08;
  this._floatDuration = _0x524d69;
  this._floatWholeDuration = _0x524d69;
  this._floatEasing = _0x57685a || "Linear";
  if (_0x524d69 <= 0x0) {
    this._floatHeight = _0xa36f08;
  }
};
Sprite_Battler.prototype.updateFloat = function () {
  if (this._floatDuration <= 0x0) {
    return;
  }
  const _0xae8ce6 = this._floatDuration;
  const _0x2410e1 = this._floatWholeDuration;
  const _0x2b0e60 = this._floatEasing;
  if (Imported.VisuMZ_0_CoreEngine) {
    this._floatHeight = this.applyEasing(this._floatHeight, this._targetFloatHeight, _0xae8ce6, _0x2410e1, _0x2b0e60);
  } else {
    this._floatHeight = (this._floatHeight * (_0xae8ce6 - 0x1) + this._targetFloatHeight) / _0xae8ce6;
  }
  this._floatDuration--;
  if (this._floatDuration <= 0x0) {
    this.onFloatEnd();
  }
};
Sprite_Battler.prototype.onFloatEnd = function () {
  this._floatHeight = this._targetFloatHeight;
};
Sprite_Battler.prototype.isFloating = function () {
  return this._floatDuration > 0x0;
};
Sprite_Battler.prototype.startJump = function (_0x5d99da, _0x29d585) {
  if (!this.canMove()) {
    return;
  }
  if (_0x29d585 <= 0x0) {
    return;
  }
  this._jumpMaxHeight = _0x5d99da;
  this._jumpDuration = _0x29d585;
  this._jumpWholeDuration = _0x29d585;
};
Sprite_Battler.prototype.updateJump = function () {
  if (this._jumpDuration <= 0x0) {
    return;
  }
  const _0x255caa = this._jumpWholeDuration - this._jumpDuration;
  const _0x9436dd = this._jumpWholeDuration / 0x2;
  const _0x2b54d4 = this._jumpMaxHeight;
  const _0x42232d = -_0x2b54d4 / Math.pow(_0x9436dd, 0x2);
  this._jumpHeight = _0x42232d * Math.pow(_0x255caa - _0x9436dd, 0x2) + _0x2b54d4;
  this._jumpDuration--;
  if (this._jumpDuration <= 0x0) {
    return this.onJumpEnd();
  }
};
Sprite_Battler.prototype.onJumpEnd = function () {
  this._jumpHeight = 0x0;
};
Sprite_Battler.prototype.isJumping = function () {
  return this._jumpDuration > 0x0;
};
Sprite_Battler.prototype.startOpacity = function (_0x3d07b2, _0x32990f, _0x42c13a) {
  if (this._targetOpacity === _0x3d07b2) {
    return;
  }
  this._targetOpacity = _0x3d07b2;
  this._opacityDuration = _0x32990f;
  this._opacityWholeDuration = _0x32990f;
  this._opacityEasing = _0x42c13a || "Linear";
  if (_0x32990f <= 0x0) {
    this.opacity = _0x3d07b2;
  }
};
Sprite_Battler.prototype.updateOpacity = function () {
  if (this.constructor.name === "Sprite_SvEnemy") {
    return;
  }
  if (this._opacityDuration <= 0x0) {
    return;
  }
  const _0x5dee5d = this._opacityDuration;
  const _0x5ae0a1 = this._opacityWholeDuration;
  const _0x41d431 = this._opacityEasing;
  if (Imported.VisuMZ_0_CoreEngine) {
    this.opacity = this.applyEasing(this.opacity, this._targetOpacity, _0x5dee5d, _0x5ae0a1, _0x41d431);
  } else {
    this.opacity = (this.opacity * (_0x5dee5d - 0x1) + this._targetOpacity) / _0x5dee5d;
  }
  this._opacityDuration--;
  if (this._opacityDuration <= 0x0) {
    this.onOpacityEnd();
  }
};
Sprite_Battler.prototype.onOpacityEnd = function () {
  this.opacity = this._targetOpacity;
};
Sprite_Battler.prototype.isChangingOpacity = function () {
  return this._opacityDuration > 0x0;
};
Sprite_Battler.prototype.updateShadow = function () {
  this._shadowSprite.visible = this._battler.hasSvBattler();
  this.updateShadowPosition();
};
Sprite_Battler.prototype.updateShadowPosition = function () {
  if (!this._shadowSprite) {
    return;
  }
  this._shadowSprite.y = this._baseY - this.y - 0x2;
};
Sprite_Battler.prototype.updateShadowScale = function () {
  if (!this._battler) {
    return;
  }
  this._shadowScaleX = this._battler.battlerShadowScaleX();
  this._shadowScaleY = this._battler.battlerShadowScaleY();
};
Game_BattlerBase.prototype.battlerShadowScaleX = function () {
  const _0x3368b7 = this.isActor() ? this.actor() : this.enemy();
  if (_0x3368b7) {
    const _0x339d68 = _0x3368b7.note;
    if (_0x339d68.match(/<SIDEVIEW SHADOW (?:SCALE|SCALE X):[ ](\d+)([%])>/i)) {
      return Number(RegExp.$1) * 0.01;
    } else {
      if (_0x339d68.match(/<SIDEVIEW SHADOW (?:SCALE|SCALE X):[ ](.*)>/i)) {
        return Number(RegExp.$1) || 0x0;
      }
    }
  }
  return 0x1;
};
Game_BattlerBase.prototype.battlerShadowScaleY = function () {
  const _0x228a80 = this.isActor() ? this.actor() : this.enemy();
  if (_0x228a80) {
    const _0x10dab1 = _0x228a80.note;
    if (_0x10dab1.match(/<SIDEVIEW SHADOW (?:SCALE|SCALE Y):[ ](\d+)([%])>/i)) {
      return Number(RegExp.$1) * 0.01;
    } else {
      if (_0x10dab1.match(/<SIDEVIEW SHADOW (?:SCALE|SCALE Y):[ ](.*)>/i)) {
        return Number(RegExp.$1) || 0x0;
      }
    }
  }
  return 0x1;
};
Sprite_Battler.prototype.updateScale = function () {
  if (this.constructor === Sprite_SvEnemy) {
    return;
  }
  this.updateGrow();
  this.finalizeScale();
};
Sprite_Battler.prototype.finalizeScale = function () {
  const _0x48eb30 = this._distortionSprite;
  if (_0x48eb30) {
    _0x48eb30.scale.x = this.mainSpriteScaleX();
    _0x48eb30.scale.y = this.mainSpriteScaleY();
  }
};
Sprite_Battler.prototype.mainSpriteScaleX = function () {
  let _0x281e29 = 0x1;
  _0x281e29 *= this._flipScaleX;
  _0x281e29 *= this._growX;
  return _0x281e29;
};
Sprite_Battler.prototype.mainSpriteScaleY = function () {
  return 0x1 * this._growY;
};
Sprite_Battler.prototype.mainSpriteWidth = function () {
  return this.width * this.mainSpriteScaleX();
};
Sprite_Battler.prototype.mainSpriteHeight = function () {
  return this.height * this.mainSpriteScaleY();
};
Sprite_Battler.prototype.startGrow = function (_0x630f5c, _0x5d2b48, _0x46dea6, _0x577e81) {
  if (!this.canMove()) {
    return;
  }
  if (!this._distortionSprite) {
    return;
  }
  if (this._targetGrowX === _0x630f5c && this._targetGrowY === _0x5d2b48) {
    return;
  }
  this._targetGrowX = _0x630f5c;
  this._targetGrowY = _0x5d2b48;
  this._growDuration = _0x46dea6;
  this._growWholeDuration = _0x46dea6;
  this._growEasing = _0x577e81 || "Linear";
  if (_0x46dea6 <= 0x0) {
    this._growX = this._targetGrowX;
    this._growY = this._targetGrowY;
  }
};
Sprite_Battler.prototype.updateGrow = function () {
  if (this._growDuration <= 0x0) {
    return;
  }
  if (!this._distortionSprite) {
    return;
  }
  const _0x1b865b = this._growDuration;
  const _0xc907d5 = this._growWholeDuration;
  const _0x1f30f7 = this._growEasing;
  if (Imported.VisuMZ_0_CoreEngine) {
    this._growX = this.applyEasing(this._growX, this._targetGrowX, _0x1b865b, _0xc907d5, _0x1f30f7);
    this._growY = this.applyEasing(this._growY, this._targetGrowY, _0x1b865b, _0xc907d5, _0x1f30f7);
  } else {
    this._growX = (this._growX * (_0x1b865b - 0x1) + this._targetGrowX) / _0x1b865b;
    this._growY = (this._growY * (_0x1b865b - 0x1) + this._targetGrowY) / _0x1b865b;
  }
  this._growDuration--;
  if (this._growDuration <= 0x0) {
    this.onGrowEnd();
  }
};
Sprite_Battler.prototype.onGrowEnd = function () {
  this._growX = this._targetGrowX;
  this._growY = this._targetGrowY;
};
Sprite_Battler.prototype.isGrowing = function () {
  return this._growDuration > 0x0;
};
Sprite_Battler.prototype.startSkew = function (_0x56278b, _0x414e27, _0x19a7de, _0x138971) {
  if (!this.canMove()) {
    return;
  }
  if (!this._distortionSprite) {
    return;
  }
  if (this._targetSkewX === _0x56278b && this._targetSkewY === _0x414e27) {
    return;
  }
  this._targetSkewX = _0x56278b;
  this._targetSkewY = _0x414e27;
  this._skewDuration = _0x19a7de;
  this._skewWholeDuration = _0x19a7de;
  this._skewEasing = _0x138971 || "Linear";
  if (_0x19a7de <= 0x0) {
    this._distortionSprite.skew.x = this._targetSkewX;
    this._distortionSprite.skew.y = this._targetSkewY;
  }
};
Sprite_Battler.prototype.updateSkew = function () {
  if (this._skewDuration <= 0x0) {
    return;
  }
  if (!this._distortionSprite) {
    return;
  }
  const _0x2547e9 = this._skewDuration;
  const _0x565b02 = this._skewWholeDuration;
  const _0xe68898 = this._skewEasing;
  const _0xfd24c = this._distortionSprite;
  if (Imported.VisuMZ_0_CoreEngine) {
    _0xfd24c.skew.x = this.applyEasing(_0xfd24c.skew.x, this._targetSkewX, _0x2547e9, _0x565b02, _0xe68898);
    _0xfd24c.skew.y = this.applyEasing(_0xfd24c.skew.y, this._targetSkewY, _0x2547e9, _0x565b02, _0xe68898);
  } else {
    _0xfd24c.skew.x = (_0xfd24c.skew.x * (_0x2547e9 - 0x1) + this._targetSkewX) / _0x2547e9;
    _0xfd24c.skew.y = (_0xfd24c.skew.y * (_0x2547e9 - 0x1) + this._targetSkewY) / _0x2547e9;
  }
  this._skewDuration--;
  if (this._skewDuration <= 0x0) {
    this.onSkewEnd();
  }
};
Sprite_Battler.prototype.onSkewEnd = function () {
  this._distortionSprite.skew.x = this._targetSkewX;
  this._distortionSprite.skew.y = this._targetSkewY;
};
Sprite_Battler.prototype.isSkewing = function () {
  return this._skewDuration > 0x0;
};
Sprite_Battler.prototype.startSpin = function (_0x27a4dc, _0x26a667, _0x49c824, _0x2f2358) {
  if (!this.canMove()) {
    return;
  }
  if (!this._distortionSprite) {
    return;
  }
  if (this._targetAngle === _0x27a4dc) {
    return;
  }
  this._targetAngle = _0x27a4dc;
  this._angleDuration = _0x26a667;
  this._angleWholeDuration = _0x26a667;
  this._angleEasing = _0x49c824 || "Linear";
  this._angleRevertOnFinish = _0x2f2358;
  if (this._angleRevertOnFinish === undefined) {
    this._angleRevertOnFinish = true;
  }
  if (_0x26a667 <= 0x0) {
    this._currentAngle = _0x27a4dc;
    if (this._angleRevertOnFinish) {
      this._targetAngle = 0x0;
      this._currentAngle = 0x0;
    }
  }
};
Sprite_Battler.prototype.updateSpin = function () {
  this.updateAngleCalculations();
  this.applyAngleChange();
};
Sprite_Battler.prototype.updateAngleCalculations = function () {
  if (this._angleDuration <= 0x0) {
    return;
  }
  const _0x4ef93b = this._angleDuration;
  const _0x39ea50 = this._angleWholeDuration;
  const _0x569227 = this._angleEasing;
  if (Imported.VisuMZ_0_CoreEngine) {
    this._currentAngle = this.applyEasing(this._currentAngle, this._targetAngle, _0x4ef93b, _0x39ea50, _0x569227);
  } else {
    this._currentAngle = (this._currentAngle * (_0x4ef93b - 0x1) + this._targetAngle) / _0x4ef93b;
  }
  this._angleDuration--;
  if (this._angleDuration <= 0x0) {
    this.onAngleEnd();
  }
};
Sprite_Battler.prototype.onAngleEnd = function () {
  this._currentAngle = this._targetAngle;
  if (this._angleRevertOnFinish) {
    this._targetAngle = 0x0;
    this._currentAngle = 0x0;
  }
};
Sprite_Battler.prototype.isSpinning = function () {
  return this._angleDuration > 0x0;
};
Sprite_Battler.prototype.applyAngleChange = function () {
  if (!this._distortionSprite) {
    return;
  }
  const _0x3b92c0 = this._currentAngle;
  const _0x1ebe70 = this.scale.x;
  const _0x23d0de = this._battler.isActor() ? -0x1 : 0x1;
  this._distortionSprite.angle = _0x3b92c0 * _0x1ebe70 * _0x23d0de;
  const _0x29b200 = this._distortionSprite.scale.y;
  this._distortionSprite.y = this.height * -0.5 * (0x2 - _0x29b200);
  this._distortionSprite.y = Math.ceil(this._distortionSprite.y);
  const _0x1d1cad = [this._mainSprite, this._svBattlerSprite, this._dragonbonesSpriteContainer];
  for (const _0x10a243 of _0x1d1cad) {
    if (!_0x10a243) {
      continue;
    }
    _0x10a243.y = this.height * 0.5;
  }
  if (this._shadowSprite) {
    this._shadowScaleX = this._shadowScaleX ?? 0x1;
    this._shadowScaleY = this._shadowScaleY ?? 0x1;
    this._shadowSprite.scale.x = this._distortionSprite.scale.x * this._shadowScaleX;
    this._shadowSprite.scale.y = this._distortionSprite.scale.y * this._shadowScaleY;
  }
};
VisuMZ.BattleCore.Sprite_Actor_createStateSprite = Sprite_Actor.prototype.createStateSprite;
Sprite_Actor.prototype.createStateSprite = function () {
  VisuMZ.BattleCore.Sprite_Actor_createStateSprite.call(this);
  if (VisuMZ.BattleCore.Settings.HpGauge.ShowActorGauge) {
    this.createHpGaugeSprite();
  }
};
VisuMZ.BattleCore.Sprite_Enemy_createStateIconSprite = Sprite_Enemy.prototype.createStateIconSprite;
Sprite_Enemy.prototype.createStateIconSprite = function () {
  if (VisuMZ.BattleCore.Settings.HpGauge.ShowEnemyGauge) {
    this.createHpGaugeSprite();
  }
  VisuMZ.BattleCore.Sprite_Enemy_createStateIconSprite.call(this);
};
Sprite_Battler.prototype.createHpGaugeSprite = function () {
  if (!ConfigManager.visualHpGauge) {
    return;
  }
  if (this.constructor === Sprite_SvEnemy) {
    return;
  }
  const _0xd0790b = VisuMZ.BattleCore.Settings.HpGauge;
  const _0x36bbc4 = new Sprite_HpGauge();
  _0x36bbc4.anchor.x = _0xd0790b.AnchorX;
  _0x36bbc4.anchor.y = _0xd0790b.AnchorY;
  _0x36bbc4.scale.x = _0x36bbc4.scale.y = _0xd0790b.Scale;
  this._hpGaugeSprite = _0x36bbc4;
  this.addChild(this._hpGaugeSprite);
  if (Spriteset_Battle.ANTI_TINT_UI) {
    BattleManager.addChildToUiContainer(this._hpGaugeSprite);
  }
};
VisuMZ.BattleCore.Sprite_Battler_setBattler = Sprite_Battler.prototype.setBattler;
Sprite_Battler.prototype.setBattler = function (_0x2285f6) {
  const _0x12094e = this._battler;
  VisuMZ.BattleCore.Sprite_Battler_setBattler.call(this, _0x2285f6);
  this.setupHpGaugeSprite(_0x2285f6);
  if (_0x12094e !== _0x2285f6) {
    this.updateShadowScale();
  }
};
Sprite_Battler.prototype.setupHpGaugeSprite = function (_0x38ce8f) {
  if (!_0x38ce8f) {
    return;
  }
  if (!this._hpGaugeSprite) {
    return;
  }
  if (_0x38ce8f.isActor()) {} else {
    if (_0x38ce8f.isEnemy()) {
      if (this.constructor === Sprite_SvEnemy && !_0x38ce8f.hasSvBattler()) {
        return;
      }
    }
  }
  this._hpGaugeSprite.setup(_0x38ce8f, 'hp');
};
Sprite_Battler.prototype.hasStaticSvBattler = function () {
  return this._battler && this._battler.hasStaticSvBattler();
};
Sprite_Battler.prototype.updateStaticSvBattlerFrames = function () {
  const _0x55397b = this._mainSprite.bitmap;
  if (!_0x55397b) {
    return;
  }
  const _0x39c60e = _0x55397b.width;
  let _0x37c9e6 = _0x55397b.height;
  if (this._battler.isDead()) {
    if (this._frame) {
      _0x37c9e6 = Math.max(0x0, this._frame.height - 0x4);
    }
  }
  this._mainSprite.setFrame(0x0, 0x0, _0x39c60e, _0x37c9e6);
  this.setFrame(0x0, 0x0, _0x39c60e, _0x37c9e6);
};
Sprite_Battler.prototype.updateHpGaugePosition = function () {
  if (!this._battler) {
    return;
  }
  if (!this._hpGaugeSprite) {
    return;
  }
  const _0x2c4763 = VisuMZ.BattleCore.Settings.HpGauge;
  const _0x14984d = this._hpGaugeSprite;
  _0x14984d.visible = this.isVisualHpGaugeDisplayed();
  const _0x525993 = _0x2c4763.OffsetX;
  const _0x425b2d = _0x2c4763.OffsetY;
  _0x14984d.x = _0x525993;
  _0x14984d.x += this._battler.battleUIOffsetX();
  _0x14984d.y = -this.height + _0x425b2d;
  _0x14984d.y += this._battler.battleUIOffsetY();
  if (Spriteset_Battle.ANTI_TINT_UI && SceneManager._scene._spriteset) {
    _0x14984d.x += this.x;
    _0x14984d.y += this.y;
  }
};
Sprite_Battler.prototype.isVisualHpGaugeDisplayed = function () {
  if (!this._battler) {
    return false;
  }
  if (this._battler.isActor()) {
    return true;
  }
  if (this._battler.isHidden()) {
    return false;
  }
  if (this.opacity <= 0x0) {
    return false;
  }
  const _0x4757f7 = this._battler.enemy().note;
  if (_0x4757f7.match(/<SHOW HP GAUGE>/i)) {
    return true;
  }
  if (_0x4757f7.match(/<HIDE HP GAUGE>/i)) {
    return false;
  }
  const _0x272534 = VisuMZ.BattleCore.Settings.HpGauge;
  if (_0x272534.RequiresDefeat) {
    if (_0x272534.BTestBypass && BattleManager.isBattleTest()) {
      return true;
    }
    if (this._battler._visualHpGauge_JustDied) {
      return false;
    }
    return this._battler.hasBeenDefeatedBefore();
  }
  return true;
};
VisuMZ.BattleCore.Sprite_Battler_isMoving = Sprite_Battler.prototype.isMoving;
Sprite_Battler.prototype.isMoving = function () {
  if (!this._battler) {
    return false;
  }
  if (this._homeDuration > 0x0) {
    return true;
  }
  return VisuMZ.BattleCore.Sprite_Battler_isMoving.call(this);
};
VisuMZ.BattleCore.Sprite_Battler_startMove = Sprite_Battler.prototype.startMove;
Sprite_Battler.prototype.startMove = function (_0x5c5d08, _0x433432, _0x1e292e) {
  if (this.canMove()) {
    VisuMZ.BattleCore.Sprite_Battler_startMove.call(this, _0x5c5d08, _0x433432, _0x1e292e);
  }
};
Sprite_Battler.prototype.canMove = function () {
  if (this._battler && this._battler.isDead()) {
    return false;
  }
  if (this._battler && !this._battler.canBattlerMove()) {
    return false;
  }
  return $gameSystem.isSideView();
};
Sprite_Battler.prototype.stepForward = function () {};
Sprite_Battler.prototype.stepBack = function () {
  this.startMove(0x0, 0x0, 0xc);
};
Sprite_Battler.prototype.retreat = function () {};
Sprite_Battler.prototype.stepFlinch = function () {
  const _0xa2370c = VisuMZ.BattleCore.Settings.Actor;
  const _0x290e5c = this._battler && this._battler.isActor() ? 0x1 : -0x1;
  const _0x54d701 = this._baseX - this._homeX + _0x290e5c * _0xa2370c.FlinchDistanceX;
  const _0x56fb69 = this._baseY - this._homeY + _0x290e5c * _0xa2370c.FlinchDistanceY;
  const _0x182aeb = _0xa2370c.FlinchDuration;
  this.startMove(_0x54d701, _0x56fb69, _0x182aeb);
};
Sprite_Battler.prototype.startShakeFlinch = function (_0x18feea, _0x5a1ca1) {
  const _0x3a0fec = VisuMZ.BattleCore.Settings.Actor;
  this._shakeFlinchDuration = Math.ceil((_0x3a0fec.ShakeFlinchDuration ?? 0x18) * _0x5a1ca1);
  this._shakeFlinchPower = Math.max(this._shakeFlinchPower, _0x18feea);
};
Sprite_Battler.prototype.updateShakeFlinch = function () {
  const _0x2f636b = VisuMZ.BattleCore.Settings.Actor;
  if (!(_0x2f636b.ShakeFlinch ?? false)) {
    return;
  }
  if (this._shakeFlinchDuration > 0x0) {
    const _0x3847de = this._shakeFlinchDuration;
    this._shakeFlinchPower = this._shakeFlinchPower * (_0x3847de - 0x1) / _0x3847de;
    this._shakeFlinchDuration--;
    if (this._shakeFlinchDuration <= 0x0) {
      this._shakeFlinchPower = 0x0;
    }
  }
  if (this._shakeFlinchPower > 0x0) {
    this._mainSprite.x = Math.randomInt(this._shakeFlinchPower) * (Math.random() < 0.5 ? -0x1 : 0x1);
    if (this._baseY !== this.y) {
      this._mainSprite.y = this.height * 0.5;
      this._mainSprite.y += Math.randomInt(this._shakeFlinchPower) * (Math.random() < 0.5 ? -0x1 : 0x1);
    }
  } else {
    this._mainSprite.x = 0x0;
    this._mainSprite.y = this.height * 0.5;
  }
};
VisuMZ.BattleCore.Sprite_Actor_initMembers = Sprite_Actor.prototype.initMembers;
Sprite_Actor.prototype.initMembers = function () {
  VisuMZ.BattleCore.Sprite_Actor_initMembers.call(this);
  this.attachSpritesToDistortionSprite();
};
Sprite_Actor.prototype.mainSprite = function () {
  return this._distortionSprite || this._mainSprite || this;
};
VisuMZ.BattleCore.Sprite_Actor_moveToStartPosition = Sprite_Actor.prototype.moveToStartPosition;
Sprite_Actor.prototype.moveToStartPosition = function () {};
Sprite_Actor.prototype.moveToStartPositionBattleCore = function (_0x1a2e59) {
  if (SceneManager.isPreviousSceneBattleTransitionable()) {
    return;
  }
  if (!_0x1a2e59) {
    return;
  }
  if (!_0x1a2e59.canMove()) {
    return;
  }
  VisuMZ.BattleCore.Sprite_Actor_moveToStartPosition.call(this);
};
VisuMZ.BattleCore.Sprite_Actor_setActorHome = Sprite_Actor.prototype.setActorHome;
Sprite_Actor.prototype.setActorHome = function (_0x2d2330) {
  if (VisuMZ.BattleCore.Settings.Actor.HomePosJS) {
    VisuMZ.BattleCore.Settings.Actor.HomePosJS.call(this, _0x2d2330);
  } else {
    VisuMZ.BattleCore.Sprite_Actor_setActorHome.call(this, _0x2d2330);
  }
};
VisuMZ.BattleCore.Sprite_Actor_setBattler = Sprite_Actor.prototype.setBattler;
Sprite_Actor.prototype.setBattler = function (_0x41c30e) {
  VisuMZ.BattleCore.Sprite_Actor_setBattler.call(this, _0x41c30e);
  this.setBattlerBattleCore(_0x41c30e);
};
Sprite_Actor.prototype.setBattlerBattleCore = function (_0x2dedc1) {
  if (!_0x2dedc1) {
    return;
  }
  if (!this._mainSprite) {
    return;
  }
  this._mainSprite.anchor.x = this._actor.svBattlerAnchorX();
  this._mainSprite.anchor.y = this._actor.svBattlerAnchorY();
  this.updateShadowVisibility();
};
VisuMZ.BattleCore.Sprite_Actor_update = Sprite_Actor.prototype.update;
Sprite_Actor.prototype.update = function () {
  VisuMZ.BattleCore.Sprite_Actor_update.call(this);
  if (this._actor) {
    this.updateStateSprite();
    this.updateStyleOpacity();
  }
};
VisuMZ.BattleCore.Sprite_Actor_updateBitmap = Sprite_Actor.prototype.updateBitmap;
Sprite_Actor.prototype.updateBitmap = function () {
  VisuMZ.BattleCore.Sprite_Actor_updateBitmap.call(this);
  if (this._mainSprite && this._mainSprite.bitmap && this._battler) {
    if (this._mainSprite.bitmap.smooth !== this._battler.battlerSmoothImage()) {
      this._mainSprite.bitmap.smooth = this._battler.battlerSmoothImage();
    }
  }
};
VisuMZ.BattleCore.Sprite_Actor_updateShadow = Sprite_Actor.prototype.updateShadow;
Sprite_Actor.prototype.updateShadow = function () {
  VisuMZ.BattleCore.Sprite_Actor_updateShadow.call(this);
  this.updateShadowBattleCore();
};
Sprite_Actor.prototype.updateShadowBattleCore = function () {
  if (!this._mainSprite) {
    return;
  }
  if (!this._shadowSprite) {
    return;
  }
  this.updateShadowVisibility();
  this.updateShadowPosition();
};
Sprite_Actor.prototype.updateStateSprite = function () {
  {
    this._stateSprite.scale.x = 0x1 / (this.scale.x || 0.001);
    this._stateSprite.scale.y = 0x1 / (this.scale.y || 0.001);
  }
  {
    this._stateSprite.x = 0x0;
    this._stateSprite.y = -this.height - 0x20 + 0x60;
    const _0x3c78f2 = VisuMZ.BattleCore.Settings.Actor;
    this._stateSprite.x += _0x3c78f2.StateOverlayOffsetX ?? 0x0;
    this._stateSprite.y += _0x3c78f2.StateOverlayOffsetY ?? 0x0;
  }
};
Sprite_Actor.prototype.updateStyleOpacity = function () {
  if (!$gameSystem.isSideView() && this.constructor === Sprite_Actor) {
    const _0x2d246a = Scene_Battle.prototype.battleLayoutStyle();
    if (["default", "list", "portrait", 'border'].includes(_0x2d246a)) {
      this.opacity = 0x0;
    }
  }
};
Sprite_Actor.prototype.refreshMotion = function () {
  const _0xc4566a = this._actor;
  if (_0xc4566a) {
    if (_0xc4566a._performDamageMotion) {
      return;
    }
    const _0x1139fc = _0xc4566a.stateMotionIndex();
    if (_0xc4566a.isInputting() || _0xc4566a.isActing()) {
      this.startMotion("walk");
    } else {
      if (_0x1139fc === 0x3) {
        this.startMotion("dead");
      } else {
        if (_0x1139fc === 0x2) {
          this.startMotion("sleep");
        } else {
          if (this.forceEscapeSprite) {
            this.startMotion("escape");
          } else {
            if (_0xc4566a.isCharging()) {
              this.startMotion('wait');
            } else {
              if (_0xc4566a.isChanting()) {
                this.startMotion('chant');
              } else {
                if (_0xc4566a.isGuard() || _0xc4566a.isGuardWaiting()) {
                  this.startMotion("guard");
                } else {
                  if (_0x1139fc === 0x1) {
                    this.startMotion('abnormal');
                  } else {
                    if (_0xc4566a.isDying()) {
                      this.startMotion("dying");
                    } else {
                      if (_0xc4566a.isUndecided()) {
                        this.startMotion("walk");
                      } else if (_0xc4566a.currentAction()) {
                        this.startMotion("wait");
                      } else {
                        this.startMotion("walk");
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
};
Sprite_Actor.prototype.retreat = function () {
  this.startMove(3000, 0x0, 300);
};
Sprite_Actor.prototype.onMoveEnd = function () {
  Sprite_Battler.prototype.onMoveEnd.call(this);
};
Sprite_Actor.prototype.motionSpeed = function () {
  return Sprite_Battler._motionSpeed;
};
Sprite_Weapon.prototype.animationWait = function () {
  return Sprite_Battler._motionSpeed;
};
Sprite_Actor.prototype.setupMotion = function () {};
Sprite_Actor.prototype.setupWeaponAnimation = function () {};
Sprite_Actor.prototype.updateMotionCount = function () {
  if (this._motion && ++this._motionCount >= this.motionSpeed()) {
    if (this._motion.loop) {
      this._pattern = (this._pattern + 0x1) % 0x4;
    } else {
      if (this._pattern < 0x2) {
        this._pattern++;
      } else {
        const _0x5f1232 = this._actor;
        if (_0x5f1232) {
          _0x5f1232._performDamageMotion = undefined;
        }
        this.refreshMotion();
      }
    }
    this._motionCount = 0x0;
  }
};
Sprite_Actor.prototype.forceMotion = function (_0xbcd86e) {
  if (this._battler && this._battler.isDead()) {
    this._motion = Sprite_Actor.MOTIONS.dead;
    return;
  }
  const _0x24ba44 = Sprite_Actor.MOTIONS[_0xbcd86e];
  this._motion = _0x24ba44;
  this._motionCount = 0x0;
  this._pattern = 0x0;
};
Sprite_Actor.prototype.forceWeaponAnimation = function (_0x527dde) {
  if (this.hasStaticSvBattler()) {
    return;
  }
  this.adjustWeaponSpriteOffset();
  this._weaponSprite.setup(_0x527dde);
  this._actor.clearWeaponAnimation();
};
Sprite_Actor.prototype.adjustWeaponSpriteOffset = function () {
  let _0x5ba4a1 = -0x10;
  let _0x5d9c36 = this.height * 0.5;
  const _0x19cca9 = /<SIDEVIEW WEAPON OFFSET:[ ]([\+\-]\d+),[ ]([\+\-]\d+)>/i;
  const _0x396219 = this._battler.traitObjects().map(_0x1baeb2 => _0x1baeb2 && _0x1baeb2.note.match(_0x19cca9) ? Number(RegExp.$1) : 0x0);
  const _0xfdebd8 = this._battler.traitObjects().map(_0x37897b => _0x37897b && _0x37897b.note.match(_0x19cca9) ? Number(RegExp.$2) : 0x0);
  _0x5ba4a1 = _0x396219.reduce((_0x245e2c, _0x5731d4) => _0x245e2c + _0x5731d4, _0x5ba4a1);
  _0x5d9c36 = _0xfdebd8.reduce((_0x4d9c9b, _0xd0a02a) => _0x4d9c9b + _0xd0a02a, _0x5d9c36);
  this._weaponSprite.x = _0x5ba4a1;
  this._weaponSprite.y = _0x5d9c36;
  this._weaponSprite.update();
};
Sprite_Weapon.prototype.setup = function (_0x387c82) {
  this._weaponImageId = _0x387c82;
  this._animationCount = -0x1;
  this._pattern = 0x0;
  this.loadBitmap();
  this.updateFrame();
};
Sprite_Actor.prototype.updateTargetPosition = function () {};
Sprite_Actor.prototype.stepForward = function () {
  const _0x4dc8bf = VisuMZ.BattleCore.Settings.ActionSequence;
  const _0x53a6bb = _0x4dc8bf.StepDistanceX;
  const _0x21cbc8 = _0x4dc8bf.StepDistanceY;
  const _0x47d645 = _0x4dc8bf.StepDuration;
  this.startMove(-_0x53a6bb, -_0x21cbc8, _0x47d645);
};
VisuMZ.BattleCore.Sprite_Actor_updateFrame = Sprite_Actor.prototype.updateFrame;
Sprite_Actor.prototype.updateFrame = function () {
  if (this.hasStaticSvBattler()) {
    this.updateStaticSvBattlerFrames();
  } else {
    this.applyFreezeMotionFrames();
    VisuMZ.BattleCore.Sprite_Actor_updateFrame.call(this);
  }
};
Sprite_Actor.prototype.applyFreezeMotionFrames = function () {
  if (this._battler && this._battler._freezeMotionData) {
    const _0x4e2e4e = this._battler._freezeMotionData;
    this._motion = Sprite_Actor.MOTIONS[_0x4e2e4e.motionType];
    this._pattern = _0x4e2e4e.pattern;
    const _0x52625f = this._weaponSprite;
    _0x52625f.freezeFrame(_0x4e2e4e.weaponImageId, _0x4e2e4e.pattern);
    this.adjustWeaponSpriteOffset();
  }
};
Sprite_Weapon.prototype.freezeFrame = function (_0x192bcd, _0xe2cacb) {
  this._weaponImageId = _0x192bcd;
  this._animationCount = -Infinity;
  this._pattern = _0xe2cacb;
  this.loadBitmap();
  this.updateFrame();
};
Sprite_Enemy.prototype.initMembers = function () {
  Sprite_Battler.prototype.initMembers.call(this);
  this._enemy = null;
  this._appeared = false;
  this._battlerName = '';
  this._battlerHue = 0x0;
  this._effectType = null;
  this._effectDuration = 0x0;
  this._shake = 0x0;
  this.createMainSprite();
  this.createStateIconSprite();
};
VisuMZ.BattleCore.Sprite_Enemy_update = Sprite_Enemy.prototype.update;
Sprite_Enemy.prototype.update = function () {
  VisuMZ.BattleCore.Sprite_Enemy_update.call(this);
  this.updateShadowVisibility();
  this.updateNameTempVisibility();
};
Sprite_Enemy.prototype.createMainSprite = function () {
  this._mainSprite = new Sprite();
  this._mainSprite.anchor.x = 0.5;
  this._mainSprite.anchor.y = 0x1;
  this.addChild(this._mainSprite);
  this.attachSpritesToDistortionSprite();
};
Sprite_Enemy.prototype.mainSprite = function () {
  return this._distortionSprite || this._mainSprite || this;
};
Sprite_Enemy.prototype.loadBitmap = function (_0x13e634) {
  this.bitmap = new Bitmap(0x1, 0x1);
  if (this.hasSvBattler()) {
    const _0x174673 = this._enemy.svBattlerData();
    this.bitmap = new Bitmap(_0x174673.width, _0x174673.height);
    this._mainSprite.bitmap = new Bitmap(0x1, 0x1);
  } else {
    if ($gameSystem.isSideView()) {
      const _0x38cac7 = ImageManager.loadSvEnemy(_0x13e634);
      _0x38cac7.addLoadListener(this.onStaticEnemyBitmapLoad.bind(this, _0x38cac7));
    } else {
      const _0x3d4cdc = ImageManager.loadEnemy(_0x13e634);
      _0x3d4cdc.addLoadListener(this.onStaticEnemyBitmapLoad.bind(this, _0x3d4cdc));
    }
  }
};
Sprite_Enemy.prototype.onStaticEnemyBitmapLoad = function (_0x2f108a) {
  this._mainSprite.bitmap = _0x2f108a;
  this.bitmap = new Bitmap(_0x2f108a.width, _0x2f108a.height);
};
VisuMZ.BattleCore.Sprite_Enemy_setHue = Sprite_Enemy.prototype.setHue;
Sprite_Enemy.prototype.setHue = function (_0x5e293e) {
  if (this._mainSprite) {
    this._mainSprite.setHue(_0x5e293e);
  }
};
VisuMZ.BattleCore.Sprite_Enemy_initVisibility = Sprite_Enemy.prototype.initVisibility;
Sprite_Enemy.prototype.initVisibility = function () {
  if (this.allowCollapse()) {
    VisuMZ.BattleCore.Sprite_Enemy_initVisibility.call(this);
  } else {
    this._appeared = !this._enemy.isHidden();
    if (!this._appeared) {
      this.opacity = 0x0;
    }
  }
};
VisuMZ.BattleCore.Sprite_Enemy_updateCollapse = Sprite_Enemy.prototype.updateCollapse;
Sprite_Enemy.prototype.updateCollapse = function () {
  if (this.allowCollapse()) {
    VisuMZ.BattleCore.Sprite_Enemy_updateCollapse.call(this);
  }
};
Sprite_Enemy.prototype.updateFrame = function () {
  Sprite_Battler.prototype.updateFrame.call(this);
  const _0x3c7604 = this.mainSprite() || this;
  if (!_0x3c7604) {
    return;
  }
  if (!_0x3c7604.bitmap) {
    _0x3c7604.bitmap = new Bitmap(this.width || 0x1, this.height || 0x1);
  }
  if (this._effectType === "bossCollapse") {
    this._mainSprite.setFrame(0x0, 0x0, this._mainSprite.width || 0x1, this._effectDuration);
  } else {
    let _0xe09cd3 = 0x1;
    if (_0x3c7604 && _0x3c7604.bitmap) {
      _0xe09cd3 = _0x3c7604.bitmap.width;
    }
    let _0x1a6c88 = 0x1;
    if (this.bitmap) {
      _0x1a6c88 = this.bitmap.height;
    }
    _0x3c7604.setFrame(0x0, 0x0, _0xe09cd3, _0x1a6c88);
  }
};
VisuMZ.BattleCore.Sprite_Enemy_updateBossCollapse = Sprite_Enemy.prototype.updateBossCollapse;
Sprite_Enemy.prototype.updateBossCollapse = function () {
  if (this.allowCollapse()) {
    VisuMZ.BattleCore.Sprite_Enemy_updateBossCollapse.call(this);
  }
};
Sprite_Enemy.prototype.isMoving = function () {
  return Sprite_Battler.prototype.isMoving.call(this);
};
VisuMZ.BattleCore.Sprite_Enemy_updateStateSprite = Sprite_Enemy.prototype.updateStateSprite;
Sprite_Enemy.prototype.updateStateSprite = function () {
  VisuMZ.BattleCore.Sprite_Enemy_updateStateSprite.call(this);
  this.updateStateSpriteBattleCore();
};
Sprite_Enemy.prototype.updateStateSpriteBattleCore = function () {
  const _0x585ae5 = VisuMZ.BattleCore.Settings.Enemy;
  if (_0x585ae5.NameAttachStateIcon && !_0x585ae5.NameLegacy) {
    this._stateIconSprite.opacity = 0x0;
    return;
  }
  this._stateIconSprite.x = 0x0;
  this._stateIconSprite.x += this._battler.battleUIOffsetX();
  let _0x552f13 = 0x1;
  if (this.bitmap) {
    _0x552f13 = this.bitmap.height;
  }
  this._stateIconSprite.y = -_0x552f13 - this._stateIconSprite.height - 0x4;
  this._stateIconSprite.y += this._battler.battleUIOffsetY();
  this._stateIconSprite.scale.x = 0x1 / (this.scale.x || 0.001);
  this._stateIconSprite.scale.y = 0x1 / (this.scale.y || 0.001);
  if (this.hasSvBattler()) {
    this._svBattlerSprite._stateSprite.scale.x = -0x1 / (this.scale.x || 0.001);
    this._svBattlerSprite._stateSprite.scale.y = 0x1 / (this.scale.y || 0.001);
  }
};
Sprite_Enemy.prototype.updateNameTempVisibility = function () {
  if (this._battler) {
    this._battler.updateNameTempVisibility();
  }
};
VisuMZ.BattleCore.Sprite_Enemy_setBattler = Sprite_Enemy.prototype.setBattler;
Sprite_Enemy.prototype.setBattler = function (_0x5d0092) {
  VisuMZ.BattleCore.Sprite_Enemy_setBattler.call(this, _0x5d0092);
  this.setSvBattlerSprite(_0x5d0092);
};
Sprite_Enemy.prototype.setSvBattlerSprite = function (_0x591c00) {
  if (!this._svBattlerSprite) {
    this._svBattlerSprite = new Sprite_SvEnemy(_0x591c00);
    this.attachSpritesToDistortionSprite();
  }
  this._svBattlerSprite.setBattler(_0x591c00);
};
Sprite_Enemy.prototype.hasSvBattler = function () {
  return this._enemy && this._enemy.hasSvBattler();
};
Sprite_Enemy.prototype.allowCollapse = function () {
  return this.hasSvBattler() ? this._enemy.allowCollapse() : true;
};
Sprite_Enemy.prototype.refreshMotion = function () {
  if (this.hasSvBattler()) {
    this._svBattlerSprite.refreshMotion();
  }
};
Sprite_Enemy.prototype.forceMotion = function (_0x47ea6c) {
  if (this.hasSvBattler()) {
    this._svBattlerSprite.forceMotion(_0x47ea6c);
  }
};
Sprite_Enemy.prototype.forceWeaponAnimation = function (_0x52e449) {
  if (this.hasSvBattler()) {
    this._svBattlerSprite.forceWeaponAnimation(_0x52e449);
  }
};
Sprite_Enemy.prototype.stepForward = function () {
  const _0x4a97b7 = VisuMZ.BattleCore.Settings.ActionSequence;
  const _0x1597a0 = _0x4a97b7.StepDistanceX;
  const _0xe99e8b = _0x4a97b7.StepDistanceY;
  const _0x182c01 = _0x4a97b7.StepDuration;
  this.startMove(_0x1597a0, _0xe99e8b, _0x182c01);
};
function Sprite_SvEnemy() {
  this.initialize(...arguments);
}
Sprite_SvEnemy.prototype = Object.create(Sprite_Actor.prototype);
Sprite_SvEnemy.prototype.constructor = Sprite_SvEnemy;
Sprite_SvEnemy.prototype.initialize = function (_0x41b495) {
  Sprite_Actor.prototype.initialize.call(this, _0x41b495);
  this.scale.x = -0x1;
  this._stateSprite.scale.x = -0x1;
};
Sprite_SvEnemy.prototype.createShadowSprite = function () {};
Sprite_SvEnemy.prototype.moveToStartPosition = function () {};
Sprite_SvEnemy.prototype.setActorHome = function (_0x2c8760) {};
Sprite_SvEnemy.prototype.updateShadow = function () {};
Sprite_SvEnemy.prototype.updateShadowPosition = function () {};
Sprite_SvEnemy.prototype.updateStateSprite = function () {
  this._stateSprite.visible = false;
};
Sprite_SvEnemy.prototype.updateBitmap = function () {
  Sprite_Battler.prototype.updateBitmap.call(this);
  const _0x1c7e8b = this._actor.svBattlerName();
  if (this._battlerName !== _0x1c7e8b) {
    this._battlerName = _0x1c7e8b;
    this._mainSprite.bitmap = ImageManager.loadSvActor(_0x1c7e8b);
  }
  if (this._mainSprite && this._mainSprite.bitmap && this._battler) {
    if (this._mainSprite.bitmap.smooth !== this._battler.battlerSmoothImage()) {
      this._mainSprite.bitmap.smooth = this._battler.battlerSmoothImage();
    }
  }
};
Sprite_SvEnemy.prototype.retreat = function () {};
Sprite_SvEnemy.prototype.startMove = function (_0xac1228, _0x1ff1dd, _0x31e623) {
  if (this.parent) {
    this.parent.startMove(_0xac1228, _0x1ff1dd, _0x31e623);
  }
};
Sprite_SvEnemy.prototype.refreshMotion = function () {
  const _0x227e88 = this._actor;
  if (_0x227e88) {
    const _0x2c21d6 = _0x227e88.stateMotionIndex();
    if (_0x227e88.isInputting() || _0x227e88.isActing()) {
      this.startMotion("walk");
    } else {
      if (_0x2c21d6 === 0x3) {
        this.startMotion('dead');
      } else {
        if (_0x2c21d6 === 0x2) {
          this.startMotion("sleep");
        } else {
          if (_0x227e88.isChanting()) {
            this.startMotion("chant");
          } else {
            if (_0x227e88.isGuard() || _0x227e88.isGuardWaiting()) {
              this.startMotion("guard");
            } else {
              if (_0x2c21d6 === 0x1) {
                this.startMotion("abnormal");
              } else {
                if (_0x227e88.isDying()) {
                  this.startMotion("dying");
                } else if (_0x227e88.isUndecided()) {
                  this.startMotion("walk");
                } else {
                  this.startMotion(_0x227e88.svBattlerData().motionIdle || "walk");
                }
              }
            }
          }
        }
      }
    }
  }
};
Sprite_SvEnemy.prototype.inHomePosition = function () {
  return this.parent ? this.parent._offsetX === 0x0 && this.parent._offsetY === 0x0 : true;
};
Sprite_SvEnemy.prototype.updateFlip = function () {};
VisuMZ.BattleCore.Sprite_Animation_targetSpritePosition = Sprite_Animation.prototype.targetSpritePosition;
Sprite_Animation.prototype.targetSpritePosition = function (_0x38dde8) {
  return _0x38dde8._distortionSprite ? this.targetDistortionSpritePosition(_0x38dde8) : VisuMZ.BattleCore.Sprite_Animation_targetSpritePosition.call(this, _0x38dde8);
};
Sprite_Animation.prototype.targetDistortionSpritePosition = function (_0x59ec98) {
  let _0x7a482d = _0x59ec98.x;
  let _0xcabb6b = _0x59ec98.y;
  let _0x2bed14 = _0x59ec98.height;
  let _0x18ce6c = _0x59ec98._distortionSprite.scale.y;
  _0x59ec98.x = _0x59ec98._baseX + _0x59ec98.extraPositionX();
  _0x59ec98.y = _0x59ec98._baseY + _0x59ec98.extraPositionY();
  _0x59ec98.height *= _0x18ce6c;
  let _0x2cf638 = VisuMZ.BattleCore.Sprite_Animation_targetSpritePosition.call(this, _0x59ec98);
  _0x59ec98.x = _0x7a482d;
  _0x59ec98.y = _0xcabb6b;
  _0x59ec98.height = _0x2bed14;
  return _0x2cf638;
};
VisuMZ.BattleCore.Sprite_AnimationMV_updatePosition = Sprite_AnimationMV.prototype.updatePosition;
Sprite_AnimationMV.prototype.updatePosition = function () {
  VisuMZ.BattleCore.Sprite_AnimationMV_updatePosition.call(this);
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  if (this._animation.position === 0x3) {
    this.x = Math.round(Graphics.boxWidth / 0x2);
    this.y = Math.round(Graphics.boxHeight / 0x2);
  } else {
    if (this.battleStatusSprite) {
      return;
    }
  }
};
Sprite_Damage.prototype.setupBattleCore = function (_0x2b1b9d) {
  const _0x1fe3c1 = _0x2b1b9d.getNextDamagePopup() || _0x2b1b9d.result();
  if (_0x1fe3c1.missed || _0x1fe3c1.evaded) {
    this._colorType = 0x0;
    this.createMiss();
  } else {
    if (_0x1fe3c1.hpAffected) {
      this._colorType = _0x1fe3c1.hpDamage >= 0x0 ? 0x0 : 0x1;
      this.createDigits(_0x1fe3c1.hpDamage);
    } else if (_0x2b1b9d.isAlive() && _0x1fe3c1.mpDamage !== 0x0) {
      this._colorType = _0x1fe3c1.mpDamage >= 0x0 ? 0x2 : 0x3;
      this.createDigits(_0x1fe3c1.mpDamage);
    }
  }
  if (_0x1fe3c1.critical) {
    this.setupCriticalEffect();
  }
};
Sprite_Damage.prototype.setup = function (_0x5bf9db) {};
Sprite_Damage.prototype.createDigits = function (_0x512061) {
  let _0x30d9d4 = this.createString(_0x512061);
  const _0xf5760c = this.fontSize();
  const _0x400db3 = Math.floor(_0xf5760c * 0.75);
  for (let _0x10e1b2 = 0x0; _0x10e1b2 < _0x30d9d4.length; _0x10e1b2++) {
    const _0x575f20 = this.createChildSprite(_0x400db3, _0xf5760c);
    _0x575f20.bitmap.drawText(_0x30d9d4[_0x10e1b2], 0x0, 0x0, _0x400db3, _0xf5760c, "center");
    _0x575f20.x = (_0x10e1b2 - (_0x30d9d4.length - 0x1) / 0x2) * _0x400db3;
    _0x575f20.dy = -_0x10e1b2;
  }
};
Sprite_Damage.prototype.createString = function (_0x146754) {
  let _0xd41ce0 = Math.abs(_0x146754).toString();
  if (this.useDigitGrouping()) {
    _0xd41ce0 = VisuMZ.GroupDigits(_0xd41ce0);
  }
  const _0x51a01d = VisuMZ.BattleCore.Settings.Damage;
  let _0x362b2f = '';
  let _0x386f57 = '';
  switch (this._colorType) {
    case 0x0:
      _0x362b2f = _0x51a01d.hpDamageFmt || "-%1";
      _0x386f57 = TextManager.hp;
      if (_0x146754 === 0x0) {
        _0x362b2f = '%1';
      }
      break;
    case 0x1:
      _0x362b2f = _0x51a01d.hpHealingFmt || "+%1";
      _0x386f57 = TextManager.hp;
      break;
    case 0x2:
      _0x362b2f = _0x51a01d.mpDamageFmt || "-%1 MP";
      _0x386f57 = TextManager.mp;
      break;
    case 0x3:
      _0x362b2f = _0x51a01d.mpHealingFmt || "+%1 MP";
      _0x386f57 = TextManager.mp;
      break;
  }
  return _0x362b2f.format(_0xd41ce0, _0x386f57).trim();
};
Sprite_Damage.prototype.useDigitGrouping = function () {
  return Imported.VisuMZ_0_CoreEngine ? VisuMZ.CoreEngine.Settings.QoL.DigitGroupingDamageSprites : false;
};
Sprite_Damage.prototype.setupCriticalEffect = function () {
  const _0x366006 = VisuMZ.BattleCore.Settings.Damage;
  _0x366006.CriticalColor = _0x366006.CriticalColor || [0x0, 0x0, 0x0, 0x0];
  this._flashColor = _0x366006.CriticalColor.slice(0x0);
  this._flashDuration = _0x366006.CriticalDuration || 0x1;
};
Sprite_Damage.prototype.setupTextPopup = function (_0x2e1c8d, _0x38005a) {
  this._flashColor = _0x38005a.flashColor || [0x0, 0x0, 0x0, 0x0];
  this._flashColor = JsonEx.makeDeepCopy(this._flashColor);
  this._flashDuration = _0x38005a.flashDuration || 0x0;
  const _0x3b6a99 = this.fontSize();
  const _0x433c40 = Math.floor(_0x3b6a99 * 0x1e);
  const _0x3ffee2 = this.createChildSprite(_0x433c40, _0x3b6a99);
  _0x3ffee2.bitmap.textColor = ColorManager.getColor(_0x38005a.textColor);
  _0x3ffee2.bitmap.drawText(_0x2e1c8d, 0x0, 0x0, _0x433c40, _0x3b6a99, "center");
  _0x3ffee2.dy = 0x0;
};
Sprite_Damage.prototype.setupIconTextPopup = function (_0x45752a, _0x187836, _0x476764) {
  const _0xb35335 = Math.max(this.fontSize(), ImageManager.iconHeight);
  const _0x11af5f = Math.floor(_0xb35335 * 0x1e);
  const _0x3071cf = this.createChildSprite(_0x11af5f, _0xb35335);
  const _0x44cf03 = ImageManager.iconWidth / 0x2;
  const _0x48062e = _0x3071cf.bitmap.measureTextWidth(_0x187836 + " ");
  _0x3071cf.bitmap.textColor = ColorManager.getColor(_0x476764.textColor);
  _0x3071cf.bitmap.drawText(_0x187836, _0x44cf03, 0x0, _0x11af5f - _0x44cf03, _0xb35335, "center");
  const _0x5ea322 = Math.round((_0xb35335 - ImageManager.iconHeight) / 0x2);
  const _0x370e05 = _0x11af5f / 0x2 - ImageManager.iconWidth - _0x48062e / 0x2 + _0x44cf03 / 0x2;
  const _0x23ca6c = ImageManager.loadSystem('IconSet');
  const _0x2ff23a = ImageManager.iconWidth;
  const _0x54a430 = ImageManager.iconHeight;
  const _0x23dc8b = _0x45752a % 0x10 * _0x2ff23a;
  const _0x3c5035 = Math.floor(_0x45752a / 0x10) * _0x54a430;
  _0x3071cf.bitmap.blt(_0x23ca6c, _0x23dc8b, _0x3c5035, _0x2ff23a, _0x54a430, _0x370e05, _0x5ea322);
  this._flashColor = _0x476764.flashColor || [0x0, 0x0, 0x0, 0x0];
  this._flashColor = JsonEx.makeDeepCopy(this._flashColor);
  this._flashDuration = _0x476764.flashDuration || 0x0;
  _0x3071cf.dy = 0x0;
  if (_0x476764.offsetX) {
    _0x3071cf.x += _0x476764.offsetX;
  }
  if (_0x476764.offsetY) {
    _0x3071cf.dy += _0x476764.offsetY;
  }
};
VisuMZ.BattleCore.Sprite_Damage_createChildSprite = Sprite_Damage.prototype.createChildSprite;
Sprite_Damage.prototype.createChildSprite = function (_0x13a2a0, _0xb0ba85) {
  _0xb0ba85 = Math.round(_0xb0ba85 * 1.2);
  return VisuMZ.BattleCore.Sprite_Damage_createChildSprite.call(this, _0x13a2a0, _0xb0ba85);
};
VisuMZ.BattleCore.Sprite_StateIcon_updateFrame = Sprite_StateIcon.prototype.updateFrame;
Sprite_StateIcon.prototype.updateFrame = function () {
  VisuMZ.BattleCore.Sprite_StateIcon_updateFrame.call(this);
  this.opacity = this._iconIndex > 0x0 ? 0xff : 0x0;
};
VisuMZ.BattleCore.Sprite_Weapon_loadBitmap = Sprite_Weapon.prototype.loadBitmap;
Sprite_Weapon.prototype.loadBitmap = function () {
  VisuMZ.BattleCore.Sprite_Weapon_loadBitmap.call(this);
  if (this.bitmap) {
    this.bitmap.smooth = VisuMZ.BattleCore.Settings.Actor.SmoothImage;
  }
};
VisuMZ.BattleCore.Sprite_Gauge_smoothness = Sprite_Gauge.prototype.smoothness;
Sprite_Gauge.prototype.smoothness = function () {
  return this._statusType !== "time" ? VisuMZ.BattleCore.Settings.HpGauge.AniDuration ?? 0x14 : VisuMZ.BattleCore.Sprite_Gauge_smoothness.call(this);
};
function Sprite_HpGauge() {
  this.initialize(...arguments);
}
Sprite_HpGauge.prototype = Object.create(Sprite_Gauge.prototype);
Sprite_HpGauge.prototype.constructor = Sprite_HpGauge;
Sprite_HpGauge.prototype.initialize = function () {
  Sprite_Gauge.prototype.initialize.call(this);
};
Sprite_HpGauge.prototype.gaugeX = function () {
  return 0x0;
};
Sprite_HpGauge.prototype.redraw = function () {
  this.bitmap.clear();
  const _0x386437 = this.currentValue();
  if (!isNaN(_0x386437)) {
    this.drawGauge();
  }
};
function Sprite_EnemyName() {
  this.initialize(...arguments);
}
Sprite_EnemyName.prototype = Object.create(Sprite_Name.prototype);
Sprite_EnemyName.prototype.constructor = Sprite_EnemyName;
Sprite_EnemyName.prototype.initialize = function () {
  Sprite_Name.prototype.initialize.call(this);
  this.createAttachedSprites();
};
Sprite_EnemyName.prototype.initMembers = function () {
  Sprite_Name.prototype.initMembers.call(this);
  this.opacity = 0x0;
  this._linkedSprite = null;
  this.anchor.x = 0.5;
  this.anchor.y = 0x0;
};
Sprite_EnemyName.prototype.createAttachedSprites = function () {
  if (VisuMZ.BattleCore.Settings.Enemy.NameAttachStateIcon) {
    this._stateIconSprite = new Sprite_StateIcon();
    this.addChild(this._stateIconSprite);
  }
};
Sprite_EnemyName.prototype.bitmapWidth = function () {
  return Graphics.boxWidth;
};
Sprite_EnemyName.prototype.bitmapHeight = function () {
  this._lineHeight = this._lineHeight || Window_Base.prototype.lineHeight() || 0x24;
  return this._lineHeight * 0x4;
};
Sprite_EnemyName.prototype.fontSize = function () {
  return VisuMZ.BattleCore.Settings.Enemy.NameFontSize || $gameSystem.mainFontSize();
};
Sprite_EnemyName.prototype.linkSprite = function (_0x1283ea) {
  this._linkedSprite = _0x1283ea;
};
Sprite_EnemyName.prototype.update = function () {
  Sprite_Name.prototype.update.call(this);
  this.updateLink();
  this.updatePosition();
  this.updateAttachedSprites();
  this.updateOpacity();
};
Sprite_EnemyName.prototype.redraw = function () {
  this._cacheTextWidth = undefined;
  const _0x356cfb = this.name();
  const _0x1affcb = this.bitmapWidth();
  const _0x536da0 = Window_Base.prototype.lineHeight();
  this.setupFont();
  this.bitmap.clear();
  this.bitmap.drawText(_0x356cfb, 0x0, 0x0, _0x1affcb, _0x536da0, 'center');
};
Sprite_EnemyName.prototype.updateLink = function () {
  if (!this._linkedSprite) {
    return;
  }
  if (this._battler !== this._linkedSprite._battler) {
    this.setup(this._linkedSprite._battler);
  }
};
Sprite_EnemyName.prototype.updatePosition = function () {
  if (!this._linkedSprite) {
    return;
  }
  this._lineHeight = this._lineHeight || Window_Base.prototype.lineHeight();
  this.x = Math.round(this._linkedSprite._baseX);
  this.y = Math.round(this._linkedSprite._baseY - this._lineHeight * 0.5);
  const _0xac665b = VisuMZ.BattleCore.Settings.Enemy;
  this.x += Math.round(_0xac665b.NameOffsetX || 0x0);
  this.y += Math.round(_0xac665b.NameOffsetY || 0x0);
};
Sprite_EnemyName.prototype.updateAttachedSprites = function () {
  this.updateStateIconSprite();
};
Sprite_EnemyName.prototype.updateStateIconSprite = function () {
  if (!this._stateIconSprite) {
    return;
  }
  if (this._battler !== this._stateIconSprite._battler) {
    this._stateIconSprite.setup(this._battler);
  }
  const _0x2373ea = this.textWidth();
  this._lineHeight = this._lineHeight || Window_Base.prototype.lineHeight();
  this._stateIconSprite.x = Math.round((_0x2373ea + ImageManager.iconWidth) / 0x2) + 0x8;
  this._stateIconSprite.y = this._lineHeight / 0x2;
  const _0x43be5f = VisuMZ.BattleCore.Settings.Enemy;
  this._stateIconSprite.x += _0x43be5f.AttachStateOffsetX || 0x0;
  this._stateIconSprite.y += _0x43be5f.AttachStateOffsetY || 0x0;
};
Sprite_EnemyName.prototype.updateOpacity = function () {
  const _0x234337 = this.visibilityState();
  if (_0x234337 && this.opacity < 0xff) {
    this.opacity += 0x10;
  } else if (!_0x234337 && this.opacity > 0x0) {
    this.opacity -= 0x10;
  }
};
Sprite_EnemyName.prototype.visibilityState = function () {
  if (this.isAlwaysHidden()) {
    return false;
  } else {
    if (!this._battler) {
      return false;
    } else {
      if (!this._battler.isAppeared()) {
        return false;
      } else {
        if (this.temporaryVisibile()) {
          return true;
        } else {
          if (this._battler.isDead()) {
            return false;
          } else {
            if (this.isBattlerTargeted()) {
              return true;
            } else {
              if (this.compatibilityVisible()) {
                return true;
              } else {
                if (this.isAlwaysVisible()) {
                  return true;
                } else {
                  if (this.isIncludedInEnemyWindow()) {
                    return true;
                  } else {
                    if (this.opacity > 0x0) {
                      return false;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
};
Sprite_EnemyName.prototype.temporaryVisibile = function () {
  return this._battler && this._battler.isNameTemporarilyVisible();
};
Sprite_EnemyName.prototype.isAlwaysHidden = function () {
  return VisuMZ.BattleCore.Settings.Enemy.NameAlwaysHidden;
};
Sprite_EnemyName.prototype.isBattlerTargeted = function () {
  return this._battler && BattleManager._subject && BattleManager._targets.includes(this._battler);
};
Sprite_EnemyName.prototype.compatibilityVisible = function () {
  return false;
};
Sprite_EnemyName.prototype.isAlwaysVisible = function () {
  return VisuMZ.BattleCore.Settings.Enemy.NameAlwaysVisible;
};
Sprite_EnemyName.prototype.isIncludedInEnemyWindow = function () {
  return VisuMZ.BattleCore.Settings.Enemy.NameAlwaysSelectOnly ? this._battler.isSelected() : SceneManager._scene._enemyWindow && SceneManager._scene._enemyWindow.active && SceneManager._scene._enemyWindow._enemies.includes(this._battler);
};
Sprite_EnemyName.prototype.textWidth = function () {
  if (!this._battler) {
    return 0x0;
  }
  if (this._cacheTextWidth) {
    return this._cacheTextWidth;
  }
  const _0x104fbf = this.name();
  this.setupFont();
  this._cacheTextWidth = this.bitmap.measureTextWidth(_0x104fbf) || 0x1;
  return this._cacheTextWidth;
};
VisuMZ.BattleCore.Sprite_Battleback_adjustPosition = Sprite_Battleback.prototype.adjustPosition;
Sprite_Battleback.prototype.adjustPosition = function () {
  const _0x54ebbc = VisuMZ.BattleCore.Settings.BattlebackScale;
  if (!_0x54ebbc) {
    return VisuMZ.BattleCore.Sprite_Battleback_adjustPosition.call(this);
  }
  const _0x6de142 = String(_0x54ebbc.DefaultStyle) || 'MZ';
  switch (_0x6de142) {
    case 'MZ':
      VisuMZ.BattleCore.Sprite_Battleback_adjustPosition.call(this);
      break;
    case "1:1":
      this.adjustPosition_1for1();
      break;
    case "ScaleToFit":
      this.adjustPosition_ScaleToFit();
      break;
    case 'ScaleDown':
      this.adjustPosition_ScaleDown();
      break;
    case "ScaleUp":
      this.adjustPosition_ScaleUp();
      break;
  }
};
Sprite_Battleback.prototype.adjustPosition_1for1 = function () {
  const _0x342b07 = VisuMZ.BattleCore.Settings.BattlebackScale;
  if (_0x342b07 && _0x342b07.jsOneForOne) {
    return _0x342b07.jsOneForOne.call(this);
  }
  this.width = Graphics.width;
  this.height = Graphics.height;
  this.scale.x = 0x1;
  this.scale.y = 0x1;
  this.x = 0x0;
  this.y = 0x0;
};
Sprite_Battleback.prototype.adjustPosition_ScaleToFit = function () {
  const _0x5e19de = VisuMZ.BattleCore.Settings.BattlebackScale;
  if (_0x5e19de && _0x5e19de.jsScaleToFit) {
    return _0x5e19de.jsScaleToFit.call(this);
  }
  this.width = Graphics.width;
  this.height = Graphics.height;
  const _0x24a4dd = this.width / this.bitmap.width;
  const _0x220731 = this.height / this.bitmap.height;
  const _0x3fd712 = Math.max(_0x24a4dd, _0x220731);
  this.scale.x = _0x3fd712;
  this.scale.y = _0x3fd712;
  this.x = (Graphics.width - this.width) / 0x2;
  this.y = Graphics.height - this.height;
};
Sprite_Battleback.prototype.adjustPosition_ScaleDown = function () {
  const _0x8c5ea9 = VisuMZ.BattleCore.Settings.BattlebackScale;
  if (_0x8c5ea9 && _0x8c5ea9.jsScaleDown) {
    return _0x8c5ea9.jsScaleDown.call(this);
  }
  this.width = Graphics.width;
  this.height = Graphics.height;
  const _0x3f8ba5 = Math.min(0x1, this.width / this.bitmap.width);
  const _0x4e3104 = Math.min(0x1, this.height / this.bitmap.height);
  const _0x3c5e24 = Math.max(_0x3f8ba5, _0x4e3104);
  this.scale.x = _0x3c5e24;
  this.scale.y = _0x3c5e24;
  this.x = (Graphics.width - this.width) / 0x2;
  this.y = Graphics.height - this.height;
};
Sprite_Battleback.prototype.adjustPosition_ScaleUp = function () {
  const _0x602211 = VisuMZ.BattleCore.Settings.BattlebackScale;
  if (_0x602211 && _0x602211.jsScaleUp) {
    return _0x602211.jsScaleUp.call(this);
  }
  this.width = Graphics.width;
  this.height = Graphics.height;
  const _0x32f654 = Math.max(0x1, this.width / this.bitmap.width);
  const _0xf9a749 = Math.max(0x1, this.height / this.bitmap.height);
  const _0x2a4fcb = Math.max(_0x32f654, _0xf9a749);
  this.scale.x = _0x2a4fcb;
  this.scale.y = _0x2a4fcb;
  this.x = (Graphics.width - this.width) / 0x2;
  this.y = Graphics.height - this.height;
};
Spriteset_Battle.ANTI_TINT_UI = VisuMZ.BattleCore.Settings.BattleLayout.AntiTintUiElements ?? true;
Spriteset_Battle.prototype.isFlipped = function () {
  if (!$gameSystem.isSideView()) {
    return false;
  }
  return false;
};
Spriteset_Battle.prototype.animationBaseDelay = function () {
  return 0x0;
};
Spriteset_Battle.prototype.animationNextDelay = function () {
  return 0x0;
};
VisuMZ.BattleCore.Spriteset_Battle_createLowerLayer = Spriteset_Battle.prototype.createLowerLayer;
Spriteset_Battle.prototype.createLowerLayer = function () {
  VisuMZ.BattleCore.Spriteset_Battle_createLowerLayer.call(this);
  this.createWeather();
  this.createEnemyNames();
};
VisuMZ.BattleCore.Spriteset_Battle_update = Spriteset_Battle.prototype.update;
Spriteset_Battle.prototype.update = function () {
  VisuMZ.BattleCore.Spriteset_Battle_update.call(this);
  this.updateBattlerContainer();
  this.updateUiContainerPosition();
  this.updateWeather();
  this.updateBattleBalloons();
};
Spriteset_Battle.prototype.createWeather = function () {
  this._weather = new Weather();
  this._battleField.addChild(this._weather);
};
Spriteset_Battle.prototype.updateWeather = function () {
  this._weather.type = $gameScreen.weatherType();
  this._weather.power = $gameScreen.weatherPower();
};
Game_Interpreter.prototype.command236 = function (_0x56a046) {
  $gameScreen.changeWeather(_0x56a046[0x0], _0x56a046[0x1], _0x56a046[0x2]);
  if (_0x56a046[0x3]) {
    this.wait(_0x56a046[0x2]);
  }
  return true;
};
VisuMZ.BattleCore.Game_Interpreter_command283 = Game_Interpreter.prototype.command283;
Game_Interpreter.prototype.command283 = function (_0xf9a7a3) {
  return SceneManager.isSceneBattle() ? (SceneManager._scene._spriteset.changeBattlebacks(_0xf9a7a3[0x0], _0xf9a7a3[0x1]), true) : VisuMZ.BattleCore.Game_Interpreter_command283.call(this, _0xf9a7a3);
};
Spriteset_Battle.prototype.updateBattlebackBitmap = function (_0x531aae, _0x4c6cb5) {
  _0x531aae.bitmap = _0x4c6cb5;
};
Spriteset_Battle.prototype.changeBattlebacks = function (_0x2e3b5f, _0x471db4) {
  _0x2e3b5f = _0x2e3b5f || '';
  _0x471db4 = _0x471db4 || '';
  if (_0x2e3b5f === '' && _0x471db4 === '') {
    _0x2e3b5f = this._back1Sprite.battleback1Name();
    _0x471db4 = this._back2Sprite.battleback2Name();
  }
  const _0x363860 = ImageManager.loadBattleback1(_0x2e3b5f);
  const _0x48d46a = ImageManager.loadBattleback2(_0x471db4);
  _0x363860.addLoadListener(this.updateBattlebackBitmap1.bind(this, this._back1Sprite, this._back2Sprite, _0x363860, _0x48d46a));
};
Spriteset_Battle.prototype.updateBattlebackBitmap1 = function (_0x4e8b5d, _0x558c6e, _0x2184f4, _0x1d7644) {
  _0x1d7644.addLoadListener(this.updateBattlebackBitmap2.bind(this, _0x4e8b5d, _0x558c6e, _0x2184f4, _0x1d7644));
};
Spriteset_Battle.prototype.updateBattlebackBitmap2 = function (_0x49c127, _0x2174e9, _0x2f0af9, _0x1a2089) {
  _0x49c127.bitmap = _0x2f0af9;
  _0x2174e9.bitmap = _0x1a2089;
  _0x49c127.adjustPosition();
  _0x2174e9.adjustPosition();
};
VisuMZ.BattleCore.Spriteset_Battle_createBattleField = Spriteset_Battle.prototype.createBattleField;
Spriteset_Battle.prototype.createBattleField = function () {
  VisuMZ.BattleCore.Spriteset_Battle_createBattleField.call(this);
  this.createBattleFieldBattleCore();
};
Spriteset_Battle.prototype.createBattleFieldBattleCore = function () {
  this.createBattleFieldContainer();
  this.createUIContainer();
  this.createAnimationContainer();
  this.createDamageContainer();
  this.adjustFlippedBattlefield();
};
Spriteset_Battle.prototype.createBattleFieldContainer = function () {
  this._battlerContainer = new Sprite();
  this._battleField.addChild(this._battlerContainer);
};
Spriteset_Battle.prototype.createAnimationContainer = function () {
  this._animationContainer = new Sprite();
  if (Spriteset_Battle.ANTI_TINT_UI) {
    this.addChild(this._animationContainer);
  } else {
    this._battleField.addChild(this._animationContainer);
  }
};
Spriteset_Battle.prototype.createDamageContainer = function () {
  this._damageContainer = new Sprite();
  this._damageContainer.x = this._battleField.x;
  this._damageContainer.y = this._battleField.y;
  this.addChild(this._damageContainer);
};
Spriteset_Battle.prototype.adjustFlippedBattlefield = function () {
  if (!this.isFlipped()) {
    return;
  }
  this._battlerContainer.scale.x = -0x1;
  this._battlerContainer.x = this._battleField.width;
  this._uiContainer.scale.x = -0x1;
  this._uiContainer.x = this._battleField.width;
  this._animationContainer.scale.x = -0x1;
  this._animationContainer.x = this._battleField.width;
  this._damageContainer.scale.x = -0x1;
  this._damageContainer.x = this._battleField.x + this._battleField.width;
};
Spriteset_Battle.prototype.createEnemies = function () {
  if (Imported.VisuMZ_0_CoreEngine && this.coreEngineRepositionEnemies()) {
    this.repositionEnemiesByResolution();
  }
  const _0x4f5ac3 = $gameTroop.members();
  const _0x329a31 = [];
  for (const _0x324b5f of _0x4f5ac3) {
    _0x329a31.push(new Sprite_Enemy(_0x324b5f));
  }
  _0x329a31.sort(this.compareEnemySprite.bind(this));
  for (const _0x2c9ec3 of _0x329a31) {
    this._battlerContainer.addChild(_0x2c9ec3);
  }
  this._enemySprites = _0x329a31;
};
Spriteset_Battle.prototype.createActors = function () {
  this._actorSprites = [];
  for (let _0x58eaad = 0x0; _0x58eaad < $gameParty.maxBattleMembers(); _0x58eaad++) {
    const _0x4d79ed = $gameParty.battleMembers()[_0x58eaad];
    const _0x3c5b1c = new Sprite_Actor();
    _0x3c5b1c.moveToStartPositionBattleCore(_0x4d79ed);
    _0x3c5b1c.setBattler(_0x4d79ed);
    _0x3c5b1c.update();
    this._actorSprites.push(_0x3c5b1c);
    this._battlerContainer.addChild(_0x3c5b1c);
  }
};
Spriteset_Battle.prototype.createAnimationSprite = function (_0x2ab45d, _0x2a51a7, _0x457b8a, _0x2db456) {
  const _0x3559cb = this.isMVAnimation(_0x2a51a7);
  const _0x500f82 = new (_0x3559cb ? Sprite_AnimationMV : Sprite_Animation)();
  const _0x2ba3c9 = this.makeTargetSprites(_0x2ab45d);
  if (this.animationShouldMirror(_0x2ab45d[0x0])) {
    _0x457b8a = !_0x457b8a;
  }
  _0x500f82.targetObjects = _0x2ab45d;
  _0x500f82.setup(_0x2ba3c9, _0x2a51a7, _0x457b8a, _0x2db456);
  this.addAnimationSpriteToContainer(_0x500f82);
};
Spriteset_Battle.prototype.addAnimationSpriteToContainer = function (_0x1c5f3f) {
  if (this.isAnimationShownOnBattlePortrait(_0x1c5f3f)) {
    this.battleStatusWindowAnimationContainer().addChild(_0x1c5f3f);
    _0x1c5f3f.battleStatusSprite = true;
  } else {
    this._animationContainer.addChild(_0x1c5f3f);
    if (Spriteset_Battle.ANTI_TINT_UI) {
      this._animationContainer.x = this._effectsContainer.x;
      this._animationContainer.y = this._effectsContainer.y;
    }
  }
  this._animationSprites.push(_0x1c5f3f);
};
Spriteset_Battle.prototype.isAnimationShownOnBattlePortrait = function (_0x3309f2) {
  if (!_0x3309f2) {
    return false;
  }
  if (!_0x3309f2._animation) {
    return false;
  }
  if (!_0x3309f2.targetObjects[0x0]) {
    return false;
  }
  if (_0x3309f2.targetObjects[0x0].isActor && !_0x3309f2.targetObjects[0x0].isActor()) {
    return false;
  }
  if ($gameSystem.isSideView()) {
    return false;
  }
  if (!this.battleStatusWindowAnimationContainer()) {
    return false;
  }
  if (_0x3309f2.constructor === Sprite_Animation) {
    if (_0x3309f2._animation.displayType !== 0x0) {
      return false;
    }
  } else {
    if (_0x3309f2.constructor === Sprite_AnimationMV) {
      if (_0x3309f2._animation.position === 0x3) {
        return false;
      }
    }
  }
  return true;
  const _0x10561a = Window_BattleStatus.prototype.battleLayoutStyle();
  return ['xp', 'portrait'].contains(_0x10561a);
};
Spriteset_Battle.prototype.battleStatusWindowAnimationContainer = function () {
  if (!SceneManager._scene) {
    return null;
  }
  if (!SceneManager._scene._statusWindow) {
    return null;
  }
  if (!SceneManager._scene._statusWindow._effectsContainer) {
    return null;
  }
  return SceneManager._scene._statusWindow._effectsContainer;
};
Spriteset_Battle.prototype.removeAnimation = function (_0x1be3fa) {
  this.removeAnimationFromContainer(_0x1be3fa);
  for (const _0x30d104 of _0x1be3fa.targetObjects) {
    if (_0x30d104.endAnimation) {
      _0x30d104.endAnimation();
    }
  }
  _0x1be3fa.destroy();
};
Spriteset_Battle.prototype.removeAnimationFromContainer = function (_0x1af80e) {
  if (this.isAnimationShownOnBattlePortrait(_0x1af80e)) {
    this.battleStatusWindowAnimationContainer().removeChild(_0x1af80e);
  } else {
    this._animationContainer.removeChild(_0x1af80e);
  }
  this._effectsContainer.removeChild(_0x1af80e);
  this._animationContainer.removeChild(_0x1af80e);
  this._animationSprites.remove(_0x1af80e);
  if (this._fauxAnimationSprites) {
    this._fauxAnimationSprites.remove(_0x1af80e);
  }
};
VisuMZ.BattleCore.Spriteset_Battle_updateActors = Spriteset_Battle.prototype.updateActors;
Spriteset_Battle.prototype.updateActors = function () {
  VisuMZ.BattleCore.Spriteset_Battle_updateActors.call(this);
  this.updateBattlerContainer();
};
Spriteset_Battle.prototype.updateBattlerContainer = function () {
  this._battlerContainer.children.sort(this.compareBattlerSprites.bind(this));
  this.putActiveBattlerOnTop();
  if (!this._battlerContainer) {
    return;
  }
  this._battlerContainer.opacity = this.targetBattlerContainerOpacity();
};
Spriteset_Battle.prototype.compareBattlerSprites = function (_0xf80463, _0x324689) {
  if (VisuMZ.BattleCore.Settings.Actor.PrioritySortActors) {
    if (_0xf80463._battler && _0x324689._battler) {
      if (_0xf80463._battler.isActor() && _0x324689._battler.isEnemy()) {
        return 0x1;
      } else {
        if (_0x324689._battler.isActor() && _0xf80463._battler.isEnemy()) {
          return -0x1;
        }
      }
    }
  }
  return _0xf80463._baseY !== _0x324689._baseY ? _0xf80463._baseY - _0x324689._baseY : _0x324689.spriteId - _0xf80463.spriteId;
};
Spriteset_Battle.prototype.putActiveBattlerOnTop = function () {
  if (!VisuMZ.BattleCore.Settings.Actor.PrioritySortActive) {
    return;
  }
  const _0x2ceb4c = BattleManager._subject;
  if (_0x2ceb4c) {
    if (_0x2ceb4c.isActor() && !$gameSystem.isSideView()) {
      return;
    }
    if (_0x2ceb4c === BattleManager.actor()) {
      return;
    }
    const _0x263069 = _0x2ceb4c.battler();
    if (_0x263069 && _0x2ceb4c.isActor()) {
      this._battlerContainer.addChild(_0x263069);
    }
  }
};
Spriteset_Battle.prototype.processEscape = function () {
  for (const _0x3ecd62 of $gameParty.aliveMembers()) {
    if (!_0x3ecd62) {
      continue;
    }
    if (!_0x3ecd62.battler()) {
      continue;
    }
    _0x3ecd62.battler().forceEscapeSprite = true;
    _0x3ecd62.battler().retreat();
  }
};
Spriteset_Battle.prototype.createUIContainer = function () {
  this._uiContainer = new Sprite();
  if (Spriteset_Battle.ANTI_TINT_UI) {
    this.addChild(this._uiContainer);
  } else {
    this._battleField.addChild(this._uiContainer);
  }
  SceneManager._scene._uiContainer = this._uiContainer;
};
Spriteset_Battle.prototype.createEnemyNames = function () {
  if (VisuMZ.BattleCore.Settings.Enemy.NameLegacy) {
    return;
  }
  this._enemyNameContainer = new Sprite();
  BattleManager.addChildToUiContainer(this._enemyNameContainer);
  for (const _0x247397 of this._enemySprites) {
    const _0xb57235 = new Sprite_EnemyName();
    this._enemyNameContainer.addChild(_0xb57235);
    _0xb57235.linkSprite(_0x247397);
  }
};
Spriteset_Battle.prototype.updateUiContainerPosition = function () {
  if (!this._damageContainer) {
    return;
  }
  if (!this._uiContainer) {
    return;
  }
  const _0x3bf03c = Spriteset_Battle.ANTI_TINT_UI ? this._damageContainer.x : 0x0;
  const _0x52d1b2 = Spriteset_Battle.ANTI_TINT_UI ? this._damageContainer.y : 0x0;
  const _0x2adf62 = Imported.VisuMZ_3_ActSeqCamera ? this._battleField.x : 0x0;
  const _0x275a19 = Imported.VisuMZ_3_ActSeqCamera ? this._battleField.y : 0x0;
  this._uiContainer.x = _0x3bf03c + _0x2adf62;
  this._uiContainer.y = _0x52d1b2 + _0x275a19;
};
BattleManager.addChildToUiContainer = function (_0x3226b0) {
  if (!SceneManager._scene._uiContainer) {
    return;
  }
  SceneManager._scene._uiContainer.addChild(_0x3226b0);
};
BattleManager.removeChildFromUiContainer = function (_0x1e36a3) {
  if (!SceneManager._scene._uiContainer) {
    return;
  }
  SceneManager._scene._uiContainer.removeChild(_0x1e36a3);
};
Spriteset_Battle.prototype.targetBattlerContainerOpacity = function () {
  return 0xff;
};
Spriteset_Battle.prototype.isBusy = function () {
  return false;
};
Spriteset_Battle.prototype.isAnyoneFloating = function () {
  return this.battlerSprites().some(_0x5ec533 => _0x5ec533.isFloating());
};
Spriteset_Battle.prototype.isAnyoneJumping = function () {
  return this.battlerSprites().some(_0x373aa1 => _0x373aa1.isJumping());
};
Spriteset_Battle.prototype.isAnyoneGrowing = function () {
  return this.battlerSprites().some(_0x13726e => _0x13726e.isGrowing());
};
Spriteset_Battle.prototype.isAnyoneSkewing = function () {
  return this.battlerSprites().some(_0x389144 => _0x389144.isSkewing());
};
Spriteset_Battle.prototype.isAnyoneSpinning = function () {
  return this.battlerSprites().some(_0x4b10cf => _0x4b10cf.isSpinning());
};
Spriteset_Battle.prototype.isAnyoneChangingOpacity = function () {
  return this.battlerSprites().some(_0x1e99d5 => _0x1e99d5.isChangingOpacity());
};
VisuMZ.BattleCore.Window_ItemList_maxCols = Window_ItemList.prototype.maxCols;
Window_ItemList.prototype.maxCols = function () {
  return SceneManager.isSceneBattle() ? SceneManager._scene.battleLayoutStyle() === "border" ? VisuMZ.BattleCore.Settings.BattleLayout.SkillItemBorderCols : VisuMZ.BattleCore.Settings.BattleLayout.SkillItemStandardCols : VisuMZ.BattleCore.Window_ItemList_maxCols.call(this);
};
VisuMZ.BattleCore.Window_SkillList_maxCols = Window_SkillList.prototype.maxCols;
Window_SkillList.prototype.maxCols = function () {
  return SceneManager.isSceneBattle() ? SceneManager._scene.battleLayoutStyle() === "border" ? VisuMZ.BattleCore.Settings.BattleLayout.SkillItemBorderCols : VisuMZ.BattleCore.Settings.BattleLayout.SkillItemStandardCols : VisuMZ.BattleCore.Window_SkillList_maxCols.call(this);
};
VisuMZ.BattleCore.Window_Options_addGeneralOptions = Window_Options.prototype.addGeneralOptions;
Window_Options.prototype.addGeneralOptions = function () {
  VisuMZ.BattleCore.Window_Options_addGeneralOptions.call(this);
  this.addAutoBattleCommands();
  this.addShowHpGaugeCommand();
};
Window_Options.prototype.addAutoBattleCommands = function () {
  if (VisuMZ.BattleCore.Settings.AutoBattle.AddOption) {
    this.addBattleCoreAutoBattleStartupCommand();
    this.addBattleCoreAutoBattleStyleCommand();
  }
};
Window_Options.prototype.addShowHpGaugeCommand = function () {
  if (!VisuMZ.BattleCore.Settings.HpGauge.AddHpGaugeOption) {
    return;
  }
  const _0x39e04c = TextManager.visualHpGauge;
  this.addCommand(_0x39e04c, 'visualHpGauge');
};
Window_Options.prototype.addBattleCoreAutoBattleStartupCommand = function () {
  const _0x4da079 = TextManager.autoBattleStart;
  this.addCommand(_0x4da079, "autoBattleAtStart");
};
Window_Options.prototype.addBattleCoreAutoBattleStyleCommand = function () {
  const _0x4d3fae = TextManager.autoBattleStyle;
  this.addCommand(_0x4d3fae, "autoBattleUseSkills");
};
VisuMZ.BattleCore.Window_Options_statusText = Window_Options.prototype.statusText;
Window_Options.prototype.statusText = function (_0x4b8b62) {
  const _0x133633 = this.commandSymbol(_0x4b8b62);
  return _0x133633 === "autoBattleUseSkills" ? this.statusTextAutoBattleStyle() : VisuMZ.BattleCore.Window_Options_statusText.call(this, _0x4b8b62);
};
Window_Options.prototype.statusTextAutoBattleStyle = function () {
  const _0x54bbab = VisuMZ.BattleCore.Settings.AutoBattle;
  const _0x29e059 = this.getConfigValue("autoBattleUseSkills");
  return _0x29e059 ? _0x54bbab.StyleON : _0x54bbab.StyleOFF;
};
Window_ShopStatus.prototype.getItemDamageAmountLabelBattleCore = function () {
  const _0x584880 = DataManager.getDamageStyle(this._item);
  const _0x3596b4 = VisuMZ.DamageStyles[_0x584880];
  if (!_0x3596b4) {
    return this.getItemDamageAmountLabelOriginal();
  }
  const _0x1d6965 = "DamageType%1".format(this._item.damage.type);
  const _0x522154 = [null, TextManager.hp, TextManager.mp, TextManager.hp, TextManager.mp, TextManager.hp, TextManager.mp][this._item.damage.type];
  return _0x3596b4[_0x1d6965].format(_0x522154);
};
Window_ShopStatus.prototype.getItemDamageAmountTextBattleCore = function () {
  const _0x2adde6 = DataManager.getDamageStyle(this._item);
  const _0x50a7c1 = VisuMZ.DamageStyles[_0x2adde6];
  if (!_0x50a7c1) {
    return this.getItemDamageAmountTextOriginal();
  }
  return _0x50a7c1.DamageDisplay.call(this);
};
VisuMZ.BattleCore.Window_PartyCommand_initialize = Window_PartyCommand.prototype.initialize;
Window_PartyCommand.prototype.initialize = function (_0x337dc0) {
  VisuMZ.BattleCore.Window_PartyCommand_initialize.call(this, _0x337dc0);
  this.createCommandNameWindow(_0x337dc0);
};
Window_PartyCommand.prototype.createCommandNameWindow = function (_0x5bffb0) {
  const _0x589a59 = new Rectangle(0x0, 0x0, _0x5bffb0.width, _0x5bffb0.height);
  this._commandNameWindow = new Window_Base(_0x589a59);
  this._commandNameWindow.opacity = 0x0;
  this.addChild(this._commandNameWindow);
  this.updateCommandNameWindow();
};
Window_PartyCommand.prototype.callUpdateHelp = function () {
  Window_Command.prototype.callUpdateHelp.call(this);
  if (this._commandNameWindow) {
    this.updateCommandNameWindow();
  }
};
Window_PartyCommand.prototype.updateCommandNameWindow = function () {
  const _0x274094 = this._commandNameWindow;
  _0x274094.contents.clear();
  const _0x5009d2 = this.commandStyleCheck(this.index());
  if (_0x5009d2 === "icon" && this.maxItems() > 0x0) {
    const _0x3c93d4 = this.itemLineRect(this.index());
    let _0x52f5fb = this.commandName(this.index());
    _0x52f5fb = _0x52f5fb.replace(/\\I\[(\d+)\]/gi, '');
    _0x274094.resetFontSettings();
    this.commandNameWindowDrawBackground(_0x52f5fb, _0x3c93d4);
    this.commandNameWindowDrawText(_0x52f5fb, _0x3c93d4);
    this.commandNameWindowCenter(_0x52f5fb, _0x3c93d4);
  }
};
Window_PartyCommand.prototype.commandNameWindowDrawBackground = function (_0x6a01e1, _0x19182e) {};
Window_PartyCommand.prototype.commandNameWindowDrawText = function (_0x52c75d, _0xfd40fb) {
  const _0x37968d = this._commandNameWindow;
  _0x37968d.drawText(_0x52c75d, 0x0, _0xfd40fb.y, _0x37968d.innerWidth, "center");
};
Window_PartyCommand.prototype.commandNameWindowCenter = function (_0x59f8dc, _0x5a73d5) {
  const _0x6014b7 = this._commandNameWindow;
  const _0x5d1c35 = $gameSystem.windowPadding();
  const _0x58eebe = _0x5a73d5.x + Math.floor(_0x5a73d5.width / 0x2) + _0x5d1c35;
  _0x6014b7.x = _0x6014b7.width / -0x2 + _0x58eebe;
  _0x6014b7.y = Math.floor(_0x5a73d5.height / 0x2);
};
Window_PartyCommand.prototype.makeCommandList = function () {
  this.addFightCommand();
  this.addAutoBattleCommand();
  this.addCustomCommands();
  this.addOptionsCommand();
  this.addEscapeCommand();
};
Window_PartyCommand.prototype.addFightCommand = function () {
  const _0x2211d3 = this.commandStyle();
  const _0x2f5dbd = VisuMZ.BattleCore.Settings.PartyCmd.CmdIconFight;
  const _0x1cfe01 = _0x2211d3 === "text" ? TextManager.fight : "\\I[%1]%2".format(_0x2f5dbd, TextManager.fight);
  const _0x28aa8e = this.isFightCommandEnabled();
  this.addCommand(_0x1cfe01, "fight", _0x28aa8e);
};
Window_PartyCommand.prototype.isFightCommandEnabled = function () {
  return true;
};
Window_PartyCommand.prototype.addAutoBattleCommand = function () {
  if (!this.isAutoBattleCommandAdded()) {
    return;
  }
  const _0x19742c = this.commandStyle();
  const _0x4fe1db = VisuMZ.BattleCore.Settings.PartyCmd.CmdIconAutoBattle;
  const _0x47cd97 = _0x19742c === "text" ? TextManager.autoBattle : "\\I[%1]%2".format(_0x4fe1db, TextManager.autoBattle);
  const _0x5ef4d4 = this.isAutoBattleCommandEnabled();
  this.addCommand(_0x47cd97, 'autoBattle', _0x5ef4d4);
};
Window_PartyCommand.prototype.isAutoBattleCommandAdded = function () {
  return VisuMZ.BattleCore.Settings.PartyCmd.CommandAddAutoBattle;
};
Window_PartyCommand.prototype.isAutoBattleCommandEnabled = function () {
  return true;
};
Window_PartyCommand.prototype.addCustomCommands = function () {};
Window_PartyCommand.prototype.addOptionsCommand = function () {
  if (!this.isOptionsCommandAdded()) {
    return;
  }
  const _0x44a514 = this.commandStyle();
  const _0x4de27e = VisuMZ.BattleCore.Settings.PartyCmd.CmdIconOptions;
  const _0x236ad3 = _0x44a514 === "text" ? TextManager.options : "\\I[%1]%2".format(_0x4de27e, TextManager.options);
  const _0x18716b = this.isOptionsCommandEnabled();
  this.addCommand(_0x236ad3, "options", _0x18716b);
};
Window_PartyCommand.prototype.isOptionsCommandAdded = function () {
  return VisuMZ.BattleCore.Settings.PartyCmd.CommandAddOptions;
};
Window_PartyCommand.prototype.isOptionsCommandEnabled = function () {
  return true;
};
Window_PartyCommand.prototype.addEscapeCommand = function () {
  const _0x413557 = this.commandStyle();
  const _0x594f5d = VisuMZ.BattleCore.Settings.PartyCmd.CmdIconEscape;
  const _0x25474e = _0x413557 === "text" ? TextManager.escape : "\\I[%1]%2".format(_0x594f5d, TextManager.escape);
  const _0x365cd1 = this.isEscapeCommandEnabled();
  this.addCommand(_0x25474e, "escape", _0x365cd1);
};
Window_PartyCommand.prototype.isEscapeCommandEnabled = function () {
  return BattleManager.canEscape();
};
Window_PartyCommand.prototype.itemTextAlign = function () {
  return VisuMZ.BattleCore.Settings.PartyCmd.CmdTextAlign;
};
Window_PartyCommand.prototype.drawItem = function (_0x13102c) {
  const _0xb50db2 = this.commandStyleCheck(_0x13102c);
  if (_0xb50db2 === "iconText") {
    this.drawItemStyleIconText(_0x13102c);
  } else if (_0xb50db2 === 'icon') {
    this.drawItemStyleIcon(_0x13102c);
  } else {
    Window_Command.prototype.drawItem.call(this, _0x13102c);
  }
};
Window_PartyCommand.prototype.commandStyle = function () {
  return VisuMZ.BattleCore.Settings.PartyCmd.CmdStyle;
};
Window_PartyCommand.prototype.commandStyleCheck = function (_0x4739ee) {
  if (_0x4739ee < 0x0) {
    return "text";
  }
  const _0x159fe6 = this.commandStyle();
  if (_0x159fe6 !== "auto") {
    return _0x159fe6;
  } else {
    if (this.maxItems() > 0x0) {
      const _0x132eda = this.commandName(_0x4739ee);
      if (_0x132eda.match(/\\I\[(\d+)\]/i)) {
        const _0x5f0fe7 = this.itemLineRect(_0x4739ee);
        const _0x179424 = this.textSizeEx(_0x132eda).width;
        return _0x179424 <= _0x5f0fe7.width ? "iconText" : 'icon';
      }
    }
  }
  return "text";
};
Window_PartyCommand.prototype.drawItemStyleIconText = function (_0xf92226) {
  const _0x59b77c = this.itemLineRect(_0xf92226);
  const _0x1b1138 = this.commandName(_0xf92226);
  const _0xfd1d63 = this.textSizeEx(_0x1b1138).width;
  this.changePaintOpacity(this.isCommandEnabled(_0xf92226));
  const _0x375f8c = this.itemTextAlign();
  if (_0x375f8c === "right") {
    this.drawTextEx(_0x1b1138, _0x59b77c.x + _0x59b77c.width - _0xfd1d63, _0x59b77c.y, _0xfd1d63);
  } else {
    if (_0x375f8c === "center") {
      const _0x253bc2 = _0x59b77c.x + Math.floor((_0x59b77c.width - _0xfd1d63) / 0x2);
      this.drawTextEx(_0x1b1138, _0x253bc2, _0x59b77c.y, _0xfd1d63);
    } else {
      this.drawTextEx(_0x1b1138, _0x59b77c.x, _0x59b77c.y, _0xfd1d63);
    }
  }
};
Window_PartyCommand.prototype.drawItemStyleIcon = function (_0x33a537) {
  this.commandName(_0x33a537).match(/\\I\[(\d+)\]/i);
  const _0x950fb9 = Number(RegExp.$1) || 0x0;
  const _0x4f37e2 = this.itemLineRect(_0x33a537);
  const _0x1abd5f = _0x4f37e2.x + Math.floor((_0x4f37e2.width - ImageManager.iconWidth) / 0x2);
  const _0x2ab248 = _0x4f37e2.y + (_0x4f37e2.height - ImageManager.iconHeight) / 0x2;
  this.drawIcon(_0x950fb9, _0x1abd5f, _0x2ab248);
};
Window_PartyCommand.prototype.hide = function () {};
Window_PartyCommand.prototype.activate = function () {
  Window_Command.prototype.activate.call(this);
  const _0xe8cf39 = this.battleLayoutStyle();
  if (_0xe8cf39 === "border") {
    this.showHelpWindow();
  }
};
Window_PartyCommand.prototype.battleLayoutStyle = function () {
  if (this._battleLayoutStyle) {
    return this._battleLayoutStyle;
  }
  this._battleLayoutStyle = SceneManager._scene.battleLayoutStyle();
  return this._battleLayoutStyle;
};
Window_PartyCommand.prototype.updateHelp = function () {
  const _0x2e59bd = VisuMZ.BattleCore.Settings.PartyCmd;
  const _0x4699d7 = this.currentSymbol();
  switch (_0x4699d7) {
    case 'fight':
      this._helpWindow.setText(_0x2e59bd.HelpFight);
      break;
    case "autoBattle":
      this._helpWindow.setText(_0x2e59bd.HelpAutoBattle);
      break;
    case "options":
      this._helpWindow.setText(_0x2e59bd.HelpOptions);
      break;
    case "escape":
      this._helpWindow.setText(_0x2e59bd.HelpEscape);
      break;
    default:
      this._helpWindow.setText('');
      break;
  }
};
VisuMZ.BattleCore.Window_ActorCommand_initialize = Window_ActorCommand.prototype.initialize;
Window_ActorCommand.prototype.initialize = function (_0x4d3f16) {
  VisuMZ.BattleCore.Window_ActorCommand_initialize.call(this, _0x4d3f16);
  this.createCommandNameWindow(_0x4d3f16);
};
Window_ActorCommand.prototype.createCommandNameWindow = function (_0x41905c) {
  const _0x385ab0 = new Rectangle(0x0, 0x0, _0x41905c.width, _0x41905c.height);
  this._commandNameWindow = new Window_Base(_0x385ab0);
  this._commandNameWindow.opacity = 0x0;
  this.addChild(this._commandNameWindow);
  this.updateCommandNameWindow();
};
Window_ActorCommand.prototype.callUpdateHelp = function () {
  Window_Command.prototype.callUpdateHelp.call(this);
  if (this._commandNameWindow) {
    this.updateCommandNameWindow();
  }
};
Window_ActorCommand.prototype.updateCommandNameWindow = function () {
  const _0x339c93 = this._commandNameWindow;
  _0x339c93.contents.clear();
  const _0x4e1855 = this.commandStyleCheck(this.index());
  if (_0x4e1855 === "icon" && this.maxItems() > 0x0) {
    const _0x189da2 = this.itemLineRect(this.index());
    let _0x423b29 = this.commandName(this.index());
    _0x423b29 = _0x423b29.replace(/\\I\[(\d+)\]/gi, '');
    _0x339c93.resetFontSettings();
    this.commandNameWindowDrawBackground(_0x423b29, _0x189da2);
    this.commandNameWindowDrawText(_0x423b29, _0x189da2);
    this.commandNameWindowCenter(_0x423b29, _0x189da2);
  }
};
Window_ActorCommand.prototype.commandNameWindowDrawBackground = function (_0x1f8ced, _0x1505cd) {};
Window_ActorCommand.prototype.commandNameWindowDrawText = function (_0x22d9cd, _0x49b995) {
  const _0x3d6c66 = this._commandNameWindow;
  _0x3d6c66.drawText(_0x22d9cd, 0x0, _0x49b995.y, _0x3d6c66.innerWidth, 'center');
};
Window_ActorCommand.prototype.commandNameWindowCenter = function (_0xc46174, _0x375678) {
  const _0x3f3d63 = this._commandNameWindow;
  const _0x11d8d5 = $gameSystem.windowPadding();
  const _0x5ecfbc = _0x375678.x + Math.floor(_0x375678.width / 0x2) + _0x11d8d5;
  _0x3f3d63.x = _0x3f3d63.width / -0x2 + _0x5ecfbc;
  _0x3f3d63.y = Math.floor(_0x375678.height / 0x2);
};
Window_ActorCommand.prototype.makeCommandList = function () {
  if (!this._actor) {
    return;
  }
  const _0x33bdbf = this._actor.battleCommands();
  for (const _0x1f1d4a of _0x33bdbf) {
    this.makeBattleCommand(_0x1f1d4a.toUpperCase().trim());
  }
};
Window_ActorCommand.prototype.makeBattleCommand = function (_0x544c75) {
  if (_0x544c75 === "ATTACK") {
    this.addAttackCommand();
  }
  if (["STYPES", "SKILLS"].includes(_0x544c75)) {
    this.addSkillCommands();
  }
  if (_0x544c75 === "GUARD") {
    this.addGuardCommand();
  }
  if (_0x544c75 === "ITEM") {
    this.addItemCommand();
  }
  if (_0x544c75 === 'ESCAPE') {
    this.addEscapeCommand();
  }
  if (_0x544c75 === "AUTO BATTLE") {
    this.addAutoBattleCommand();
  }
  if (_0x544c75.match(/STYPE: (\d+)/i)) {
    const _0x2dfa1e = Number(RegExp.$1);
    this.addSkillTypeCommand(_0x2dfa1e);
  } else {
    if (_0x544c75.match(/STYPE: (.*)/i)) {
      const _0x35a7fa = DataManager.getStypeIdWithName(RegExp.$1);
      this.addSkillTypeCommand(_0x35a7fa);
    }
  }
  if (_0x544c75 === "ALL SKILLS") {
    this.addSingleSkillCommands();
  }
  if (_0x544c75.match(/SKILL: (\d+)/i)) {
    const _0x2cd970 = Number(RegExp.$1);
    this.addSingleSkillCommand($dataSkills[_0x2cd970]);
  } else {
    if (_0x544c75.match(/SKILL: (.*)/i)) {
      const _0x20a27f = DataManager.getSkillIdWithName(RegExp.$1);
      this.addSingleSkillCommand($dataSkills[_0x20a27f]);
    }
  }
  if (_0x544c75 === "PARTY" && Imported.VisuMZ_2_PartySystem) {
    this.addPartyCommand();
  }
  if (["COMBATLOG", "COMBAT LOG"].includes(_0x544c75) && Imported.VisuMZ_4_CombatLog) {
    this.addCombatLogCommand();
  }
  if (_0x544c75 === "WEAPON SWAP" && Imported.VisuMZ_2_WeaponSwapSystem) {
    this.addWeaponSwapCommand(true);
  }
  if (_0x544c75 === "GRID MOVE" && Imported.VisuMZ_2_BattleGridSystem) {
    this.addBattleGridMoveCommand();
  }
};
Window_ActorCommand.prototype.addAttackCommand = function () {
  const _0x38f3af = $dataSkills[this._actor.attackSkillId()];
  if (!_0x38f3af) {
    return;
  }
  if (!this.canAddSkillCommand(_0x38f3af)) {
    return;
  }
  const _0x4d9499 = this.commandStyle();
  const _0x2a202e = DataManager.battleCommandName(_0x38f3af);
  const _0x29d618 = DataManager.battleCommandIcon(_0x38f3af);
  const _0x14a7e3 = _0x4d9499 === 'text' ? _0x2a202e : "\\I[%1]%2".format(_0x29d618, _0x2a202e);
  this.addCommand(_0x14a7e3, "attack", this._actor.canAttack());
};
Window_ActorCommand.prototype.addGuardCommand = function () {
  const _0x5b23dd = $dataSkills[this._actor.guardSkillId()];
  if (!_0x5b23dd) {
    return;
  }
  if (!this.canAddSkillCommand(_0x5b23dd)) {
    return;
  }
  const _0x508ffc = this.commandStyle();
  const _0x1872ae = DataManager.battleCommandName(_0x5b23dd);
  const _0x511a2d = DataManager.battleCommandIcon(_0x5b23dd);
  const _0x699260 = _0x508ffc === "text" ? _0x1872ae : "\\I[%1]%2".format(_0x511a2d, _0x1872ae);
  this.addCommand(_0x699260, "guard", this._actor.canGuard());
};
Window_ActorCommand.prototype.addItemCommand = function () {
  const _0x478e85 = this.commandStyle();
  const _0x479df9 = VisuMZ.BattleCore.Settings.ActorCmd.CmdIconItem;
  const _0x5072bf = _0x478e85 === "text" ? TextManager.item : "\\I[%1]%2".format(_0x479df9, TextManager.item);
  const _0x5da8b7 = this.isItemCommandEnabled();
  this.addCommand(_0x5072bf, 'item', _0x5da8b7);
};
Window_ActorCommand.prototype.isItemCommandEnabled = function () {
  return this._actor && this._actor.canUseItemCommand();
};
Window_ActorCommand.prototype.addSkillCommands = function () {
  const _0x1910c7 = this._actor.skillTypes();
  for (const _0x27bb77 of _0x1910c7) {
    this.addSkillTypeCommand(_0x27bb77);
  }
};
Window_ActorCommand.prototype.addSkillTypeCommand = function (_0x3072da) {
  let _0x578145 = $dataSystem.skillTypes[_0x3072da];
  if (!_0x578145) {
    return;
  }
  let _0x539a0c = _0x578145;
  const _0x1e31a2 = this.commandStyle();
  if (_0x1e31a2 === "text") {
    _0x539a0c = _0x539a0c.replace(/\x1I\[(\d+)\]/gi, '');
    _0x539a0c = _0x539a0c.replace(/\\I\[(\d+)\]/gi, '');
  } else {
    if (!_0x578145.match(/\\I\[(\d+)\]/i)) {
      const _0x2b3b2d = Imported.VisuMZ_1_SkillsStatesCore ? VisuMZ.SkillsStatesCore.Settings.Skills : VisuMZ.BattleCore.Settings.ActorCmd;
      const _0x1a0d76 = $dataSystem.magicSkills.includes(_0x3072da);
      const _0x38c5a4 = _0x1a0d76 ? _0x2b3b2d.IconStypeMagic : _0x2b3b2d.IconStypeNorm;
      _0x539a0c = "\\I[%1]%2".format(_0x38c5a4, _0x578145);
    }
  }
  this.addCommand(_0x539a0c, "skill", true, _0x3072da);
};
Window_ActorCommand.prototype.addSingleSkillCommands = function () {
  const _0x33a41f = this._actor.skillTypes();
  const _0xc44d78 = this._actor.skills();
  for (const _0x1cf383 of _0xc44d78) {
    if (!_0x1cf383) {
      continue;
    }
    if (Imported.VisuMZ_1_SkillsStatesCore) {
      if (this.noSimilarSTypes(_0x1cf383)) {
        continue;
      }
      if (this.isHiddenSkill(_0x1cf383)) {
        continue;
      }
    } else {
      if (!_0x33a41f.includes(_0x1cf383.stypeId)) {
        continue;
      }
    }
    this.addSingleSkillCommand(_0x1cf383);
  }
};
Window_ActorCommand.prototype.noSimilarSTypes = function (_0x264e7d) {
  const _0x4ec8a9 = this._actor.skillTypes();
  const _0x335694 = _0x4ec8a9.filter(_0x2361b0 => DataManager.getSkillTypes(_0x264e7d).includes(_0x2361b0));
  return _0x335694.length <= 0x0;
};
Window_ActorCommand.prototype.isHiddenSkill = function (_0x33b7f5) {
  if (Imported.VisuMZ_1_SkillsStatesCore) {
    if (VisuMZ.SkillsStatesCore.version >= 1.24) {
      if (this._actor) {
        if (!VisuMZ.SkillsStatesCore.CheckVisibleBattleNotetags(this._actor, _0x33b7f5)) {
          return true;
        }
        if (!VisuMZ.SkillsStatesCore.CheckVisibleSwitchNotetags(this._actor, _0x33b7f5)) {
          return true;
        }
        if (!VisuMZ.SkillsStatesCore.CheckVisibleSkillNotetags(this._actor, _0x33b7f5)) {
          return true;
        }
      }
    } else {
      if (!Window_SkillList.prototype.checkShowHideBattleNotetags.call(this, _0x33b7f5)) {
        return true;
      }
      if (!Window_SkillList.prototype.checkShowHideSwitchNotetags.call(this, _0x33b7f5)) {
        return true;
      }
      if (!Window_SkillList.prototype.checkShowHideSkillNotetags.call(this, _0x33b7f5)) {
        return true;
      }
    }
  }
  return false;
};
Window_ActorCommand.prototype.addSingleSkillCommand = function (_0x599cb9) {
  if (!_0x599cb9) {
    return;
  }
  if (!this.canAddSkillCommand(_0x599cb9)) {
    return;
  }
  const _0x1d142d = this.commandStyle();
  const _0x237a2b = DataManager.battleCommandName(_0x599cb9);
  const _0x407d5b = DataManager.battleCommandIcon(_0x599cb9);
  const _0x19b996 = _0x1d142d === "text" ? _0x237a2b : "\\I[%1]%2".format(_0x407d5b, _0x237a2b);
  const _0x953421 = this._actor.canUse(_0x599cb9);
  this.addCommand(_0x19b996, "singleSkill", _0x953421, _0x599cb9.id);
};
Window_ActorCommand.prototype.canAddSkillCommand = function (_0x882818) {
  const _0x2c84e5 = _0x882818.note;
  if (_0x2c84e5.match(/<COMMAND REQUIRE LEARN>/i)) {
    if (!this._actor.isLearnedSkill(_0x882818.id)) {
      return false;
    }
  }
  if (_0x2c84e5.match(/<COMMAND REQUIRE ACCESS>/i)) {
    if (!this._actor.hasSkill(_0x882818.id)) {
      return false;
    }
  }
  const _0x33c420 = VisuMZ.BattleCore.createKeyJS(_0x882818, "CommandVisible");
  if (VisuMZ.BattleCore.JS[_0x33c420]) {
    if (!VisuMZ.BattleCore.JS[_0x33c420].call(this, this._actor, _0x882818)) {
      return false;
    }
  }
  return VisuMZ.BattleCore.CheckSkillCommandShowSwitches(_0x882818);
};
VisuMZ.BattleCore.CheckSkillCommandShowSwitches = function (_0x12f605) {
  const _0x2cf308 = _0x12f605.note;
  if (_0x2cf308.match(/<COMMAND SHOW[ ](?:SW|SWITCH|SWITCHES):[ ]*(\d+(?:\s*,\s*\d+)*)>/i)) {
    const _0x4548c6 = JSON.parse('[' + RegExp.$1.match(/\d+/g) + ']');
    for (const _0x2fb9a2 of _0x4548c6) {
      if (!$gameSwitches.value(_0x2fb9a2)) {
        return false;
      }
    }
    return true;
  }
  if (_0x2cf308.match(/<COMMAND SHOW ALL[ ](?:SW|SWITCH|SWITCHES):[ ]*(\d+(?:\s*,\s*\d+)*)>/i)) {
    const _0x3160d9 = JSON.parse('[' + RegExp.$1.match(/\d+/g) + ']');
    for (const _0x417ce4 of _0x3160d9) {
      if (!$gameSwitches.value(_0x417ce4)) {
        return false;
      }
    }
    return true;
  }
  if (_0x2cf308.match(/<COMMAND SHOW ANY[ ](?:SW|SWITCH|SWITCHES):[ ]*(\d+(?:\s*,\s*\d+)*)>/i)) {
    const _0x236556 = JSON.parse('[' + RegExp.$1.match(/\d+/g) + ']');
    for (const _0x1d45fa of _0x236556) {
      if ($gameSwitches.value(_0x1d45fa)) {
        return true;
      }
    }
    return false;
  }
  if (_0x2cf308.match(/<COMMAND HIDE[ ](?:SW|SWITCH|SWITCHES):[ ]*(\d+(?:\s*,\s*\d+)*)>/i)) {
    const _0x2a458a = JSON.parse('[' + RegExp.$1.match(/\d+/g) + ']');
    for (const _0x1e3e01 of _0x2a458a) {
      if (!$gameSwitches.value(_0x1e3e01)) {
        return true;
      }
    }
    return false;
  }
  if (_0x2cf308.match(/<COMMAND HIDE ALL[ ](?:SW|SWITCH|SWITCHES):[ ]*(\d+(?:\s*,\s*\d+)*)>/i)) {
    const _0x1abde7 = JSON.parse('[' + RegExp.$1.match(/\d+/g) + ']');
    for (const _0x3b717a of _0x1abde7) {
      if (!$gameSwitches.value(_0x3b717a)) {
        return true;
      }
    }
    return false;
  }
  if (_0x2cf308.match(/<COMMAND HIDE ANY[ ](?:SW|SWITCH|SWITCHES):[ ]*(\d+(?:\s*,\s*\d+)*)>/i)) {
    const _0x91ff = JSON.parse('[' + RegExp.$1.match(/\d+/g) + ']');
    for (const _0x1d7643 of _0x91ff) {
      if ($gameSwitches.value(_0x1d7643)) {
        return false;
      }
    }
    return true;
  }
  return true;
};
Window_ActorCommand.prototype.addEscapeCommand = function () {
  const _0x2016da = this.commandStyle();
  const _0x5eb4c0 = VisuMZ.BattleCore.Settings.PartyCmd.CmdIconEscape;
  const _0x5e36fd = _0x2016da === 'text' ? TextManager.escape : "\\I[%1]%2".format(_0x5eb4c0, TextManager.escape);
  const _0x29257e = this.isEscapeCommandEnabled();
  this.addCommand(_0x5e36fd, "escape", _0x29257e);
};
Window_ActorCommand.prototype.isEscapeCommandEnabled = function () {
  return BattleManager.canEscape();
};
Window_ActorCommand.prototype.addAutoBattleCommand = function () {
  const _0x3d4e62 = this.commandStyle();
  const _0x3e4285 = VisuMZ.BattleCore.Settings.PartyCmd.CmdIconAutoBattle;
  const _0x28247b = _0x3d4e62 === "text" ? TextManager.autoBattle : "\\I[%1]%2".format(_0x3e4285, TextManager.autoBattle);
  const _0x1be54a = this.isAutoBattleCommandEnabled();
  this.addCommand(_0x28247b, "autoBattle", _0x1be54a);
};
Window_ActorCommand.prototype.isAutoBattleCommandEnabled = function () {
  return true;
};
Window_ActorCommand.prototype.itemTextAlign = function () {
  return VisuMZ.BattleCore.Settings.ActorCmd.CmdTextAlign;
};
Window_ActorCommand.prototype.drawItem = function (_0xaca5eb) {
  const _0x3de316 = this.commandStyleCheck(_0xaca5eb);
  if (_0x3de316 === "iconText") {
    this.drawItemStyleIconText(_0xaca5eb);
  } else if (_0x3de316 === "icon") {
    this.drawItemStyleIcon(_0xaca5eb);
  } else {
    Window_Command.prototype.drawItem.call(this, _0xaca5eb);
  }
  this.drawSingleSkillCost(_0xaca5eb);
};
Window_ActorCommand.prototype.commandStyle = function () {
  return VisuMZ.BattleCore.Settings.ActorCmd.CmdStyle;
};
Window_ActorCommand.prototype.commandStyleCheck = function (_0x5d5160) {
  if (_0x5d5160 < 0x0) {
    return "text";
  }
  const _0xbb9696 = this.commandStyle();
  if (_0xbb9696 !== "auto") {
    return _0xbb9696;
  } else {
    if (this.maxItems() > 0x0) {
      const _0x1bae15 = this.commandName(_0x5d5160);
      if (_0x1bae15.match(/\\I\[(\d+)\]/i)) {
        const _0x4dfa3b = this.itemLineRect(_0x5d5160);
        const _0x57ef05 = this.textSizeEx(_0x1bae15).width;
        return _0x57ef05 <= _0x4dfa3b.width ? "iconText" : "icon";
      }
    }
  }
  return "text";
};
Window_ActorCommand.prototype.drawItemStyleIconText = function (_0x114fc0) {
  const _0x4c2664 = this.itemLineRect(_0x114fc0);
  const _0x393b94 = this.commandName(_0x114fc0);
  const _0xb813f2 = this.textSizeEx(_0x393b94).width;
  this.changePaintOpacity(this.isCommandEnabled(_0x114fc0));
  const _0x1dd8ae = this.itemTextAlign();
  if (_0x1dd8ae === "right") {
    this.drawTextEx(_0x393b94, _0x4c2664.x + _0x4c2664.width - _0xb813f2, _0x4c2664.y, _0xb813f2);
  } else {
    if (_0x1dd8ae === "center") {
      const _0x3d9bb2 = _0x4c2664.x + Math.floor((_0x4c2664.width - _0xb813f2) / 0x2);
      this.drawTextEx(_0x393b94, _0x3d9bb2, _0x4c2664.y, _0xb813f2);
    } else {
      this.drawTextEx(_0x393b94, _0x4c2664.x, _0x4c2664.y, _0xb813f2);
    }
  }
};
Window_ActorCommand.prototype.drawItemStyleIcon = function (_0x4038ec) {
  this.commandName(_0x4038ec).match(/\\I\[(\d+)\]/i);
  const _0x6cf721 = Number(RegExp.$1) || 0x0;
  const _0x2da492 = this.itemLineRect(_0x4038ec);
  const _0x1555fb = _0x2da492.x + Math.floor((_0x2da492.width - ImageManager.iconWidth) / 0x2);
  const _0x27402e = _0x2da492.y + (_0x2da492.height - ImageManager.iconHeight) / 0x2;
  this.drawIcon(_0x6cf721, _0x1555fb, _0x27402e);
};
Window_ActorCommand.prototype.drawSingleSkillCost = function (_0x1fdd7f) {
  if (!(VisuMZ.BattleCore.Settings.ActorCmd.ShowCosts ?? true)) {
    return;
  }
  const _0x5d660f = this.commandSymbol(_0x1fdd7f);
  if (!['attack', "guard", "singleSkill"].includes(_0x5d660f)) {
    return;
  }
  const _0x13182e = this.itemLineRect(_0x1fdd7f);
  let _0x391e51 = null;
  if (_0x5d660f === "attack") {
    _0x391e51 = $dataSkills[this._actor.attackSkillId()];
  } else if (_0x5d660f === "guard") {
    _0x391e51 = $dataSkills[this._actor.guardSkillId()];
  } else {
    _0x391e51 = $dataSkills[this._list[_0x1fdd7f].ext];
  }
  this.drawSkillCost(this._actor, _0x391e51, _0x13182e.x, _0x13182e.y, _0x13182e.width);
};
Window_ActorCommand.prototype.drawSkillCost = function (_0xbd5284, _0x3dc8f2, _0x689087, _0x466602, _0x49b223) {
  if (!_0x3dc8f2) {
    return;
  }
  if (Imported.VisuMZ_1_SkillsStatesCore) {
    Window_Command.prototype.drawSkillCost.call(this, _0xbd5284, _0x3dc8f2, _0x689087, _0x466602, _0x49b223);
  } else {
    Window_SkillList.prototype.drawSkillCost.call(this, _0x3dc8f2, _0x689087, _0x466602, _0x49b223);
  }
};
Window_ActorCommand.prototype.hide = function () {};
Window_ActorCommand.prototype.activate = function () {
  Window_Command.prototype.activate.call(this);
  const _0x3e2ef8 = this.battleLayoutStyle();
  if (_0x3e2ef8 === "border") {
    this.showHelpWindow();
  }
};
Window_ActorCommand.prototype.battleLayoutStyle = function () {
  if (this._battleLayoutStyle) {
    return this._battleLayoutStyle;
  }
  this._battleLayoutStyle = SceneManager._scene.battleLayoutStyle();
  return this._battleLayoutStyle;
};
VisuMZ.BattleCore.Window_ActorCommand_setup = Window_ActorCommand.prototype.setup;
Window_ActorCommand.prototype.setup = function (_0x92a461) {
  const _0x5c76cb = this.battleLayoutStyle();
  if (_0x92a461 && ['xp', "portrait"].includes(_0x5c76cb)) {
    this.resizeWindowXPStyle(_0x92a461);
  } else if (_0x92a461 && ["border"].includes(_0x5c76cb)) {
    this.resizeWindowBorderStyle(_0x92a461);
    this.showHelpWindow();
  }
  VisuMZ.BattleCore.Window_ActorCommand_setup.call(this, _0x92a461);
  if (_0x92a461 && $gameTroop.aliveMembers().length > 0x0 && _0x92a461.battler()) {
    _0x92a461.battler().stepForward();
  }
};
Window_ActorCommand.prototype.resizeWindowXPStyle = function (_0x3ca086) {
  const _0x196433 = VisuMZ.BattleCore.Settings.BattleLayout.CommandWidth;
  const _0x3057d5 = Math.round(Graphics.boxWidth / 0x3);
  const _0x27e69a = Math.round(Graphics.boxWidth / $gameParty.battleMembers().length);
  const _0x1eb014 = Math.max(Math.min(_0x3057d5, _0x27e69a), _0x196433);
  const _0x5bbf68 = this.fittingHeight(VisuMZ.BattleCore.Settings.BattleLayout.XPActorCommandLines);
  const _0x175baa = Math.floor((Graphics.boxWidth - Graphics.width) / 0x2);
  const _0x3e8594 = Graphics.boxWidth - _0x175baa;
  const _0xf61f3b = (Math.round(_0x27e69a * _0x3ca086.index()) + Math.round((_0x27e69a - _0x1eb014) / 0x2)).clamp(_0x175baa, _0x3e8594 - _0x1eb014);
  const _0x1c86de = Math.round(SceneManager._scene._statusWindow.y - _0x5bbf68);
  this.move(_0xf61f3b, _0x1c86de, _0x1eb014, _0x5bbf68);
  this.createContents();
  this.setBackgroundType(0x1);
};
Window_ActorCommand.prototype.resizeWindowBorderStyle = function (_0x302af6) {
  const _0x15d416 = SceneManager._scene.partyCommandWindowRectBorderStyle();
  this.move(_0x15d416.x, _0x15d416.y, _0x15d416.width, _0x15d416.height);
  this.createContents();
  this.setBackgroundType(0x0);
};
Window_ActorCommand.prototype.refreshDimmerBitmap = function () {
  if (this._dimmerSprite) {
    const _0x57e4a2 = this._dimmerSprite.bitmap;
    const _0x37c18a = this.width - 0x8;
    const _0x2bb2d6 = this.height;
    const _0x2d4fbd = this.padding;
    const _0x5786c0 = ColorManager.dimColor1();
    const _0x3d17da = ColorManager.dimColor2();
    this._dimmerSprite.x = 0x4;
    _0x57e4a2.resize(_0x37c18a, _0x2bb2d6);
    _0x57e4a2.gradientFillRect(0x0, 0x0, _0x37c18a, _0x2d4fbd, _0x3d17da, _0x5786c0, true);
    _0x57e4a2.fillRect(0x0, _0x2d4fbd, _0x37c18a, _0x2bb2d6 - _0x2d4fbd * 0x2, _0x5786c0);
    _0x57e4a2.gradientFillRect(0x0, _0x2bb2d6 - _0x2d4fbd, _0x37c18a, _0x2d4fbd, _0x5786c0, _0x3d17da, true);
    this._dimmerSprite.setFrame(0x0, 0x0, _0x37c18a, _0x2bb2d6);
  }
};
Window_ActorCommand.prototype.updateHelp = function () {
  if (!this._actor) {
    return;
  }
  const _0x715134 = VisuMZ.BattleCore.Settings.ActorCmd;
  const _0x50ffe5 = this.currentSymbol();
  switch (_0x50ffe5) {
    case 'attack':
      this.setHelpWindowItem($dataSkills[this._actor.attackSkillId()]);
      break;
    case "guard":
      this.setHelpWindowItem($dataSkills[this._actor.guardSkillId()]);
      break;
    case "skill":
      const _0x1b768b = _0x715134.HelpSkillType;
      const _0x3b690a = _0x1b768b.format($dataSystem.skillTypes[this.currentExt()]);
      this._helpWindow.setText(_0x3b690a);
      break;
    case "singleSkill":
      this.setHelpWindowItem($dataSkills[this.currentExt()]);
      break;
    case "item":
      this._helpWindow.setText(_0x715134.HelpItem);
      break;
    case "escape":
      this._helpWindow.setText(_0x715134.HelpEscape);
      break;
    case "autoBattle":
      this._helpWindow.setText(_0x715134.HelpAutoBattle);
      break;
    default:
      this._helpWindow.setText('');
      break;
  }
};
Window_ActorCommand.prototype.selectLast = function () {
  this.forceSelect(0x0);
  if (this._actor && ConfigManager.commandRemember) {
    const _0x418931 = this._actor.lastCommandSymbol();
    this.selectSymbol(_0x418931);
    if (_0x418931 === "skill") {
      const _0xd0e640 = this._actor.lastBattleSkill();
      if (_0xd0e640) {
        const _0xbbb786 = this.findSymbolExt("skill", _0xd0e640.stypeId);
        this.select(_0xbbb786 || 0x0);
      }
    } else {
      if (_0x418931 === "singleSkill") {
        const _0x50d390 = this._actor.lastBattleSkill();
        if (_0x50d390) {
          const _0x320ed6 = this.findSymbolExt("singleSkill", _0x50d390.id);
          this.select(_0x320ed6 || 0x0);
        }
      }
    }
  }
};
Window_ActorCommand.prototype.findSymbolExt = function (_0x51cecb, _0x244d3f) {
  return this._list.findIndex(_0x561f65 => _0x561f65.symbol === _0x51cecb && _0x561f65.ext === _0x244d3f);
};
VisuMZ.BattleCore.Window_BattleStatus_initialize = Window_BattleStatus.prototype.initialize;
Window_BattleStatus.prototype.initialize = function (_0x51dedc) {
  VisuMZ.BattleCore.Window_BattleStatus_initialize.call(this, _0x51dedc);
  this.initBattleCore();
  this.createAttachmentSprites();
};
Window_BattleStatus.prototype.battleLayoutStyle = function () {
  if (this._battleLayoutStyle) {
    return this._battleLayoutStyle;
  }
  this._battleLayoutStyle = SceneManager._scene.battleLayoutStyle();
  return this._battleLayoutStyle;
};
Window_BattleStatus.prototype.initBattleCore = function () {
  this.frameVisible = this.isFrameVisible();
  const _0x4094fa = VisuMZ.BattleCore.Settings.BattleLayout;
  if (_0x4094fa.StatusWindowSkinHide) {
    this.opacity = 0x0;
  }
};
Window_BattleStatus.prototype.isFrameVisible = function () {
  const _0x3125a9 = VisuMZ.BattleCore.Settings.BattleLayout;
  if (_0x3125a9.StatusWindowSkinFilename) {
    return true;
  }
  const _0x268cfd = this.battleLayoutStyle();
  switch (_0x268cfd) {
    case "list":
    case 'border':
      return true;
      break;
    case "default":
    case 'xp':
    case 'portrait':
    default:
      return false;
      break;
  }
};
Window_BattleStatus.prototype.extraHeight = function () {
  return this.isFrameVisible() ? 0x0 : 0xa;
};
Window_BattleStatus.prototype.maxCols = function () {
  const _0x35e646 = this.battleLayoutStyle();
  switch (_0x35e646) {
    case 'list':
      return 0x1;
      break;
    case 'xp':
    case "portrait":
      return $gameParty.battleMembers().length;
      break;
    case "default":
    default:
      return $gameParty.maxBattleMembers();
      break;
  }
};
Window_BattleStatus.prototype.itemHeight = function () {
  const _0x1d38ec = this.battleLayoutStyle();
  switch (_0x1d38ec) {
    case "list":
      return Window_StatusBase.prototype.itemHeight.call(this);
      break;
    case 'default':
    case 'xp':
    case "portrait":
    default:
      return this.innerHeight;
      break;
  }
};
Window_BattleStatus.prototype.rowSpacing = function () {
  const _0x29fd5a = this.battleLayoutStyle();
  switch (_0x29fd5a) {
    case "list":
      return Window_StatusBase.prototype.rowSpacing.call(this);
      break;
    case 'default':
    case 'xp':
    case "portrait":
    default:
      return 0x0;
      break;
  }
};
Window_BattleStatus.prototype.updatePadding = function () {
  if (this.isFrameVisible()) {
    Window_StatusBase.prototype.updatePadding.call(this);
  } else {
    this.padding = 0x8;
  }
};
Window_BattleStatus.prototype.loadWindowskin = function () {
  const _0x363ec2 = VisuMZ.BattleCore.Settings.BattleLayout;
  if (_0x363ec2.StatusWindowSkinFilename) {
    this.windowskin = ImageManager.loadSystem(_0x363ec2.StatusWindowSkinFilename);
  } else {
    Window_StatusBase.prototype.loadWindowskin.call(this);
  }
};
Window_BattleStatus.prototype.drawItemBackground = function (_0x5216b0) {
  const _0x231268 = VisuMZ.BattleCore.Settings.BattleLayout;
  if (_0x231268.StatusWindowSelectableBackHide) {
    return;
  }
  Window_StatusBase.prototype.drawItemBackground.call(this, _0x5216b0);
};
Window_BattleStatus.prototype.requestRefresh = function () {
  this._requestRefresh = true;
};
Window_BattleStatus.prototype.update = function () {
  Window_StatusBase.prototype.update.call(this);
  this.updateRefresh();
  this.updateEffectContainers();
  if (this.battleLayoutStyle() === 'border') {
    this.updateBorderStyle();
  }
};
Window_BattleStatus.prototype.updateRefresh = function () {
  if ($gameTemp.isBattleRefreshRequested()) {
    this.preparePartyRefresh();
    this._requestRefresh = false;
    $gameTemp.clearBattleRefreshRequest();
  } else if (this._requestRefresh) {
    this._requestRefresh = false;
    this.refresh();
    this.updateAttachmentSprites();
  }
};
Window_BattleStatus.prototype.show = function () {
  Window_StatusBase.prototype.show.call(this);
  if (!$gameSystem.isSideView()) {
    this.refresh();
  }
};
Window_BattleStatus.prototype.hide = function () {
  if (this.constructor === Window_BattleStatus) {
    return;
  }
  Window_StatusBase.prototype.hide.call(this);
};
Window_BattleStatus.prototype.drawBackgroundRect = function (_0x4ab8d7) {
  const _0x1bc930 = this.battleLayoutStyle();
  switch (_0x1bc930) {
    case 'xp':
    case "portrait":
      break;
    case "default":
    case 'list':
    case "border":
    default:
      return Window_StatusBase.prototype.drawBackgroundRect.call(this, _0x4ab8d7);
      break;
  }
};
VisuMZ.BattleCore.Window_BattleStatus_drawItemImage = Window_BattleStatus.prototype.drawItemImage;
Window_BattleStatus.prototype.drawItemImage = function (_0x344ef9) {
  const _0x559225 = this.battleLayoutStyle();
  switch (_0x559225) {
    case "list":
      this.drawItemImageListStyle(_0x344ef9);
      break;
    case 'xp':
      this.drawItemImageXPStyle(_0x344ef9);
      break;
    case "portrait":
      this.drawItemImagePortraitStyle(_0x344ef9);
      break;
    case "default":
    case "border":
    default:
      VisuMZ.BattleCore.Window_BattleStatus_drawItemImage.call(this, _0x344ef9);
      break;
  }
};
Window_BattleStatus.prototype.drawItemStatus = function (_0x44686e) {
  const _0x368070 = this.battleLayoutStyle();
  if (!$gameSystem.isSideView()) {
    this.centerFrontViewSprite(_0x44686e);
  }
  switch (_0x368070) {
    case "list":
      this.drawItemStatusListStyle(_0x44686e);
      break;
    case 'xp':
    case 'portrait':
    case "default":
    case "border":
    default:
      this.drawItemStatusXPStyle(_0x44686e);
      break;
  }
};
Window_BattleStatus.prototype.refreshCursor = function () {
  const _0x1bca40 = this.battleLayoutStyle();
  if (['xp'].includes(_0x1bca40) && !$gameSystem.isSideView()) {
    this.setCursorRect(0x0, 0x0, 0x0, 0x0);
    return;
  }
  Window_StatusBase.prototype.refreshCursor.call(this);
};
Window_BattleStatus.prototype.centerFrontViewSprite = function (_0x255859) {
  const _0x33ff2d = this.actor(_0x255859).battler();
  if (!_0x33ff2d) {
    return;
  }
  const _0x1a2ecd = this.battleLayoutStyle();
  const _0x5339a0 = this.itemRect(_0x255859);
  let _0x513d4d = Math.round(_0x5339a0.x + _0x5339a0.width / 0x2) + this.padding;
  if (["list"].includes(_0x1a2ecd)) {
    _0x513d4d = _0x5339a0.width / $gameParty.battleMembers().length;
    _0x513d4d *= _0x255859;
    _0x513d4d += _0x5339a0.width / $gameParty.battleMembers().length / 0x2;
  }
  let _0x1b71c1 = Math.round(this.frontviewSpriteY(_0x255859, _0x33ff2d, _0x5339a0));
  _0x33ff2d.setHome(_0x513d4d, _0x1b71c1);
  this.addChildAt(_0x33ff2d, 0x1);
  _0x33ff2d.show();
  this.updateEffectsContainer();
  this.updateAttachmentSprites();
};
Window_BattleStatus.prototype.frontviewSpriteY = function (_0x1bc654, _0x420a50, _0xeb152e) {
  const _0x37ca57 = VisuMZ.BattleCore.Settings.BattleLayout;
  const _0x5bcb6e = this.battleLayoutStyle();
  if (_0x5bcb6e === 'xp') {
    const _0x4170e2 = _0x37ca57.XPSpriteYLocation;
    switch (_0x4170e2.toLowerCase().trim()) {
      case "bottom":
        return _0xeb152e.height - _0x420a50._shadowSprite.height / 0x4;
        break;
      case "center":
        const _0x1c7bb5 = _0x37ca57.XPActorDefaultHeight;
        return (_0xeb152e.height + (_0x420a50.height || _0x1c7bb5)) / 0x2;
        break;
      case "top":
        return 0x0;
      case "name":
      default:
        return this.nameY(_0xeb152e);
        break;
    }
  } else {
    if (_0x5bcb6e === 'portrait') {}
  }
  return _0x420a50.height;
};
Sprite_Name.prototype.bitmapHeight = function () {
  return 0x24;
};
Sprite_Name.prototype.redraw = function () {
  const _0x2f76d3 = this.name();
  const _0x451d96 = this.bitmapWidth();
  const _0x22e955 = this.bitmapHeight();
  this.setupFont();
  this.bitmap.clear();
  this.bitmap.drawTextTopAligned(_0x2f76d3, 0x4, 0x0, _0x451d96, _0x22e955, "left");
};
Bitmap.prototype.drawTextTopAligned = function (_0xd01434, _0x5e75a9, _0x4778fe, _0x59602e, _0x12a53b, _0x5d1210) {
  if (TextManager.parseLocalizedText) {
    _0xd01434 = TextManager.parseLocalizedText(_0xd01434);
  }
  const _0x10b688 = this.context;
  const _0x47622c = _0x10b688.globalAlpha;
  _0x59602e = _0x59602e || 0xffffffff;
  let _0x5e2717 = _0x5e75a9;
  let _0x4b95b3 = Math.round(_0x4778fe + 12 + this.fontSize * 0.35);
  if (_0x5d1210 === 'center') {
    _0x5e2717 += _0x59602e / 0x2;
  }
  if (_0x5d1210 === "right") {
    _0x5e2717 += _0x59602e;
  }
  _0x10b688.save();
  _0x10b688.font = this._makeFontNameText();
  _0x10b688.textAlign = _0x5d1210;
  _0x10b688.textBaseline = "alphabetic";
  _0x10b688.globalAlpha = 0x1;
  this._drawTextOutline(_0xd01434, _0x5e2717, _0x4b95b3, _0x59602e);
  _0x10b688.globalAlpha = _0x47622c;
  this._drawTextBody(_0xd01434, _0x5e2717, _0x4b95b3, _0x59602e);
  _0x10b688.restore();
  this._baseTexture.update();
};
Window_BattleStatus.prototype.nameY = function (_0xf1ecb8) {
  return this.basicGaugesY(_0xf1ecb8) - this.gaugeLineHeight();
};
Window_BattleStatus.prototype.drawItemImageListStyle = function (_0xc9169b) {
  if (!VisuMZ.BattleCore.Settings.BattleLayout.ShowFacesListStyle) {
    return;
  }
  const _0x116a83 = this.actor(_0xc9169b);
  const _0x43a881 = this.itemRect(_0xc9169b);
  _0x43a881.width = ImageManager.faceWidth;
  _0x43a881.height -= 0x2;
  this.drawActorFace(_0x116a83, _0x43a881.x + 0x1, _0x43a881.y + 0x1, _0x43a881.width, _0x43a881.height);
};
Window_BattleStatus.prototype.drawItemStatusListStyle = function (_0x50e46e) {
  const _0x1cbb7b = VisuMZ.BattleCore.Settings.BattleLayout;
  const _0xaa93c4 = $dataSystem.optDisplayTp ? 0x4 : 0x3;
  const _0x9fadee = _0xaa93c4 * 0x80 + (_0xaa93c4 - 0x1) * 0x8 + 0x4;
  const _0x40b3a9 = this.actor(_0x50e46e);
  const _0x484764 = this.itemRect(_0x50e46e);
  let _0x2dbe13 = _0x484764.x + this.padding;
  if (_0x1cbb7b.ShowFacesListStyle) {
    _0x2dbe13 = _0x484764.x + ImageManager.faceWidth + 0x8;
  } else {
    _0x2dbe13 += ImageManager.iconWidth;
  }
  const _0x1972a8 = Math.round(Math.min(_0x484764.x + _0x484764.width - _0x9fadee, _0x2dbe13));
  const _0x3af821 = Math.round(_0x484764.y + (_0x484764.height - Sprite_Name.prototype.bitmapHeight()) / 0x2);
  const _0x1d21e2 = Math.round(_0x1972a8 - ImageManager.iconWidth / 0x2 - 0x4);
  const _0x714819 = Math.round(_0x484764.y + (_0x484764.height - ImageManager.iconHeight) / 0x2 + ImageManager.iconHeight / 0x2);
  let _0x3d1909 = _0x1972a8 + 0x88;
  this.placeTimeGauge(_0x40b3a9, _0x1972a8 - 0x4 + (_0x1cbb7b.TpbGaugeOffsetX || 0x0), _0x3af821 + (_0x1cbb7b.TpbGaugeOffsetY || 0x0));
  this.placeActorName(_0x40b3a9, _0x1972a8 + (_0x1cbb7b.NameOffsetX || 0x0), _0x3af821 + (_0x1cbb7b.NameOffsetY || 0x0));
  this.placeStateIcon(_0x40b3a9, _0x1d21e2 + (_0x1cbb7b.StateIconOffsetX || 0x0), _0x714819 + (_0x1cbb7b.StateIconOffsetY || 0x0));
  this.placeGauge(_0x40b3a9, 'hp', _0x3d1909 + 0 + (_0x1cbb7b.HpGaugeOffsetX || 0x0), _0x3af821 + (_0x1cbb7b.HpGaugeOffsetY || 0x0));
  this.placeGauge(_0x40b3a9, 'mp', _0x3d1909 + 136 + (_0x1cbb7b.MpGaugeOffsetX || 0x0), _0x3af821 + (_0x1cbb7b.MpGaugeOffsetY || 0x0));
  if ($dataSystem.optDisplayTp) {
    this.placeGauge(_0x40b3a9, 'tp', _0x3d1909 + 272 + (_0x1cbb7b.TpGaugeOffsetX || 0x0), _0x3af821 + (_0x1cbb7b.TpGaugeOffsetY || 0x0));
  }
};
Window_BattleStatus.prototype.drawItemImageXPStyle = function (_0x4bcf72) {
  if (!$gameSystem.isSideView()) {
    return;
  }
  VisuMZ.BattleCore.Window_BattleStatus_drawItemImage.call(this, _0x4bcf72);
};
Window_BattleStatus.prototype.drawItemStatusXPStyle = function (_0x3c4c2f) {
  const _0x19d50e = VisuMZ.BattleCore.Settings.BattleLayout;
  const _0x29a1df = this.actor(_0x3c4c2f);
  const _0x66ced6 = this.itemRect(_0x3c4c2f);
  const _0x19330b = Math.round(_0x66ced6.x + (_0x66ced6.width - 0x80) / 0x2);
  const _0x278ae9 = this.nameY(_0x66ced6);
  let _0x2cad39 = _0x19330b - ImageManager.iconWidth / 0x2 - 0x4;
  let _0x100b41 = _0x278ae9 + ImageManager.iconHeight / 0x2;
  if (_0x2cad39 - ImageManager.iconWidth / 0x2 < _0x66ced6.x) {
    _0x2cad39 = _0x19330b + ImageManager.iconWidth / 0x2 - 0x4;
    _0x100b41 = _0x278ae9 - ImageManager.iconHeight / 0x2;
  }
  const _0x5aaf5c = this.basicGaugesY(_0x66ced6);
  this.placeTimeGauge(_0x29a1df, _0x19330b + (_0x19d50e.TpbGaugeOffsetX || 0x0), _0x278ae9 + (_0x19d50e.TpbGaugeOffsetY || 0x0));
  this.placeActorName(_0x29a1df, _0x19330b + (_0x19d50e.NameOffsetX || 0x0), _0x278ae9 + (_0x19d50e.NameOffsetY || 0x0));
  this.placeStateIcon(_0x29a1df, _0x2cad39 + (_0x19d50e.StateIconOffsetX || 0x0), _0x100b41 + (_0x19d50e.StateIconOffsetY || 0x0));
  this.placeGauge(_0x29a1df, 'hp', _0x19330b + (_0x19d50e.HpGaugeOffsetX || 0x0), _0x5aaf5c + (_0x19d50e.HpGaugeOffsetY || 0x0));
  this.placeGauge(_0x29a1df, 'mp', _0x19330b + (_0x19d50e.MpGaugeOffsetX || 0x0), _0x5aaf5c + this.gaugeLineHeight() + (_0x19d50e.MpGaugeOffsetY || 0x0));
  if ($dataSystem.optDisplayTp) {
    this.placeGauge(_0x29a1df, 'tp', _0x19330b + (_0x19d50e.TpGaugeOffsetX || 0x0), _0x5aaf5c + this.gaugeLineHeight() * 0x2 + (_0x19d50e.TpGaugeOffsetY || 0x0));
  }
};
Window_BattleStatus.prototype.showPortraits = function (_0x148369) {
  if (!VisuMZ.BattleCore.Settings.BattleLayout.ShowPortraits) {
    return false;
  }
  if (_0x148369.getBattlePortrait()) {
    return true;
  }
  return Imported.VisuMZ_1_MainMenuCore && _0x148369.getMenuImage();
};
Game_Actor.prototype.getBattlePortraitOffsetX = function () {
  if (this.actor().note.match(/<BATTLE (?:IMAGE|PORTRAIT) OFFSET X:[ ]([\+\-]\d+)>/i)) {
    return Number(RegExp.$1);
  } else {
    if (this.actor().note.match(/<BATTLE (?:IMAGE|PORTRAIT) OFFSET:[ ]([\+\-]\d+),[ ]([\+\-]\d+)>/i)) {
      return Number(RegExp.$1);
    }
  }
  return 0x0;
};
Game_Actor.prototype.getBattlePortraitOffsetY = function () {
  if (this.actor().note.match(/<BATTLE (?:IMAGE|PORTRAIT) OFFSET Y:[ ]([\+\-]\d+)>/i)) {
    return Number(RegExp.$1);
  } else {
    if (this.actor().note.match(/<BATTLE (?:IMAGE|PORTRAIT) OFFSET:[ ]([\+\-]\d+),[ ]([\+\-]\d+)>/i)) {
      return Number(RegExp.$2);
    }
  }
  return 0x0;
};
Window_BattleStatus.prototype.drawItemImagePortraitStyle = function (_0x364ca3) {
  const _0x2640b9 = this.actor(_0x364ca3);
  if (this.showPortraits(_0x2640b9)) {
    const _0x47b25b = "actor%1-portrait".format(_0x2640b9.actorId());
    const _0x5ab2a0 = this.createInnerPortrait(_0x47b25b, Sprite);
    const _0x328015 = _0x2640b9.getBattlePortraitFilename();
    if (_0x328015 !== '') {
      _0x5ab2a0.bitmap = ImageManager.loadPicture(_0x328015);
    } else {
      _0x5ab2a0.bitmap = ImageManager._emptyBitmap;
    }
    const _0x4f098a = this.itemRect(_0x364ca3);
    _0x5ab2a0.anchor.x = 0.5;
    _0x5ab2a0.anchor.y = 0x1;
    let _0x995010 = Math.round(_0x4f098a.x + _0x4f098a.width / 0x2) + this.padding;
    _0x995010 += _0x2640b9.getBattlePortraitOffsetX();
    let _0x5458f0 = Math.round(this.height);
    _0x5458f0 += _0x2640b9.getBattlePortraitOffsetY();
    _0x5ab2a0.move(_0x995010, _0x5458f0);
    const _0xe2a696 = VisuMZ.BattleCore.Settings.BattleLayout.PortraitScale;
    _0x5ab2a0.scale.x = _0xe2a696;
    _0x5ab2a0.scale.y = _0xe2a696;
    _0x5ab2a0.show();
  } else {
    const _0x3c9d07 = this.faceRect(_0x364ca3);
    this.drawActorFace(_0x2640b9, _0x3c9d07.x, _0x3c9d07.y, _0x3c9d07.width, _0x3c9d07.height);
  }
};
Window_BattleStatus.prototype.createInnerPortrait = function (_0x532489, _0x2b36b2) {
  const _0x100d76 = this._additionalSprites;
  if (_0x100d76[_0x532489]) {
    return _0x100d76[_0x532489];
  } else {
    const _0x134e35 = new _0x2b36b2();
    _0x100d76[_0x532489] = _0x134e35;
    this.addChildToBack(_0x134e35);
    this.addChildToBack(this._cursorArea);
    return _0x134e35;
  }
};
Window_BattleStatus.prototype._createClientArea = function () {
  this._createCursorArea();
  this._createEffectsContainer();
  Window_StatusBase.prototype._createClientArea.call(this);
  this._createDamageContainer();
};
Window_BattleStatus.prototype._createCursorArea = function () {
  this._cursorArea = new Sprite();
  this._cursorArea.filters = [new PIXI.filters.AlphaFilter()];
  this._cursorArea.filterArea = new Rectangle();
  this._cursorArea.move(this._padding, this._padding);
  this.addChild(this._cursorArea);
};
Window_BattleStatus.prototype._createEffectsContainer = function () {
  this._effectsContainer = new Sprite();
  this.addChild(this._effectsContainer);
};
Window_BattleStatus.prototype.updateEffectsContainer = function () {
  if (this._effectsContainer) {
    this.addChild(this._effectsContainer);
  }
};
Window_BattleStatus.prototype._createDamageContainer = function () {
  this._damageContainer = new Sprite();
  this.addChild(this._damageContainer);
};
Window_BattleStatus.prototype._createCursorSprite = function () {
  this._cursorSprite = new Sprite();
  for (let _0x4930b4 = 0x0; _0x4930b4 < 0x9; _0x4930b4++) {
    this._cursorSprite.addChild(new Sprite());
  }
  this._cursorArea.addChild(this._cursorSprite);
};
Window_BattleStatus.prototype._updateClientArea = function () {
  Window_StatusBase.prototype._updateClientArea.call(this);
  this._updateCursorArea();
};
Window_BattleStatus.prototype._updateCursorArea = function () {
  const _0x12ef19 = this._padding;
  this._cursorArea.move(_0x12ef19, _0x12ef19);
  this._cursorArea.x = _0x12ef19 - this.origin.x;
  this._cursorArea.y = _0x12ef19 - this.origin.y;
  if (this.innerWidth > 0x0 && this.innerHeight > 0x0) {
    this._cursorArea.visible = this.isOpen();
  } else {
    this._cursorArea.visible = false;
  }
};
Window_BattleStatus.prototype._updateFilterArea = function () {
  Window_StatusBase.prototype._updateFilterArea.call(this);
  this._updateCursorFilterArea();
};
Window_BattleStatus.prototype._updateCursorFilterArea = function () {
  const _0x1321e8 = this._cursorArea.worldTransform.apply(new Point(0x0, 0x0));
  const _0x47afbc = this._cursorArea.filterArea;
  _0x47afbc.x = _0x1321e8.x + this.origin.x;
  _0x47afbc.y = _0x1321e8.y + this.origin.y;
  _0x47afbc.width = this.innerWidth;
  _0x47afbc.height = this.innerHeight;
};
Window_BattleStatus.prototype.refreshActorPortrait = function (_0x276320) {
  if (this.battleLayoutStyle() !== "portrait") {
    return;
  }
  this.drawItemImagePortraitStyle(_0x276320.index());
};
Window_BattleStatus.prototype.addDamageSprite = function (_0x4ef18e, _0x4440e7) {
  if (!this._damageContainer) {
    return;
  }
  if (!_0x4ef18e) {
    return;
  }
  if (!_0x4440e7) {
    return;
  }
  const _0x2dad23 = this.itemRect(_0x4440e7.index());
  _0x2dad23.x += _0x2dad23.width / 0x2 + this.padding;
  _0x4ef18e.x = _0x2dad23.x;
  _0x4ef18e.y = _0x2dad23.y;
  this._damageContainer.addChild(_0x4ef18e);
};
Window_BattleStatus.prototype.removeDamageSprite = function (_0x57fa57) {
  if (!this._damageContainer) {
    return;
  }
  if (!_0x57fa57) {
    return;
  }
  this._damageContainer.removeChild(_0x57fa57);
};
Window_BattleStatus.prototype.updateBorderStyle = function () {
  if (!this.isBorderStylePortraitShown()) {
    return;
  }
  if (!this._borderPortraitSprite) {
    this.createBorderStylePortraitSprite();
  }
  this.prepareBorderActor();
  this.updateBorderSprite();
};
Window_BattleStatus.prototype.isBorderStylePortraitShown = function () {
  if (this.constructor !== Window_BattleStatus) {
    return false;
  }
  if (!SceneManager.isSceneBattle()) {
    return false;
  }
  return VisuMZ.BattleCore.Settings.BattleLayout.ShowPortraitsBorderStyle;
};
Window_BattleStatus.prototype.createBorderStylePortraitSprite = function () {
  this._borderPortraitSprite = new Sprite();
  const _0xa7c2e0 = SceneManager._scene;
  const _0x5f5b9d = _0xa7c2e0.children.indexOf(_0xa7c2e0._windowLayer);
  _0xa7c2e0.addChildAt(this._borderPortraitSprite, _0x5f5b9d);
  this._borderPortraitSprite.anchor.x = 0.5;
  this._borderPortraitSprite.anchor.y = 0x1;
  const _0x3a15d6 = VisuMZ.BattleCore.Settings.BattleLayout.PortraitScaleBorderStyle;
  this._borderPortraitSprite.scale.x = _0x3a15d6;
  this._borderPortraitSprite.scale.y = _0x3a15d6;
  this._borderPortraitSprite.y = this.y + this.height;
  this._borderPortraitDuration = 0x0;
};
Window_BattleStatus.prototype.isBorderPortraitSpriteVisible = function () {
  return BattleManager.isInputting();
};
Window_BattleStatus.prototype.prepareBorderActor = function () {
  this._borderPortraitSprite.visible = this.isBorderPortraitSpriteVisible();
  const _0x510e9f = BattleManager.actor();
  const _0x5f512a = _0x510e9f ? _0x510e9f.getBattlePortraitFilename() || '' : '';
  if (_0x510e9f === this._borderPortraitSprite.actor && _0x5f512a === this._borderPortraitSprite.lastFilename) {
    return;
  }
  this._borderPortraitSprite.actor = _0x510e9f || this._borderPortraitSprite.actor;
  this._borderPortraitSprite.lastFilename = _0x5f512a;
  if (!_0x510e9f) {
    return;
  } else {
    if (_0x5f512a === '') {
      this._borderPortraitSprite.bitmap = ImageManager._emptyBitmap;
      this._borderPortraitSprite.lastFilename = '';
      return;
    } else {
      const _0x4fca7d = ImageManager.loadPicture(_0x5f512a);
      this._borderPortraitSprite.opacity = 0x0;
      _0x4fca7d.addLoadListener(this.processBorderActor.bind(this, _0x4fca7d));
    }
  }
};
Window_BattleStatus.prototype.processBorderActor = function (_0x1dc0c1) {
  this._borderPortraitDuration = 0x14;
  this._borderPortraitSprite.bitmap = _0x1dc0c1;
  if (SceneManager._scene.isRightInputMode()) {
    this._borderPortraitSprite.x = 0x0;
    this._borderPortraitTargetX = Math.ceil(_0x1dc0c1.width / 0x2);
  } else {
    this._borderPortraitSprite.x = this.width;
    this._borderPortraitTargetX = this.width * 0x3 / 0x4;
  }
  this._borderPortraitSprite.opacity = 0x0;
  this._borderPortraitSprite.y = this.y + this.height;
  const _0x162518 = BattleManager.actor();
  if (_0x162518) {
    this._borderPortraitTargetX += _0x162518.getBattlePortraitOffsetX();
    this._borderPortraitSprite.y += _0x162518.getBattlePortraitOffsetY();
  }
};
Window_BattleStatus.prototype.updateBorderSprite = function () {
  if (this._borderPortraitDuration > 0x0) {
    const _0x381def = this._borderPortraitDuration;
    const _0x33a54e = this._borderPortraitSprite;
    _0x33a54e.x = (_0x33a54e.x * (_0x381def - 0x1) + this._borderPortraitTargetX) / _0x381def;
    _0x33a54e.opacity = (_0x33a54e.opacity * (_0x381def - 0x1) + 0xff) / _0x381def;
    this._borderPortraitDuration--;
  }
};
Window_BattleStatus.prototype.updateEffectContainers = function () {
  return;
  if (this._effectsContainer) {
    this._effectsContainer.x = this.x;
    this._effectsContainer.y = this.y;
  }
  if (this._damageContainer) {
    this._damageContainer.x = this.x;
    this._damageContainer.y = this.y;
  }
};
Window_BattleStatus.prototype.createAttachmentSprites = function () {
  const _0x5025e1 = VisuMZ.BattleCore.Settings.BattleLayout;
  if (_0x5025e1.StatusWindowAttachmentBack) {
    const _0xa60f7b = new Sprite();
    _0xa60f7b.bitmap = ImageManager.loadSystem(_0x5025e1.StatusWindowAttachmentBack);
    _0xa60f7b.x = _0x5025e1.StatusWindowAttachmentBackOffsetX || 0x0;
    _0xa60f7b.y = _0x5025e1.StatusWindowAttachmentBackOffsetY || 0x0;
    this.addChildToBack(_0xa60f7b);
    this._backAttachmentSprite = _0xa60f7b;
  }
  if (_0x5025e1.StatusWindowAttachmentFront) {
    const _0x1296b6 = new Sprite();
    _0x1296b6.bitmap = ImageManager.loadSystem(_0x5025e1.StatusWindowAttachmentFront);
    _0x1296b6.x = _0x5025e1.StatusWindowAttachmentFrontOffsetX || 0x0;
    _0x1296b6.y = _0x5025e1.StatusWindowAttachmentFrontOffsetY || 0x0;
    this.addChild(_0x1296b6);
    this._frontAttachmentSprite = _0x1296b6;
  }
};
Window_BattleStatus.prototype.updateAttachmentSprites = function () {
  if (this._frontAttachmentSprite) {
    this.addChild(this._frontAttachmentSprite);
  }
  if (this._backAttachmentSprite) {
    this.addChildToBack(this._backAttachmentSprite);
  }
};
Window_BattleActor.prototype.isCurrentItemEnabled = function () {
  return this.isActionSelectionValid();
};
Window_BattleActor.prototype.isActionSelectionValid = function () {
  const _0x5ceb6f = BattleManager.inputtingAction();
  if (!_0x5ceb6f) {
    return true;
  }
  if (!_0x5ceb6f.item()) {
    return true;
  }
  const _0x2cb572 = this.actor(this.index());
  if (_0x5ceb6f.isForNotUser()) {
    if (_0x2cb572 === BattleManager.actor()) {
      return false;
    }
  }
  if (_0x5ceb6f.isForDeadFriend()) {
    if (!_0x2cb572.isDead()) {
      return false;
    }
  }
  if (_0x5ceb6f.isForAliveFriend()) {
    if (!_0x2cb572.isAlive()) {
      return false;
    }
  }
  return true;
};
Window_BattleActor.prototype.setEnemyWindowMode = function (_0x4bae2e) {
  this._enemyWindowMode = _0x4bae2e;
};
VisuMZ.BattleCore.Window_BattleActor_processTouch = Window_BattleActor.prototype.processTouch;
Window_BattleActor.prototype.processTouch = function () {
  Window_BattleStatus.prototype.processTouch.call(this);
  if (this._enemyWindowMode) {
    this.processEnemyModeTouchBattleCore();
  } else {
    VisuMZ.BattleCore.Window_BattleActor_processTouch.call(this);
  }
};
Window_BattleActor.prototype.processEnemyModeTouchBattleCore = function () {
  const _0x1a31bf = SceneManager._scene._enemyWindow;
  if (!_0x1a31bf) {
    return;
  }
  this._doubleTouch = false;
  const _0x65e82b = this.hitIndex();
  if (_0x65e82b >= 0x0) {
    this.select(_0x65e82b);
    if (TouchInput.isClicked()) {
      const _0x25d5a2 = $gameParty.members()[_0x65e82b];
      const _0x37118b = _0x1a31bf._enemies.indexOf(_0x25d5a2);
      if (_0x37118b >= 0x0) {
        _0x1a31bf.select(_0x37118b);
        _0x1a31bf.processOk();
      }
    }
  }
};
Window_BattleActor.prototype._makeCursorAlpha = function () {
  if (this._enemyWindowMode) {
    this._animationCount++;
    this.active = true;
  }
  const _0x1e924d = Window_BattleStatus.prototype._makeCursorAlpha.call(this);
  if (this._enemyWindowMode) {
    this.active = false;
  }
  return _0x1e924d;
};
VisuMZ.BattleCore.Window_BattleActor_show = Window_BattleActor.prototype.show;
Window_BattleActor.prototype.show = function () {
  VisuMZ.BattleCore.Window_BattleActor_show.call(this);
  const _0x42d79f = BattleManager.inputtingAction();
  if (_0x42d79f) {
    const _0x5877a3 = $gameParty.aliveMembers();
    if (_0x42d79f.canSingleOrMultipleSelect() && _0x5877a3.length > 0x1) {
      this.setHandler('pagedown', this.selectAllActors.bind(this));
    }
  }
};
VisuMZ.BattleCore.Window_BattleActor_hide = Window_BattleActor.prototype.hide;
Window_BattleActor.prototype.hide = function () {
  VisuMZ.BattleCore.Window_BattleActor_hide.call(this);
  delete this._handlers.pageup;
  delete this._handlers.pagedown;
};
Window_BattleActor.prototype.selectAllActors = function () {
  const _0xe28936 = BattleManager.inputtingAction();
  if (_0xe28936) {
    _0xe28936.setTargetBattlerKey("all actors");
  }
  this.processOk();
};
VisuMZ.BattleCore.Window_BattleEnemy_initialize = Window_BattleEnemy.prototype.initialize;
Window_BattleEnemy.prototype.initialize = function (_0x4d30ce) {
  this._lastEnemy = null;
  VisuMZ.BattleCore.Window_BattleEnemy_initialize.call(this, _0x4d30ce);
  if (Imported.VisuMZ_2_AggroControlSystem) {
    if (VisuMZ.AggroControlSystem.version < 1.12) {
      let _0x327913 = '';
      _0x327913 += "VisuMZ_2_AggroControlSystem needs to be updated ";
      _0x327913 += "in order for Taunt and Provoke features to work ";
      _0x327913 += "with latest version of VisuMZ_1_BattleCore!";
      alert(_0x327913);
      SceneManager.exit();
    }
  }
};
Window_BattleEnemy.prototype.maxCols = function () {
  return this.maxItems();
};
VisuMZ.BattleCore.Window_BattleEnemy_show = Window_BattleEnemy.prototype.show;
Window_BattleEnemy.prototype.show = function () {
  VisuMZ.BattleCore.Window_BattleEnemy_show.call(this);
  this.y = Graphics.height * 0xa;
  if (this.meetsSelectFrontviewActorConditions()) {
    this.openBattleActorWindow();
  }
};
VisuMZ.BattleCore.Window_BattleEnemy_hide = Window_BattleEnemy.prototype.hide;
Window_BattleEnemy.prototype.hide = function () {
  VisuMZ.BattleCore.Window_BattleEnemy_hide.call(this);
  $gameParty.select(null);
  delete this._handlers.pageup;
  delete this._handlers.pagedown;
};
Window_BattleEnemy.prototype.validTargets = function () {
  let _0x2e63f6 = $gameTroop.aliveMembers();
  const _0x131ae5 = BattleManager.inputtingAction();
  if (_0x131ae5) {
    if (_0x131ae5.canSingleOrMultipleSelect() && _0x2e63f6.length > 0x1) {
      this.setHandler("pageup", this.selectAllEnemies.bind(this));
    }
    if (_0x131ae5.isForAnyone()) {
      const _0x5257ed = $gameParty.aliveMembers();
      _0x2e63f6 = _0x2e63f6.concat(_0x5257ed);
      if (_0x131ae5.canSingleOrMultipleSelect() && _0x5257ed.length > 0x1) {
        this.setHandler("pagedown", this.selectAllActors.bind(this));
      }
    }
  }
  return _0x2e63f6;
};
Window_BattleEnemy.prototype.refresh = function () {
  this._enemies = this.validTargets();
  this.sortEnemies();
  Window_Selectable.prototype.refresh.call(this);
};
Window_BattleEnemy.prototype.sortEnemies = function () {
  this._enemies.sort((_0x3ff61e, _0x5c026f) => {
    if (_0x3ff61e.isActor() !== _0x5c026f.isActor()) {
      if (_0x3ff61e.isEnemy()) {
        return -0x1;
      }
      if (_0x5c026f.isEnemy()) {
        return 0x1;
      }
    }
    if (_0x3ff61e.isActor() && _0x5c026f.isActor()) {
      return _0x3ff61e.index() - _0x5c026f.index();
    }
    return _0x3ff61e.battler()._baseX === _0x5c026f.battler()._baseX ? _0x3ff61e.battler()._baseY - _0x5c026f.battler()._baseY : _0x3ff61e.battler()._baseX - _0x5c026f.battler()._baseX;
  });
  if (SceneManager.isBattleFlipped()) {
    this._enemies.reverse();
  }
};
Window_BattleEnemy.prototype.autoSelect = function () {
  const _0x130ea9 = VisuMZ.BattleCore.Settings.Enemy;
  if (_0x130ea9.LastSelected) {
    this.autoSelectLastSelected();
  } else {
    this.autoSelectPriority();
  }
};
Window_BattleEnemy.prototype.autoSelectLastSelected = function () {
  const _0xdbd464 = BattleManager.inputtingAction();
  if (_0xdbd464 && _0xdbd464.isForAnyone()) {
    if (_0xdbd464.isForAnyoneFocusFriends()) {
      if (this._lastActor && this._enemies.includes(this._lastActor)) {
        const _0x4a9228 = this._enemies.indexOf(this._lastActor);
        return this.forceSelect(_0x4a9228);
      } else {
        return this.autoSelectPriority();
      }
    }
  }
  if (this._lastEnemy && this._enemies.includes(this._lastEnemy)) {
    const _0x1883fb = this._enemies.indexOf(this._lastEnemy);
    this.forceSelect(_0x1883fb);
  } else {
    this.autoSelectPriority();
  }
};
Window_BattleEnemy.prototype.autoSelectPriority = function () {
  const _0x2e5839 = BattleManager.inputtingAction();
  if (_0x2e5839 && _0x2e5839.isForAnyone()) {
    const _0x5caf85 = $gameParty.aliveMembers()[0x0];
    let _0x27ba15 = this._enemies.indexOf(_0x5caf85);
    const _0x2b27eb = _0x2e5839.item().scope;
    if (_0x2b27eb.match(/(?:ALLY|FRIEND) OR (?:ENEMY|FOE)/i)) {
      this.forceSelect(_0x27ba15);
      return;
    } else {
      if (_0x2b27eb.match(/(?:ENEMY|FOE) OR (?:ALLY|FRIEND)/i)) {
        this.forceSelect(_0x27ba15 - 0x1);
        return;
      }
    }
  }
  const _0x42d8bf = VisuMZ.BattleCore.Settings.Enemy;
  let _0x331a39 = false;
  if ($gameSystem.isSideView()) {
    _0x331a39 = _0x42d8bf.SideviewSelect;
  } else {
    _0x331a39 = _0x42d8bf.FrontViewSelect;
  }
  this.forceSelect(_0x331a39 ? this.maxItems() - 0x1 : 0x0);
};
Window_BattleEnemy.prototype.callOkHandler = function () {
  Window_Selectable.prototype.callOkHandler.call(this);
  if (!this.enemy()) {
    return;
  }
  if (this.enemy().isEnemy()) {
    this._lastEnemy = this.enemy();
  }
  if (this.enemy().isActor()) {
    this._lastActor = this.enemy();
  }
};
Window_BattleEnemy.prototype.select = function (_0x1fa029) {
  Window_Selectable.prototype.select.call(this, _0x1fa029);
  $gameTroop.select(this.enemy());
  $gameParty.select(this.enemy());
  if (!this.enemy()) {
    return;
  }
  if (this.meetsSelectFrontviewActorConditions()) {
    const _0x5b3850 = SceneManager._scene._actorWindow;
    if (this.enemy().isActor()) {
      _0x5b3850.select(this.enemy().index());
    } else {
      _0x5b3850.deselect();
    }
  }
};
Window_BattleEnemy.prototype.meetsSelectFrontviewActorConditions = function () {
  if (!this.visible) {
    return false;
  }
  if ($gameSystem.isSideView()) {
    return false;
  }
  const _0x133731 = SceneManager._scene.battleLayoutStyle();
  const _0x284b62 = ["default", "list", 'xp', "portrait", "border"];
  return _0x284b62.includes(_0x133731);
};
Window_BattleEnemy.prototype.openBattleActorWindow = function () {
  const _0x4b73fe = SceneManager._scene._actorWindow;
  _0x4b73fe.show();
  _0x4b73fe.setEnemyWindowMode(true);
  _0x4b73fe.refresh();
  _0x4b73fe.deselect();
  const _0x2e6381 = SceneManager._scene.battleLayoutStyle();
  const _0x514917 = ['xp', 'portrait', 'border'];
  if (_0x514917.includes(_0x2e6381)) {
    const _0x5ce9b8 = SceneManager._scene._statusWindow;
    _0x5ce9b8.scale.y = 0x0;
  }
};
Window_BattleEnemy.prototype.closeBattleActorWindow = function () {
  const _0x23ced9 = SceneManager._scene._actorWindow;
  _0x23ced9.hide();
  _0x23ced9.setEnemyWindowMode(false);
  _0x23ced9.deselect();
  const _0x944994 = SceneManager._scene._statusWindow;
  _0x944994.scale.y = 0x1;
};
Window_BattleEnemy.prototype.selectAllEnemies = function () {
  const _0x34dace = BattleManager.inputtingAction();
  if (_0x34dace) {
    _0x34dace.setTargetBattlerKey("all enemies");
  }
  this.processOk();
};
Window_BattleEnemy.prototype.selectAllActors = function () {
  const _0x5a575d = BattleManager.inputtingAction();
  if (_0x5a575d) {
    _0x5a575d.setTargetBattlerKey("all actors");
  }
  this.processOk();
};
Window_BattleEnemy.prototype.isCurrentItemEnabled = function () {
  return this.isActionSelectionValid();
};
Window_BattleEnemy.prototype.isActionSelectionValid = function () {
  const _0x20c6e9 = BattleManager.inputtingAction();
  if (!_0x20c6e9) {
    return true;
  }
  if (!_0x20c6e9.item()) {
    return true;
  }
  const _0x5af56a = this.enemy();
  if (_0x20c6e9.isForNotUser()) {
    if (_0x5af56a === BattleManager.actor()) {
      return false;
    }
  }
  return true;
};
Window_BattleItem.prototype.includes = function (_0x18e556) {
  if (!_0x18e556) {
    return false;
  }
  return _0x18e556.occasion === 0x0 || _0x18e556.occasion === 0x1;
};
function Window_AutoBattleCancel() {
  this.initialize(...arguments);
}
Window_AutoBattleCancel.prototype = Object.create(Window_Base.prototype);
Window_AutoBattleCancel.prototype.constructor = Window_AutoBattleCancel;
Window_AutoBattleCancel.prototype.initialize = function (_0x54f0d5) {
  Window_Base.prototype.initialize.call(this, _0x54f0d5);
  this.setBackgroundType(this.bgType());
  this.refresh();
};
Window_AutoBattleCancel.prototype.bgType = function () {
  return VisuMZ.BattleCore.Settings.AutoBattle.AutoBattleBgType;
};
Window_AutoBattleCancel.prototype.refresh = function () {
  this.contents.clear();
  const _0x4cea26 = VisuMZ.BattleCore.Settings.AutoBattle.AutoBattleMsg;
  const _0x5b3e3f = _0x4cea26.format(this.okButtonText(), this.cancelButtonText());
  const _0x3143d2 = this.textSizeEx(_0x5b3e3f).width;
  const _0xb0cf43 = Math.floor((this.innerWidth - _0x3143d2) / 0x2);
  this.drawTextEx(_0x5b3e3f, _0xb0cf43, 0x0, _0x3143d2);
};
Window_AutoBattleCancel.prototype.okButtonText = function () {
  return Imported.VisuMZ_0_CoreEngine ? TextManager.getInputButtonString('ok') : VisuMZ.BattleCore.Settings.AutoBattle.AutoBattleOK;
};
Window_AutoBattleCancel.prototype.cancelButtonText = function () {
  return Imported.VisuMZ_0_CoreEngine ? TextManager.getInputButtonString("cancel") : VisuMZ.BattleCore.Settings.AutoBattle.AutoBattleCancel;
};
Window_AutoBattleCancel.prototype.update = function () {
  Window_Base.prototype.update.call(this);
  this.updateVisibility();
  this.updateCancel();
};
Window_AutoBattleCancel.prototype.updateVisibility = function () {
  this.visible = BattleManager._autoBattle;
};
Window_AutoBattleCancel.prototype.updateCancel = function () {
  if (!BattleManager._autoBattle) {
    return;
  }
  if (Input.isTriggered('ok') || Input.isTriggered("cancel") || TouchInput.isClicked() || TouchInput.isCancelled()) {
    SoundManager.playCancel();
    BattleManager._autoBattle = false;
    Input.clear();
    TouchInput.clear();
  }
};
function Window_EnemyName() {
  this.initialize(...arguments);
}
Window_EnemyName.prototype = Object.create(Window_StatusBase.prototype);
Window_EnemyName.prototype.constructor = Window_EnemyName;
Window_EnemyName.prototype.initialize = function (_0x7a8a5e) {
  this._enemyID = _0x7a8a5e;
  this._text = '';
  const _0x4598d9 = new Rectangle(0x0, 0x0, Graphics.boxWidth, this.lineHeight() * 0x4);
  Window_StatusBase.prototype.initialize.call(this, _0x4598d9);
  this.setBackgroundType(0x2);
  this.contentsOpacity = 0x0;
};
Window_EnemyName.prototype.updatePadding = function () {
  this.padding = 0x0;
};
Window_EnemyName.prototype.enemy = function () {
  return $gameTroop.members()[this._enemyID];
};
Window_EnemyName.prototype.update = function () {
  Window_StatusBase.prototype.update.call(this);
  if (this.enemy() && this.enemy().name() !== this._text) {
    this._text = this.enemy().name();
    this.refresh();
  }
  this.updateOpacity();
  this.updatePosition();
};
Window_EnemyName.prototype.updateOpacity = function () {
  if (!this.enemy()) {
    if (this.contentsOpacity > 0x0) {
      this.contentsOpacity -= 0x10;
    }
  } else {
    if (this.enemy().isDead()) {
      if (this.contentsOpacity > 0x0) {
        this.contentsOpacity -= 0x10;
      }
    } else {
      if (SceneManager._scene._enemyWindow && SceneManager._scene._enemyWindow.active && SceneManager._scene._enemyWindow._enemies.includes(this.enemy())) {
        if (this.contentsOpacity < 0xff) {
          this.contentsOpacity += 0x10;
        }
      } else if (this.contentsOpacity > 0x0) {
        this.contentsOpacity -= 0x10;
      }
    }
  }
};
Window_EnemyName.prototype.updatePosition = function () {
  if (!this.enemy()) {
    return;
  }
  if (SceneManager.isBattleFlipped()) {
    this.x = Graphics.boxWidth - this.enemy().battler()._baseX;
  } else {
    this.x = this.enemy().battler()._baseX;
  }
  this.x -= Math.round(this.width / 0x2);
  this.y = this.enemy().battler()._baseY - Math.round(this.lineHeight() * 1.5);
  const _0x1b9409 = VisuMZ.BattleCore.Settings.Enemy;
  this.x += _0x1b9409.NameOffsetX || 0x0;
  this.y += _0x1b9409.NameOffsetY || 0x0;
};
Window_EnemyName.prototype.resetFontSettings = function () {
  Window_Base.prototype.resetFontSettings.call(this);
  this.contents.fontSize = VisuMZ.BattleCore.Settings.Enemy.NameFontSize;
};
Window_EnemyName.prototype.refresh = function () {
  Window_StatusBase.prototype.refresh.call(this);
  this.contents.clear();
  if (!this.enemy()) {
    return;
  }
  this.drawEnemyName();
};
Window_EnemyName.prototype.drawEnemyName = function () {
  this._text = this.enemy().name();
  const _0x45c23c = this.textSizeEx(this._text).width;
  const _0x40e5c8 = Math.round((this.innerWidth - _0x45c23c) / 0x2);
  this.drawTextEx(this._text, _0x40e5c8, 0x0, _0x45c23c + 0x8);
};
Window_BattleLog.prototype.maxLines = function () {
  return VisuMZ.BattleCore.Settings.BattleLog.MaxLines;
};
Window_BattleLog.prototype.messageSpeed = function () {
  return VisuMZ.BattleCore.Settings.BattleLog.MessageWait;
};
Window_BattleLog.prototype.backColor = function () {
  return VisuMZ.BattleCore.Settings.BattleLog.BackColor;
};
Window_BattleLog.prototype.isFastForward = function () {
  return false;
};
Window_BattleLog.prototype.actionEffect = function (_0x40fef6, _0xf367a7) {
  this.unshift("actionSplicePoint");
  BattleManager.invokeAction(_0x40fef6, _0xf367a7);
  this.callNextMethod();
};
Window_BattleLog.prototype.emulateActionEffect = function (_0x408021, _0x433786, _0x261d8c) {
  this.unshift("actionSplicePoint");
  BattleManager.emulateAction(_0x408021, _0x433786, _0x261d8c);
  this.callNextMethod();
};
Window_BattleLog.prototype.actionSplicePoint = function () {
  this.callNextMethod();
};
Window_BattleLog.prototype.push = function (_0x2a811a) {
  const _0x1d0408 = Array.prototype.slice.call(arguments, 0x1);
  const _0x1924ce = {
    'name': _0x2a811a,
    'params': _0x1d0408
  };
  const _0x3ee2a2 = this._methods.map(_0x41b5f6 => _0x41b5f6.name).indexOf("actionSplicePoint");
  if (_0x3ee2a2 >= 0x0) {
    this._methods.splice(_0x3ee2a2, 0x0, _0x1924ce);
  } else {
    this._methods.push(_0x1924ce);
  }
};
Window_BattleLog.prototype.unshift = function (_0x4bd97f) {
  const _0x134b19 = Array.prototype.slice.call(arguments, 0x1);
  this._methods.unshift({
    'name': _0x4bd97f,
    'params': _0x134b19
  });
};
Window_BattleLog.prototype.logActionList = function () {
  if (!$gameTemp.isPlaytest()) {
    return;
  }
  console.log(this._methods.map(_0x38fbcc => _0x38fbcc.name).join("\n"));
};
VisuMZ.BattleCore.Window_BattleLog_refresh = Window_BattleLog.prototype.refresh;
Window_BattleLog.prototype.refresh = function () {
  this._requestRefresh = true;
};
VisuMZ.BattleCore.Window_BattleLog_update = Window_BattleLog.prototype.update;
Window_BattleLog.prototype.update = function () {
  VisuMZ.BattleCore.Window_BattleLog_update.call(this);
  if (this._requestRefresh) {
    this.processRefresh();
  }
};
Window_BattleLog.prototype.processRefresh = function () {
  this._requestRefresh = false;
  VisuMZ.BattleCore.Window_BattleLog_refresh.call(this);
};
Window_BattleLog.prototype.drawLineText = function (_0x27e5dc) {
  let _0x58c28c = VisuMZ.BattleCore.Settings.BattleLog.TextAlign.toLowerCase().trim();
  let _0x154247 = this._lines[_0x27e5dc];
  if (_0x154247.match(/<LEFT>/i)) {
    _0x58c28c = 'left';
  } else {
    if (_0x154247.match(/<CENTER>/i)) {
      _0x58c28c = "center";
    } else if (_0x154247.match(/<RIGHT>/i)) {
      _0x58c28c = "right";
    }
  }
  _0x154247 = _0x154247.replace(/<(?:LEFT|CENTER|RIGHT)>/gi, '');
  _0x154247 = _0x154247.replace(/\\I\[0\]/gi, '');
  const _0x49c046 = this.lineRect(_0x27e5dc);
  this.contents.clearRect(_0x49c046.x, _0x49c046.y, _0x49c046.width, _0x49c046.height);
  const _0x528829 = this.textSizeEx(_0x154247).width;
  let _0x4b3d49 = _0x49c046.x;
  if (_0x58c28c === 'center') {
    _0x4b3d49 += (_0x49c046.width - _0x528829) / 0x2;
  } else if (_0x58c28c === "right") {
    _0x4b3d49 += _0x49c046.width - _0x528829;
  }
  this.drawTextEx(_0x154247, _0x4b3d49, _0x49c046.y, _0x528829 + 0x8);
};
Window_BattleLog.prototype.addText = function (_0x554624) {
  this._lines.push(_0x554624);
  this.refresh();
  this.callNextMethod();
};
Window_BattleLog.prototype.updateWaitMode = function () {
  let _0x491682 = false;
  switch (this._waitMode) {
    case "effect":
      _0x491682 = this._spriteset.isEffecting();
      break;
    case "movement":
      _0x491682 = this._spriteset.isAnyoneMoving();
      break;
    case "animation":
      _0x491682 = this._spriteset.isAnimationPlaying();
      break;
    case "float":
      _0x491682 = this._spriteset.isAnyoneFloating();
      break;
    case 'jump':
      _0x491682 = this._spriteset.isAnyoneJumping();
      break;
    case "opacity":
      _0x491682 = this._spriteset.isAnyoneChangingOpacity();
      break;
  }
  if (!_0x491682) {
    this._waitMode = '';
  }
  return _0x491682;
};
Window_BattleLog.prototype.waitForAnimation = function () {
  this.setWaitMode("animation");
};
Window_BattleLog.prototype.waitForFloat = function () {
  this.setWaitMode('float');
};
Window_BattleLog.prototype.waitForJump = function () {
  this.setWaitMode('jump');
};
Window_BattleLog.prototype.waitForOpacity = function () {
  this.setWaitMode("opacity");
};
Window_BattleLog.prototype.startTurn = function () {
  const _0xb30583 = VisuMZ.BattleCore.Settings.BattleLog;
  if (!_0xb30583.StartTurnShow) {
    return;
  }
  this.push("addText", _0xb30583.StartTurnMsg.format($gameTroop.turnCount()));
  this.push('waitCount', _0xb30583.StartTurnWait);
  this.push("clear");
};
Window_BattleLog.prototype.startAction = function (_0x43316b, _0x575912, _0x1bf6aa) {
  if (this.isCustomActionSequence(_0x575912)) {
    BattleManager.prepareCustomActionSequence();
  } else {
    this.usePremadeActionSequence(_0x43316b, _0x575912, _0x1bf6aa);
  }
};
Window_BattleLog.prototype.isCustomActionSequence = function (_0x4ccc16) {
  if (!SceneManager.isSceneBattle()) {
    return false;
  }
  if (!_0x4ccc16) {
    return false;
  }
  if (!_0x4ccc16.item()) {
    return false;
  }
  if (_0x4ccc16.item().note.match(/<CUSTOM ACTION SEQUENCE>/i)) {
    return true;
  }
  if (DataManager.checkAutoCustomActionSequenceNotetagEffect(_0x4ccc16.item())) {
    return true;
  }
  return false;
};
Window_BattleLog.prototype.usePremadeActionSequence = function (_0x57387b, _0x5445d4, _0x56c9f2) {
  this.setupActionSet(_0x57387b, _0x5445d4, _0x56c9f2);
  this.createEffectActionSet(_0x57387b, _0x5445d4, _0x56c9f2);
  this.finishActionSet(_0x57387b, _0x5445d4, _0x56c9f2);
};
Window_BattleLog.prototype.displayAction = function (_0x5e40f0, _0x3712f4) {
  const _0x22722e = VisuMZ.BattleCore.Settings.BattleLog;
  if (_0x22722e.ActionCenteredName) {
    this.push('addText', "<CENTER>%1".format(DataManager.battleDisplayText(_0x3712f4)));
  }
  if (DataManager.isSkill(_0x3712f4)) {
    if (_0x22722e.ActionSkillMsg1) {
      this.displayItemMessage(_0x3712f4.message1, _0x5e40f0, _0x3712f4);
    }
    if (_0x22722e.ActionSkillMsg2) {
      this.displayItemMessage(_0x3712f4.message2, _0x5e40f0, _0x3712f4);
    }
  } else {
    if (_0x22722e.ActionItemMsg) {
      this.displayItemMessage(TextManager.useItem, _0x5e40f0, _0x3712f4);
    }
  }
};
Window_BattleLog.prototype.setupActionSet = function (_0x195b65, _0x229f37, _0x4bf3b9) {
  const _0x3d3b3f = _0x229f37.item();
  this.displayAction(_0x195b65, _0x3d3b3f);
  this.push('applyImmortal', _0x195b65, _0x4bf3b9, true);
  this.push("performActionStart", _0x195b65, _0x229f37);
  this.push("waitForMovement");
  this.push('performCastAnimation', _0x195b65, _0x229f37);
  this.push("waitForAnimation");
};
Window_BattleLog.prototype.createEffectActionSet = function (_0x10fd79, _0x5a9cf4, _0x18ac33) {
  if (this.isMeleeSingleTargetAction(_0x5a9cf4)) {
    this.autoMeleeSingleTargetActionSet(_0x10fd79, _0x5a9cf4, _0x18ac33);
  } else {
    if (this.isMeleeMultiTargetAction(_0x5a9cf4)) {
      this.autoMeleeMultiTargetActionSet(_0x10fd79, _0x5a9cf4, _0x18ac33);
    } else if (_0x5a9cf4.isForRandom()) {
      this.targetActionSet(_0x10fd79, _0x5a9cf4, _0x18ac33);
    } else {
      this.wholeActionSet(_0x10fd79, _0x5a9cf4, _0x18ac33);
    }
  }
};
Window_BattleLog.prototype.addMeleeReturnActionSet = function (_0x30a226, _0x16648b, _0x1287bf, _0x42bb3b) {
  if (_0x16648b) {
    const _0x58d02a = _0x30a226.battler();
    this.push("performJump", [_0x30a226], _0x1287bf, _0x42bb3b);
    this.push('performMoveToPoint', _0x30a226, _0x58d02a._homeX, _0x58d02a._homeY, _0x42bb3b, false, 'Linear');
    this.push("requestMotion", [_0x30a226], 'evade');
    this.push("waitForMovement");
    this.push('requestMotion', [_0x30a226], "walk");
  }
};
Window_BattleLog.prototype.isMeleeSingleTargetAction = function (_0x3aae7a) {
  if (!_0x3aae7a.isPhysical()) {
    return false;
  }
  if (!_0x3aae7a.isForOne()) {
    return false;
  }
  if (!_0x3aae7a.isForOpponent()) {
    return false;
  }
  return VisuMZ.BattleCore.Settings.ActionSequence.AutoMeleeSolo;
};
Window_BattleLog.prototype.autoMeleeSingleTargetActionSet = function (_0x47c028, _0x12f247, _0x4a186c) {
  const _0x1878a3 = _0x47c028.getAttackMotion().type < 0x2;
  let _0x5cdd3e = true;
  if (_0x4a186c.length > 0x0 && _0x47c028.isActor() === _0x4a186c[0x0].isActor()) {
    _0x5cdd3e = false;
  }
  if (_0x1878a3 && _0x5cdd3e) {
    this.push('performJump', [_0x47c028], 0x30, 0x14);
    this.push("performMoveToTargets", _0x47c028, _0x4a186c, "front base", 0x14, true, "Linear", true);
    this.push("requestMotion", [_0x47c028], "walk");
    this.push("waitForMovement");
  }
  let _0x4750af = _0x12f247.isAttack() ? this.getDualWieldTimes(_0x47c028) : 0x1;
  for (let _0x4e4ebc = 0x0; _0x4e4ebc < _0x4750af; _0x4e4ebc++) {
    if (_0x12f247.isAttack() && _0x47c028.isActor()) {
      this.push("setActiveWeaponSet", _0x47c028, _0x4e4ebc);
    }
    if (_0x12f247.item().animationId < 0x0) {
      this.targetActionSet(_0x47c028, _0x12f247, _0x4a186c);
    } else {
      this.wholeActionSet(_0x47c028, _0x12f247, _0x4a186c);
    }
  }
  if (_0x12f247.isAttack() && _0x47c028.isActor()) {
    this.push('clearActiveWeaponSet', _0x47c028);
  }
  this.push("applyImmortal", _0x47c028, _0x4a186c, false);
  this.addMeleeReturnActionSet(_0x47c028, _0x1878a3, 0x30, 0x14);
};
Window_BattleLog.prototype.isMeleeMultiTargetAction = function (_0x4d6b1b) {
  if (!_0x4d6b1b.isPhysical()) {
    return false;
  }
  if (!_0x4d6b1b.isForAll()) {
    return false;
  }
  if (!_0x4d6b1b.isForOpponent()) {
    return false;
  }
  return VisuMZ.BattleCore.Settings.ActionSequence.AutoMeleeAoE;
};
Window_BattleLog.prototype.autoMeleeMultiTargetActionSet = function (_0x37c3c3, _0x389ab5, _0x1bd22c) {
  const _0x3f87bd = _0x37c3c3.getAttackMotion().type < 0x2;
  if (_0x3f87bd) {
    this.push("performJump", [_0x37c3c3], 0x30, 0x14);
    const _0x25b9de = _0x1bd22c.length > 0x1 ? "front center" : "front base";
    this.push('performMoveToTargets', _0x37c3c3, _0x1bd22c, _0x25b9de, 0x14, true, 'Linear', true);
    this.push("requestMotion", [_0x37c3c3], "walk");
    this.push("waitForMovement");
  }
  let _0x37c0a1 = _0x389ab5.isAttack() ? this.getDualWieldTimes(_0x37c3c3) : 0x1;
  for (let _0x4b1040 = 0x0; _0x4b1040 < _0x37c0a1; _0x4b1040++) {
    if (_0x389ab5.isAttack() && _0x37c3c3.isActor()) {
      this.push("setActiveWeaponSet", _0x37c3c3, _0x4b1040);
    }
    this.wholeActionSet(_0x37c3c3, _0x389ab5, _0x1bd22c);
  }
  if (_0x389ab5.isAttack() && _0x37c3c3.isActor()) {
    this.push("clearActiveWeaponSet", _0x37c3c3);
  }
  this.push("applyImmortal", _0x37c3c3, _0x1bd22c, false);
  this.addMeleeReturnActionSet(_0x37c3c3, _0x3f87bd, 0x30, 0x14);
};
Window_BattleLog.prototype.targetActionSet = function (_0x14edfd, _0xde8fe4, _0x2f20ca) {
  const _0x246fa0 = _0xde8fe4.item();
  for (const _0x312d19 of _0x2f20ca) {
    if (!_0x312d19) {
      continue;
    }
    this.push("performAction", _0x14edfd, _0xde8fe4);
    this.push("waitCount", Sprite_Battler._motionSpeed);
    this.push("showAnimation", _0x14edfd, [_0x312d19], _0x246fa0.animationId);
    this.push("waitCount", 0x18);
    this.push("actionEffect", _0x14edfd, _0x312d19);
  }
};
Window_BattleLog.prototype.wholeActionSet = function (_0x1f1dac, _0xa51cb0, _0x46454a) {
  const _0x523b37 = _0xa51cb0.item();
  let _0x8d67f9 = _0xa51cb0.isAttack() ? 0x1 + _0x1f1dac.attackTimesAdd() : 0x1;
  while (_0x8d67f9--) {
    this.push("performAction", _0x1f1dac, _0xa51cb0);
    this.push("waitCount", Sprite_Battler._motionSpeed);
    this.push("showAnimation", _0x1f1dac, _0x46454a.clone(), _0x523b37.animationId);
    this.push('waitForAnimation');
  }
  for (const _0x569564 of _0x46454a) {
    if (!_0x569564) {
      continue;
    }
    this.push("actionEffect", _0x1f1dac, _0x569564);
  }
};
Window_BattleLog.prototype.finishActionSet = function (_0x2655ef, _0x16d939, _0x1f3eb0) {
  this.push("applyImmortal", _0x2655ef, _0x1f3eb0, false);
  this.push('waitForNewLine');
  this.push("waitForEffect");
  this.push('clear');
  this.push("performActionEnd", _0x2655ef);
  this.push("waitForMovement");
};
Window_BattleLog.prototype.endAction = function (_0x3ab2a1) {};
VisuMZ.BattleCore.Window_BattleLog_displayCurrentState = Window_BattleLog.prototype.displayCurrentState;
Window_BattleLog.prototype.displayCurrentState = function (_0x48b4a0) {
  if (!VisuMZ.BattleCore.Settings.BattleLog.ShowCurrentState) {
    return;
  }
  VisuMZ.BattleCore.Window_BattleLog_displayCurrentState.call(this, _0x48b4a0);
};
Window_BattleLog.prototype.displayCounter = function (_0x1df5d2) {
  this.push('performCounter', _0x1df5d2);
  if (VisuMZ.BattleCore.Settings.ActionSequence.CounterPlayback) {
    this.push("showAnimation", _0x1df5d2, [BattleManager._subject], -0x1);
  }
  if (!VisuMZ.BattleCore.Settings.BattleLog.ShowCounter) {
    return;
  }
  this.push("addText", TextManager.counterAttack.format(_0x1df5d2.name()));
};
Window_BattleLog.prototype.displayReflection = function (_0x2c3089) {
  this.push("performReflection", _0x2c3089);
  if (!VisuMZ.BattleCore.Settings.BattleLog.ShowReflect) {
    return;
  }
  this.push("addText", TextManager.magicReflection.format(_0x2c3089.name()));
};
Window_BattleLog.prototype.displayReflectionPlayBack = function (_0x434b8a, _0x3bb774) {
  if (VisuMZ.BattleCore.Settings.ActionSequence.ReflectPlayback) {
    const _0x329937 = _0x3bb774.item();
    this.push("showAnimation", _0x434b8a, [_0x434b8a], _0x329937.animationId);
  }
};
Window_BattleLog.prototype.displaySubstitute = function (_0x347353, _0x5a8a7a) {
  this.push("performSubstitute", _0x347353, _0x5a8a7a);
  if (!VisuMZ.BattleCore.Settings.BattleLog.ShowSubstitute) {
    return;
  }
  const _0x5c63c1 = _0x347353.name();
  const _0x2ecb88 = TextManager.substitute.format(_0x5c63c1, _0x5a8a7a.name());
  this.push('addText', _0x2ecb88);
};
VisuMZ.BattleCore.Window_BattleLog_displayActionResults = Window_BattleLog.prototype.displayActionResults;
Window_BattleLog.prototype.displayActionResults = function (_0x354e1a, _0x3cb8be) {
  VisuMZ.BattleCore.Window_BattleLog_displayActionResults.call(this, _0x354e1a, _0x3cb8be);
};
VisuMZ.BattleCore.Window_BattleLog_displayFailure = Window_BattleLog.prototype.displayFailure;
Window_BattleLog.prototype.displayFailure = function (_0xf6b84) {
  if (!VisuMZ.BattleCore.Settings.BattleLog.ShowFailure) {
    return;
  }
  VisuMZ.BattleCore.Window_BattleLog_displayFailure.call(this, _0xf6b84);
};
VisuMZ.BattleCore.Window_BattleLog_displayCritical = Window_BattleLog.prototype.displayCritical;
Window_BattleLog.prototype.displayCritical = function (_0x3a14dc) {
  if (!VisuMZ.BattleCore.Settings.BattleLog.ShowCritical) {
    return;
  }
  VisuMZ.BattleCore.Window_BattleLog_displayCritical.call(this, _0x3a14dc);
};
VisuMZ.BattleCore.Window_BattleLog_displayMiss = Window_BattleLog.prototype.displayMiss;
Window_BattleLog.prototype.displayMiss = function (_0x24b5d4) {
  if (!VisuMZ.BattleCore.Settings.BattleLog.ShowMissEvasion) {
    this.push("performMiss", _0x24b5d4);
  } else {
    VisuMZ.BattleCore.Window_BattleLog_displayMiss.call(this, _0x24b5d4);
  }
};
VisuMZ.BattleCore.Window_BattleLog_displayEvasion = Window_BattleLog.prototype.displayEvasion;
Window_BattleLog.prototype.displayEvasion = function (_0x369f63) {
  if (!VisuMZ.BattleCore.Settings.BattleLog.ShowMissEvasion) {
    if (_0x369f63.result().physical) {
      this.push("performEvasion", _0x369f63);
    } else {
      this.push("performMagicEvasion", _0x369f63);
    }
  } else {
    VisuMZ.BattleCore.Window_BattleLog_displayEvasion.call(this, _0x369f63);
  }
};
Window_BattleLog.prototype.displayHpDamage = function (_0x5bc02e) {
  if (_0x5bc02e.result().hpAffected) {
    _0x5bc02e._lastHpDamage = 0x0;
    if (_0x5bc02e.result().hpDamage > 0x0 && !_0x5bc02e.result().drain) {
      _0x5bc02e._lastHpDamage = _0x5bc02e.result().hpDamage;
      this.push("performDamage", _0x5bc02e);
    }
    if (_0x5bc02e.result().hpDamage < 0x0) {
      this.push('performRecovery', _0x5bc02e);
    }
    if (VisuMZ.BattleCore.Settings.BattleLog.ShowHpDmg) {
      this.push("addText", this.makeHpDamageText(_0x5bc02e));
    }
  }
};
VisuMZ.BattleCore.Window_BattleLog_displayMpDamage = Window_BattleLog.prototype.displayMpDamage;
Window_BattleLog.prototype.displayMpDamage = function (_0x1eddb5) {
  if (!VisuMZ.BattleCore.Settings.BattleLog.ShowMpDmg) {
    return;
  }
  VisuMZ.BattleCore.Window_BattleLog_displayMpDamage.call(this, _0x1eddb5);
};
VisuMZ.BattleCore.Window_BattleLog_displayTpDamage = Window_BattleLog.prototype.displayTpDamage;
Window_BattleLog.prototype.displayTpDamage = function (_0x4130d2) {
  if (!VisuMZ.BattleCore.Settings.BattleLog.ShowTpDmg) {
    return;
  }
  VisuMZ.BattleCore.Window_BattleLog_displayTpDamage.call(this, _0x4130d2);
};
Window_BattleLog.prototype.displayAffectedStatus = function (_0x46bd36) {
  if (_0x46bd36.result().isStatusAffected()) {
    this.push("pushBaseLine");
    this.displayChangedStates(_0x46bd36);
    this.displayChangedBuffs(_0x46bd36);
    this.push("waitForNewLine");
  }
};
Window_BattleLog.prototype.displayAddedStates = function (_0x1d9d4a) {
  const _0x27d86e = _0x1d9d4a.result();
  const _0x5293da = _0x27d86e.addedStateObjects();
  for (const _0x54c481 of _0x5293da) {
    const _0x4a11f0 = _0x1d9d4a.isActor() ? _0x54c481.message1 : _0x54c481.message2;
    if (_0x4a11f0 && VisuMZ.BattleCore.Settings.BattleLog.ShowAddedState) {
      this.push("fnordAddedStates");
      this.push("popBaseLine");
      this.push("pushBaseLine");
      this.push("addText", _0x4a11f0.format(_0x1d9d4a.name()));
      this.push("wait");
    }
    if (_0x54c481.id === _0x1d9d4a.deathStateId()) {
      this.push("performCollapse", _0x1d9d4a);
    }
  }
};
Window_BattleLog.prototype.fnordAddedStates = function () {};
Window_BattleLog.prototype.displayRemovedStates = function (_0x305374) {
  if (!VisuMZ.BattleCore.Settings.BattleLog.ShowRemovedState) {
    return;
  }
  const _0x4a22be = _0x305374.result();
  const _0x28193e = _0x4a22be.removedStateObjects();
  for (const _0x25f04a of _0x28193e) {
    if (_0x25f04a.message4) {
      this.push("fnordRemovedStates");
      this.push("popBaseLine");
      this.push('pushBaseLine');
      this.push("addText", _0x25f04a.message4.format(_0x305374.name()));
      this.push('wait');
    }
  }
};
Window_BattleLog.prototype.fnordRemovedStates = function () {};
Window_BattleLog.prototype.displayChangedBuffs = function (_0x5e9517) {
  const _0x141072 = VisuMZ.BattleCore.Settings.BattleLog;
  const _0x2cf43d = _0x5e9517.result();
  if (_0x141072.ShowAddedBuff) {
    this.displayBuffs(_0x5e9517, _0x2cf43d.addedBuffs, TextManager.buffAdd);
  }
  if (_0x141072.ShowAddedDebuff) {
    this.displayBuffs(_0x5e9517, _0x2cf43d.addedDebuffs, TextManager.debuffAdd);
  }
  if (_0x141072.ShowRemovedBuff) {
    this.displayBuffs(_0x5e9517, _0x2cf43d.removedBuffs, TextManager.buffRemove);
  }
};
Window_BattleLog.prototype.displayBuffs = function (_0x5968e9, _0x1557bc, _0x4894e0) {
  for (const _0x1f405a of _0x1557bc) {
    const _0x9777d6 = _0x4894e0.format(_0x5968e9.name(), TextManager.param(_0x1f405a));
    this.push('popBaseLine');
    this.push("pushBaseLine");
    this.push("addText", _0x9777d6);
    this.push('wait');
  }
};
VisuMZ.BattleCore.Window_BattleLog_clear = Window_BattleLog.prototype.clear;
Window_BattleLog.prototype.clear = function () {
  VisuMZ.BattleCore.Window_BattleLog_clear.call(this);
  this.callNextMethod();
};
VisuMZ.BattleCore.Window_BattleLog_pushBaseLine = Window_BattleLog.prototype.pushBaseLine;
Window_BattleLog.prototype.pushBaseLine = function () {
  VisuMZ.BattleCore.Window_BattleLog_pushBaseLine.call(this);
  this.callNextMethod();
};
VisuMZ.BattleCore.Window_BattleLog_popBaseLine = Window_BattleLog.prototype.popBaseLine;
Window_BattleLog.prototype.popBaseLine = function () {
  VisuMZ.BattleCore.Window_BattleLog_popBaseLine.call(this);
  this.processRefresh();
  this.callNextMethod();
};
VisuMZ.BattleCore.Window_BattleLog_popupDamage = Window_BattleLog.prototype.popupDamage;
Window_BattleLog.prototype.popupDamage = function (_0x1ec945) {
  VisuMZ.BattleCore.Window_BattleLog_popupDamage.call(this, _0x1ec945);
  this.callNextMethod();
};
Window_BattleLog.prototype.waitForNewLine = function () {
  let _0x760eb4 = 0x0;
  if (this._baseLineStack.length > 0x0) {
    _0x760eb4 = this._baseLineStack[this._baseLineStack.length - 0x1];
  }
  if (this._lines.length > _0x760eb4) {
    this.wait();
  } else {
    this.callNextMethod();
  }
};
VisuMZ.BattleCore.Window_BattleLog_performActionStart = Window_BattleLog.prototype.performActionStart;
Window_BattleLog.prototype.performActionStart = function (_0x2fcfd0, _0x267fc9) {
  VisuMZ.BattleCore.Window_BattleLog_performActionStart.call(this, _0x2fcfd0, _0x267fc9);
  this.callNextMethod();
};
VisuMZ.BattleCore.Window_BattleLog_performAction = Window_BattleLog.prototype.performAction;
Window_BattleLog.prototype.performAction = function (_0x3ee348, _0x40a204) {
  VisuMZ.BattleCore.Window_BattleLog_performAction.call(this, _0x3ee348, _0x40a204);
  this.callNextMethod();
};
VisuMZ.BattleCore.Window_BattleLog_performActionEnd = Window_BattleLog.prototype.performActionEnd;
Window_BattleLog.prototype.performActionEnd = function (_0x430875) {
  VisuMZ.BattleCore.Window_BattleLog_performActionEnd.call(this, _0x430875);
  for (const _0x33c0c9 of BattleManager.allBattleMembers()) {
    if (!_0x33c0c9) {
      continue;
    }
    if (_0x33c0c9.isDead()) {
      continue;
    }
    _0x33c0c9.performActionEndMembers();
  }
  this.callNextMethod();
};
VisuMZ.BattleCore.Window_BattleLog_performDamage = Window_BattleLog.prototype.performDamage;
Window_BattleLog.prototype.performDamage = function (_0x27af95) {
  VisuMZ.BattleCore.Window_BattleLog_performDamage.call(this, _0x27af95);
  this.callNextMethod();
};
VisuMZ.BattleCore.Window_BattleLog_performMiss = Window_BattleLog.prototype.performMiss;
Window_BattleLog.prototype.performMiss = function (_0x54bcf6) {
  VisuMZ.BattleCore.Window_BattleLog_performMiss.call(this, _0x54bcf6);
  this.callNextMethod();
};
VisuMZ.BattleCore.Window_BattleLog_performRecovery = Window_BattleLog.prototype.performRecovery;
Window_BattleLog.prototype.performRecovery = function (_0x4ec29f) {
  VisuMZ.BattleCore.Window_BattleLog_performRecovery.call(this, _0x4ec29f);
  this.callNextMethod();
};
VisuMZ.BattleCore.Window_BattleLog_performEvasion = Window_BattleLog.prototype.performEvasion;
Window_BattleLog.prototype.performEvasion = function (_0x175a74) {
  VisuMZ.BattleCore.Window_BattleLog_performEvasion.call(this, _0x175a74);
  this.callNextMethod();
};
VisuMZ.BattleCore.Window_BattleLog_performMagicEvasion = Window_BattleLog.prototype.performMagicEvasion;
Window_BattleLog.prototype.performMagicEvasion = function (_0x27dfb7) {
  VisuMZ.BattleCore.Window_BattleLog_performMagicEvasion.call(this, _0x27dfb7);
  this.callNextMethod();
};
VisuMZ.BattleCore.Window_BattleLog_performCounter = Window_BattleLog.prototype.performCounter;
Window_BattleLog.prototype.performCounter = function (_0x596fc9) {
  VisuMZ.BattleCore.Window_BattleLog_performCounter.call(this, _0x596fc9);
  this.callNextMethod();
};
VisuMZ.BattleCore.Window_BattleLog_performReflection = Window_BattleLog.prototype.performReflection;
Window_BattleLog.prototype.performReflection = function (_0x2dc7d3) {
  VisuMZ.BattleCore.Window_BattleLog_performReflection.call(this, _0x2dc7d3);
  this.callNextMethod();
};
VisuMZ.BattleCore.Window_BattleLog_performSubstitute = Window_BattleLog.prototype.performSubstitute;
Window_BattleLog.prototype.performSubstitute = function (_0x530d91, _0x5fe282) {
  VisuMZ.BattleCore.Window_BattleLog_performSubstitute.call(this, _0x530d91, _0x5fe282);
  this.callNextMethod();
};
VisuMZ.BattleCore.Window_BattleLog_performCollapse = Window_BattleLog.prototype.performCollapse;
Window_BattleLog.prototype.performCollapse = function (_0x154724) {
  VisuMZ.BattleCore.Window_BattleLog_performCollapse.call(this, _0x154724);
  this.callNextMethod();
};
Window_BattleLog.prototype.performCastAnimation = function (_0x4cbfe6, _0x5907c9) {
  _0x4cbfe6.performCastAnimation(_0x5907c9);
  this.callNextMethod();
};
Window_BattleLog.prototype.showEnemyAttackAnimation = function (_0x8aefca, _0xd7631c) {
  const _0x74b7ce = _0x8aefca.attackAnimationId1();
  if (_0x74b7ce <= 0x0) {
    SoundManager.playEnemyAttack();
  } else {
    this.showNormalAnimation(_0xd7631c, _0x74b7ce);
  }
};
Window_BattleLog.prototype.applyImmortal = function (_0x2ab275, _0x39f880, _0x30df15) {
  const _0x246997 = [_0x2ab275].concat(_0x39f880);
  for (const _0x37391f of _0x246997) {
    if (!_0x37391f) {
      continue;
    }
    _0x37391f.setImmortal(_0x30df15);
  }
  this.callNextMethod();
};
Window_BattleLog.prototype.waitCount = function (_0xd5d4dc) {
  this._waitCount = _0xd5d4dc;
};
Window_BattleLog.prototype.requestMotion = function (_0x4b8d43, _0x127411) {
  for (const _0xe684ff of _0x4b8d43) {
    if (!_0xe684ff) {
      continue;
    }
    _0xe684ff.requestMotion(_0x127411);
  }
  this.callNextMethod();
};
Window_BattleLog.prototype.performMoveToPoint = function (_0x50b131, _0x2c606f, _0x29e072, _0x21a082, _0x50c778, _0x4ec7a7) {
  _0x50b131.moveBattlerToPoint(_0x2c606f, _0x29e072, _0x21a082, _0x50c778, _0x4ec7a7, -0x1);
  this.callNextMethod();
};
Window_BattleLog.prototype.performMoveToTargets = function (_0x577196, _0x127c85, _0x45b8ee, _0x59c128, _0x1069f1, _0x58df37, _0x590783) {
  const _0x2b5d43 = Math.min(..._0x127c85.map(_0x25751b => _0x25751b.battler()._baseX - _0x25751b.battler().mainSpriteWidth() / 0x2));
  const _0x2b17c9 = Math.max(..._0x127c85.map(_0x5a8bac => _0x5a8bac.battler()._baseX + _0x5a8bac.battler().mainSpriteWidth() / 0x2));
  const _0x106399 = Math.min(..._0x127c85.map(_0x5b63c5 => _0x5b63c5.battler()._baseY - _0x5b63c5.battler().mainSpriteHeight()));
  const _0x5cc149 = Math.max(..._0x127c85.map(_0x5caddb => _0x5caddb.battler()._baseY));
  const _0x19ba0b = _0x127c85.filter(_0x13f613 => _0x13f613.isActor()).length;
  const _0x2e845e = _0x127c85.filter(_0x5aecf2 => _0x5aecf2.isEnemy()).length;
  let _0x2f980e = 0x0;
  let _0xe4b52e = 0x0;
  if (_0x45b8ee.match(/front/i)) {
    _0x2f980e = _0x19ba0b >= _0x2e845e ? _0x2b5d43 : _0x2b17c9;
  } else {
    if (_0x45b8ee.match(/middle/i)) {
      _0x2f980e = (_0x2b5d43 + _0x2b17c9) / 0x2;
      _0x590783 = -0x1;
    } else if (_0x45b8ee.match(/back/i)) {
      _0x2f980e = _0x19ba0b >= _0x2e845e ? _0x2b17c9 : _0x2b5d43;
    }
  }
  if (_0x45b8ee.match(/head/i)) {
    _0xe4b52e = _0x106399;
  } else {
    if (_0x45b8ee.match(/center/i)) {
      _0xe4b52e = (_0x106399 + _0x5cc149) / 0x2;
      if (_0x577196.battler()) {
        _0xe4b52e += _0x577196.battler().height / 0x2;
      }
    } else if (_0x45b8ee.match(/base/i)) {
      _0xe4b52e = _0x5cc149;
    }
  }
  _0x577196.moveBattlerToPoint(_0x2f980e, _0xe4b52e, _0x59c128, _0x1069f1, _0x58df37, _0x590783);
  this.callNextMethod();
};
Window_BattleLog.prototype.performJump = function (_0x45007a, _0x366e8d, _0x368213) {
  for (const _0x54eb38 of _0x45007a) {
    if (!_0x54eb38) {
      continue;
    }
    _0x54eb38.jumpBattler(_0x366e8d, _0x368213);
  }
  this.callNextMethod();
};
function Window_BattleMultiTarget() {
  this.initialize(...arguments);
}
Window_BattleMultiTarget.prototype = Object.create(Window_Command.prototype);
Window_BattleMultiTarget.prototype.constructor = Window_BattleMultiTarget;
VisuMZ.BattleCore.Settings.MultiTarget = VisuMZ.BattleCore.Settings.MultiTarget || {};
Window_BattleMultiTarget.WIDTH = VisuMZ.BattleCore.Settings.MultiTarget.WindowWidth ?? 0x118;
Window_BattleMultiTarget.BG_TYPE = VisuMZ.BattleCore.Settings.MultiTarget.BgType ?? 0x2;
Window_BattleMultiTarget.SHOW_BUTTON = VisuMZ.BattleCore.Settings.MultiTarget.ShowButton ?? true;
Window_BattleMultiTarget.ALL_ACTORS = VisuMZ.BattleCore.Settings.MultiTarget.AllActorsText ?? "All Allies";
Window_BattleMultiTarget.ALL_ENEMIES = VisuMZ.BattleCore.Settings.MultiTarget.AllEnemiesText ?? "All Enemies";
Window_BattleMultiTarget.ACTOR_OFFSET_X = VisuMZ.BattleCore.Settings.MultiTarget.ActorOffsetX ?? 0x0;
Window_BattleMultiTarget.ACTOR_OFFSET_Y = VisuMZ.BattleCore.Settings.MultiTarget.ActorOffsetY ?? 0x0;
Window_BattleMultiTarget.ENEMY_OFFSET_X = VisuMZ.BattleCore.Settings.MultiTarget.EnemyOffsetX ?? 0x0;
Window_BattleMultiTarget.ENEMY_OFFSET_Y = VisuMZ.BattleCore.Settings.MultiTarget.EnemyOffsetY ?? 0x0;
Window_BattleMultiTarget.prototype.initialize = function (_0x359cc1, _0xf2e2ab) {
  this._forActor = _0xf2e2ab;
  Window_Command.prototype.initialize.call(this, _0x359cc1);
  this.setBackgroundType(Window_BattleMultiTarget.BG_TYPE);
  this.deactivate();
  this.hide();
  this.deselect();
};
Window_BattleMultiTarget.prototype.forActor = function () {
  return this._forActor;
};
Window_BattleMultiTarget.prototype.makeCommandList = function () {
  let _0x594f43 = this.forActor() ? Window_BattleMultiTarget.ALL_ACTORS : Window_BattleMultiTarget.ALL_ENEMIES;
  if (Imported.VisuMZ_0_CoreEngine && Window_BattleMultiTarget.SHOW_BUTTON) {
    this._buttonKey = this.forActor() ? "pagedown" : 'pageup';
    this._buttonText = TextManager.getInputButtonString(this._buttonKey);
    const _0x5bbf56 = VisuMZ.CoreEngine.Settings.ButtonAssist.TextFmt;
    _0x594f43 = _0x5bbf56.format(this._buttonText, _0x594f43);
  }
  this.addCommand(_0x594f43, "selectAll");
};
Window_BattleMultiTarget.prototype.drawItem = function (_0x240d75) {
  const _0x10cc3f = this.itemLineRect(_0x240d75);
  this.resetTextColor();
  this.changePaintOpacity(this.isCommandEnabled(_0x240d75));
  const _0x48651b = this.commandName(_0x240d75);
  const _0x12c29b = this.textSizeEx(_0x48651b).width;
  const _0xbd681d = _0x10cc3f.x + Math.floor((_0x10cc3f.width - _0x12c29b) / 0x2);
  this.drawTextEx(_0x48651b, _0xbd681d, _0x10cc3f.y, _0x10cc3f.width);
};
Window_BattleMultiTarget.prototype.update = function () {
  Window_Command.prototype.update.call(this);
  this.updateVisibility();
  this.updateKeyboardKeys();
};
Window_BattleMultiTarget.prototype.updateVisibility = function () {
  this.visible = this.visibilityState();
};
Window_BattleMultiTarget.prototype.visibilityState = function () {
  const _0x340575 = BattleManager.inputtingAction();
  const _0x3701a9 = _0x340575 && _0x340575.canSingleOrMultipleSelect();
  if (!_0x3701a9) {
    return false;
  }
  const _0x3a3449 = SceneManager._scene;
  if (this.forActor()) {
    if (_0x3a3449._actorWindow.active && _0x3a3449._actorWindow._handlers.pagedown) {
      return true;
    }
    if (_0x3a3449._enemyWindow.active && _0x3a3449._enemyWindow._handlers.pagedown) {
      return true;
    }
  } else {
    if (_0x3a3449._enemyWindow.active && _0x3a3449._enemyWindow._handlers.pageup) {
      return true;
    }
  }
  return false;
};
Window_BattleMultiTarget.prototype.updateKeyboardKeys = function () {
  if (!Imported.VisuMZ_0_CoreEngine) {
    return;
  }
  if (this._buttonText !== TextManager.getInputButtonString(this._buttonKey)) {
    this.refresh();
  }
};
Window_BattleMultiTarget.prototype.processTouch = function () {
  if (this.visible && TouchInput.isClicked()) {
    const _0x4d6e69 = this.hitIndex();
    if (_0x4d6e69 >= 0x0) {
      const _0x8abcac = this.forActor() ? "pagedown" : "pageup";
      Input.virtualClick(_0x8abcac);
    }
  }
};
function Window_DamageCounter() {
  this.initialize(...arguments);
}
Window_DamageCounter.prototype = Object.create(Window_Base.prototype);
Window_DamageCounter.prototype.constructor = Window_DamageCounter;
Window_DamageCounter.SETTINGS = {
  'enabled': VisuMZ.BattleCore.Settings.ComboWindow.Enable ?? true,
  'customFontFace': VisuMZ.BattleCore.Settings.ComboWindow.CustomFontFace ?? '',
  'textAlign': VisuMZ.BattleCore.Settings.ComboWindow.TextAlign ?? "left",
  'hitsDmgFmt': VisuMZ.BattleCore.Settings.ComboWindow.hitsDmgFmt ?? "\\C[6]%1\\} \\C[4]Hit Combo\\{",
  'hitsHealFmt': VisuMZ.BattleCore.Settings.ComboWindow.hitsHealFmt ?? "\\C[6]%1\\} \\C[4]Heal Combo\\{",
  'totalDmgFmt': VisuMZ.BattleCore.Settings.ComboWindow.totalDmgFmt ?? "\\}\\C[21]Total Damage: \\{\\C[0]%1",
  'totalHealFmt': VisuMZ.BattleCore.Settings.ComboWindow.totalHealFmt ?? "\\}\\C[21]Total Healing: \\{\\C[24]+%1",
  'fadeShiftX': VisuMZ.BattleCore.Settings.ComboWindow.fadeShiftX ?? -0x2,
  'fadeShiftY': VisuMZ.BattleCore.Settings.ComboWindow.fadeShiftY ?? 0x0,
  'positionOffsetX': VisuMZ.BattleCore.Settings.ComboWindow.PosOffsetX ?? 0x0,
  'positionOffsetY': VisuMZ.BattleCore.Settings.ComboWindow.PosOffsetY ?? 0x0,
  'updateDuration': VisuMZ.BattleCore.Settings.ComboWindow.updateDuration ?? 0x14,
  'minimumStayDuration': VisuMZ.BattleCore.Settings.ComboWindow.minimumStayDuration ?? 0x28,
  'minimumHits': VisuMZ.BattleCore.Settings.ComboWindow.minimumHits ?? 0x1,
  'opacitySpeed': VisuMZ.BattleCore.Settings.ComboWindow.opacitySpeed ?? 0x10
};
Window_DamageCounter.prototype.initialize = function (_0x544ae6) {
  this._visibleDuration = 0x0;
  Window_Base.prototype.initialize.call(this, _0x544ae6);
  this._targetX = _0x544ae6.x;
  this._targetY = _0x544ae6.y;
  this.resetCounter();
  this.setBackgroundType(0x2);
};
Window_DamageCounter.prototype.resetCounter = function () {
  this._updateDuration = 0x0;
  this._totalHits = 0x0;
  this._totalDamage = 0x0;
  this._targetHits = 0x0;
  this._targetDamage = 0x0;
};
Window_DamageCounter.prototype.resetFontSettings = function () {
  Window_Base.prototype.resetFontSettings.call(this);
  const _0x3f27c2 = Window_DamageCounter.SETTINGS;
  if (_0x3f27c2.customFontFace) {
    this.contents.fontFace = _0x3f27c2.customFontFace;
  } else {
    this.contents.fontFace = $gameSystem.numberFontFace();
  }
};
var $comboWindowReset = function () {
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  const _0x454271 = SceneManager._scene._damageCounterWindow;
  if (_0x454271) {
    _0x454271.resetCounter();
  }
};
Window_DamageCounter.prototype.increaseHits = function (_0x14d2a2) {
  this._targetHits += Math.round(_0x14d2a2);
  const _0x105060 = Window_DamageCounter.SETTINGS;
  this._updateDuration = _0x105060.updateDuration;
  if (this._targetHits >= _0x105060.minimumHits) {
    this._visibleDuration = _0x105060.minimumStayDuration;
  }
};
var $comboWindowIncreaseHits = function (_0x54fb34) {
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  const _0x2d8622 = SceneManager._scene._damageCounterWindow;
  if (_0x2d8622) {
    _0x2d8622.increaseHits(_0x54fb34);
  }
};
Window_DamageCounter.prototype.increaseTotal = function (_0x2b7ef4) {
  this._targetDamage += Math.round(_0x2b7ef4);
  const _0x2ba7aa = Window_DamageCounter.SETTINGS;
  this._updateDuration = _0x2ba7aa.updateDuration;
  if (this._targetHits >= _0x2ba7aa.minimumHits) {
    this._visibleDuration = _0x2ba7aa.minimumStayDuration;
  }
};
var $comboWindowIncreaseDamage = function (_0x4a266b) {
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  const _0x4e70e0 = SceneManager._scene._damageCounterWindow;
  if (_0x4e70e0) {
    _0x4e70e0.increaseTotal(_0x4a266b);
  }
};
var $comboWindowIncreaseHealing = function (_0x507b29) {
  if (!SceneManager.isSceneBattle()) {
    return;
  }
  const _0x8d0beb = SceneManager._scene._damageCounterWindow;
  if (_0x8d0beb) {
    _0x8d0beb.increaseTotal(-_0x507b29);
  }
};
VisuMZ.BattleCore.Scene_Battle_createAllWindows_ComboWindow = Scene_Battle.prototype.createAllWindows;
Scene_Battle.prototype.createAllWindows = function () {
  this.createDamageCounterWindow();
  VisuMZ.BattleCore.Scene_Battle_createAllWindows_ComboWindow.call(this);
};
Scene_Battle.prototype.createDamageCounterWindow = function () {
  if (!Window_DamageCounter.SETTINGS.enabled) {
    return;
  }
  const _0x5a1772 = this.damageCounterWindowRect();
  const _0x594b14 = new Window_DamageCounter(_0x5a1772);
  this.addWindow(_0x594b14);
  this._damageCounterWindow = _0x594b14;
};
Scene_Battle.prototype.damageCounterWindowRect = function () {
  if (VisuMZ.BattleCore.Settings.ComboWindow.ComboWindow_RectJS) {
    return VisuMZ.BattleCore.Settings.ComboWindow.ComboWindow_RectJS.call(this);
  }
  const _0x16fdce = Math.ceil(Graphics.width / 0x4);
  const _0x4c4c9d = this.calcWindowHeight(0x2, true);
  const _0xfa995f = 0x0 + this.comboWindowOffsetX();
  const _0x539936 = Math.round(Graphics.boxHeight * 0x1 / 0x3) + this.comboWindowOffsetY();
  return new Rectangle(_0xfa995f, _0x539936, _0x16fdce, _0x4c4c9d);
};
Scene_Battle.prototype.comboWindowOffsetX = function () {
  return Window_DamageCounter.SETTINGS.positionOffsetX;
};
Scene_Battle.prototype.comboWindowOffsetY = function () {
  return Window_DamageCounter.SETTINGS.positionOffsetY;
};
Window_DamageCounter.prototype.update = function () {
  Window_Base.prototype.update.call(this);
  this.updateCounter();
  this.updateOpacity();
};
Window_DamageCounter.prototype.updateCounter = function () {
  if (this._updateDuration <= 0x0) {
    return;
  }
  const _0x3c7d14 = this._updateDuration;
  this._totalHits = this._targetHits;
  this._totalDamage = (this._totalDamage * (_0x3c7d14 - 0x1) + this._targetDamage) / _0x3c7d14;
  this._updateDuration--;
  if (this._updateDuration <= 0x0) {
    this._totalHits = this._targetHits;
    this._totalDamage = this._targetDamage;
  }
  this.refresh();
};
Window_DamageCounter.prototype.updateOpacity = function () {
  const _0x4473c3 = Window_DamageCounter.SETTINGS;
  const _0x518c9f = this.visibilityState();
  const _0x23d6f6 = _0x4473c3.opacitySpeed || 0x1;
  if (_0x518c9f && this.contentsOpacity < 0xff) {
    this.contentsOpacity += _0x23d6f6;
  } else if (!_0x518c9f && this.contentsOpacity > 0x0) {
    this.contentsOpacity -= _0x23d6f6;
    this.x += _0x4473c3.fadeShiftX || 0x0;
    this.y += _0x4473c3.fadeShiftY || 0x0;
  }
};
Window_DamageCounter.prototype.visibilityState = function () {
  const _0x2a50eb = Window_DamageCounter.SETTINGS;
  if (this._targetHits >= _0x2a50eb.minimumHits) {
    return true;
  }
  if (this._visibleDuration-- > 0x0) {
    return true;
  }
  return false;
};
VisuMZ.BattleCore.Game_Action_executeHpDamage_ComboWindow = Game_Action.prototype.executeHpDamage;
Game_Action.prototype.executeHpDamage = function (_0x14f0cf, _0x1cb10) {
  $comboWindowIncreaseHits(0x1);
  $comboWindowIncreaseDamage(_0x1cb10);
  VisuMZ.BattleCore.Game_Action_executeHpDamage_ComboWindow.call(this, _0x14f0cf, _0x1cb10);
};
VisuMZ.BattleCore.BattleManager_endAction_ComboWindow = BattleManager.endAction;
BattleManager.endAction = function () {
  $comboWindowReset();
  VisuMZ.BattleCore.BattleManager_endAction_ComboWindow.call(this);
};
Window_DamageCounter.prototype.refresh = function () {
  this.contents.clear();
  this.drawComboText();
  this.x = this._targetX;
  this.y = this._targetY;
};
Window_DamageCounter.prototype.textAlignment = function () {
  const _0x13686a = Window_DamageCounter.SETTINGS;
  return _0x13686a.textAlign || "left";
};
Window_DamageCounter.prototype.hitText = function () {
  const _0xa33e9a = Window_DamageCounter.SETTINGS;
  let _0x54ae6d = this._totalDamage >= 0x0 ? _0xa33e9a.hitsDmgFmt : _0xa33e9a.hitsHealFmt;
  return _0x54ae6d.format(Math.abs(Math.ceil(this._totalHits)));
};
Window_DamageCounter.prototype.damageText = function () {
  const _0x49c630 = Window_DamageCounter.SETTINGS;
  let _0x1cf6af = this._totalDamage >= 0x0 ? _0x49c630.totalDmgFmt : _0x49c630.totalHealFmt;
  return _0x1cf6af.format(Math.abs(Math.round(this._totalDamage)));
};
Window_DamageCounter.prototype.drawComboText = function () {
  if (VisuMZ.BattleCore.Settings.ComboWindow.ComboWindow_DrawJS) {
    return VisuMZ.BattleCore.Settings.ComboWindow.ComboWindow_DrawJS.call(this);
  }
  let _0x5a4fc9 = 0x0;
  let _0x450b43 = 0x0;
  const _0xcda638 = this.hitText();
  const _0x3792d1 = this.textSizeEx(_0xcda638);
  if (this.textAlignment() === "right") {
    _0x5a4fc9 = this.innerWidth - this.itemPadding() - _0x3792d1.width;
  } else if (this.textAlignment() === "center") {
    _0x5a4fc9 = Math.floor((this.innerWidth - _0x3792d1.width) / 0x2);
  } else {
    _0x5a4fc9 = this.itemPadding();
  }
  this.drawTextEx(_0xcda638, _0x5a4fc9, _0x450b43);
  _0x450b43 += Math.ceil(this.lineHeight() * 0x2 / 0x3);
  const _0x258faa = this.damageText();
  const _0x4ee02f = this.textSizeEx(_0x258faa);
  if (this.textAlignment() === "right") {
    _0x5a4fc9 = this.innerWidth - this.itemPadding() - _0x4ee02f.width;
  } else if (this.textAlignment() === "center") {
    _0x5a4fc9 = Math.floor((this.innerWidth - _0x4ee02f.width) / 0x2);
  } else {
    _0x5a4fc9 = this.itemPadding();
  }
  this.drawTextEx(_0x258faa, _0x5a4fc9, _0x450b43);
};